R 元编程（metaprogramming）

	元编程的操作对象是代码。code as data。
	元编程一言以蔽之，就是用代码生成（操纵）代码。
	如果编程的本质是抽象，那么元编程就是更高层次的抽象。
	Metaprogramming is writing code that writes code.
	一般代码的操作对象是数据，元编程操作的对象是其他代码。



	- R语言里的调用类型（call）

大佬的书 有几节: https://adv-r.hadley.nz/metaprogramming.html
                 http://adv-r.had.co.nz/   Metaprogramming
                 http://adv-r.had.co.nz/Computing-on-the-language.html
pdf	book: https://www.programmer-books.com/wp-content/uploads/2019/05/Metaprogramming-in-R.pdf
		https://github.com/Apress/metaprogramming-in-r

https://cran.r-project.org/doc/manuals/R-lang.html  第6章
https://liripo.github.io/noteWeb/R-metaprogramming.html
https://shixiangwang.github.io/home/cn/post/2019-11-20-meta-programming/
https://wutaoblog.com.cn/2021/01/14/r-meta/




C++ 的五种编程范式
	面向过程
	面向对象
	泛型
	模板元
	函数式


Quite true. R was originally build on top of Lisp and it shows in many places, such as in the metaprogramming stuff that you mention.



========================================
元编程（metaprogramming）：很强大的扩展能力
----------------------------------------
书籍: Metaprogramming in R – pdf


1. 所谓的元编程（metaprogramming）其实就是编写运行时动态修改程序本身的代码（编写产生代码的代码）。 

元编程概念：编写运行时动态修改程序本身的代码（编写产生代码的代码）【使用编程语言来操作或修改自己的代码,代码就是数据】

R中进行元编程的操作可以使用base R中的函数，也可以使用rlang函数【Tidy evaluation的实现】，当然，data.table也有自己的元编程。



R语言支持元编程，有几个基础函数需要深入了解：

substitute
quote(expr)
eval
deparse(expr)
call(name, ...)
expression(...)
parse(text="")

https://blog.csdn.net/ofoliao/article/details/103471604




2. 总结这些函数的关系

表达式的几个状态：
表达式字面量 --> 未经eval的表达式 --> 表达式字符串 or 计算结果

(1) 表达式字面量 -> 未经eval的表达式 
substitute()
quote()

(2) 未经eval的表达式 -> 求值 
eval() 

(3) 未经eval的表达式 -> 表达式字符串
deparse()

(4) 表达式字符串 -> 未经eval的表达式
parse()

(5) 生成 未经eval的表达式 
call()
expression()



3. 类 

> getClass("expression")
Class "expression" [package "methods"]

No Slots, prototype of class "expression"

Extends: "vector"


> getClass("language")
Virtual Class "language" [package "methods"]

No Slots, prototype of class "name"

Known Subclasses: 
Class "name", directly
Class "call", directly
Class "{", directly
Class "if", directly
Class "<-", directly
Class "for", directly
Class "while", directly
Class "repeat", directly
Class "(", directly
Class ".name", by class "name", distance 2, with explicit coerce

可以看到expression类由向量 vector 派生得到。
language类是虚拟类，它包括我们熟悉的程序控制关键词/符号和name、call 子类。















========================================
|-- call(name, ) 函数：构造调用对象，等待用 evel() 执行
----------------------------------------
call(name, ...)
Create or test for objects of mode "call" (or "(", see Details).

构造一个没有eval的函数调用。第一个参数是函数名（字符串），后面是函数的参数。


1. call() 函数
(1) 创建调用对象
> x2=1:5
> my_call=call("sum", x2, na.rm=T) #第一个参数必须是字符串
> my_call
sum(1:5, na.rm = TRUE)
> class(my_call)
[1] "call"

> typeof(my_call)
[1] "language"
> str(my_call)
 language sum(1:5, na.rm = TRUE)


(2) 执行该 call 对象
> eval(my_call)
[1] 15


(3) 转为字符串
> deparse(my_call)
[1] "sum(1:5, na.rm = TRUE)"

> class(deparse(my_call))
[1] "character"





2. 获取语法树
> (cl_list <- as.list(my_call))
[[1]]
sum

[[2]]
[1] 1 2 3 4 5

$na.rm
[1] TRUE

查看类型:
> class(cl_list)
[1] "list"
> typeof(cl_list)
[1] "list"


还可以再转为 call 类型
> as.call(cl_list)
sum(1:5, na.rm = TRUE)
> eval(as.call(cl_list))
[1] 15


还可以修改 mode()方式转为 call 类型:
> mode(cl_list) <- "call"
> cl_list
sum(1:5, na.rm = TRUE)







3. do.call(what, args, quote = FALSE, envir = parent.frame())命令则是直接在envir中执行 what 命令。
这个和call 只是名字相似。

> c2=call("sum", quote(1:n), na.rm=T)
> c2
sum(1:n, na.rm = TRUE)
> class(c2)
[1] "call"

#新建一个环境
e1=new.env()
e1$n=100
e1
ls(e1)
e1$n
do.call(what='eval', args=list(c2), envir = e1 ) #5050




4. quote(expr)函数捕获未执行的代码。enquote(cl)捕获代码的运行结果,cl为call对象。

> enquote(c2)
base::quote(sum(1:n, na.rm = TRUE))


> quote(1:9+5)
1:9 + 5
> enquote(1:9+5)
base::quote(c(6, 7, 8, 9, 10, 11, 12, 13, 14))













========================================
|-- deparse函数: 将未求值的表达式转换为字符串
----------------------------------------
Turn unevaluated expressions into character strings.

1. 函数定义

deparse(expr, width.cutoff = 60L,
        backtick = mode(expr) %in%
            c("call", "expression", "(", "function"),
        control = c("keepInteger", "showAttributes", "keepNA"),
        nlines = -1L)


> deparse
function (expr, width.cutoff = 60L, backtick = mode(expr) %in% 
    c("call", "expression", "(", "function"), 
    control = c("keepNA", "keepInteger", "niceNames", 
        "showAttributes"), nlines = -1L) 
.Internal(deparse(expr, width.cutoff, backtick, .deparseOpts(control), 
    nlines))
<bytecode: 0x000000000ac588b0>
<environment: namespace:base>


2. 示例

(1) 未求值的表达式(调用类型) 变字符串
> quote(2+2)
2 + 2
> class(quote(2+2))
[1] "call"

> deparse(quote(2+2))
[1] "2 + 2"
> class(deparse(quote(2+2)))
[1] "character"



# 例子2: 定义x、y轴的label为变量名本身
myplot=function(x, y){
  plot(x,y,
       xlab=xlab=paste0("xx_",deparse(substitute(x))),
       ylab=deparse(substitute(y))
  )
}
myplot(iris$Sepal.Length, iris$Sepal.Width) #这样 xlab 就是 "xx_iris$Sepal.Length"
plot(iris$Sepal.Length, iris$Sepal.Width) #默认的plot的 xlab 是 "iris$Sepal.Length"




(2) 函数 变字符串
> class(args(lm))
[1] "function"

> args(lm)
function (formula, data, subset, weights, na.action, method = "qr", 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...) 
NULL

> deparse(args(lm))
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", " 
[2] "    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, "
[3] "    contrasts = NULL, offset, ...) " 
[4] "NULL"
> deparse(args(lm), width.cutoff = 500)
[1] "function (formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) "
[2] "NULL"    





========================================
|-- parse(text=): 把表达式字符串解析成为未eval的expression
----------------------------------------
parse(text="") 是deparse的逆函数，把字符串转为语法树。
注意: 第一个参数是 file 一般不用，所以必须指定参数名。



1. 例1
> ex1 <- parse(text = "1 + 2 + 3")
> ex1
expression(1 + 2 + 3)
> eval(ex1)
[1] 6



2. 例2
> str2="apply(iris[,1:4], 2,mean)"
> str2
[1] "apply(iris[,1:4], 2,mean)"

> ex2=parse(text=str2)
> ex2
expression(apply(iris[,1:4], 2,mean))

> eval(ex2)
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 
> 




========================================
|-- expressioin() 表达式类型
----------------------------------------
1. 表达式
expression(...)

把参数看成表达式，返回expression类型的对象。
expression类型和list类型类似，是个容器，每个成员可能是call，symbol（name）和constants中的一种。
若有多个成员，eval每个成员都会求值一遍，但是只返回最后一个成员eval之后的值，这与绝大多数编程语言多个表达式语句（逗号隔开）返回的结果类似。


(1) 简单例子
> ex1=expression(iris)
> ex1
expression(iris)
> class(ex1)
[1] "expression"
> head(eval(ex1))
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa


(2) expression类型和list类型类似，是个容器，每个成员可能是call，symbol（name）和constants中的一种。

> ex2=expression(iris, mtcars, 1:20, n<-5)
> ex2
expression(iris, mtcars, 1:20, n <- 5)
> length(ex2)
[1] 4
> ex2[[1]]
iris
> ex2[[2]]
mtcars
> ex2[[3]]
1:20
> ex2[[4]]
n <- 5


使用 apply 函数遍历
> sapply(ex2, class)
[1] "name" "name" "call" "<-"  
> sapply(ex2, typeof)
[1] "symbol"   "symbol"   "language" "language"


> sapply(ex2, function(x){
+   x
+ })
[[1]]
iris

[[2]]
mtcars

[[3]]
1:20

[[4]]
n <- 5



> sapply(ex2, function(x){
+   dim(eval(x))
+ })
[[1]]
[1] 150   5

[[2]]
[1] 32 11

[[3]]
NULL

[[4]]
NULL


(3) 若有多个成员，eval每个成员都会求值一遍，但是只返回最后一个成员eval之后的值，这与绝大多数编程语言多个表达式语句（逗号隔开）返回的结果类似。

> eval(expression(1, 2<10))
[1] TRUE
> eval(expression(1, 2>10))
[1] FALSE


确实发生求值了:
> x=1
> eval(expression(x<-2, 2>10))
[1] FALSE
> x
[1] 2









========================================
|-- eval() 求值，可以指定环境
----------------------------------------
1. 函数定义 
Evaluate an R expression in a specified environment.

> eval
function (expr, envir = parent.frame(), enclos = if (is.list(envir) || 
    is.pairlist(envir)) parent.frame() else baseenv()) 
.Internal(eval(expr, envir, enclos))
<bytecode: 0x00000000046aa520>
<environment: namespace:base>

对expr进行计算，默认是当前环境（也就是eval的parent.frame)。
如果envir是list/data.frame，enclos 参数默认增加当前环境，作为 expr 计算在list/data.frame之外寻找对象定义的闭包。


(1) 简单例子
例:
ex1=quote(x+y)

> x=1; y=2
> eval(ex1)
[1] 3


(2) 还可以指定环境
> eval(ex1, envir = list(x=10,y=20))
[1] 30


# 如果只指定一个，另一个从环境变量中查找
> eval(ex1, envir = list(x=10))
[1] 12



(3) 可以指定数据框作为环境，执行某个表达式

在环境 mtcars 下，求表达式 gear>4 的值
> eval( quote(gear>4), mtcars)
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[20] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE


可以使用该值过滤 mtcars 的行
> mtcars[eval( quote(gear>4), mtcars), ]
                mpg cyl  disp  hp drat    wt qsec vs am gear carb
Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2
Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4
Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6
Maserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8





========================================
|-- quote() 把表达式变为 未求值的调用类型
----------------------------------------
quote(expr)
简单地返回expr，expr没有进行eval。和substitute相比，没有替换。


1. 生成
> e1 <- quote(x/y)
> e1
x/y
> c(class(e1), typeof(e1))
[1] "call"     "language"




2. 求值 
> eval(e1, envir = list(x=3, y=5))
[1] 0.6




3. 变字符串
> deparse(e1) #这样才对
[1] "x/y"
> class(deparse(e1))
[1] "character"




4. 访问语法树
> e1
x/y
> as.character(e1) #貌似不对
[1] "/" "x" "y"

> e1[[1]]
`/`
> e1[[2]]
x
> e1[[3]]
y

subtitute/quote返回class/type根据表达式的不同而不同。表达式被解析为抽象语法树，可以访问其中每一个组成，还可以对返回的对象进行修改，即自己构造语法树（meta-programming）。








========================================
|-- substitute(expr, env) 替换，变体函数 bquote(expr)
----------------------------------------

substitute returns the parse tree for the (unevaluated) expression expr, substituting any variables bound in env.

substitute的用处就是把输入的字符直接使用，不用加引号。


1. 把变量名字替换为 name 类型
很多时候，我们不希望像上文一样，直接修改表达式的内部结构。
更多的时候，我们仅仅希望获得一个表达式来 deparse 并用于添加画图的标签。
比如 plot.default:

xlabel <- if (!missing(x))
    deparse(substitute(x))
这就把x参数的变量名变成了x轴的标签文字。

测试:
> deparse(substitute(iris))
[1] "iris"
> deparse1(substitute(iris))
[1] "iris"

> res0=substitute(iris);res0
iris
> c(class(res0), typeof(res0))
[1] "name"   "symbol"

substitute 会识别一个 promise 变量，替换它的表达式slot值。
如果函数内触发 substitute ，则函数的局部变量也会被替换。






(2) 变量名替换

substitute 的参数不仅仅可以是简单变量，还可以是包含几个变量的表达式，并可以对每个变量逐个替换。
还可以提供一个 environment 或者 list 用于查找变量。

> res=substitute(a + b, list(a = 1, b = quote(x)))
> res
1 + x

> c(class(res), typeof(res))  #这个和简单变量替换的分类不同，是因为这是函数？
[1] "call"     "language"


注意：quote()是必须的，否则就解析并使用了x的值
> x=120
> substitute(a + b, list(a = 1, b =x))
1 + 120


这可以很方便的把数学表达式打印到图中：
> plot(0)
> for (i in 1:4)
   text(1, 0.2 * i,
        substitute(x[ix] == y, list(ix = i, y = pnorm(i))))
效果：
[]里的是下标，自动替换为数字i；
==只保留一个= ??//todo
右侧的y是数值 pnrom(i)


注意：替换是纯语法的，不检查输出的call对象在求值时刻是否合法。比如:
> substitute(x <- x + 1, list(x = 2))
2 <- 2 + 1

但是，R的有些部分自己定义了什么是有意义 和什么无意义的规则，而且事实上就是采用了这些形式上有问题的表达式。 
例如，使用“图中数学”的特性时常常会有语法上正确，但求值毫无意义的 构造，如 {}>=40*" years"。
> plot(0)
> text(1, 0.2 * i,  labels=substitute({}>=40*" years") )



2) substitute不仅能够替换变量，也能够替换运算符（函数）
> substitute(a + b, list("+" = quote(func)))
func(a, b)







(3) 两次替换
Substitute 不对第一个参数求值。这导致了如何对包含在变量中的对象进行替换的难题。解决方法是再调用一次 substitute.

> expr <- quote(x + y)
> substitute(substitute(e, list(x = 3)), list(e = expr))
substitute(x + y, list(x = 3))
> eval(substitute(substitute(e, list(x = 3)), list(e = expr)))
3 + y


替换的精确规则如下： 第一个参数的解析树的每个符号 和第二个参数匹配，既可以是有键名的列表也可以是一个环境变量。
如果它是一个简单的局部对象，它的值将被插入， 除非它 匹配全局环境。//?
如果它是一个 promise（常常是函数参数）， promise 表达式会被替换。
如果符号没有被匹配，它不会有任何改变。 
而在高层次的替换的特殊例外确实很奇怪。
这是从 S 继承而来，原理基本上是，没有控制哪个变量可能在那个层次上绑定，所以最好让 substitute  的表现和 quote 一致。
// 不是很懂






(4) 如果局部变量在substitute使用前被替换(函数内部)

如果局部变量在substitute使用前被替换，promise 替换的规则和 S相应的规则稍稍有点不同。R 将使用变量的新值，而 S 将无条件地使用参数表达式 —— 除非它是一个常量。这导致一个很古怪的结果，即在S里面 f((1)) 可能和 f(1) 差异很大。但 R 的规则更清晰，尽管它也有一些比较奇怪的和 lazy evaluation(惰性求值) 相关结果。 参看下面的例子

logplot <- function(y, ylab = deparse(substitute(y))) {
    y <- log(y)
    plot(y, ylab = ylab)
}
height=1:10
logplot(y=height)
# 调用之后发现，ylab是丑陋的、log求值后的数字！

这是因为 y 被修改后才调用的 ylab 变量。
解决方法是首先强制yalb求值。

logplot <- function(y, ylab = deparse(substitute(y))) {
  ylab;
  y <- log(y)
  plot(y, ylab = ylab)
}
height=1:10
logplot(y=height)
# 这样 ylab 就是正常的 "height" 值了。

注意：这种情况不能使用 eval(ylab)。如果 ylab 是  language or expression 对象，那样将会导致求值，更不适合传入类似 quote(log[e](y)) 这样的数学表达式。

logplot <- function(y, ylab = deparse(substitute(y))) {
  ylab
  #eval(ylab); ##rror: object 'e' not found 
  y <- log(y)
  plot(y, ylab = ylab)
}
height=1:10
logplot(y=height, ylab=quote(log[e](y)))
# 不理想：图中的ylab 是 loge(y) (其中e是下标)，怎么变成 log e(height)?
> logplot(y=height, ylab=quote(log[e](height)))


A promise捕获(capture)了需要计算的表达式（但是没有计算eval），以及计算表达式所处的environment. 
第一次访问promise时，触发表达式的计算，从而产生environment中的表达式对应绑定对象的值。
promise就像“薛定谔的猫”，一旦访问，就触发计算，从而退出promise状态。





2. bquote() 函数是 substitute 的变体，用于替换子表达式为值。

bquote(expr, where = parent.frame(), splice = FALSE)

简单地返回expr，expr没有进行eval。和substitute相比，没有替换。


> res1 <- quote(height); res1
height
> c(class(res1), typeof(res1))
[1] "name"   "symbol"


> res3 <- quote(a/b); res3
# a/b
> c(class(res3), typeof(res3))
[1] "call"     "language"

subtitute/quote返回class/type根据表达式的不同而不同。
表达式被解析为抽象语法树，可以访问其中每一个组成，还可以对返回的对象进行修改，即自己构造语法树（meta-programming）。




图形中打字的例子:
> plot(0)
> for (i in 1:4)
   text(1, 0.2 * i, substitute(x[ix] == y, list(ix = i, y = pnorm(i))))

可以简写为:
> plot(0)
> for(i in 1:4)
    text(1, 0.2*i, bquote( x[.(i)] == .(pnorm(i)) ))

替换规则就是，.()内的表达式求值，外边的保留表达式。
第二个参数是可选的，指定计算值的环境。
bquote 语法来自 LISP 的后置引用宏(backquote macro)。






ref:
https://cran.r-project.org/doc/manuals/R-lang.html#Substitutions
https://blog.csdn.net/tanzuozhev/article/details/50603045














========================================
|-- 获取并修改R表达式的语法树：调用类型 (call) 实质上是一个list(可修改)，可用 quote() 包围表达式生成，调用 eval() 执行
----------------------------------------
1. call 对象

(1) 参考资料
官方: https://cran.r-project.org/doc/manuals/R-lang.html  第6章
	https://cran.r-project.org/doc/manuals/R-lang.html#Direct-manipulation-of-language-objects
pdf: https://cran.r-project.org/doc/manuals/r-devel/R-lang.pdf
	2017: http://web.mit.edu/~r/current/arch/amd64_linux26/lib/R/doc/manual/R-lang.pdf

本质:
调用类型（call()）这个东西，其实是一个list，如果不执行，就是一个相当于list的东西，如果执行，将会返回一个值。如果想让他执行，就用eval()，一般eval() 里面都有quote之类的函数，来保证里面的函数是表达式。

另外，因为call类型有list的属性，那么用as.list() 和as.call() 之间可以相互转换。比如list转换成了call，然后在eval() 执行。





2. 直接操作 语言对象
There are three kinds of language objects that are available for modification, calls, expressions, and functions. 
有三种语言对象可用于修改: 调用，表达式和函数。这里集中说调用对象。
它有时候也被叫做 未求值的表达式 "unevaluated expressions"


(1) 最直接的创建方式是给 quote() 函数传递一个表达式参数，比如:

> e1 <- quote(2 + 2)

> x=1:10; y=x**2
> e2 <- quote(plot(x, y))

查看类型
> class(e1)
[1] "call"
> class(e2)
[1] "call"
> str(e1)
 language 2 + 2

> e1
2 + 2
> e2
plot(x, y)


# 也可以通过函数调用形式创建
> "+"(2, 2)
[1] 4
> e1_2 <- quote( "+"(2, 2) )
> e1_2
2 + 2



(2) 这个对象e1、e2没有求值，可以通过 eval() 求值
> e1
2 + 2

> eval(e1)
[1] 4
> eval(e2) #直接画图




(3) 或者像list一样操作

> e2[[1]]
plot
> e2[[2]]
x
> e2[[3]]
y

> class(e2[[3]]) #参数都是 name 类的
[1] "name"


#2) 当使用键值对参数的时候，还可以使用键名访问
> e3 <- quote(plot(x = age, y = weight))
> e3
plot(x = age, y = weight)
> e3$x
age
> e3$y
weight

> class(e3$y)
[1] "name"



#3) 修改元素
既然每个元素都是 name 类的，我们也可以像操作list一样，使用同类对象替换每个元素。

> e2
plot(x, y)

这个调用对象本来是画图的，我们把操作符替换为加号:
> e2[[1]]
plot
> e2[[1]]=as.name("+")
> e2
x + y
> eval(e2)
 [1]   2   6  12  20  30  42  56  72  90 110


#4) 调用对象的元素也可以是 call 类型
> e1
2 + 2
> e1[[2]]
[1] 2
> e1[[2]] = e2
> e1 #注意: 第一个元素是操作符+，第二个元素是参数1，第三个元素是参数2
x + y + 2






(4) 对于括号的处理
这两段有点翻译不动，附原文。

所有用来分组的括号，都保留在解析后的表达式中了。它们的形式就是带一个参数的函数调用，所以 4-(2-2) 变成了 "-"(4, "(" ("-"(2, 2)))。求值的时候，"("操作符就是返回它的参数本身。
# All grouping parentheses in input are preserved in parsed expressions. They are represented as a function call with one argument, so that 4 - (2 - 2) becomes "-"(4, "(" ("-"(2, 2))) in prefix notation. In evaluations, the ‘(’ operator just returns its argument.


> a1=quote(4-(2-2))
> a1
4 - (2 - 2)
> as.list(a1)
[[1]]
`-`

[[2]]
[1] 4

[[3]]
(2 - 2)


> a1[[1]]
`-`
> a1[[2]]
[1] 4
> a1[[3]]
(2 - 2)

> # 第三个元素又是一个list-like对象，第一个运算符是(，后面作为它的参数
> a2=a1[[3]]
> a2[[1]]
`(`
> a2[[2]]
2 - 2

> # (运算符的参数，就是最简单的 2-2 运算符
> a3=a2[[2]]
> a3[[1]]
`-`
> a3[[2]]
[1] 2
> a3[[3]]
[1] 2
> 


这很不幸，但是写一个好用的 parser/deparser 组合并不容易！
要能保存用户输入，尽量简短，且能还原回去。 
# This is a bit unfortunate, but it is not easy to write a parser/deparser combination that both preserves user input, stores it in minimal form and ensures that parsing a deparsed expression gives the same expression back.


碰巧的是/偶然情况，R的 parser 不是完全可逆的，它的 deparser 也不是完全可逆的，比如这个例子：
# As it happens, R’s parser is not perfectly invertible, nor is its deparser, as the following examples show


> str(quote(c(1,2)))
 language c(1, 2)
> str(c(1,2))
 num [1:2] 1 2

> deparse(quote(c(1,2)))
[1] "c(1, 2)"
> deparse(c(1,2))
[1] "c(1, 2)"

> quote("-"(2, 2))
2 - 2
> quote(2 - 2)
2 - 2


然而，Deparsed 表达式应该计算为与原始表达式等价的值(最多有点舍入误差)。
# Deparsed expressions should, however, evaluate to an equivalent value to the original expression (up to rounding error).


流程控制结构的内部存储，和S+不兼容。
# ...internal storage of flow control constructs...note Splus incompatibility...




# Q&A
deparse: Turn unevaluated expressions into character strings.

没有用substitute而是用的quote，没仔细看二者有没有什么区别，就是觉得quote打起来省事点
aaa=1:5
as.character(quote(aaa))

> deparse(substitute(deg))
[1] "deg"








========================================
rlang 包: 拆解R表达式(Defusing R expressions):  expr(), quo()/enquo(), !!, eval_tidy()
----------------------------------------

1. 拆解后的R表达式，不再是正常的R表达式，二是一个树状结构，可看作计算结果的蓝图。

(1) 举例
> 1 + 1 #表达式，常规是直接计算值
[1] 2

> expr(1 + 1) #而加上 expr() 后返回的是一个"call" 对象
1 + 1
> class(expr(1 + 1))
[1] "call"

> eval( expr(1 + 1) ) #"call" 对象可以通过 eval() 求值
[1] 2


(2) 使用场景
拆解表达式的最常用的场景，是在一个指定环境中使用该表达式。
eval()的第二个参数是环境，给出查找的范围。

> e = expr(mean(cyl)); e
# mean(cyl) #相当于该表达式被静态化了，暂时不求值。
> eval(e, mtcars)
#[1] 6.1875



(3) sym() 字符串 to symbol 
> class(sym('1+2')) 
[1] "name"
> sym('1+2')
`1+2`
> class(sym('1+2'))
[1] "name"

> parse(text=sym('1+2') ) #转为表达式
expression(1+2)
> eval(parse(text=sym('1+2') ))
[1] 3



2. quo() 和 quo() 类似 expr() 但是返回的是 quosure 对象，可以记录环境。

(1) 示例
> quo(1+2) #返回一个对象
<quosure>
expr: ^1 + 2
env:  global
> class(quo(1+2))
[1] "quosure" "formula"


> quos(1+2) #返回要给list
<list_of<quosure>>

[[1]]
<quosure>
expr: ^1 + 2
env:  global


(2) 求值
> eval_tidy(expr=quo(1+2))
[1] 3



(3) 嵌套并解析
> a1=quo(iris[,1]); a1
<quosure>
expr: ^iris[, 1]
env:  global
> a2=quo(mean(!!a1)); a2 #嵌套进去一个 quosure 对象，使用 !!可以替换其内容。 
<quosure>
expr: ^mean(^iris[, 1])
env:  global
> eval_tidy(a2)
[1] 5.843333







3. enquo() 拆解函数的参数
(1) enquo() 能拆解函数
> enquo(arg=mean) #把函数拆开了，貌似不是我们需要的
<quosure>
expr: ^<function(x, ...) UseMethod("mean")>
env:  empty

求值后是一个函数的定义。
> eval_tidy(enquo(arg=mean))
function (x, ...) 
UseMethod("mean")
<bytecode: 0x5612e33a7378>
<environment: namespace:base>

可以给该函数一个名字:
> fn2=eval_tidy(enquo(arg=mean))
> fn2(iris$Sepal.Length)
[1] 5.843333
效果确实和原函数一样:
> mean(iris$Sepal.Length)
[1] 5.843333


(2) 拆解函数的参数
使用 quo() 获取参数失败
fn1=function(x){
  quo(x)
}
> fn1(c(1,2)) #获取失败
<quosure>
expr: ^x
env:  0x5612f86e0150

# 使用 enquo() 获取函数参数成功
fn2=function(x){
  enquo(x)
}
> fn2(c(1,2)) #获取成功
<quosure>
expr: ^c(1, 2)
env:  global





(3) 神奇的求值：把公式传入函数
# try1
mean_in_data <- function(data, expr) {
  expr0 <- substitute(expr)           # capture user expression
  print(expr0)
  expr <- bquote(mean(.(expr0)))      # wrap it in `mean`
  print(expr)
  print(parent.frame())
  eval(expr, data, parent.frame())
}
> l.per.cubic.i <- 2.54^3 / 1000
> mean_in_data(mtcars, disp * l.per.cubic.i)
disp * l.per.cubic.i
mean(disp * l.per.cubic.i)
<environment: R_GlobalEnv>
[1] 3.780854


到底计算了什么？
> exp1=parse(text="mean(disp * l.per.cubic.i)")
> exp1
expression(mean(disp * l.per.cubic.i))
> eval(exp1, mtcars)
[1] 3.780854
就一句话:
> mean(mtcars$disp * 2.54^3 / 1000)
[1] 3.780854



#try2
mean_in_data_rl <- function(data, expr) {
  quosure0 <- enquo(expr)           # capture user expression
  print(quosure0)
  quosure <- quo(mean(!!quosure0))  # wrap it in `mean`
  print(quosure)
  eval_tidy(quosure, data)
}
> mean_in_data_rl(mtcars, disp * l.per.cubic.i)
<quosure>  #第一个是捕获公式
expr: ^disp * l.per.cubic.i
env:  global
<quosure> #第二个是把第一个变量替换掉
expr: ^mean(^disp * l.per.cubic.i)
env:  0x5612fcb7a2d8
[1] 3.780854





3. rlang 和 base 的对标
(1) rlang::quo 对应 base::bquote

rlang::quo is used similarly to base::bquote, but is lexically closer to base::quote, and at same time gives no indication of its special environment capture abilities in its name.


(2) rlang::enquo 对应 base::substitute

rlang::enquo is used similarly to base::substitute, but bears no relation to base::enquote. This clash with base::enquote is particularly confusing to me given that the “en” gives no indication of how enquo is different from quo (my personal experience was that the lexical similarity between quo and enquo made it harder to figure out what was going on).


(3) !! 对应 .() ,实现注入表达式

rlang designates partial evaluation with !! instead of .() as in base, which is probably the most controversial design decision.












ref: https://www.brodieg.com/2020/08/11/quosures/
https://github.com/r-lib/rlang
https://rlang.r-lib.org/reference/enquo.html
https://rlang.r-lib.org/reference/topic-metaprogramming.html
https://rlang.r-lib.org/reference/topic-metaprogramming.html









========================================
assign("para", value): 给字符串变量赋值
----------------------------------------
1. 如果我们不确定有几个变量时怎么赋值？
例: 生成变量，并赋值。

for(i in 1:5){
  assign(paste0("x",i),i)
}


赋值需要用assign函数，第一个参数是变量名的字符串；第二个则是我们需要赋值的具体对象（可以是数字、字符、以及任意对象）

然后我们就有了5个变量：x1/x2/x3/x4/x5。





========================================
函数的拆解与组装
----------------------------------------
1. 基本结构
f <- function(x) x

formals(f)
## $x

body(f)
## x

environment(f)
## <environment: R_GlobalEnv>

功能分别是:
获取参数列表
获取函数体
获取运行环境




2. 修改参数 formals()
Access to and Manipulation of the Formal Arguments
Description: Get or set the formal arguments of a function.

> formals
function (fun = sys.function(sys.parent()), envir = parent.frame()) 
{
    if (is.character(fun)) 
        fun <- get(fun, mode = "function", envir = envir)
    .Internal(formals(fun))
}
<bytecode: 0x0000000009ea7e98>
<environment: namespace:base>


例子:
> formals(plot)
$x


$y


$...

> names(formals(plot))
[1] "x"   "y"   "..."


(2) 替换参数
> f <- function(x) x
> formals(f) # $x
$x

> class(formals(f))
[1] "pairlist"
> typeof(formals(f))
[1] "pairlist"


> formals(f)=list(x=quote(y)) #如果不解析，要加 quote()
> f
function (x = y) #参数已经被修改了
x

调用函数
> y=10
> f()
[1] 10
> y=2
> f()
[1] 2





3. 修改函数体 body(f)

> f=function(x)x
> body(f)
x
> c(class(body(f)), typeof(body(f)))
[1] "call"     "language"


> body(f)= quote(2*x) #修改函数体
> body(f)
2 * x
> f
function (x) 
2 * x  #函数体已经被改变


调用函数:
> f(5)
[1] 10
> f(15)
[1] 30






4. 组装函数
rs=alist(a=, b=, a+b)
f=as.function(rs)
f
f(4, 5) #9



(2) alist 经常和 formals 连用
f=function(x)x
formals(f) <- alist(x =, y =)
> f
function (x, y) 
x


(3) 定义函数的等价形式
nested <- function(y) {
 as.function(alist(x =, y = y, x + y))
}

nested2 <- function(y) {
 function(x, y = y) x + y
}

获取返回的函数:
> f1=nested()
> f2=nested2()
> f1
function (x, y = y) 
x + y
<environment: 0x55cabdd10f40>
> f2
function(x, y = y) x + y
<environment: 0x55cabdb64338>

求值
> f1(1,3)
[1] 4
> f2(1,3)
[1] 4


(4) 怎么设置函数的环境
nested3 <- function(z) {
 as.function(alist(x =, y = z, x + y))
}

nested4 <- function(z) {
 as.function(alist(x =, y = z, x + y),
 envir = globalenv())
}

f3=nested3(3)
f4=nested4(3)

查看函数
> f3
function (x, y = z) 
x + y
<environment: 0x55cacf5f0490>
> f4
function (x, y = z) 
x + y

求值:
> z=10
> f3(1) #使用内部环境中的z，就是第一次调用函数时传入的z=3
[1] 4
> f4(1) #使用全局环境中的z
[1] 11

#还可以使用连续圆括号调用
> z=10
> nested3(3)(1)
[1] 4
> nested4(3)(1)
[1] 11


查看函数所在环境中的变量名
> ls(environment(f3))
[1] "z"

> ls(environment(f4))
 [1] "counter"  ... "y"           "z" 






5. 函数内部获取函数信息

f <- function(x = 5) {
 y <- 2 * x
 sys.function()
}

该函数的返回值是它自己:
> f
function(x = 5) {
    y <- 2 * x
    sys.function()
}
> f()
function(x = 5) {
    y <- 2 * x
    sys.function()
}


(2) 函数内获取参数列表
可以直接调用无参数的 formals()

f <- function(x, y = 2 * x) formals()
params <- f(1, 2)
class(params)
# [1] "pairlist"

> params
$x


$y
2 * x



(3) 函数内部获取函数体
f <- function(x, y = 2 * x) {
 z <- x - y
 body()
}
> f(2)
{
    z <- x - y
    body()
}



(4) environment() 不带参数则是获取其执行的环境

f=function(){
  x=1
  y=2
  z=3
  environment()
}
env=f()
> env
<environment: 0x55cace385110>

> as.list(env)
$z
[1] 3

$y
[1] 2

$x
[1] 1


注意：直接传入函数名，返回的是函数运行时所在的空间，比如:
> environment(f)
<environment: R_GlobalEnv>


(5) 获取运行时的父环境 parent.env()
f <- function() {
 x <- 1
 y <- 2
 z <- 3
 parent.env(environment())
}

> f()
<environment: R_GlobalEnv>







6. 获取函数的真实参数

f <- function(x = 1:3) {
 print(formals()$x)
 x
}
f(x = 4:6)
## 1:3
## [1] 4 5 6




========================================
// todo P28/106
----------------------------------------
https://www.programmer-books.com/wp-content/uploads/2019/05/Metaprogramming-in-R.pdf
















========================================
local(): Evaluate an R expression in a specified environment. //todo
----------------------------------------
1. 语法
eval(expr, envir = parent.frame(),
           enclos = if(is.list(envir) || is.pairlist(envir))
                       parent.frame() else baseenv())


https://adv-r.hadley.nz/evaluation.html




2. 示例
可以在指定环境解析表达式的值。

(1) 全局环境
x=20
y1=local(
  expr={
    add10=function(x){
      return (x+10)
    }
    add10(x);
  },
  
  envir=parent.frame()
)
x=25 #这个不影响评估值
y1 #30



(2) 自定义环境
e1=environment()
e1$x=-1
ls(envir = e1)
y2=local(
  expr={
    add10=function(x){
      return (x+10)
    }
    add10(x);
  },
  
  envir=e1
)
y2 #9







========================================
元编程实例1: 怎么实现 subset(data, expr)?
----------------------------------------
1. 实例
subset(iris, Sepal.Length>7)
> subset(iris, Sepal.Length>7 & Sepal.Width<=2.8)
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica
131          7.4         2.8          6.1         1.9 virginica



2. 源码

> getAnywhere("subset.data.frame")
A single object matching ‘subset.data.frame’ was found
It was found in the following places
  package:base
  registered S3 method for subset from namespace base
  namespace:base
with value

function (x, subset, select, drop = FALSE, ...) 
{
    r <- if (missing(subset)) 
        rep_len(TRUE, nrow(x))
    else {
        e <- substitute(subset)
        r <- eval(e, x, parent.frame())
        if (!is.logical(r)) 
            stop("'subset' must be logical")
        r & !is.na(r)
    }
    vars <- if (missing(select)) 
        rep_len(TRUE, ncol(x))
    else {
        nl <- as.list(seq_along(x))
        names(nl) <- names(x)
        eval(substitute(select), nl, parent.frame())
    }
    x[r, vars, drop = drop]
}
<bytecode: 0x55e6e1ce9b48>
<environment: namespace:base>
> 



(2) 解析
去掉异常检测之外的代码。

> e1=substitute(Sepal.Length>7 & Sepal.Width<=2.8) #捕获表达式
> e1
Sepal.Length > 7 & Sepal.Width <= 2.8
> class(e1)
[1] "call"


> rs=eval(e1, iris, parent.frame()) #计算e1，后面是环境
> table(rs) #结果是一个布尔值向量，T or F
rs
FALSE  TRUE 
  147     3 


> rs=rs & !is.na(rs) #过滤掉NA

> vars=rep_len(TRUE, ncol(iris)); vars #获取列
[1] TRUE TRUE TRUE TRUE TRUE


> iris[rs, vars, drop = F] #
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica
131          7.4         2.8          6.1         1.9 virginica




(3) 仿写一个交互版的 subset2 函数 
subset(airquality, Ozone > 50 & Temp >= 50 & Wind >= 10)
subset(airquality, Ozone > 50 & Temp >= 90)

filter1=function(dt=airquality, O1=50, T2=90){
  dt=subset(dt, Ozone > O1 & Temp >= T2)
  return(dt)
}
filter1(airquality)
filter1(airquality, 95)
filter1(airquality, 95, 92)

#
subset2=function(dt=airquality, expr){
  expr=substitute(expr)
  #dt=subset(dt, subset=deparse(expr) ) #这个一直无法通过
  rs=eval(expr, dt) #在dt的环境下，求 expr 的布尔值
  rs=rs & !is.na(rs) #remove NA
  return(dt[rs,]) #返回布尔值为T的行
}
subset2(airquality, expr=Ozone > 95 & Temp >= 92)




(4) 用到函数中报错
filter3=function(dt=airquality, expr){
  dt=subset(dt, expr)
  return(dt)
}

> filter3(airquality, Temp>95)
Error in eval(e, x, parent.frame()) : object 'Temp' not found


try2:
filter3=function(dt=airquality, expr){
  expr=substitute(expr)
  dt=subset(dt, expr)
  return(dt)
}
filter3(airquality, Temp>95)
> filter3(airquality, Temp>95)
Error in subset.data.frame(dt, expr) : 'subset' must be logical



try3:








========================================
|-- 怎么在函数中使用  subset? //todo
----------------------------------------
3. 在函数中使用 subset //todo

# https://github.com/satijalab/seurat/issues/1538

> library(Seurat)
> testFunction <- function(pbmc, threshold=c(200,2500)){
  sub <- subset(pbmc, subset = nFeature_RNA > threshold[1] )
    return(sub)
}

> testFunction(pbmc)
An object of class Seurat 
13714 features across 2638 samples within 1 assay 
Active assay: RNA (13714 features, 2000 variable features)
 3 dimensional reductions calculated: pca, umap, tsne

> testFunction(pbmc, threshold=c(500,3000))
An object of class Seurat 
13714 features across 2450 samples within 1 assay 
Active assay: RNA (13714 features, 2000 variable features)
 3 dimensional reductions calculated: pca, umap, tsne


说明 Seurat 的 subset() 已经可以在函数内使用了，而之前是不能在函数内使用的。




(2) 源码解析

没读懂精华在哪几句。。。

> getAnywhere("subset.Seurat")
A single object matching ‘subset.Seurat’ was found
It was found in the following places
  registered S3 method for subset from namespace SeuratObject
  namespace:SeuratObject
with value

function (x, subset, cells = NULL, features = NULL, idents = NULL, 
    return.null = FALSE, ...) 
{
    x <- UpdateSlots(object = x)
    if (!missing(x = subset)) {
        subset <- enquo(arg = subset)
    }
    cells <- WhichCells(object = x, cells = cells, idents = idents, 
        expression = subset, return.null = TRUE, ...)
    if (length(x = cells) == 0) {
        if (isTRUE(x = return.null)) {
            return(NULL)
        }
        stop("No cells found", call. = FALSE)
    }
    if (all(cells %in% Cells(x = x)) && length(x = cells) == 
        length(x = Cells(x = x)) && is.null(x = features)) {
        return(x)
    }
    if (!all(colnames(x = x) %in% cells)) {
        slot(object = x, name = "graphs") <- list()
        slot(object = x, name = "neighbors") <- list()
    }
    assays <- FilterObjects(object = x, classes.keep = "Assay")
    for (assay in assays) {
        assay.features <- features %||% rownames(x = x[[assay]])
        slot(object = x, name = "assays")[[assay]] <- tryCatch(expr = base::subset(x = x[[assay]], 
            cells = cells, features = assay.features), error = function(e) {
            if (e$message == "Cannot find features provided") {
                return(NULL)
            }
            else {
                stop(e)
            }
        })
    }
    slot(object = x, name = "assays") <- Filter(f = Negate(f = is.null), 
        x = slot(object = x, name = "assays"))
    if (length(x = FilterObjects(object = x, classes.keep = "Assay")) == 
        0 || is.null(x = x[[DefaultAssay(object = x)]])) {
        stop("Under current subsetting parameters, the default assay will be removed. Please adjust subsetting parameters or change default assay.", 
            call. = FALSE)
    }
    for (dimreduc in FilterObjects(object = x, classes.keep = "DimReduc")) {
        x[[dimreduc]] <- tryCatch(expr = subset.DimReduc(x = x[[dimreduc]], 
            cells = cells, features = features), error = function(e) {
            if (e$message %in% c("Cannot find cell provided", 
                "Cannot find features provided")) {
                return(NULL)
            }
            else {
                stop(e)
            }
        })
    }
    slot(object = x, name = "meta.data") <- slot(object = x, 
        name = "meta.data")[cells, , drop = FALSE]
    for (assay in FilterObjects(object = x, classes.keep = "Assay")) {
        n.calc <- CalcN(object = x[[assay]])
        if (!is.null(x = n.calc)) {
            names(x = n.calc) <- paste(names(x = n.calc), assay, 
                sep = "_")
            x[[names(x = n.calc)]] <- n.calc
        }
    }
	
    Idents(object = x, drop = TRUE) <- Idents(object = x)[cells]
    for (image in Images(object = x)) {
        x[[image]] <- base::subset(x = x[[image]], cells = cells)
    }
    return(x)
}
<bytecode: 0x55cacb7e89b8>
<environment: namespace:SeuratObject>













========================================
元编程实例2: 实现一种编写 html 的 DSL //todo
----------------------------------------

http://adv-r.had.co.nz/dsl.html
https://adv-r.hadley.nz/translation.html
https://www.apress.com/gp/blog/all-blog-posts/domain-specific-languages-in-r/15742536

Domain-Specific Languages in R: Advanced Statistical Programming: https://link.springer.com/book/10.1007/978-1-4842-3588-1 
	可下载: Mailund2018_Book_Domain-SpecificLanguagesInR.pdf


组装逻辑表达式: https://stackoverflow.com/questions/69721004/r-meta-programming-paste-logic-expressions-with-function-call

https://combine-australia.github.io/r-pkg-dev/advanced-topics.html
https://search.r-project.org/CRAN/refmans/rlang/html/topic-metaprogramming.html
https://tidyeval.tidyverse.org/

	https://livebook.manning.com/book/dsls-in-action/appendix-b/1
















========================================
实例3: 怎么实现管道符?  //todo
----------------------------------------
R 有magrittr包提供的管道符 `%>%`，也有最近原生提供的 `|>`。

本文向探究一下它们是怎么实现的。




1. 目标效果

(1) R包提供的管道符
> library(magrittr)
> iris %>% dim %>% sum
[1] 155
> iris %>% dim() %>% sum()
[1] 155

> iris %>% dim() %>% sum(100,2000) #额外加2个参数
[1] 2255


(2) R 原生管道符
> iris |> dim() |> sum(100,2000)
[1] 2255


(3) 查看源代码

> `%>%`
function (lhs, rhs) 
{
    lhs <- substitute(lhs)
    rhs <- substitute(rhs)
    kind <- 1L
    env <- parent.frame()
    lazy <- TRUE
    .External2(magrittr_pipe)
}
<bytecode: 0x55efd70e97b0>
<environment: namespace:magrittr>


> `|>`
Error: object '|>' not found

> `+`
function (e1, e2)  .Primitive("+")


查看不到源码。








2. 我的尝试
https://stackoverflow.com/questions/13354048/r-pipelining-functions

(1) version1: 不支持圆括号，那么就不能有参数了
"%>>%" <- function(x, fun){
  if(is.function(x)) {
    function(...) fun(x(...))
  } else {
    fun(x)
  }
}

> iris %>>% dim %>>% sum
[1] 155



# 这个相当于把函数写成整体，没法使用额外的参数
"%|>%" <- function(fun1, fun2){
    function(x){fun2(fun1(x))}
}
> fn001=dim %|>% sum  #合并函数
> fn001(iris)
[1] 155






(2) 可能需要对函数进行拆解: 传入函数调用，拆出来其函数名和参数列表；不能跨函数传递

fn=function(x=dim()){
  x1=substitute(x);
  x2=deparse(x1) #"dim()"
  #
  fname=""
  arg.str=""
  if( endsWith(x2, ")") ){
    #找到第一个(
    start=grepRaw("\\(", x2);
    fname=substr(x2, 1, start-1)
    arg.str=substr(x2, start+1, nchar(x2)-1)
  }else{
    #没有() 时是不是函数?怎么判断
    if( is.function(x) ){
      fname=x2;
    }else{
      arg.str="not a fun"
    }
  }
  # string to list
  if(fname!="")
    arg.list=parse(text = paste0( "list(", arg.str, ")" ))
  else
    arg.list=arg.str;
  message("fun name:", fname)
  message("arg list:", arg.list)
}

#
> fn( dim() )
fun name:dim
arg list:list()

> fn( sum(iris[,1:4]) )
fun name:sum
arg list:list(iris[, 1:4])

> fn("dog")
fun name:
arg list:not a fun

> fn( ls )
fun name:ls
arg list:list()

> fn( ls('./', pattern = "R$") )
fun name:ls
arg list:list("./", pattern = "R$")


不能嵌套
# 能通过函数传递吗？目前不能 //todo
fn2=function(x, y){
  #x2=substitute(x)
  #print(x2)
  #print( class(x2) )
  fn( x)
}

> fn(ls)
fun name:ls  #函数名正常
arg list:list()

> fn2(ls)
fun name:x  #函数名失效
arg list:list()






(3) 能跨函数传递版本：传入字符串

# 可以把函数调用转为字符串，支持多个函数传递
parse_func=function(x2){
  if(!is.character(x2)){
    stop("must input a character!")
  }

  fname=-1
  arg.str=""
  if( endsWith(x2, ")") ){
    #找到第一个(
    start=grepRaw("\\(", x2);
    fname=substr(x2, 1, start-1)
    arg.str=substr(x2, start+1, nchar(x2)-1)
  }else{
    #没有() 时是不是函数?怎么判断
    tryCatch({
      if( is.function(eval(parse(text=x2)) ) ){
        fname=x2;
      }
    })
  }
  # string to list
  if(fname!="")
    arg.list=parse(text = paste0( "list(", arg.str, ")" ))
  else{
    fname=-1
    arg.list=""
  }
  #
  return(list(
    fname=fname,
    args=arg.list
  ))
}

# 传入字符串
parse_func( "ls" )
parse_func( "ls(a=2,b=3)" )


# test: 能通过函数传递吗？
fn2=function(x, y){
  x3=deparse( substitute(x) )
  parse_func( x3)
}
fn2(ls)
fn2(iris)


> fn2(ls)
$fname
[1] "ls"

$args
expression(list())

> fn2(iris) #不是函数，则函数名是 -1
$fname
[1] -1

$args
expression(list())



# 尝试制作自己的管道符

"%>>2%" <- function(x, fun){
  # 1. 函数调用表达式 to 字符串
  x2=deparse(substitute(x));
  fun2=deparse(substitute(fun));
  # 2.提取函数名字和参数列表
  x3=parse_func(x2);
  fun3=parse_func(fun2);
  # 3.调用函数: 第2个的函数名( 第一个参数作为第一个参数，紧随第二个函数的其余参数)
  arg.list=c( list(eval(parse(text=x2))), eval(fun3$args) ) #如果参数中有表达式，这样写有问题
  do.call(fun3$fname, arg.list)
};
iris %>>2% head()
iris %>>2% head() %>>2% dim() %>>2% sum()



> iris %>>2% head(n=3)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa

> iris %>>2% head() %>>2% dim() %>>2% sum()
[1] 11

> iris %>>2% dim() %>>2% sum(100,2000)
[1] 2255




# 自定义函数，一个不带其他参数，一个带其他参数
square=function(x){x**2}
add= function(x, n=1){x+n}

1:5
1:5 %>>2% square()
1:5 %>>2% square() %>>2% add(5)

1:5 %>% square() %>% add(5)





# 支持设置参数: 修改列名
> iris %>% setNames( paste0("c",c(1,2,3,4, 5))) %>>2% head(n=3)
   c1  c2  c3  c4     c5
1 5.1 3.5 1.4 0.2 setosa
2 4.9 3.0 1.4 0.2 setosa
3 4.7 3.2 1.3 0.2 setosa



# 可以使用 ggplot2 绘图

library(ggplot2)
mtcars %>>2% head(n=30) %>%
  ggplot(aes(wt, mpg, col=factor(gear) )) + geom_point()


# 支持按列选择数据 http://adv-r.had.co.nz/Computing-on-the-language.html
select <- function(df, vars) {
  vars <- substitute(vars)
  var_pos <- setNames(as.list(seq_along(df)), names(df))
  pos <- eval(vars, var_pos)
  df[, pos, drop = FALSE]
}

> mtcars %>>2% head(n=3) %>>2% select(c("wt", "am", "mpg"))
                 wt am  mpg
Mazda RX4     2.620  1 21.0
Mazda RX4 Wag 2.875  1 21.0
Datsun 710    2.320  1 22.8






# 无法处理表达式参数: //todo 这又回到了问题(2)，表达式无法嵌套

iris %>% subset( Petal.Length>6 )
iris %>>2% subset( Petal.Length>6 ) #not work


# http://adv-r.had.co.nz/Computing-on-the-language.html
subset2a <- function(x, condition) {
  condition_call <- substitute(condition)
  env <- list2env(x, parent = parent.frame())
  r <- eval(condition_call, env)
  x[r, ]
}

> subset2a(iris, Petal.Length>6.5)
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
106          7.6         3.0          6.6         2.1 virginica
118          7.7         3.8          6.7         2.2 virginica
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica

> iris %>>2% subset2a( Petal.Length>6 )
Error in eval(fun3$args) : object 'Petal.Length' not found








3. 表达式做为函数参数，怎么传递给其他函数？

http://adv-r.had.co.nz/Computing-on-the-language.html

- 替换(quote/substitute)一次为 call 就可以在函数之间传递了
- call 可以嵌套替换。


(1) 第一个函数可以筛选：给出数据框和条件
X=30
f1=function(x, condition){
  condition_call=substitute(condition)
  sel=eval(condition_call, x, parent.frame())
  #sel=eval(condition_call, x)
  x[sel,]
}

> f1(mtcars, mpg>X)
                mpg cyl disp  hp drat    wt  qsec vs am gear carb
Fiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1
Lotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2


(2) 第二个函数固定数据框，只需要给出条件，然后调用第一个函数：失败

f2=function(x){
  f1(mtcars, x)
}
f2(mpg>30) #这里是x，不是传入的 mpg>30

> f2(mpg>30)
[1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
<0 rows> (or 0-length row.names)



(3) 第二个函数 v2: 成功
f2_b=function(x){
  x=substitute(x)
  call=substitute( substitute( f1(mtcars, y)), list(y=x) )
  #print(call)
  call2=eval(call) #为什么要 eval 两次？
  eval(call2)
}

> f2_b(mpg>30)
                mpg cyl disp  hp drat    wt  qsec vs am gear carb
Fiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1
Lotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2
> f2_b(mpg>30 & carb==1)
                mpg cyl disp hp drat    wt  qsec vs am gear carb
Fiat 128       32.4   4 78.7 66 4.08 2.200 19.47  1  1    4    1
Toyota Corolla 33.9   4 71.1 65 4.22 1.835 19.90  1  1    4    1






4. 回到主线2(3)，接着修复主线

(1) 发现只需要修改一行即可: 倒数第二行 eval(fun3$args) 改为  eval(fun3$args,x) 即可支持输入表达式。

"%>>3%" <- function(x, fun){
  # 1. 函数调用表达式 to 字符串
  x2=deparse(substitute(x));
  fun2=deparse(substitute(fun));
  # 2.提取函数名字和参数列表
  x3=parse_func(x2);
  fun3=parse_func(fun2);
  # 3.调用函数: 第2个的函数名( 第一个参数作为第一个参数，紧随第二个函数的其余参数)
  arg.list=c( list(eval(parse(text=x2))),  eval(fun3$args, x) ) #只需要修改这一行即可
  do.call(fun3$fname, arg.list)
};

> iris %>>3% head() %>>3% subset(Sepal.Length>5) #第三版正常
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa

> iris %>>3% head() %>>2% subset(Sepal.Length>5) #第二版还是报错的
Error in eval(fun3$args) : object 'Sepal.Length' not found



更多对比测试，输出结果相同:
> subset(iris, Petal.Length>6.5)
> iris %>% subset( Petal.Length>6.5)
> iris %>>3% subset( Petal.Length>6.5)
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
106          7.6         3.0          6.6         2.1 virginica
118          7.7         3.8          6.7         2.2 virginica
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica


(2) 发现新的bug //todo

> iris %>>3% head() %>>3% dim() %>>2% sum()
Error in eval(fun3$args, x) : numeric 'envir' arg not of length one

> iris %>>3% dim() %>>3% sum(100,2000)
Error in eval(fun3$args, x) : numeric 'envir' arg not of length one


> iris %>>2% subset( Petal.Length>6.5) %>>2% dim() %>>% head()
Error in checkHT(n, dx <- dim(x)) :
argument "x" is missing, with no default




ref: https://oomake.com/question/3745806
http://adv-r.had.co.nz/Computing-on-the-language.html






========================================
----------------------------------------





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


