ggplot2




http://sape.inf.usi.ch/quick-reference/ggplot2
https://blog.csdn.net/u014801157/article/category/2215813



完整代码示例:
https://github.com/DawnEve/bioToolKit/blob/master/R_scripts/ggplot2_dplyr/000-ggplot2-book1.R



我的笔记: 示例图及代码
http://www.biomooc.com/R/R-draw-adv-ggplot2.html
http://tool.biomooc.com/R_scripts/index.html


========================================
ggplot2 概述与学习资源
----------------------------------------
1. 设计理念

ggplot2是用于绘图的R语言扩展包，其理念根植于《Grammar of Graphics》一书。它将绘图视为一种映射，即从数学空间映射到图形元素空间。例如将不同的数值映射到不同的色彩或透明度。该绘图包的特点在于并不去定义具体的图形（如直方图，散点图），而是定义各种底层组件（如线条、方块）来合成复杂的图形，这使它能以非常简洁的函数构建各类图形，而且默认条件下的绘图品质就能达到出版要求。

ggplot2 是一个增强的数据可视化R包，帮助我们轻松创建令人惊叹的多层图形。它的设计理念类似于PhotoShop,具体参数包含设计对象、艺术渲染、统计量、尺寸调整、坐标系统、分片显示、位置调整、动画效果等等。




2. ggplot2权威资料
ggplot2代码在github上
https://github.com/hadley
https://github.com/tidyverse/ggplot2

速查表： https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf
官方教程： https://ggplot2.tidyverse.org/reference/index.html

经典入门书《ggplot2：数据分析与图形艺术》
pdf下载：http://ishare.iask.sina.com.cn/f/68933673.html

实战可以参考R Graphics Cookbook一书： http://www.cookbook-r.com/Graphs/
全本: https://github.com/harryprince/R-Tutor/raw/master/R%E4%B9%A6/R%20Graphics%20Cookbook%20.pdf

《R for Data Science》书：https://r4ds.had.co.nz/data-visualisation.html

图形库：https://www.r-graph-gallery.com/portfolio/ggplot2-package/









3. ggplot2 书中缺少的资源

(1). movies 数据集(P129) 
gplot2movies: Movies Data
A dataset about movies. This was previously contained in ggplot2, but has been moved its own package to reduce the download size of ggplot2.
https://cran.r-project.org/web/packages/ggplot2movies/index.html
原本包含在ggplot2中的数据集，为了减少ggplot2的体积，现在该数据集已去掉。
> install.packages("ggplot2movies")







############
refer博客等:
1.Hadley Wickham2016年写的一篇广告：http://blog.rstudio.com/2016/11/14/ggplot2-2-2-0/
2.【推荐】中文详细教程 https://www.cnblogs.com/nxld/p/6059603.html

3. 实例附代码 Top 50 ggplot2 Visualizations - The Master List (With Full R Code)
http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html
4. 实例附代码 Beautiful plotting in R: A ggplot2 cheatsheet
http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/

5. Be Awesome in ggplot2: A Practical Guide to be Highly Effective - R software and data visualization
http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization


6.ggplot2高效实用指南 (可视化脚本、工具、套路、配色):
https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&mid=2247486262&idx=1&sn=d38221a4063d866b1f10f4c9ebab5f88


7.如何用ggplot2画经济学人上的插图
http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html#orgheadline17


https://www.cnblogs.com/nkwy2012/p/9267516.html





========================================
ggplot2作图详解1：入门函数qplot
----------------------------------------
安装
install.packages("ggplot2") #3.1.0

1. 我们常用的是qplot()和ggplot()函数作图。
qplot 即“快速作图”（quick plot），类似原生的plot(), 用于入门和日常作图。稍微更细微的作图，还是要依靠ggplot()函数。

用法
qplot(x, y, ..., data, facets = NULL, margins = FALSE, geom = "auto",
  xlim = c(NA, NA), ylim = c(NA, NA), log = "", main = NULL,
  xlab = NULL, ylab = NULL, asp = NA, stat = NULL,
  position = NULL)

参数列表：
- x和y就是为坐标提供数据，必须是data中的列名。
- facets 分面。就是把数据按照某个变量分类，每类画一个图。
- margins 是否显示边界
- geom:  图形的几何类型（geometry），这又是ggplot2的作图概念。ggplot2用几何类型表示图形类别，比如point表示散点图、line表示曲线图、bar表示柱形图等。
- stat: 统计类型（statistics），这个更加特殊。直接将数据统计和图形结合，这是ggplot2强大和受欢迎的原因之一。
- position: 图形或者数据的位置调整，这不算太特殊，但对于图形但外观很重要
- xlim, ylim, xlab, ylab, asp： 初步可以按照plot函数的相应参数来理解





2. data参数
(1)不指定图形类型，默认是散点图
library(ggplot2)
x <- 1:1000
y <- rnorm(1000)
plot(x, y, main="Scatter plot by plot()")
qplot(x,y, main="Scatter plot by qplot()")

(2) 使用数据框输入
# 检查数据结构
str(diamonds)
#抽取子集
set.seed(1000) # 设置随机种子，使随机取样具有可重复性
datax<- diamonds[sample(53940, 100), seq(1,7)] #随机取100行，取前7列
head(datax, 4)
# # A tibble: 4 x 7
#   carat cut   color clarity depth table price
#   <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int>
# 1  1.23 Ideal H     VS2      62.2    55  7130
# 2  0.3  Ideal E     SI1      61.7    58   499
# 3  0.9  Good  H     VS2      61.9    58  3989
# 4  0.31 Ideal G     VVS1     62.8    57   977



1)如果要做钻石克拉和价格关系的曲线图，用plot和qplot函数都差不多：
plot(x=datax$carat, y=datax$price, xlab="Carat", ylab="Price", main="plot function")
qplot(x=carat, y=price, data=datax, xlab="Carat", ylab="Price", main="qplot function")



2)但如果要按切工进行分类作图，plot函数的处理就复杂了，你首先得将数据进行分类提取，然后再一个个作图。虽然可以用循环完成，但作图后图标的添加还得非常小心，你得自己保证数据和图形外观之间的对应关系：
plot(x=datax$carat, y=datax$price, xlab="Carat", ylab="Price", main="plot function", type='n')
cut.levels <- levels(datax$cut)
cut.n <- length(cut.levels)
for(i in seq(1,cut.n)){
  subdatax <- datax[datax$cut==cut.levels[i], ]
  points(x=subdatax$carat, y=subdatax$price, col=i, pch=i)
}
legend("topleft", legend=cut.levels, col=seq(1,cut.n), pch=seq(1,cut.n), box.col="transparent", cex=0.8)


但用ggplot2作图你需要考虑数据分类和图形元素方面的问题就很少，你只要告诉它用做分类的数据就可以了：
qplot(x=carat, y=price, data=datax, color=cut, shape=cut, main="qplot function")

如果不喜欢它默认的图形背景，要改变也相当简单，ggplot2预置了几个模板，这些内容我们在后面再详细说：
theme_set(theme_bw())
qplot(x=carat, y=price, data=datax, color=cut, shape=cut, main="qplot function")


3)数据框可以存储不同的数据，而这些数据是有类型差别的。ggplot2作图对各类数据的要求也非常严格，用于分类的数据必需是因子类型，否则就会报错：
qplot(x=carat, y=price, data=datax, shape=depth)
## Error: A continuous variable can not be mapped to shape





3. geom参数，做不同的曲线图

(1)和plot函数一样，qplot也可以通过设置合适的参数产生曲线图，这个参数就是geom（几何类型）。图形的组合非常直接，组合表示几何类型的向量即可：
qplot(x=carat, y=price, data=datax, color=cut, geom="line", main="geom=\"line\"")
qplot(x=carat, y=price, data=datax, color=cut, geom=c("line", "point"), main="geom=c(\"line\", \"point\")")


(2) qplot做统计图
qplot是名副其实的qplot（quick plot）函数，通过改变几何类型geom参数的值你可以获得各种图形。geom参数可以设置的值和意义是：

point：散点图
line：曲线图
smooth：平滑曲线
jitter：另一种散点图
boxplot：箱线图
histogram：直方图
density：密度分布图
bar：柱状图

前两种我们看过了，bar类型下面另讲，jitter以后有机会再说，看看其他4种类型：

qplot(carat, price, data = diamonds, color=cut, geom = "smooth", main = "smooth") #曲线和上下可信区间
qplot(cut, price, data = diamonds, fill=cut, geom = "boxplot", main = "boxplot") #箱线图
qplot(price, data = diamonds, fill=cut, geom = "histogram", main = "histogram") #柱状图
qplot(price, data = diamonds, color=cut, geom = "density", main = "density") #概率密度图

虽然可以合并多个图，但是也要考虑合理性。比如把散点图和密度分布图融合，就直接报错：
qplot(price, data = diamonds, color=cut, geom = c("point", "density"))
## Error: geom_point requires the following missing aesthetics: y




(3) qplot做柱形图
ggplot2对柱形图的处理体现了这一思想：柱形图是一种特殊的直方图。所以ggplot2可以直接用原始数据做出柱形图。

按钻石切工对价格求平均值后做柱形图：
qplot(x=cut, y=price, data = diamonds, 
	fill=cut, geom = "histogram", 
	stat="summary", fun.y="mean")
# 报错 //todo

可以先计算出平均值再柱形图也没什么问题。引物bar图形的本质是统计图形，所以得设置stat参数为identity，即不做统计：
(mean.price <- with(diamonds, aggregate(price~cut, FUN=mean)))
##         cut price
## 1      Fair  4359
## 2      Good  3929
## 3 Very Good  3982
## 4   Premium  4584
## 5     Ideal  3458
qplot(x=cut, y=price, data=mean.price, fill=cut, geom="bar", stat="identity") #还是报错
ggplot(mean.price, aes( cut,price, fill=cut)) + geom_histogram(stat="identity")



ggplot2作图是基于图层的，从上面qplot函数的使用例子中显然看不出来，除此外还有很多深层次的概念、理论和函数。


refer:
https://blog.csdn.net/u014801157/article/details/24372499




========================================
ggplot2作图详解2：ggplot图形对象
----------------------------------------

1.
ggplot2不一样，它用图形对象存储做图的细节，通过输出图形对象获得图形。
library(ggplot2)
theme_set(theme_bw())
x <- 1:100
y <- rnorm(100)
p1 <- plot(x, y)
p2 <- qplot(x, y)


class(p2) #[1] "gg"     "ggplot"
typeof(p2) #[1] "list"
str(p2)
## List of 9
## $ data       :'data.frame':	0 obs. of  0 variables
## $ layers     :List of 1

plot函数的返回值p1的class属性为NULL（空），而qplot函数的返回值p2的calss属性有两个“gg” 和 “ggplot”，其本质是长度为9的列表对象。

print(p2) #画图

qplot函数的作用是产生一个ggplot对象，但获得ggplot对象的更一般方法是使用对象类型的同名函数ggplot。
# 非运行代码
ggplot(df, aes(x, y, <other aesthetics>))
ggplot(df)
ggplot()


ggplot函数用于初始化一个ggplot对象，即使不指定任何做图相关的内容，它的结构也是完整的：
length(p2)
## [1] 9
length(ggplot()) #[1] 9







2 ggplot图形对象组成
ggplot图形对象是由9个元素组成的列表，这点已经清楚。元素的名称为：
> names(p2)
# [1] "data"        "layers"      "scales"      "mapping"     "theme"      
# [6] "coordinates" "facet"       "plot_env"    "labels" 


> str(p4)
就能全部看到这个list的9个元素。

ggplot2是Wilkinson做图理论 Grammer of Graphics 的R语言实现。太高深了，不知道从哪开始，还是从ggplot图形列表对象的元素组成做一点简单了解吧。


(1)数据 data
似乎就是数据。但是如果试图查看上面p2对象的数据：
p2$data  # data frame with 0 columns and 0 rows

是空的。但如果使用qplot函数时指定了data，情况就不一样了：
p3 <- qplot(carat, price, data=diamonds, color=cut, shape=cut)
head(p3$data, 3)
nrow(p3$data) # [1] 53940


列表对象的data元素存储了整个diamnods数据框的数据。用ggplot函数可以单独指定data项：
p4 <- ggplot(diamonds)
head(p4$data, 3)
##   carat     cut color clarity depth table price    x    y    z
## 1  0.23   Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
## 2  0.21 Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
## 3  0.23    Good     E     VS1  56.9    65   327 4.05 4.07 2.31




(2) 映射 mapping
ggplot对象的data项存储了整个数据框的内容，而“映射”则确定如何使用这些数据。

在ggplot2中，图形的可视属性如形状、颜色、透明度等称为美学属性（或艺术属性），确定数据与美学属性之间对应关系的过程称为映射，通常使用aes函数完成（qplot函数中使用参数设置映射）

> str(p3$mapping)
## List of 4
## $ x     : language ~carat
##  ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
## $ y     : language ~price
##  ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
## $ colour: language ~cut
##  ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
## $ shape : language ~cut
##  ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
## - attr(*, "class")= chr "uneval"


> str(p4$mapping)
## Named list()
## - attr(*, "class")= chr "uneval"


> p4 <- p4 + aes(x=carat, y=price, color=color, shape=cut)
> str(p4$mapping)
输出和p3类似。

上述代码使用了加号，这是ggplot2为ggplot对象定义的运算方法，表示设置ggplot对象中对应的内容。






(3) 图层 layers
1)
在ggplot的列表结构里面看不到我们指定的图形类型参数。这些设置被分派到layers里面了：
> p3$layers
## [[1]]
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 


一个图层包含了至少3个东西（数据和映射当然必需，另算）：geom、stat和position

几何类型 geom：是数据在图上的展示形式，即点、线、面等。在ggplot2里面有很多预定义的几何类型。

统计类型 stat：是对数据所应用的统计类型/方法。上面的p2和p3对象我们并没有指定统计类型，但是自动获得了identity，因为ggplot2为每一种几何类型指定了一种默认的统计类型，反之亦然。所以如果仅指定geom或stat中的一个，另外一个会自动获取。

位置 position：几何对象在图像上的位置调整，这也有默认设定。
不指定几何类型或统计类型的ggplot对象的图层是空列表，即没有图层，也不能输出图像：

> p4$layers
## list()

> print(p4)
## 出现一个带坐标的空白图

也就是说，指定了几何类型或统计类型，图层就会产生：
> (p4 + geom_point())$layers
## [[1]]
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 


2)
为什么图层说“至少”包含3个内容呢？如果你把整个图层的内容转成列表结构显示以下就会发现更多：

> rs=(p4 + geom_point())$layers[[1]]
> str(rs)
## Classes 'LayerInstance', 'Layer', 'ggproto', 'gg' <ggproto object: Class LayerInstance, Layer, gg>
##     aes_params: list
##     compute_aesthetics: function
...


> as.list((p4 + geom_point())$layers[[1]])
## $mapping
## NULL
## 
## $geom_params
## $geom_params$na.rm
## [1] FALSE
## 
## 
## $layer_data
## function (self, plot_data) 
...


3)图层加法
从图层的结构可以看到它在ggplot对象中是一个多重列表，如果对ggplot对象做图层加法运算，是增加图层而不是替换图层：
(p4 + geom_point() + geom_line())$layers
## [[1]]
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 
## 
## [[2]]
## geom_line: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 



4) 图层顺序
ggplot2按“层”做图，所以图层的顺序对于图形的表现会有影响，如果几何对象有叠加，那么后面图层的对象会覆盖前面图层的对象。下面只是调换了两个图层的顺序，但由于数据点是相同的，所以图形的颜色完全不一样：

p4 + geom_point(color="red") + geom_point(color="blue")
p4 + geom_point(color="blue") + geom_point(color="red")






(4) 标尺 scales
这是ggplot2中比较复杂的一个概念，从ggplot对象中能获取的信息不多：

p4$scales
## <ggproto object: Class ScalesList, gg>
##     add: function
##     clone: function
##     find: function
##     get_scales: function
##     has_scale: function
##     input: function
##     n: function
##     non_position_scales: function
##     scales: list
##     super:  <ggproto object: Class ScalesList, gg>

注释：这个对象，相比原博客变化较大。

在ggplot2中，一个标尺就是一个函数，它使用一系列参数将我们的数据（如钻石价格、克拉）转成计算机能够识别的数据（如像素、颜色值），然后展示在图像上。使用标尺对数据进行处理的过程称为缩放（scaling）。坐标的产生和图形美学属性的处理都需要使用标尺对数据进行缩放。这个过程比较复杂，尤其是美学属性与数据的关联，因为和美学属性相关的数据不仅有连续型还有离散型，多组数据之间还要相互关照。但这些过程我们都可以不管，ggplot2也替我们做了。

标尺是函数，它的反函数用于产生坐标刻度标签和图表的图例等，这样我们才能把图形外观、位置等信息和数据对应起来。






(5) 坐标 coordinates
这都知道，用于确定采用的坐标系统和坐标轴的范围。

str(p4$coordinates)
## Classes 'CoordCartesian', 'Coord', 'ggproto', 'gg' <ggproto object: Class CoordCartesian, Coord, gg>
##     aspect: function
##     backtransform_range: function
##     clip: on
##     default: TRUE
##     distance: function
##     expand: TRUE
##     is_free: function
##     is_linear: function
##     labels: function
##     limits: list
##     modify_scales: function
##     range: function
##     render_axis_h: function
##     render_axis_v: function
##     render_bg: function
##     render_fg: function
##     setup_data: function
##     setup_layout: function
##     setup_panel_params: function
##     setup_params: function
##     transform: function
##     super:  <ggproto object: Class CoordCartesian, Coord, gg> 

注释：这个对象，相比原博客变化较大。






(6) 主题 theme
标题文字（字体、字号、颜色）、图形边框和底纹等跟数据无关的一些图形元素的设置都可以归到“主题”这一类。

ggplot2提供了4个成套主题：theme_gray(), theme_bw() , theme_minimal() 和 theme_classic()。其中theme_gray()为默认主题，灰背景；后两个是0.9.3版才增加的。

p5 <- p4 + geom_point(color="blue")
p5 + theme_gray() + ggtitle("theme_gray()") #灰色背景，带白色格子
p5 + theme_bw() + ggtitle("theme_bw()") #白色背景，带灰色格子
p5 + theme_minimal() + ggtitle("theme_minimal()") #白色背景，灰色格子
p5 + theme_classic() + ggtitle("theme_classic()") #全白背景，无格子(可能是最常用的！)







(7) 分面 facet：
一页多图，跟图层好像没有直接关系。以后再说。
p4$facet
##<ggproto object: Class FacetNull, Facet, gg>
##    compute_layout: function
##    draw_back: function
##    draw_front: function
##    draw_labels: function
##    draw_panels: function
##    finish_data: function
##    init_scales: function
##    map_data: function
##    params: list
##    setup_data: function
##    setup_params: function
##    shrink: TRUE
##    train_scales: function
##    vars: function
##    super:  <ggproto object: Class FacetNull, Facet, gg>







(8) 标签 labels：
str(p4$labels)
#List of 4
# $ x     : chr "carat"
# $ y     : chr "price"
# $ colour: chr "color"
# $ shape : chr "cut"





(9)> 作图环境
p4$plot_env
## <environment: R_GlobalEnv>
不知道干啥用的








3. ggplot2做图过程
如果英文水平可以，下载 Hadley Wickham 写的《ggplot2: Elegant Graphics for Data Analysis》一书来看看（到处都有）。理论性太强，太高深，不敢乱说。
https://ggplot2-book.org/






refer:
https://blog.csdn.net/u014801157/article/details/24372503



========================================
ggplot2作图详解3：映射（mapping
----------------------------------------
ggplot2数据层面的操作包括映射和分面。先说映射。

1 映射的类型
前面我们已经了解到ggplot对象的data项存储了整个数据框的内容，而“映射”则确定如何使用这些数据。

ggplot2按照图形属性提供了以下可用映射类型：

颜色类型映射：包括 color（颜色或边框颜色）、fill（填充颜色）和 alpha（透明度）
形状类型映射：包括 linetype（线型）、size（点的大小或线的宽度）和 shape（形状）
位置类型映射：包括 x, y, xmin, xmax, ymin, ymax, xend, yend
特殊类型：包括两类，一类是指定数据分组和顺序的映射group和order，另一类是字符串映射。
前两种类型是经典的美学属性映射，第三类的x和y映射也常规，第四类很特别，尤其是字符串映射，很另类，其他类型的映射都可以用aes函数指定，但H.W.为字符串映射专门造了个函数：aes_string。不知道他对字符串特别关照还是实在想不出其他解决方案。






2 颜色和形状类型映射
规律性的东西简单轻松，大家都喜欢；而到处暗藏潜规则、充斥着特例的东西（比如plotrix、perl和中国社会）很杂碎很累人，当然也很让人烦躁和讨厌。
ggplot2中颜色和形状这两类映射最符合台面规则的，即：把数据框的变量和图形的美学属性对应起来。

2.1 映射的过程
先看下面ggplot2的数据diamonds：
library(ggplot2)
set.seed(100)
d.sub <- diamonds[sample(nrow(diamonds), 500), ]
head(d.sub, 4)


(1) 散点图，映射数据到x和y坐标
p  <- ggplot(data=d.sub, aes(x=carat, y=price))


theme_set(theme_bw())
p  + geom_point()


(2) 映射钻石颜色属性到颜色
p  + geom_point() + aes(color=color) + theme(legend.position=c(2,2))


(3) 使用原生R绘图模拟ggplot的映射
ggplot2映射的过程可以用plot函数作图步骤进行分解，它包含三方面的操作（不包括图形页面设置）：

数据分组
设定颜色标尺
按颜色标尺指定每组数据的颜色

# 设定颜色标尺
levs  <- levels(d.sub$color)
cl  <-  rainbow(length(levs))
# 页面设置
par(mar=c(3,3,0.5,0.5), mgp=c(1.5, 0.5, 0), bg="white")
plot(d.sub$carat, d.sub$price, type='n', xlab="carat", ylab="price")
i  <- 1
for(lev in levs){
  # 数据分组
  datax  <- d.sub[d.sub$color==lev, ]
  # 作图并指定数据点颜色
  points(datax$carat, datax$price, pch=20, col=cl[i])
  i  <- i + 1
}


上面对数据的分组只设定了一个变量，如果增加数据分组的变量，ggplot2中只需要增加映射的类型就可以了，比如在颜色分类的基础上加钻石切工（cut）进行分类：

p  + geom_point() + aes(color=color, shape=cut) + theme(legend.position=c(2,2))


用plot函数处理起来要考虑的问题就多一些。






2.2 映射的标尺
用plot函数作图我们得自己考虑使用什么颜色表示不同组的数据，也就是使用什么标尺（或比例尺）。ggplot2则自动应用标尺，这是一个隐含过程。标尺大体可以分为两类：

离散型（或枚举型）标尺。罗列出所有数据分类并将其与美学属性一一对应，处理过程包含数据分类，如上例。
连续型（或区间型）标尺。看下面例子：

(1)
p + geom_point( aes(size= x*y*z ) )+ theme(legend.position=c(0.8,0.5))

上图中点的大小反映钻石的x*y*z值，相当于钻石的大小。用plot函数也可以实现：

cex <- d.sub[,"x"]*d.sub[,"y"]*d.sub[,"z"]
cex  <- cex/max(cex)*4
par(mar=c(3,3,0.5,0.5), mgp=c(1.5, 0.5, 0), bg="white")
plot(d.sub$carat, d.sub$price, type='n', xlab="carat", ylab="price")
points(d.sub$carat, d.sub$price, pch=20, cex=cex$x)

可以看到作图过程也需要手动建立数据和图形属性间的对应关系，但没有对数据分类。


(2)
ggplot2对映射应用的标尺可以修改，ggplot提供了一大批 scale_xxxxxxxx 类型的函数，比如 scale_color_xxxx 类型函数用户修改颜色标尺，scale_shape_xxxx 修改形状，scale_linetype_xxxx 修改线型等。按照数据的类型，这些函数还有4种基本类型：

continuous：连续型
discrete：离散型
identity：和数据取值相同
manual：手工指定
有关颜色和坐标轴标尺设定的函数较多，适应不同需要。

cls  <- terrain.colors(length(levels(d.sub$color)))
p  + geom_point() + aes(color=color) + scale_color_manual(values=cls)

p  + geom_point() + aes(color=color) +scale_color_brewer(palette = "Set2")




2.3 映射与图例
映射还有一个作用：产生图例。这在ggplot2也是自动的隐含过程，但在plot函数作图中是一个体力活，制作过程就不举例说明了，可以参考legend函数。



2.4 图形颜色和形状的非映射设置
(1)除了通过映射设置几何图形的图形颜色和形状属性外，ggplot2还提供了直接设定方式。和映射方式设置不一样的是：直接设定方式不会在图例上有反映。比较下面两图：

q=ggplot(d.sub, aes(x=cut, y=price))
q+geom_point()

q  + geom_boxplot(aes(x=cut, fill=cut)) +
  scale_fill_manual(values=rep("cyan", length(levels(d.sub$cut))))
q  + geom_boxplot(aes(x=cut), fill="cyan")

虽然填充色都是青色，但前者用的映射对数据进行了分组，所以会出现分组图例。
注意：直接设定方法的参数名称和映射设定是一样的，但是不放在aes函数内部。




(2)在qplot函数中如果要进行美学属性的非映射设定得用 “I” 函数，否则将被当长映射设置。
qplot(x=cut, y=price, data=d.sub, geom="boxplot", fill="cyan")
qplot(x=cut, y=price, data=d.sub, geom="boxplot", fill=I("cyan"))

“I”函数表示设为固定值，如果不是在qplot函数中可以不用它。


(3)透明度属性虽然包含在映射类型中，但一般情况下都是直接设定而非映射设定：

p1=ggplot(diamonds, aes(x=carat, y=price))

p1 + geom_point(aes(alpha=carat/100))
p1 + geom_point(alpha=0.05)
# 第一张图就达不到设置透明度显示点密集度的效果






3 位置类型映射
x和y映射的用法很明确，就不再罗嗦了。xmin, xmax, ymin, ymax, xend, yend这几种映射属于特殊类型，H.W.在ggplot2的说明档里面写得很清楚（赞，H.W.不仅是写R软件的高手，还是普及教育的牛人），下面就照搬他的例子简单说明一下用法。


3.1 ymin/ymax映射的用法
下面代码通过直线拟合产生了钻石切工和价格的关系数据（预测的价格和标准差）

dmod <- lm(price ~ cut, data = diamonds)
cuts <- data.frame(cut = unique(diamonds$cut), 
                   predict(dmod, 
                           data.frame(cut =unique(diamonds$cut)), 
                           se = TRUE)[c("fit", "se.fit")]
                   )
cuts
##         cut  fit se.fit
## 1     Ideal 3458  27.00
## 2   Premium 4584  33.75
## 3      Good 3929  56.59
## 4 Very Good 3982  36.06
## 5      Fair 4359  98.79


(2)
通过设定ymin/ymax映射，用pointrange几何类型可以直接做出带误差线的散点图，无需使用errorbar设置：
se <- ggplot(cuts, aes(x = cut, y = fit, ymin = fit - se.fit, ymax = fit + se.fit, colour = cut))
se + geom_pointrange()

(3)
当然也可以先画点再做误差线，这样思路明确些。或者做其他类型的图如柱形图：

se + geom_point() + geom_errorbar(width=0.2)
se + geom_bar(stat="identity", aes(fill=cut)) + geom_errorbar(width=0.2)


(4)
ymin/ymax可以用来改变几何类型的坐标轴范围，但 这不是标准用法，最简单的是用ylim函数：
se + geom_point(aes(ymin = 3000, ymax = 4800)) + geom_errorbar(width=0.2) 
#Warning: Ignoring unknown aesthetics: ymin, ymax 不识别这俩参数?

se + geom_point() + geom_errorbar(width=0.2) + ylim(3000,5000)
# 或者用： scale_y_continuous(limits=c(3000,5000))
se + geom_point() + scale_y_continuous(limits=c(3000,5000))





4. 特殊映射
特殊类型映射有特殊应用。曲线图和柱形图对于x轴数据类型的要求是不一样的，曲线图要用连续型数据，而柱形图要用因子型（或离散型）数据，这两类图形如果不经特殊处理就不能放在一起。group映射可以轻松搞定它：

se + geom_bar(stat="identity", aes(fill=cut)) + geom_errorbar(width=0.2) +
  coord_cartesian(ylim=c(3000,4800)) + 
  geom_line(aes(group="Subject"), color="black")












ref:
https://blog.csdn.net/u014801157/article/details/24372505







========================================
ggplot2作图详解4：分面（faceting）
----------------------------------------
ggplot2的分面有两种方式，分别使用 facet_wrap 或 facet_grid 函数。

# 准备工作
library(ggplot2)
set.seed(100)
d.sub <- diamonds[sample(nrow(diamonds), 500), ]
head(d.sub, 4)

theme_set(theme_bw())
p  <- ggplot(data=d.sub, aes(x=carat, y=price))




1 缠绕分面 facet_wrap
facet_wrap 即“缠绕分面”，对数据分类只能应用一个标准，不同组数据获得的小形按从左到右从上到下的“缠绕”顺序进行排列：

(1)
levels(d.sub$cut)
## [1] "Fair"      "Good"      "Very Good" "Premium"   "Ideal"
p  + geom_point() + facet_wrap(~cut)


(2)
显然这是对数据进行分组后绘制得到的图形，这类图形对于比较不同数据的趋势非常有帮助。facet_wrap 的参数如下：

# 非运行代码
facet_wrap(facets, nrow = NULL, ncol = NULL, scales = "fixed",
           shrink = TRUE, as.table = TRUE, drop = TRUE)
#
facets：分面参数如 ~cut，表示用 cut 变量进行数据分类
nrow：绘制图形的行数
ncol：绘制图形的列数，一般nrow/ncol只设定一个即可
scales：坐标刻度的范围，可以设定四种类型。fixed 表示所有小图均使用统一坐标范围；free表示每个小图按照各自数据范围自由调整坐标刻度范围；free_x为自由调整x轴刻度范围；free_y为自由调整y轴刻度范围。
shrinks：也和坐标轴刻度有关，如果为TRUE（默认值）则按统计后的数据调整刻度范围，否则按统计前的数据设定坐标。
as.table：和小图排列顺序有关的选项。如果为TRUE（默认）则按表格方式排列，即最大值（指分组level值）排在表格最后即右下角，否则排在左上角。
drop：是否丢弃没有数据的分组，如果为TRUE（默认），则空数据组不绘图。


(3)scales 的设定效果：

p  + geom_point() + facet_wrap(~cut, scales="free") + ggtitle('scales="free"')
p  + geom_point() + facet_wrap(~cut, scales="free_y") + ggtitle('scales="free_y"')






2 格网分面 facet_grid
(1)格网分面可以应用多个标准对数据进行分组。还是先看看效果：

qplot(carat, price, data=diamonds, alpha=I(0.2)) + facet_grid(color~cut)

显然参数 color~cut 对数据的分组和小图排列有决定作用，波浪号前为小图分行标准，后面为分列标准。


(2)facet_grid 的完整用法为：
# 非运行代码
facet_grid(facets, margins = FALSE, scales = "fixed", space = "fixed", shrink = TRUE,
           labeller = "label_value", as.table = TRUE, drop = TRUE)
和facet_wrap比较，除不用设置ncol和nrow外（facets公式已经包含）外还有几个参数不同：


1)margins
注意：这不是设定图形边界的参数。它是指用于分面的包含每个变量元素所有数据的数据组。

margins	
Either a logical value or a character vector. Margins are additional facets which contain all the data for each of the possible values of the faceting variables. If FALSE, no additional facets are included (the default). If TRUE, margins are included for all faceting variables. If specified as a character vector, it is the names of variables for which margins are to be created.


就是在行的最后、列的最后添加一个汇总的图，名字叫(all)。

qplot(carat, price, data=diamonds, alpha=I(0.2)) + facet_grid(color~cut, margins=TRUE)



2)







#





#






ref:
https://blog.csdn.net/u014801157/article/details/24372507



========================================
ggplot2作图详解5：图层语法和图形组合
----------------------------------------
图层设置是ggplot2做图的关键。通过查看ggplot图形对象的数据结构我们了解到一个图层至少包含几何类型、统计类型和位置调整三方面的东西，当然数据和映射得首先建立。如果把ggplot2当成是太极，这些内容的设置就相当于太极的招式，有固定方法；对招式理解透彻后以随意对它们进行组合，并融合数据层面的一些设置（如分面、美学属性映射等）创造出用于解决问题的完美图形。

1 图层的几何和统计类型
1.1 几何/统计类型设置函数
在ggplot2中，每种几何类型都有对应的（默认）统计类型，反之亦然。两者不分家，所以得放在一起来说。几何类型的设置函数全部为geom_xxx形式，而统计类型设置函数全部为stat_xxx的形式：

library(ggplot2)
ls("package:ggplot2", pattern="^geom_.+")
##  [1] "geom_abline"     "geom_area"       "geom_bar"        "geom_bin2d"      "geom_blank"     
##  [6] "geom_boxplot"    "geom_col"        "geom_contour"    "geom_count"      "geom_crossbar"  
## [11] "geom_curve"      "geom_density"    "geom_density_2d" "geom_density2d"  "geom_dotplot"   
## [16] "geom_errorbar"   "geom_errorbarh"  "geom_freqpoly"   "geom_hex"        "geom_histogram" 
## [21] "geom_hline"      "geom_jitter"     "geom_label"      "geom_line"       "geom_linerange" 
## [26] "geom_map"        "geom_path"       "geom_point"      "geom_pointrange" "geom_polygon"   
## [31] "geom_qq"         "geom_qq_line"    "geom_quantile"   "geom_raster"     "geom_rect"      
## [36] "geom_ribbon"     "geom_rug"        "geom_segment"    "geom_sf"         "geom_sf_label"  
## [41] "geom_sf_text"    "geom_smooth"     "geom_spoke"      "geom_step"       "geom_text"      
## [46] "geom_tile"       "geom_violin"     "geom_vline"

ls("package:ggplot2", pattern="^stat_.+")
##  [1] "stat_bin"            "stat_bin_2d"         "stat_bin_hex"        "stat_bin2d"         
##  [5] "stat_binhex"         "stat_boxplot"        "stat_contour"        "stat_count"         
##  [9] "stat_density"        "stat_density_2d"     "stat_density2d"      "stat_ecdf"          
## [13] "stat_ellipse"        "stat_function"       "stat_identity"       "stat_qq"            
## [17] "stat_qq_line"        "stat_quantile"       "stat_sf"             "stat_sf_coordinates"
## [21] "stat_smooth"         "stat_spoke"          "stat_sum"            "stat_summary"       
## [25] "stat_summary_2d"     "stat_summary_bin"    "stat_summary_hex"    "stat_summary2d"     
## [29] "stat_unique"         "stat_ydensity" 

很多，有小部分是相同的。如果一个个介绍就得写成说明书了，跟软件包作者写的函数说明没什么两样；再说也没必要，不是每个人都会用到全部的类型。下面看一下几何函数geom_point和统计函数stat_identity的参数：

# 函数说明，非运行代码
geom_point(mapping = NULL, data = NULL, stat = "identity",
           position = "identity", na.rm = FALSE, ...)
stat_identity(mapping = NULL, data = NULL, geom = "point",
              position = "identity", width = NULL,
              height = NULL, ...)
#

有4个参数是一样的：映射（mapping）、数据（data）、位置（position）和点点点（Dot-dot-dot: …）。H.W.特别强调了mapping和data参数的先后顺序在几何/统计类型设定函数和ggplot函数中的差别：ggplot函数先设定数据，再设定映射；而几何/统计类型函数则相反，因为确定作图或统计之前一般都已经有数据，只需指定映射即可。如果不写参数名，它们的用法是这样的：

# 示例，非运行代码
ggplot(数据, 映射)
geom_xxx(映射, 数据)
stat_xxx(映射, 数据)

"点点点"参数是R语言非常特殊的一个数据类型，用在函数的参数用表示任意参数，在这里表示传递给图层的任意参数如color, shape, alpha等。




(2)前面我们一直用geom_point来做散点图，其实完全可以用stat_identity来做，得到的图形是完全相同的：

# 取ggplot2的diamonds数据集的一部分数据：
set.seed(100)
d.sub <- diamonds[sample(nrow(diamonds), 500),]
p <- ggplot(d.sub, aes(x=carat, y=price))
theme_set(theme_bw())
p + stat_identity()
p + geom_point()


查看图层组成可以看到两者都有geom_point、stat_identity和position_identity：
(p + stat_identity())$layers
# [[1]]
# geom_point: na.rm = FALSE
# stat_identity: na.rm = FALSE
# position_identity 

(p + geom_point())$layers
# [[1]]
# geom_point: na.rm = FALSE
# stat_identity: na.rm = FALSE
# position_identity 




如果把geom_xxx类函数获得的图层称为“几何图层”，stat_xxx类函数获得的图层就可以称为“统计图层”。但这样的说法很不合适，因为每个图层都包含这两个东西，两者没有本质差别。如果你一定要把geom或stat清理掉（设为NULL），不会有任何错误信息，但图层的内容还是老样：

(p + stat_identity(geom=NULL))$layers
(p + geom_point(stat=NULL))$layers
## 我的测试是报错 Error: Attempted to create layer with no geom.


为什么设置两套方案，H.W.有他的理由吧，毕竟有很多人只作图不统计，也有很多人做了很多统计以后才偶尔作个图。





1.2 图层对象
(1)
geom_xxx和stat_xxx可以指定数据，映射、几何类型和统计类型，一般来说，有这些东西我们就可以作图了。但实际情况是这些函数不可以直接出图，因为它不是完整的ggplot对象：

p <- geom_point(mapping=aes(x=carat, y=price), data=d.sub)
class(p)
## [1] "LayerInstance" "Layer"         "ggproto"       "gg"

p
## mapping: x = ~carat, y = ~price 
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity


(2)
图层只是存储类型为environment的R语言对象，它只有建立在ggplot结构的基础上才会成为图形，在这里哪怕是一个空的ggplot对象框架都很有用。这好比仓库里的帐篷，如果你找不到地方把它们支起来，这些东西顶多是一堆货物

ggplot() + p


(3)
前面说过多个图层的相加是有顺序的，图层和ggplot对象的加法也是有顺序的，如果把ggplot对象加到图层上就没有意义。这种规则同样适用于映射和ggplot的相加：

p + ggplot()
## Error: Cannot add ggproto objects together. Did you forget to add this object to a ggplot object?

class(aes(x=carat, y=price) + ggplot(d.sub))
## [1] "NULL"

class(ggplot(d.sub) + aes(x=carat, y=price))
## [1] "gg"     "ggplot"






2 图层的位置调整参数
(1)
这和位置映射没有关系，当前版ggplot2只有5种：

- dodge：“避让”方式，即往旁边闪，如柱形图的并排方式就是这种。
- fill：填充方式， 先把数据归一化，再填充到绘图区的顶部。
- identity：原地不动，不调整位置
- jitter：随机抖一抖，让本来重叠的露出点头来
- stack：叠罗汉

p <- ggplot(d.sub, aes(x=cut, y=price, fill=color))
p + geom_bar(stat="summary", fun.y="mean", position="stack")
p + geom_bar(stat="summary", fun.y="mean", position="fill")
p + geom_bar(stat="summary", fun.y="mean", position="dodge")
p + geom_bar(stat="summary", fun.y="mean", position="jitter") #柱形图的抖动很没道理

但散点图里面就有效果了：
p + geom_point(position="identity")
p + geom_point(position="jitter")

p + geom_boxplot()+geom_point(position="jitter")
所以怎么调整还得看图形的需要。


(2)再看看x轴数据连续的图形：

p <- ggplot(d.sub, aes(x=price, fill=cut, color=cut))
p + stat_density(position="stack")
p + stat_density(position="fill")
p + stat_density(position="identity")
p + stat_density(position="identity", alpha=0.2)
p + stat_density(position="identity", fill="transparent")

看起来很奇妙，改变一个参数就得到不同的图形。






3 图层组合
图层的组合不是连续使用几个几何或统计类型函数那么简单。ggplot函数可以设置数据和映射，每个图层设置函数（geom_xxx和stat_xxx）也都可以设置数据和映射，这虽然给组合图制作带来很大便利，但也可能产生一些混乱。如果不同图层设置的数据和映射不同，将会产生什么后果？得了解规则。

3.1 简单组合
(1)不同的图层使用同一套数据，只是几何类型或统计类型有差别。这是最简单也是最常用的，用ggplot函数设置好数据和映射，把几个图层加起来即可：

datax <- data.frame(x=1:10, y=rnorm(10)+1:10)
p  <- ggplot(datax, aes(x=x, y=y))
p + geom_point() + geom_line()
p + geom_point() + geom_smooth(method="lm")


(2)
ggplot2的图层设置函数对映射的数据类型是有较严格要求的，比如geom_point和geom_line函数要求x映射的数据类型为数值向量，而geom_bar函数要使用因子型数据。如果数据类型不符合映射要求就得做类型转换，在组合图形时还得注意图层的先后顺序：

p  <- ggplot(datax, aes(x=factor(x), y=y)) + xlab("x")
p + geom_bar(stat="identity", fill="gray") +
  geom_line(aes(group=1), size=2) + geom_point(color="red")
p + geom_bar(stat="identity", fill="gray") +
  geom_smooth(aes(group=1), method="lm", se=FALSE, size=2)

上面第一个图除了花哨一点外没有任何科学意义，如果放在论文中会被骂得狗学喷头：一套数据重复作图还都是一个意思，是不是脑子有病？但这里只是说明作图方法。作图过程应先作柱形图，因为它要求x映射是因子型数据。x映射为因子的数据作散点图的调整步骤相对简单。如果先作散点图，把坐标轴从数值向量（连续型）改为因子型相当麻烦。



(3)
3.2 不同映射的组合
映射反映的是数据变量。多数情况下一个图形中使用的是同一个数据集，只是变量不同。通常情况下x，y轴至少有一个是相同的，可以用不同图层叠加不同的数据变量：

p <- ggplot(d.sub, aes(x=carat)) + ylab("depth (blue) / table (red)")
p + geom_point(aes(y=depth), color="blue")  +
  geom_point(aes(y=table), color="red")
#

但是为什么要这么做呢？预先处理一下数据再作图会更好，图例都已经帮你设好了：

library(reshape2)
datax <- melt(d.sub, id.vars="carat", measure.vars=c("depth", "table"))
ggplot(datax, aes(x=carat, y=value, color=variable)) + geom_point()





3.3 不同类型数据的组合
如果在geom_xxx函数中改变数据会怎么样呢？不同类型的数据一般不会有完全相同的变量，否则就不是“不同类型”了，所以映射也会相应做修改。下面把钻石数据diamonds和汽车数据mtcars这两个风牛马不相及的数据放在一起看看。
（首先声明：下面的方法只是演示，图形没有任何科学意义。科学图形应该能让观众直观地了解数据，而不是让明白者糊涂让糊涂者脑残。有不少人喜欢用双坐标作混合数据图，个人认为那是很愚昧的做法。）

diamonds数据我们在前面已经了解过了，先看看R datasets包里面的mtcars数据：


data(mtcars, package="datasets")
str(mtcars)

head(mtcars, 4)

好，开始玩点玄乎的：

p  <- ggplot(data=d.sub, aes(x=carat, y=price, color=cut))
layer1 <- geom_point(aes(x=carb, y=mpg), mtcars, color="black")
(p1 <- p + layer1)

图中数据点是正确的，但坐标轴标题却对不上号。看看ggplot对象的数据、映射和图层：
head(p1$data, 4)
## # A tibble: 4 x 10
##   carat cut     color clarity depth table price     x     y     z
##   <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
## 1  1.26 Ideal   G     SI1      59.6    57  6738  7.08  7.04  4.21
## 2  0.7  Ideal   D     VS2      62.7    57  3448  5.65  5.67  3.55


p1$mapping
## Aesthetic mapping: 
## * `x`      -> `carat`
## * `y`      -> `price`
## * `colour` -> `cut`

p1$layers
## [[1]]
## mapping: x = ~carb, y = ~mpg 
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 

数据和映射都还是ggplot原来设置的样子，layer2图层设置的都没有存储到ggplot图形列表对象的data和mapping元素中，而是放在了图层中，但图层中设定的数据不知道跑哪里。

如果再增加一个图层，把坐标轴标题标清楚：

layer2 <- geom_point(aes(y=depth))
(p1 <- p1 + layer2 + xlab("carb(black) / carat") + ylab("mpg(black) / depth"))


很有意思。layer2重新指定了y映射，但没碰原来ggplot对象设置的x和color映射，从获得的图形来看y数据改变了，x和color还是原ggplot对象的设置。查看一下映射和图层：

p1$mapping
## Aesthetic mapping: 
## * `x`      -> `carat`
## * `y`      -> `price`
## * `colour` -> `cut`

p1$layers
## [[1]]
## mapping: x = ~carb, y = ~mpg 
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 
## 
## [[2]]
## mapping: y = ~depth 
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity 


可以这么理解：ggplot2图层作图时依次从ggplot对象和图层中获取数据/映射，如果两者映射有重叠，后者将替换前者，但只是在该图层中进行替换而不影响ggplot对象。

如果ggplot对象的映射比图层的映射多，而图层又使用了不同的数据，这是什么情况？看看：
p + geom_point(aes(x=carb, y=mpg), mtcars)

# Don't know how to automatically pick scale for object of type function. Defaulting to continuous.
# Error: Aesthetics must be valid data columns. Problematic aesthetic(s): colour = cut. 
# Did you mistype the name of a data column or forget to add stat()?

由于图层继承了ggplot对象的color映射，但又找不到数据，所以没法作图。解决办法是把原有的映射用NULL取代，或者设为常量（非映射）：

p + geom_point(aes(x=carb, y=mpg, color=NULL), mtcars)
p + geom_point(aes(x=carb, y=mpg), mtcars, color="red")








1. 散点图

控制散点的大小size、透明度alpha
ggplot(df, aes(gene.mean, gene.dispersion))+geom_point(size=0.1, alpha=0.2)









ref:
https://blog.csdn.net/u014801157/article/details/24372517



========================================
ggplot2作图详解6：标尺（scale）设置
----------------------------------------

标尺是ggplot2作图必需的元素，在《映射》一节提到了它的概念并简单进行了设置。在数据分析阶段，为避免陷入数据无关的垃圾坑，我们只需要设置映射，ggplot2自动配置合适的标尺并产生坐标和图例。这是ggplot2适合数据可视化分析的原因之一。

在图形美化阶段，我们可以通过修改标尺改善图形外观。标尺设置一般不会对数据产生影响，但坐标轴标尺除外。




1.标尺设定函数
(1)ggplot2修改标尺的函数有一大堆：

library(ggplot2)
scalex <- ls("package:ggplot2", pattern="^scale.+")
length(scalex)

# [1] 94



(2)提取函数名的第二个字段，对这些函数的作用进行分类：

> scalex <- scalex[grep("([^_]+_){2}.+", scalex)]
> unique(gsub("(([^_]+_){2}).+","\\1***",scalex))
 [1] "scale_alpha_***"      "scale_color_***"      "scale_colour_***"     "scale_continuous_***"
 [5] "scale_discrete_***"   "scale_fill_***"       "scale_linetype_***"   "scale_shape_***"     
 [9] "scale_size_***"       "scale_x_***"          "scale_y_***"   

可以看到标尺设置的内容有10种（颜色color/colour算一种）：透明度、线条颜色、连续变量、离散变量、填充色、线型、形状、大小，x和y轴。
标尺设置的内容都有对应的映射设置类型，但映射比标尺多了xmin, xmax, ymin, ymax, xend, yend，group和string等（请参看《映射》一节）。


(3)虽然设置函数很多，但不管是函数用法还是函数名称上都是很有规律的：
getNames=function(keyword){
	scalexx <- scalex[grepl( paste0(keyword,".+"), scalex)]
	unique(gsub("(([^_]+_){2})(.+)","\\3",scalexx))
}


# 线条颜色
> getNames('scale_color')
 [1] "brewer"     "continuous" "discrete"   "distiller"  "gradient"   "gradient2" 
 [7] "gradientn"  "grey"       "hue"        "identity"   "manual"     "viridis_c" 
[13] "viridis_d" 


# 填充色
> getNames('scale_fill')
 [1] "brewer"     "continuous" "date"       "datetime"   "discrete"   "distiller" 
 [7] "gradient"   "gradient2"  "gradientn"  "grey"       "hue"        "identity"  
[13] "manual"     "ordinal"    "viridis_c"  "viridis_d" 


# 大小
> getNames('scale_size')
[1] "area"       "continuous" "date"       "datetime"   "discrete"   "identity"  
[7] "manual"     "ordinal"


# 透明度
> getNames('scale_alpha')
[1] "continuous" "date"       "datetime"   "discrete"   "identity"   "manual"    
[7] "ordinal"


# 线型
> getNames('scale_linetype')
[1] "continuous" "discrete"   "identity"   "manual"

# 形状
> getNames('scale_shape')
[1] "continuous" "discrete"   "identity"   "manual"     "ordinal"


# x轴
> getNames('scale_x')
# y轴
> getNames('scale_y')
[1] "continuous" "date"       "datetime"   "discrete"   "log10"      "reverse"   
[7] "sqrt"       "time" 



> getNames('scale_continuous')
[1] "identity"

> getNames('scale_discrete')
[1] "identity" "manual" 

除坐标轴外，其它标尺都有四种基本设置函数："continuous"，"discrete"，"identity"和"manual"。
结合标尺的作用和设定方法两个标准，H.W把它们分为4种类型的标尺：位置、颜色、无变换和人工设置类型（说实话，他的分类思维有点乱）。
颜色设置相关的函数较多，线条颜色和填充色设置的函数类型一样，而x轴和y轴设置的函数类型也一样。

由于标尺函数的命名和用法很有规律，下面仅介绍颜色和坐标轴设置函数的一些用法。








2 颜色标尺设置

2.1 连续型颜色标尺
ggplot2提供了16个填充色设置的标尺函数（线条颜色也一样）：

> ls("package:ggplot2", pattern="^scale_fill.+")
 [1] "scale_fill_brewer"     "scale_fill_continuous" "scale_fill_date"      
 [4] "scale_fill_datetime"   "scale_fill_discrete"   "scale_fill_distiller" 
 [7] "scale_fill_gradient"   "scale_fill_gradient2"  "scale_fill_gradientn" 
[10] "scale_fill_grey"       "scale_fill_hue"        "scale_fill_identity"  
[13] "scale_fill_manual"     "scale_fill_ordinal"    "scale_fill_viridis_c" 
[16] "scale_fill_viridis_d" 


先看看“continuous”的用法。对于数据为非因子型的填充色映射，ggplot2自动使用“continuous”类型颜色标尺表示连续颜色空间。如果要修改默认颜色就要使用scale_fill_continuous函数进行修改，这个函数最有用的参数是low和high，分别表示低端和高端数据的颜色，中间颜色根据颜色空间space自动计算：


###
theme_set(theme_bw())
df  <- expand.grid(1:30, 1:30)
colnames(df) <- c('x','y')
df$z <- rnorm(900)
head(df)

p <- ggplot(data=df, aes(x=x, y=y, fill=z));p
p+geom_point()
p + geom_raster()
p + geom_raster() + scale_fill_continuous(low="darkgreen", high="orangered", space='rgb')

p + geom_raster() + scale_fill_gradient2(low="darkgreen", high="red", mid="yellow", midpoint=1)





2.2 离散型颜色标尺

##
set.seed(100)
dms <- diamonds[sample(nrow(diamonds),500),] #随机选取500个样本
head(dms)
p  <- ggplot(data=dms, aes(x=carat, y=price, color=cut));

p + geom_point() + scale_color_manual(values=c('blue','cyan', 'yellow', 'orange', 'red'))
p + geom_point() + scale_color_manual(values=rainbow(5))












ref:
https://blog.csdn.net/u014801157/article/details/24372521









========================================
ggplot2作图详解7：主题（theme）设置
----------------------------------------
凡是和数据无关的图形设置内容理论上都可以归 主题类 但考虑到一些内容（如 坐标轴 ）的特殊性，可以允许例外的情况。主题的设置相当繁琐，很容易就占用了大量的作图时间，应尽量把这些东西简化，把注意力主要放在数据分析上。基于这种考虑，ggplot2主题设置的内容虽然相当多，本文仅在总体上作一简单介绍。


1.theme函数及其参数
(1)ggplot2预设主题，
    theme_gray() # 默认
    theme_bw()
    theme_linedraw()
    theme_light()
    theme_dark()
    theme_minimal()
    theme_void()
    theme_test() #常用于学术期刊
    theme_classic()#常用于学术期刊

# 测试例
library(ggplot2)
head(mtcars)
#Displacement (cu.in.)排量越大，每加仑汽油跑的距离越小
g=ggplot(mtcars, aes(disp, mpg))+geom_point() 

g+theme_bw() #有边框，有背景线
g+theme_test() #有边框，白板
g+theme_classic() #白班，无上、右边框





(2)这些主题都包括哪些参数？
> library(ggplot2)
> theme_test  # 函数名不加括号，获得函数的代码

function (base_size = 11, base_family = "", base_line_size = base_size/22, 
    base_rect_size = base_size/22) 
{
    half_line <- base_size/2
    theme(line = element_line(colour = "black", size = base_line_size, 
        linetype = 1, lineend = "butt"), rect = element_rect(fill = "white", 
        colour = "black", size = base_rect_size, linetype = 1), 
        text = element_text(family = base_family, face = "plain", 
            colour = "black", size = base_size, lineheight = 0.9, 
            hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), 
            debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, 
        axis.line.y = NULL, axis.text = element_text(size = rel(0.8), 
            colour = "grey30"), axis.text.x = element_text(margin = margin(t = 0.8 * 
            half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * 
            half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * 
            half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * 
            half_line/2), hjust = 0), axis.ticks = element_line(colour = "grey20"), 
        axis.ticks.length = unit(half_line/2, "pt"), axis.ticks.length.x = NULL, 
        axis.ticks.length.x.top = NULL, axis.ticks.length.x.bottom = NULL, 
        axis.ticks.length.y = NULL, axis.ticks.length.y.left = NULL, 
        axis.ticks.length.y.right = NULL, axis.title.x = element_text(margin = margin(t = half_line/2), 
            vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), 
            vjust = 0), axis.title.y = element_text(angle = 90, 
            margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, 
            margin = margin(l = half_line/2), vjust = 0), legend.background = element_rect(colour = NA), 
        legend.spacing = unit(2 * half_line, "pt"), legend.spacing.x = NULL, 
        legend.spacing.y = NULL, legend.margin = margin(0, 0, 
            0, 0, "cm"), legend.key = element_rect(fill = "white", 
            colour = NA), legend.key.size = unit(1.2, "lines"), 
        legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = rel(0.8)), 
        legend.text.align = NULL, legend.title = element_text(hjust = 0), 
        legend.title.align = NULL, legend.position = "right", 
        legend.direction = NULL, legend.justification = "center", 
        legend.box = NULL, legend.box.margin = margin(0, 0, 0, 
            0, "cm"), legend.box.background = element_blank(), 
        legend.box.spacing = unit(2 * half_line, "pt"), panel.background = element_rect(fill = "white", 
            colour = NA), panel.border = element_rect(fill = NA, 
            colour = "grey20"), panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), panel.spacing = unit(half_line, 
            "pt"), panel.spacing.x = NULL, panel.spacing.y = NULL, 
        panel.ontop = FALSE, strip.background = element_rect(fill = "grey85", 
            colour = "grey20"), strip.text = element_text(colour = "grey10", 
            size = rel(0.8), margin = margin(0.8 * half_line, 
                0.8 * half_line, 0.8 * half_line, 0.8 * half_line)), 
        strip.text.x = NULL, strip.text.y = element_text(angle = -90), 
        strip.placement = "inside", strip.placement.x = NULL, 
        strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, 
            "pt"), strip.switch.pad.wrap = unit(half_line/2, 
            "pt"), plot.background = element_rect(colour = "white"), 
        plot.title = element_text(size = rel(1.2), hjust = 0, 
            vjust = 1, margin = margin(b = half_line)), plot.subtitle = element_text(hjust = 0, 
            vjust = 1, margin = margin(b = half_line)), plot.caption = element_text(size = rel(0.8), 
            hjust = 1, vjust = 1, margin = margin(t = half_line)), 
        plot.tag = element_text(size = rel(1.2), hjust = 0.5, 
            vjust = 0.5), plot.tag.position = "topleft", plot.margin = margin(half_line, 
            half_line, half_line, half_line), complete = TRUE)
}
<bytecode: 0x173ffb48>
<environment: namespace:ggplot2>


看穿了吧，没神秘感了。它无非是一个具有两个参数的函数：base_size和base_family。
其主题部分直接应用了另外一个函数：theme。它就是ggplot2的主题设置函数。这个theme函数的产生看起来非常简单：

# 函数说明，非运行代码
theme(..., complete = FALSE)

但dotdotdot(···) 参数却内涵丰富，它可以设置很多内容。


ref: https://blog.csdn.net/u014801157/article/details/24372531
官方文档: 












2. 所有元素都在theme函数内使用element_line，element_rect，element_text和element_blank函数设置，使用方法参考这几个函数的参数说明即可，这里不再一一举例说明。
text, line, rect和title是最顶层的元素，理论上可以做全局设定，但当前版本ggplot2还没有实现(?)，可以根据情况做一些调整：

(1) 简单实例
p=ggplot(mtcars, aes(disp, mpg, color=factor(gear) ))+geom_point(); p

p + theme(
  panel.background=element_rect(fill='transparent', color='black'), #背景透明，黑边框
  legend.key=element_rect(fill='transparent', color='transparent'), #图例无背景，无边框
  axis.text=element_text(color='red')) #坐标轴文字红色
#



(2) element_text() 上按下f1帮助键
 
element_blank: draws nothing, and assigns no space.
element_rect: borders and backgrounds.
element_line: lines.
element_text: text.

rel() is used to specify sizes relative to the parent, 
margins() is used to specify the margins of elements.




(3).更复杂的设置
https://www.sohu.com/a/135157372_572440


1)基于填充色属性：
scale_fill_discrete() #离散变量填充色
scale_fill_continuous() #连续变量填充色
scale_fill_gradient() #连续变量色阶
scale_fill_gray() #灰度填充色
scale_fill_hue() #自定义画板填充色
scale_fill_brewer() #自定义画板填充色
scale_fill_manual() #自定义填充色



2)基于颜色属性：
scale_colour_discrete()
scale_colour_continuous()
scale_colour_gradient()
scale_colour_gray()
scale_colour_hue()
scale_colour_brewer()
scale_colour_manual()



3)基于大小属性：
scale_size_discrete()
scale_size_continuous()
scale_size_manual()
scale_size_area()



4)基于形状属性：
scale_shape_discrete()
scale_shape_continuous()
scale_shape_manual()



5)基于线型属性：
scale_linetype_discrete()
scale_linetype_continuous()
scale_linetype_manual()



















========================================
|-- 去除 ggplot2 背景色和网格、外边框
----------------------------------------
推荐方式：

#提前定义好空白主题样式
theme_blank=theme_bw() +
  theme(panel.border = element_blank(), 去掉外边框
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
g #
g+theme_blank #直接用


添加外边框
  p+theme_classic()+
  theme(panel.border = element_rect(fill = NA, colour = "black")) #方框





1. 去掉背景
blank_theme <- theme_bw()+ #保留边框
  #theme_minimal()+ #连边框都没有
  theme(
    #axis.title.x = element_blank(), #去 x坐标标题
    #axis.title.y = element_blank(), 
    #
    #axis.text.x = element_blank(), #x坐标刻度文字
    #axis.text.y = element_blank(),
    #axis.ticks = element_blank(), #坐标轴刻度
    
    panel.border = element_blank(), #去 外边框
    #axis.line = element_line(colour = "red",size=3), #坐标轴的颜色，线条粗细
    axis.line = element_line(colour = "black"), #要坐标轴
    
    panel.background = element_blank(), #去背景色
    panel.grid=element_blank(), #去背景网格
    #panel.grid.major = element_blank(), #去背景网格 主线
    #panel.grid.minor = element_blank(), #去背景网格 虚线
    
    plot.title=element_text(size=14, face="bold") #最顶上的标题(main)
  )
a=ggplot(mtcars, aes( factor(gear), mpg, fill=factor(gear) ))+geom_boxplot();a #默认效果
a+blank_theme+labs(title='This is title') #干净背景



方法一：推荐！(没有边框，有坐标轴)
a + theme(panel.grid.major =element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"))


方法二：
a + theme_bw() +
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))






https://blog.csdn.net/aspirinvagrant/article/details/39672635




========================================
|-- ggplot2默认主题怎么设置？自定义主题
----------------------------------------
1.设置默认主题
#Cowplot made ggplot2 theme disappear / How to see current ggplot2 theme, and restore the default?
#https://stackoverflow.com/questions/41096293/cowplot-made-ggplot2-theme-disappear-how-to-see-current-ggplot2-theme-and-res
#library(cowplot)
theme_set(theme_grey())


2.如何选择其他主题
g=ggplot(...) #画图命令
g + theme_gray() #添加主题




3. 自定义主题 

# 自定义主题
library(ggplot2)
theme_01 <- function(..., bg='white'){
  require(grid)
  #theme_classic(...) + #基于预设主题
  theme_bw(...)+
    theme(
          rect=element_rect(fill=bg), #背景色填充
          plot.margin=unit(rep(0.1,4), 'lines'), #图片四周距离
          
          #panel.background=element_rect(fill='transparent', color='black'),#白底黑边
          #panel.border=element_rect(fill='transparent', color='transparent'),
          
          panel.grid=element_blank(), #不要背景网格
          axis.title = element_text(color='black', vjust=0.1), #坐标轴标题也就是变量名
          
          axis.ticks.length = unit(-0.2,"lines"), #坐标刻度向内
          axis.ticks = element_line(color='black'), #坐标轴刻度颜色
          
          #axis.ticks.margin = unit(0.8,"lines"), #`axis.ticks.margin` is deprecated. Please set `margin` property  of `axis.text` instead 
          # unit(c(t, r, b, l), unit)
          axis.text.x = element_text(margin=margin(t=0.8, unit="lines") ), #x轴刻度向上到坐标轴0.8行
          axis.text.y = element_text(margin=margin(r=0.8, unit="lines") ),
          
          ##legend.title=element_blank(), #去掉图例标题
          #legend.key=element_rect(fill='transparent', color='transparent')
          plot.title=element_text(face="bold", hjust = 0.5), #大图标题居中 #size=14,
          
          legend.position="bottom", #图例显示位置
          legend.margin=margin(t = -0.5, unit='line') #图例整体上边距,缩减n行
      )
}

p=ggplot(mtcars, aes(disp, mpg, color=factor(gear) ))+geom_point();p

p+theme_01()+
  scale_color_hue("gear_DIY")+
  labs(title="mpg ~ disp")
#






========================================
|-- 根据x坐标为图片添加不同背景颜色
----------------------------------------
nFac <- 6; nDat <- 10
df <- data.frame(x = gl(nFac, nDat), 
                 y = runif(nFac * nDat))
rec <- data.frame(xmin = head(seq <- seq(0.5, nFac + .5, 1), -1), 
                  xmax = tail(seq, -1), 
                  alpha = c(.5, 0, 0, .5, .5, 0))
rec

library(ggplot2)
ggplot() +
  scale_x_discrete(seq_len(nFac)) +
  geom_rect(data = rec, 
            aes(xmin = xmin, 
                xmax = xmax, 
                alpha = alpha), 
            ymin = -Inf, 
            ymax = Inf, 
            fill = "lightblue",
            colour = "blue",
            size = 1) +
  geom_boxplot(data = df, 
               aes(x = x, y = y)) +
  theme(panel.background = element_rect(fill = "pink"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  guides(alpha = FALSE)
#





========================================
|-- 字号: 字体大小设置Change Font Size of ggplot2: all text/ axis text/ axis title/ main title/ legend
----------------------------------------
########
# Example data
data <- data.frame(Probability = c(0.5, 0.7, 0.4),
                   Groups = c("Group A", "Group B", "Group C"))
data
library("ggplot2")

my_ggp <- ggplot(data,                                            # Basic ggplot2
                 aes(x = Groups, y = Probability, fill = Groups)) +
  geom_bar(stat = "Identity") +
  ggtitle("My ggplo2 Plot")
my_ggp 

#1. Change Font Size of All Text Elements
my_ggp + theme(text = element_text(size = 20))

#2. Change Font Size of Axis Text 坐标刻度的文字
my_ggp + theme(axis.text = element_text(size = 20))
my_ggp + theme(axis.text.x = element_text(size = 20)) #仅x坐标刻度的文字

#3. Change Font Size of Axis Titles 坐标的标题
my_ggp + theme(axis.title = element_text(size = 20))
my_ggp + theme(axis.title.y = element_text(size = 20)) #仅y坐标的标题

#4. Change Font Size of Main Title 改变标题字号
my_ggp + theme(plot.title = element_text(size = 20))


#5. Change Font Size of Legend
my_ggp + theme(legend.text = element_text(size = 20)) #legend text
my_ggp + theme(legend.title = element_text(size = 20)) # Legend title

# https://statisticsglobe.com/change-font-size-of-ggplot2-plot-in-r-axis-text-main-title-legend






========================================
一页多图，同时绘制多图
----------------------------------------
利用facet_grid
利用cowplot包
利用gridExtra包


1.gridExtra包，一行绘制多个图
library(gridExtra)
grid.arrange(p1,p2,nrow=1)


可以设置多行多列
grid.arrange(plots[[1]]...plots[[10]],ncol=1,nrow=10)



2.
library(Rmisc)
multiplot(p1,p2,cols=2)



3.
install.packages("cowplot")
library(cowplot)
plot_grid(p1,  NULL, NULL,p2, labels = c("A", "", "", "B"),ncol = 2)

例:
plot_grid(plot.mpg, plot.diamonds, labels = c("A", "B"), align = "h") #自动排版
plot_grid(plot.mpg, NULL, NULL, plot.diamonds, labels = c("A", "B", "C", "D"), ncol = 2) #指定排版
plot_grid(plot.mpg, plot.diamonds, labels = c("A", "B"), nrow = 2, align = "v") #上下排布

https://www.jianshu.com/p/fea410378360




4.ggplot2 的分面(facet)可以绘制一页多图, 但是必须是来自同一个数据集的图形,局限性很大. 如果我们有多个不同来源的图形,想绘制到一张图上又该如何处理呢? multiplot提供了极为强大的函数功能.

multiplot可以设置行列, 也可以设置一个矩阵进行布局.
http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/

multiplot(p1, p2, p3, p4, cols=2)






ref:
https://www.jianshu.com/p/ff05c07d42d7
https://blog.csdn.net/scpcmoon/article/details/80722376
https://blog.csdn.net/tanzuozhev/article/details/51112223





========================================
|-- 使用grid包，把多个ggplot2图片打印到一页上
----------------------------------------
grid中文翻译为网格，可将其解释为画布分割，通过设定相应的参数，从而可以任意的摆放图形



1. 实例(来自作者的书)
#造三个图
library(ggplot2)
a=ggplot(mtcars, aes( factor(gear), mpg, fill=factor(gear) ))+geom_boxplot()
b=a+geom_jitter()
c=ggplot(diamonds, aes(carat, price, color=cut))+geom_point(alpha=0.2);

#
library(grid)
pdf(paste0(outPath,"pdf/multyPic_onePage.pdf"),width=8,height=8)
#
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)) ) #造一个网格，2行2列
#
vplayout=function(x,y){
  viewport(layout.pos.row=x, layout.pos.col=y)
}
print(a,vp=vplayout(1,1:2)) #第1行第1和2列，图a
print(b,vp=vplayout(2,1)) #第2行第1列，图b
print(c,vp=vplayout(2,2)) #第2行第2列，图c
#
dev.off()





2. 常用函数：
grid.newpage() 创建新的画布
grid.layout() 分割画布，使用参数widths和heights指定分割比例 ,从上到下，从左到右排列
viewport() 在画布中创建视窗

grid.show.viewport() 在画布中展示视窗

grid.show.layout() 展示分割的画布

pushViewport() 将新建的viewport推出去，即将工作区域切换到新的viewport

popViewport() 将当前的viewport删除，其父viewport作为新的工作区域, 子viewport中的绘制的图形不会被删除

downViewport() 导航到子viewport，并作为工作区域，原viewport不会删除

upViewport() 导航到父viewport，父viewport变为工作区域, 原viewport不会被删除

seekViewport() 导航到name参数所在的viewport,并作为工作区域

grid.text() 输出文本标签,坐标只与画布有关，与viewport无关




(2)
viewport(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         default.units = "npc", just = "centre",
         gp = gpar(), clip = "inherit",
         xscale = c(0, 1), yscale = c(0, 1),
         angle = 0,
         layout = NULL,
         layout.pos.row = NULL, layout.pos.col = NULL,
         name = NULL)

grid.layout(nrow = 1, ncol = 1,
        widths = unit(rep_len(1, ncol), "null"),
        heights = unit(rep_len(1, nrow), "null"),
        default.units = "null", respect = FALSE,
        just="centre")
#

(3) 参数解释：
name 指定viewport的名字，用于搜索和定位
x,y 为起点坐标，默认是矩形视窗中心坐标，为0 - 1的数字，表示占newpage的比例
width, height 为矩形视窗的长宽，同样是占newpage的比例
angle 表示角度，从-360到360,正数表示逆时针旋转，负数表示顺时针旋转
just 表示指定视窗起点位置，默认“centre”, 还可以设置左下角c(“left”, “buttom”), 右上角c(“right”, “top”) 等

layout grid.layout 对象，用于将当前的viewport拆分为子区域
layout.pos.row 创建的viewport在父节点layout的行位置
layout.pos.col 创建的viewport在父节点的layout列位置

nrow 表示将该区域拆分为几行
ncol 表示将该区域拆分为几列
widths 表示每个子区域的宽度,向量长度等于ncol
heights 表示每个子区域的高度，向量长度等于nrow

gp = gpar() 表示传递其它参数，如: col/fill颜色,lty线型, lwd线宽, fontsize文本尺寸, fontfamily字体, fontface字型等，
可以通过?gpar查询


例: 倾斜45度的矩形
library(ggplot2)
library(grid)
grid.newpage()  # 创建一个空白画布
vp1 <- viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle = 45)  # 设定视窗大小
grid.show.viewport(vp1)  # 查看在画布中的的视窗，自动上色，方便观察




(4)例: 新建互相重叠的3个绘图视窗
library(ggplot2)
library(grid)
#library(showtext)

#YaHei <- windowsFont("微软雅黑")font_add("YaHei", regular = "msyh.ttc", bold = "msyhbd.ttc")  
# 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体 
#showtext_auto()

#### 父viewport
grid.newpage()   #新建一个page
vp1 <- viewport(x = 0, y = 0.2, w = 0.9, h = 0.8, just = c("left", "bottom"))  #新建一个viewport，起点为左下角，
pushViewport(vp1)  # 推出vp1
grid.rect(gp = gpar(col = "red"))  # 新建一个矩形,gp=gpar()表示设置图形参数
grid.text("我在vp1_1", x = 0.8, y = 0.2, gp = gpar(col = "red", fontfamily = "YaHei", fontsize = 15))  # 新建一个文本,输出到vp1

vp2 <- viewport(x = 0, y = 0.2, w = 0.9, h = 0.8, just = c("left", "bottom"))  # 新建一个viewport，起点为左下角，
pushViewport(name = vp2)  # 将工作区域设置到vp2
grid.rect(x = 0.1, y = 0.2, width = 0.9, height = 0.7, just = c("left", "bottom"), gp = gpar(col = "blue", lty = "dashed"))  # 新建一个矩形,gp=gpar()表示设置图形参数 
grid.text("我在vp2_1", x = 0.8, y = 0.3, gp = gpar(col = "blue", fontfamily = "YaHei", fontsize = 15))  # 新建一个文本,输出到vp2

vp3 <- viewport(x = 0.1, y = 0.2, width = 0.9, height = 0.7, just = c("left", "bottom"))
pushViewport(vp3)
grid.rect(x = 0.1, y = 0.2, width = 0.7, height = 0.7, just = c("left", "bottom"), gp = gpar(col = "orange", lty = "twodash", lwd = 2))  
# 新建一个矩形,gp=gpar()表示设置图形参数 
grid.text("我在vp3_1", x = 0.6, y = 0.4, gp = gpar(col = "orange", fontfamily = "YaHei", fontsize = 15))  # 新建一个文本,输出到vp2





(5) layout参数

library(ggplot2)
library(grid)
grid.newpage()
g1 <- grid.layout(nrow = 3, ncol = 2, widths = c(2, 3), heights = c(2, 1, 3))  # 设置分割的宽度和长度比例
 
grid.show.layout(l = g1) #显示3行2列的视窗




(6) 综合例子: 三个图，上面一个，下面两个（左右各一个）
library(ggplot2)
library(grid)
#library(showtext)

#YaHei <- windowsFont("微软雅黑")font_add("YaHei", regular = "msyh.ttc", bold = "msyhbd.ttc")  # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体 
#showtext_auto()

### 准备ggplot对象
plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + 
  facet_grid(cols = vars(Species))  # 按Species列分面
plot.iris

plot.mpg <- ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + 
  geom_point(size = 2.5) +       
  labs(title = "dot plot")
plot.mpg

plot.diamonds <- ggplot(diamonds, aes(clarity, fill = cut)) + 
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 70, 
                                   vjust = 0.5)) + labs(title = "bar plot")
plot.diamonds

###开始填充图
grid.newpage()  # 新建画布
layout_1 <- grid.layout(nrow = 3, ncol = 2, 
                        widths = c(1, 1), heights = c(1, 4, 5))  # 分成上下2*3共6个版块，最上面版块显示标题
pushViewport(viewport(layout = layout_1))  # 推出分成6个版块的视窗
#
print(plot.iris, vp = viewport(layout.pos.row = 2, layout.pos.col = c(1, 2)))  # 在中间一行子视窗中画plot.iris
print(plot.mpg, vp = viewport(layout.pos.row = 3, layout.pos.col = 1))  # 在左下角子视窗中画plot.mpg
print(plot.diamonds, vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  #在右下角子视窗中画plot.diamonds
grid.text("我是画布名称", x = 0.5, y = 0.95, gp = gpar(col = "orange", fontfamily = "YaHei", fontsize = 15))  # 增加画布标题






========================================
|-- grid 拼接蝴蝶图(向左右的柱状图，中间一列是文字)
----------------------------------------

1.例:

library(ggplot2)
library(grid)
library(dplyr)
#library(showtext)
library(Cairo)

#YaHei <-  windowsFont("微软雅黑")
#font_add("YaHei",regular = "msyh.ttc", bold = "msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体 

#CairoPNG(file = "蝴蝶图_exercing.png", width = 1200, height = 700)
#showtext_begin()

#生成图形所需数据集：
mydata<-data.frame(id=1:14,
                   A=c(5.0,14.7,2.5,8.5,5.1,6.9,7.7,6.8,4.4,4.9,5.3,1.0,0.9,7.8),
                   B=c(31.3,24.7,17.8,17.2,15.3,14.3,13.9,13.9,12.4,10.0,6.5,4.2,2.5,0.9),
                   Label=c("Website","Customer & Employee Referral","Webinar","Facebook/Twitter/Other Social",
                           "Marketting & Advertising","Paid Serch","Other","Sales generated","Tradeshows",
                           "Parter","Linkedin","Events","Lead list","Emial Campaign"))
p1<-ggplot(mydata) + # 绘制右侧的柱形图  
  geom_hline(yintercept=mean(mydata$A),linetype=2,size=.25,colour="grey")+  
  geom_bar(aes(x=id,y=A),stat="identity",fill="#E2BB1E",colour=NA)+  
  ylim(-5.5,16)+   
  scale_x_reverse()+   
  geom_text(aes(x=id,y=-4,label=Label),vjust=.5)+  
  geom_text(aes(x=id,y=A+.75,label=paste0(A,"%")),size=4.5,family="YaHei",fontface="bold")+  
  coord_flip()+  
  theme_void()
p1

##
p2<-ggplot(mydata)+ # 绘制左侧柱形图, 左侧图没有横坐标刻度标签  
  geom_hline(yintercept=-mean(mydata$B),linetype=2,size=.25,colour="grey")+  geom_bar(aes(x=id,y=-B),stat="identity",fill="#C44E4C",colour=NA)+ 
  # y=-B,绘制的图形在另一侧  
  ylim(-40,0)+  scale_x_reverse()+ #   
  geom_text(aes(x=id,y=-B-1.75,label=paste0(B,"%")),size=4.5,family="YaHei",fontface="bold")+  
  coord_flip()+  
  theme_void()
p2

##
# 图形拼接
grid.newpage() # 新建画布
layout_1 <- grid.layout(nrow = 2, ncol = 2, widths = c(2, 3), heights = c(1, 9)) # 分成2*2共4个版块
pushViewport(viewport(layout = layout_1)) # 推出分为4个版块的视窗
print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 2)) # 将p1输出到右下角
print(p2, vp = viewport(layout.pos.row = 2, layout.pos.col = 1)) # 将p2输出到左下角# 添加主标题和分标题
# 差不多结束了。下面是文字
grid.text(label="我是主标题",x = 0.5,y = 0.97,gp=gpar(col="cyan",fontsize=15,fontfamily="YaHei",draw=TRUE,just = "centre"))
grid.text(label="我是左标题", x = 0.15,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just = c("left", "top")))
grid.text(label="我是右标题",x = 0.85,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just = c("right", "top")))
#
#showtext_end()
#dev.off()






========================================
|-- 子母图: 子图嵌入主图
----------------------------------------
子母图主要是形成局部放大的效果，既可以从整体上对比，又兼顾特别小的数据组，或特别密的数据点可以查看，而没有必要单独做2张图。

library(ggplot2)
library(grid)



1. 
library(grid)
vp <- viewport(width = 0.3, height = 0.4, x = 0.65,y = 0.9,just=c("left","top"))
    # width\height表示插入图形的大小，x\y表示插入图形相对于图片底层just的位置
print(p1)
print(p2,vp=vp)




2.
install.packages("viridis")
library(viridis)
ggdraw() +draw_plot(p1,0,0,1,1)+
draw_plot(p2,0.1,0.5,0.3,0.4)   # 0.1\0.5为图的左下角x\y的位置，0.3\0.4为图形的宽度和高度






3.不同的图叠加拼凑在一起展示
(1)不同的数据放到同一张图展示
par(new=TRUE) # 每叠加一次新图形，运行一次该程序命令，即可实现在原图上继续叠加数据绘图

plot(x1,x2,xlab="维度",ylab="物种多样性数量");    #做散点图
lines(lowess(x1,x2),col=2);    #利用lowess做回归曲线
par(new=TRUE)  # 是否叠加新图形，没叠加一次运行一次该命令
plot(x3,x4,yaxt="n",xaxt="n",xlab="维度",ylab="物种多样性数量");    #做散点图
lines(lowess(x1,x2),col=2,lty=4);    #利用lowess做回归曲线



(2)用grid.newpage()函数命令选择是否进行图形叠加，该命令有先后顺序，先运行。

library(grid)
library(ggplot2)
gg <- ggplot(mpg, aes(displ, hwy, colour = class)) +  geom_point()
library(png)
logo <- readPNG("C:\\Users\\TD\\Desktop\\test.png")
grid.newpage()
print(gg)  # 绘制第一个图
vp <- viewport(x = 0.6, y = 0.3, width = 0.2, height = 0.2)
grid.raster(logo, vp = vp)  # 将第一个图和第二个图形合并




4.grid包可以画子母图。 
安装gridExtra包后，ggplot2中多了一个ggplotGrob()函数，可以创建grob对象参数：

library(ggplot2)
library(gridExtra)
g <- ggplotGrob(qplot(1, 1) + #子图
                  theme(plot.background = element_rect(colour = "black")))
qplot(1:10, 1:10) +    
  annotation_custom(  # 通过添加注释的方式，向图形内部添加一个图形
    grob = g,  # 插入子图形对象，即添加内容
    xmin = 1, xmax = 5, ymin = 5, ymax = 10 # 添加位置4个坐标
  )
#





ref:
1. R语言组合绘图和多个图形叠加、图片叠加绘图
https://blog.csdn.net/tandelin/article/details/94412733

2. R语言绘图叠加 https://blog.csdn.net/tandelin/article/details/94362055






========================================
|-- gridExtra包，组合多个图形
----------------------------------------
1. 主要函数：
arrangeGrob()
grid.arrange()
marrangeGrob()


(2). 语法：
arrangeGrob(..., grobs = list(...), layout_matrix, vp = NULL,
  name = "arrange", as.table = TRUE, respect = FALSE, clip = "off",
  nrow = NULL, ncol = NULL, widths = NULL, heights = NULL, top = NULL,
  bottom = NULL, left = NULL, right = NULL, padding = unit(0.5, "line"))
 
grid.arrange(..., newpage = TRUE)
 
marrangeGrob(grobs, ..., ncol, nrow, layout_matrix = matrix(seq_len(nrow *
  ncol), nrow = nrow, ncol = ncol), top = quote(paste("page", g, "of",
  npages)))
#

(3)
参数解释：
grobs 图形对象列表，grob是graphical object两个单词的缩写，表示ggpot等图形对象
layout_matrix 表示布局的矩阵





2. 为散点图顶部和右侧添加柱状图
#为散点图顶部和右侧添加柱状图
library(ggplot2)
library(gridExtra)
#library(showtext)

#YaHei <-  windowsFont("微软雅黑")
#font_add("YaHei",regular = "msyh.ttc", bold = "msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体 
#showtext.auto()

empty <- ggplot() + geom_point(aes(1, 1), colour = "white") +   
  theme(axis.ticks = element_blank(), 
        panel.background = element_blank(), 
        axis.line = element_blank(), 
        axis.text.x = element_blank(), axis.text.y = element_blank(), 
        axis.title.x = element_blank(), axis.title.y = element_blank())
#
scatter <- ggplot() + 
  geom_point(aes(mtcars$mpg, mtcars$qsec)) # 绘制主图散点图
scatter
#
hist_top <- ggplot() + 
  geom_histogram(aes(mtcars$mpg)) # 绘制上方频率分布直方图
hist_top
#
hist_right <- ggplot() + 
  geom_histogram(aes(mtcars$qsec)) + coord_flip() # 绘制右侧频率分布直方图# 最终组合，由4个图拼图而成，只有右上角的图已经将标注移除了
hist_right
#
grid.arrange(hist_top, empty, scatter, hist_right, # 按从左到右，从上到下顺序排列4个图
             ncol = 2, nrow = 2, widths = c(4, 1), heights = c(1, 4)) 
             # 4个版块的长宽比例# 其实这种组合图已经有相应的R包了，ggExtra
#
#
# 一行画出来以上过程
df <- data.frame(x = mtcars$mpg, y = mtcars$qsec)
p <- ggplot(df, aes(x, y)) + geom_point() + theme_classic()
ggExtra::ggMarginal(p, type = "histogram")






3.把绘图对象添加到列表总，并把该列表传递给grid.arrange()函数中的grobs参数

library(ggplot2)
library(gridExtra)
library(lattice)  # 类似ggplot,但是语法更加复杂
#library(showtext)

#YaHei <- windowsFont("微软雅黑")
#font_add("YaHei", regular = "msyh.ttc", bold = "msyhbd.ttc")  # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体 showtext.auto()

gs <- list(NULL)
gs[[1]] <- qplot(1, 1)
gs[[2]] <- xyplot(1 ~ 1)  # lattice包
grid.arrange(grobs = gs, ncol = 2)

## 或者ggplot2对象
gs <- list(NULL)
gs[[1]]=ggplot(mtcars, aes(disp, mpg))+geom_point()
gs[[2]]=ggplot(mtcars, aes(disp, mpg))+geom_point()
grid.arrange(grobs = gs, ncol = 2)









========================================
|-- cowplot包为ggplot2 提供出版物级的主题
----------------------------------------

1. cowplot是一个ggplot2包的简单补充，意味着其可以为ggplot2提供出版物级的主题等。
更重要的是，这个包可以组合多个”ggplot2”绘制的图为一个图，并且为每个图加上例如A,B,C等标签，
这在具体的出版物上通常是要求的。 

语法结构与ggplot类似，将ggplot2图作为一个对象置于 ggdraw()中

draw_plot(plot, x = 0, y = 0, width = 1, height = 1, scale = 1)
draw_text(text, x = 0.5, y = 0.5, size = 14, hjust = 0.5, vjust = 0.5,...)
draw_plot_label(label, x = 0, y = 1, hjust = -0.5, vjust = 1.5, size = 16, fontface = "bold", family = NULL, colour = NULL, ...)

参数解释：
- plot 表示ggplot2绘图对象
- x, y 表示子图的起点坐标(左下角坐标)，在0-1之间，表示占母图的比例，
- width, height 表示子图长宽所占比例，在0-1之间
- text 表示要映射的文本向量
- label 表示要映射的文本向量

其它参数与ggplot2中意思一样




2. 例子: 拼接三个图，顶上一个，底下两个(左一个右一个)。
library(ggplot2)
library(cowplot)
theme_set(theme_cowplot())
#library(showtext)

#font_add_google("Dancing Script", "Dancing")

plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +     
  geom_point() + 
  facet_grid(cols = vars(Species)) 
plot.iris
# 按Species列分面

plot.mpg <- ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) +   
  geom_point(size = 2.5) +    
  labs(title = "dot plot") 
plot.mpg

plot.diamonds <- ggplot(diamonds, aes(clarity, fill = cut)) +   
  geom_bar() +   
  theme(axis.text.x = element_text(angle = 70, vjust = 0.5)) +   
  labs(title = "bar plot")
plot.diamonds

gg <- ggdraw() +  
  draw_plot(plot.iris, 0, 0.5, 1, 0.5) + # 在母图上半部，占母图比例1/2  
  draw_plot(plot.mpg, 0, 0, 0.5, 0.5) + # 在母图左下角，占母图比例1/4  
  draw_plot(plot.diamonds, 0.5, 0, 0.5, 0.5) + # 在母图右下角，占母图比例1/4 
  draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), 
                  size = 15, colour = "cyan", family = "Dancing") # 加上标签，
#showtext_begin()
print(gg)
#showtext_end()














========================================
ggplot2 Plotting means and error bar
----------------------------------------
http://blog.sina.com.cn/s/blog_4a0824490102w7mr.html
1.如何在ggplot2中的line graph或者histogram中添加error bar：
参考资料：
http://ggplot2.tidyverse.org/reference/geom_linerange.html
http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/
http://www.sthda.com/english/wiki/ggplot2-error-bars-quick-start-guide-r-software-and-data-visualization

例1：单数据的errorbar。
# 数据格式
#N	len	sd
#1	-65843.8	81.4
#2	-61454.7	584.9
#3	-59690.7	754.4
#4	-58326.3	1212
#5	-57695.8	1523.1

data=read.table('clipboard', sep="\t",header=T)
library(ggplot2)

ggplot(data,aes(x=N,y=len))+
  geom_errorbar(aes(ymin=len-sd, ymax=len+sd),width=.1)+
  geom_line()+
  geom_point()
####

例2：多数据的errorbar
使用R的内部数据集
tg <- ToothGrowth
head(tg)
#>    len supp dose
#> 1  4.2   VC  0.5
#> 2 11.5   VC  0.5
#> 3  7.3   VC  0.5
#> 4  5.8   VC  0.5
#> 5  6.4   VC  0.5
#> 6 10.0   VC  0.5

library(ggplot2)

#先对数据进行汇总，多种方法：http://www.cookbook-r.com/Manipulating_data/Summarizing_data/
#使用其中定义的 summarySE() 函数。
## Summarizes data.
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
    library(plyr)

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm=FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    # This does the summary. For each group's data frame, return a vector with
    # N, mean, and sd
    datac <- ddply(data, groupvars, .drop=.drop,
      .fun = function(xx, col) {
        c(N    = length2(xx[[col]], na.rm=na.rm),
          mean = mean   (xx[[col]], na.rm=na.rm),
          sd   = sd     (xx[[col]], na.rm=na.rm)
        )
      },
      measurevar
    )

    # Rename the "mean" column    
    datac <- rename(datac, c("mean" = measurevar))

    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

    # Confidence interval multiplier for standard error
    # Calculate t-statistic for confidence interval: 
    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
    ciMult <- qt(conf.interval/2 + .5, datac$N-1)
    datac$ci <- datac$se * ciMult

    return(datac)
}

#汇总
# summarySE provides the standard deviation, standard error of the mean, and a (default 95%) confidence interval
tgc <- summarySE(tg, measurevar="len", groupvars=c("supp","dose"))
tgc
#>   supp dose  N   len       sd        se       ci
#> 1   OJ  0.5 10 13.23 4.459709 1.4102837 3.190283
#> 2   OJ  1.0 10 22.70 3.910953 1.2367520 2.797727
#> 3   OJ  2.0 10 26.06 2.655058 0.8396031 1.899314
#> 4   VC  0.5 10  7.98 2.746634 0.8685620 1.964824
#> 5   VC  1.0 10 16.77 2.515309 0.7954104 1.799343
#> 6   VC  2.0 10 26.14 4.797731 1.5171757 3.432090

#画图
par(mfrow=c(2,2))
# Standard error of the mean
ggplot(tgc, aes(x=dose, y=len, colour=supp)) + 
    geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.1) +
    geom_line() +
    geom_point()
	
	
#errorbar重叠了，可以移位以便看得更清楚。
# The errorbars overlapped, so use position_dodge to move them horizontally
pd <- position_dodge(0.1) # move them .05 to the left and right
ggplot(tgc, aes(x=dose, y=len, colour=supp)) + 
    geom_errorbar(aes(ymin=len-se, ymax=len+se), width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd)


# Use 95% confidence interval instead of SEM 使用95%置信区间，而不是SEM
ggplot(tgc, aes(x=dose, y=len, colour=supp)) + 
    geom_errorbar(aes(ymin=len-ci, ymax=len+ci), width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd)


# Black error bars - notice the mapping of 'group=supp' -- without it, the error
# bars won't be dodged!
ggplot(tgc, aes(x=dose, y=len, colour=supp, group=supp)) + 
    geom_errorbar(aes(ymin=len-ci, ymax=len+ci), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=3)




（2）如何把error bar画成阴影填充的曲线？
http://stackoverflow.com/questions/12033319/plot-mean-and-sd-of-dataset-per-x-value-using-ggplot2

a <- data.frame(x=rep(c(1,2,3,5,7,10,15,20), 5),
    y=rnorm(40, sd=2) + rep(c(4,3.5,3,2.5,2,1.5,1,0.5), 5))
ggplot(a, aes(x=x,y=y)) + geom_point() +geom_smooth()




========================================
柱状图(高度均值,带error bar)+散点图 done
----------------------------------------
效果图：http://tool.biomooc.com/R_scripts/index.html

library(ggplot2)
library(reshape2)

#示例数据：某基因在对照和肿瘤样本中的表达量。
d1=data.frame(
  control=c(10,20,30,40,30,60,20,40,20,20,10,20,30,40,30,40,20,40,20,20),
  tumor=c(50,70,40,60,80,90,40,50,70,80,50,70,40,60,80,90,40,50,70,80)
);

# 数据框重塑，数据合并为一列，添加分类列
d2=melt(d1,
	variable.name="type",#新变量的名字
	value.name="value" #值得名字
);
d2



######## 开始画图1 箱线图 + 散点图 done
ggplot(d2,aes(factor(type), value))+
  geom_boxplot()+
  geom_jitter()


######## 开始画图2 带误差bar的柱状图 + 散点图 done
#http://www.cookbook-r.com/Manipulating_data/Summarizing_data/
## Summarizes data.
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
	 .fun = function(xx, col) {
	   c(N    = length2(xx[[col]], na.rm=na.rm),
		 mean = mean   (xx[[col]], na.rm=na.rm),
		 sd   = sd     (xx[[col]], na.rm=na.rm)
	   )
	 },
	 measurevar
  )

  # Rename the "mean" column    
  datac <- rename(datac, c("mean" = measurevar))

  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult

  return(datac)
}


# http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/
d3 <- summarySE(d2, measurevar="value", groupvars=c("type"))
d3

ggplot(d3, aes(x=type, y=value)) + 
  geom_bar(aes(fill=type),position=position_dodge(), stat="identity", width=0.5) +
  geom_errorbar(aes(ymin=value-ci, ymax=value+ci),
	width=.2, # Width of the error bars
	position=position_dodge(.9))+
  geom_jitter(data=d2,aes(type,value), width=0.15) +
  ylab( expression(paste( italic("Sox2")," Expression(normalization)") ) )
  #ylab("Sox2 Expression\n(normalization)") 



========================================
ggplot2标题控制
----------------------------------------
1. 控制标题位置、文字大小
p+labs(title="cor(gDPAU, RNA) low, BC: 212 genes")+
  theme(plot.title = element_text(hjust = 0.1, vjust=-5, size=9));
#
hjust 控制左右移动
vjust 控制上下移动
size 字体大小
#




========================================
ggplot2坐标轴控制、图例控制
----------------------------------------
1.隐藏x轴上的标签文字。
scale_x_continuous(labels = NULL)


2.更多控制选项：坐标轴命名、图标题
ggplot(readsCounts_df, aes(cell_id, mean, fill=factor(type)))+
  geom_histogram(stat='identity', position="dodge")+ #identity用数量作为柱子高度。dodge表并列
  scale_fill_hue("Type", breaks=c("h","nh","all"))+ #图例标题，图例顺序，图例重命名用labels=c()
  labs(title="B116", x="Cell ID", y="Mean read counts")+ #图的标题，和坐标轴重命名
  scale_x_discrete(limits=tmp2$cell_id, labels = NULL) #对x坐标进行重排序

#设置x,y轴的连续变量范围
#使用xlim()和ylim设置x、y轴的最大最小值。
p <- ggplot(PlantGrowth, aes(x=group, y=weight)) + geom_boxplot()
p + ylim(0, max(PlantGrowth$weight)) #ylim()是对scale_y_continuous()的快速实现。
#其中breaks用来控制刻度。
p + scale_y_continuous(limits=c(0, 10), breaks=NULL)


#怎么写坐标轴文字上标
#https://cloud.tencent.com/developer/ask/173132
labs(x="Average normalized read count", y=expression(~CV^2) ) 
#Y坐标文字就是CV^2其中2是上标






3.图例
  # scale_color_hue("Type",breaks=c("h","nh","all"))+ #修改图例顺序
  theme(legend.position="none") + #隐藏图例


自定义点的颜色
ggplot(wjl2, aes(PC_1, PC_2, col=factor(type) ))+
  geom_point(alpha=0.8,size=0.8)+
  guides(color=guide_legend(title=NULL)) + #隐藏图例标题
  scale_color_manual(values=c( 'red',     'green',       'black','orange',    "#F8766D",   'grey'), #value是颜色，limits是分类因子的值
                     limits =c('in2Cluster0','in2Cluster1','mix','nonsyncHeLa','syncHeLa','unknown'))


图例文字
ggplot(df3.filterd,aes(reads/1e6, geneNums, color=group.x))+
  geom_point(alpha=0.5,size=3)+
  labs(x="Million Reads", y="nGene")+
  xlim(0,4)+ylim(2000,9000)+ #控制坐标轴的显示范围
  guides(color=guide_legend(title="Group")) #改变图例文字，为 title=NULL 则表示清空图例标题
  
  


4.标记p值
# 做t检验
p_h_nh=t.test(mean_h, mean_nh)$p.value;p_h_nh
p_h_all=t.test(mean_h, mean_all)$p.value;p_h_all
#保留2位有效数字
p_h_nh=formatC(p_h_nh, format = "e", digits = 2)
p_h_all=formatC(p_h_all, format = "e", digits = 2)

  #画线，在线上标记p值
g+geom_segment(aes(x=1, y=155, xend=2, yend=155))+ #横线
  annotate("text", x=1.5, y=160, label=p_h_nh, size=3) +#annotate函数也可以添加标签
  geom_segment(aes(x=1, y=165, xend=3, yend=165))+ #横线
  annotate("text", x=2, y=170, label=p_h_all, size=3)



5.坐标轴标签60度转向，同时一次显示两张图。
  #数据宽变长
  library(reshape2)
  #画图1 raw counts
  g1=ggplot(melt(exp_df_cell1,id.vars="geneSymbol", measure.vars=c("APA_1","APA_2")), aes(geneSymbol, value,fill=variable))+
    geom_histogram(stat="identity")+
    #geom_histogram(stat="identity", position="fill")+
    theme(  axis.text.y=element_text(angle=90, hjust=1,size=8),legend.position="top" )+
    labs(title=s1)+ylab("Read counts")+#xlab("Gene Symbols")+
    scale_x_discrete(limits=o_gs, name=NULL, labels=NULL) +
    theme(axis.title.x=element_blank(),plot.margin=unit(x=c(2,5,0,5),units="mm"))+
    scale_fill_discrete("Type")
  #画图2 percentage
  g2=ggplot(melt(exp_df_cell1,id.vars="geneSymbol", measure.vars=c("APA_1p","APA_2p")), aes(geneSymbol, value,fill=variable))+
    geom_histogram(stat="identity")+
    #geom_histogram(stat="identity", position="fill")+
    theme(axis.text.x=element_text(angle=60, hjust=1,size=8,color="grey50"), #坐标轴刻度旋转60度。
          axis.text.y=element_text(angle=90, hjust=1,size=8),
          plot.margin=unit(x=c(0,5,2,5),units="mm"), legend.position="none")+#guides(fill=FALSE)+
    ylab("Percentage")+#xlab("Gene Symbols")+
    scale_x_discrete(name="Gene Symbols", limits=o_gs)
  library(scater)
  multiplot(g1,g2)
  # #这就是需要的效果

#




========================================
|-- 如何去除坐标左右框和曲线之间的空白距离?expand=c(0,0)
----------------------------------------
ggplot2默认主题图形和坐标轴间会有间隙，看起来会不舒服。

scale_y_continuous(expand = c(0,0)) #这个可以去掉与X轴间隙
scale_x_continuous(expand = c(0,0)) #这个可以去掉与Y轴间隙

另外当画柱形图只有两个柱子时，想把柱子间隙放大一些，也可以用expand来调节

https://bbs.pinggu.org/thread-4923520-1-1.html



========================================
|-- 隐藏某一个坐标轴
----------------------------------------

    theme( axis.ticks.y = element_blank(),
           axis.line.y = element_blank(),
           axis.text.y = element_blank() )






========================================
|-- 放大图例的点，指定列数
----------------------------------------

p3 + guides(colour = guide_legend(override.aes = list(alpha = 1,size=10)))


p + guides( color = guide_legend(ncol=2, override.aes = list(size=5))) #两列，放大图例






========================================
|-- ggplot2 legend图例的修改
----------------------------------------
https://www.cnblogs.com/emanlee/p/5373649.html
http://www.360doc.com/content/18/1205/11/57890290_799444872.shtml

1.
ggplot2中的legend包括四个部分: legend.tittle, legend.text, legend.key, legend.backgroud。针对每一部分有四种处理方式：

element_text()绘制标签和标题，可控制字体的family, face, colour, size, hjust, vjust, angle, lineheight,当改变角度时，序将hjust调整至0或1.
element_rect()绘制主要供背景使用的矩形，你可以控制颜色的填充（fill）和边界的colour, size, linetype
element_blank()表示空主题，即对元素不分配相应的绘图空间。该函数可以山区我们不感兴趣的绘图元素。使用之前的colour=NA，fill=NA,让某些元素不可见，但仍然占绘图空间。
element_get()可得到当前主题的设置。
theme()可在一幅图中对某些元素进行局部性修改，theme_update()可为后面图形的绘制进行全局性的修改。


(1) 不加Legend
p+theme(legend.position='none');


(2) 删除legend.tittle
p+theme(legend.title=element_blank())


(3) 图例的位置和对齐

图例（legend）的位置和对齐使用的主题设置legend.position来控制，其值可为right,left,top,bottom,none(不加图例，或是一个表示位置的数值。这个数值型位置由legend.justfication给定的相对边角位置表示（取0和1之间的值），它是一个长度为2的数值型向量：右上角为c(1,1),左下角为c(0,0)

例如：p+theme(legend.position='left')



(4) 指定图例精确位置

legend.position还可以设置图例的具体位置，即legend.position = c(x, y)。注意，这里的x和y的取值范围均为[0,1]。
#将图例放到图形内部，并设置为左上角

p + theme(legend.position=c(0,1)) #跑到图外面去了, why？怎么办?
因为默认情况下图例的中心点位置设在了(0,1)的位置，如果需要更改图例中心点位置，则需使用legend.justification = c(x, y)进行设置，如legend.justification = c(1,0)表示图例中心点在图例的左上角。下面使用legend.justification重新绘制一下图例的位置：
p + theme(legend.position=c(0,1), legend.justification=c(0,1))

legend.justification:
anchor point for positioning legend inside plot ("center" or two-element numeric vector) or the justification according to the plot area when positioned outside the plot.


library(ggplot2) #ggplot 3.2.1
p=ggplot(iris, aes(Sepal.Length, Sepal.Width, color=Species))+
  geom_point(size=0.8)+theme_bw(); p

p +
  theme(
    legend.position = c(0.75, 0.95),
    legend.justification = c(0, 1))
#


(5)
theme(legend.key.height=unit(5, 'line')) #图例元素之间的间距




(6) 修改legend.tittle内容
p+scale_colour_hue("what does it eat?",breaks=c("herbi","carni","omni",NA),labels=c("plants","meat","both","don't know"));


修改尺寸大小
p+theme(legend.background=element_rect(colour="purple",fill="pink",size=3,linetype="dashed"));
p+theme(legend.key.size=unit(2,'cm'));
p+theme(legend.key.width=unit(5,'cm'));
p+theme(legend.text = element_text(colour = 'red', angle = 45, size = 10, hjust = 3, vjust = 3, face = 'bold'))
报错：could not find function "unit"
解决办法：library(grid)


颜色的修改以及一致性：
library(RColorBrewer);
newpalette<-colorRampPalette(brewer.pal(12,"Set3"))(length(unique(eee$name)));
p+scale_fill_manual(values=newpalette);
p+geom_bar(position="stack",aes(order=desc(name)))




ref:
https://github.com/hadley/ggplot2/wiki/Legend-Attributes








========================================
|-- annotate()在图中添加注释文字(比如p值、相关系数等)、图形等
----------------------------------------
ggplot2中的annotate可以在已有图形基础上，添加任意几何对象（如rect,pointrange，text等）。


1.添加文字
(1).添加相关系数
corA=cor.test(xx$A, xx$B, method="pearson")

annotate("text", x=2, y=3, #位置
	hjust = 0, #文字左对齐
	label=paste0("Spearman correlation. \nrho=", #拼接要显示的文字
                  round(corA$estimate,2), '\np=', p.value) )
#


(2). 添加p值，并画线 (请在本页搜索 annotate )
# 计算p值，并保留2位有效数字
p=t.test(arr1, arr2)$p.value;
p=formatC(p, format = "e", digits = 2)

#画线，在线上标记p值
g+geom_segment(aes(x=1, y=155, xend=2, yend=155))+ #横线
  annotate("text", x=1.5, y=160, label=p, size=3) +#annotate函数也可以添加标签
#


(3). 使用 geom_text() 标注文字时，要指定data参数，否则会出现很多文字互相覆盖导致“色彩斑斓的黑”。
原因是没有指定data，则使用已有的data，导致文字多次出现在同一个位置上。





2. 在途中添加图形
学习优秀代码: 不能运行
ggplot(ct1, aes(x=pos, group=Feature, weight=weight))  +
        scale_x_continuous(minor_breaks = seq(0, 5, 1)) + 
        ggtitle("Distribution on mRNA") +
        theme(axis.ticks = element_blank(), axis.text.x = element_blank()) + 
        xlab("") + 
        ylab("Frequency") +
        geom_density(adjust=adjust,aes(fill=factor(Feature),colour=factor(Feature)),alpha=0.2) +
        annotate("text", x = sum(x1[1:2])/2, y = -0.2, label = "5'UTR") +
        annotate("text", x = sum(x1[2:3])/2, y = -0.2, label = "CDS") +
        annotate("text", x = x1[1]/2, y = -0.2, label = "Promoter (1kb)") +
        annotate("text", x = sum(x1[4:5])/2, y = -0.2, label = "Tail (1kb)") +
        annotate("text", x = sum(x1[3:4])/2, y = -0.2, label = "3'UTR")  + 
        geom_vline(xintercept=x1[1:4], linetype="dotted") + 
        annotate("rect", xmin = x1[1], xmax = x1[2], ymin = -0.12, ymax = -0.08, alpha = .99, colour = "black")+
        annotate("rect", xmin = x1[3], xmax = x1[4], ymin = -0.12, ymax = -0.08, alpha = .99, colour = "black")+
        annotate("rect", xmin = x1[2], xmax = x1[3], ymin = -0.16, ymax = -0.04, alpha = .2, colour = "black") +
        xlim(0,1) +
        theme(legend.position="bottom")
上图最底层的长方形就是用annotate制作出来的（代码来自于Guitar包）



(2) 模仿：可运行
library(ggplot2)
head(mtcars)

x1=c( 0.13,0.15,0.20,0.30, 0.35 )*100 #定义基因结构
ggplot(mtcars, aes(x=mpg,y=..density..*3, group=disp, weight=wt)) +
  scale_x_continuous(minor_breaks = seq(0, 5, 1)) +
  geom_density( aes(fill=factor(gear)), color=NA, alpha=0.4 ) + #,colour=factor(carb)
  
  # 添加底部基因结构图
  geom_vline(xintercept=x1[1:4], linetype="dotted") + 
  annotate("rect", xmin = x1[1], xmax = x1[2], ymin = -0.12, ymax = -0.08, alpha = .99, colour = "black")+
  annotate("rect", xmin = x1[3], xmax = x1[4], ymin = -0.12, ymax = -0.08, alpha = .99, colour = "black")+
  annotate("rect", xmin = x1[2], xmax = x1[3], ymin = -0.16, ymax = -0.04, alpha = .2, colour = "black")+
  
  # 添加注释文字
  annotate("text", x = sum(x1[1:2])/2, y = -0.2, label = "5'UTR") +
  annotate("text", x = sum(x1[2:3])/2, y = -0.2, label = "CDS") +
  annotate("text", x = sum(x1[3:4])/2, y = -0.2, label = "3'UTR")  + 
  #
  annotate("text", x = x1[1]/2*1.7, y = -0.15, label = "Promoter \n(1kb)") +
  annotate("text", x = sum(x1[4:5])/2, y = -0.2, label = "Tail (1kb)") +
  
  theme_bw()+
  theme(axis.ticks = element_blank(), axis.text.x = element_blank()) + 
  xlab("") + ylab("Frequency") + ggtitle("Distribution on gene") +
  theme(legend.position="bottom")
#





ref:
annotate(ggplot2): #https://www.cnblogs.com/zhengzh/p/9769111.html






========================================
|-- geom_bar 条形图、旋转坐标轴coord_flip()、极坐标系统 coord_polar()
----------------------------------------
# 抽样
set.seed(100)
keep=sample(1:nrow(diamonds),100)
#
bar <- ggplot(data = diamonds[keep,]) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    #show.legend = FALSE,
    width = 1
  ) + 
  theme_bw()+
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL);bar #条形图
#
bar + coord_flip() #旋转坐标轴，相当于互换x和y轴，变横着的条形图
bar + coord_polar() #极坐标，扇形图






========================================
|-- 共用一个图例
----------------------------------------

plotc <- plot1+plot2+ plot_layout(guides = 'collect')






========================================
添加辅助线: 竖线geom_hline，横线geom_vline，斜线geom_abline
----------------------------------------
1. 添加一条水平线
bp + geom_hline(aes(yintercept=12))


2. linetype 设置线型为 虚线
bp + geom_hline(aes(yintercept=12), colour="#990000", linetype="dashed")


3.倾斜线
g+geom_abline(intercept=2.709e+01,slope=-7.447e-05 )
通过斜率和截距可以添加线性拟合线，至于两个参数的值可以同线性函数lm()获得。


g+geom_vline(aes(xintercept=1.5), colour="#ff0000", linetype="dashed",size=1)+
      xlim(0,10)+ylim(0,10



refer:
https://blog.csdn.net/tanzuozhev/article/details/51112057



========================================
色彩： ggplot2中的颜色(color, fill): RGB, HSV or HCL colour spaces
----------------------------------------
提供色盲人士也可识别的配色方案
https://cran.r-project.org/web/packages/dichromat/

ggplot2颜色设置
https://blog.csdn.net/chang349276/article/details/77476848

#最感兴趣的调色板是 Set1 Dark2
# 对面积而言是 Set2 Pastel1 Pastel2 Accent
RColorBrewer::display.brewer.all() #列出所有的调色板。



1.色彩列表
http://sape.inf.usi.ch/quick-reference/ggplot2/colour
http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/

d=expand.grid(r=seq(0,1,0.1), g=seq(0,1,0.1), b=seq(0,1,0.1))
ggplot() +
	facet_wrap(~b) +
	scale_x_continuous(name="red", breaks=seq(0.05, 1.05, 0.2), labels=seq(0, 1, 0.2)) +
	scale_y_continuous(name="green", breaks=seq(0.05, 1.05, 0.2), labels=seq(0, 1, 0.2)) +
	scale_fill_identity() +
	geom_rect(data=d, mapping=aes(xmin=r, xmax=r+resolution(r), ymin=g, ymax=g+resolution(g), fill=rgb(r,g,b)), color="white", size=0.1)
#





2.连续的颜色：
https://ggplot2.tidyverse.org/reference/scale_gradient.html
# Generate some data
set.seed(133)
df <- data.frame(xval=rnorm(50), yval=rnorm(50))

# Make color depend on yval
ggplot(df, aes(x=xval, y=yval, colour=yval)) + geom_point()

# Use a different gradient
ggplot(df, aes(x=xval, y=yval, colour=yval)) + geom_point() + 
    scale_colour_gradientn(colours=rainbow(4))

#
scale_colour_gradient(..., low = "#132B43", high = "#56B1F7",
  space = "Lab", na.value = "grey50", guide = "colourbar",
  aesthetics = "colour")
#



3.离散的颜色
https://www.cnblogs.com/shaocf/p/9600340.html



========================================
|-- ggplot2 自定义点、线的颜色
----------------------------------------
head(tmp)
#             tSNE_1     tSNE_2 type
#c14ROW27  0.3270342 -15.399062    1
#c16ROW10  0.8202637 -13.007762    1
#c16ROW03 -2.8134028   4.019970    1

ggplot(tmp, aes(tSNE_1, tSNE_2, col=factor(type) ))+geom_point()+
  scale_color_manual(values=c("#F8766D","grey"))
#
  scale_color_manual(values=c("#F8766D","#7CAE00","#00BFC4","#C77CFF",'#000000')) #前几个默认颜色
#







========================================
坐标轴显示范围控制：ylim和coord_cartesian
----------------------------------------
两个结果是不同的

data(diamonds)
p <- ggplot(data = diamonds, aes(x = cut, y = table, color = cut)) + geom_boxplot() 
p
# 截取
p + ylim(c(0,60))


这里是因为ylim是直接处理的数据导致的，比如例子中不在范围的数据就直接被移除。
同等操作应该用coord_cartesian来实现。coord_cartesian指定参数控制图形特定区域放大显示，只影响图形展示，不影响内部数据的值。也就是用原数据作图，再对图形进行变动。



ref:
https://www.jianshu.com/p/312d30049a25


========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

