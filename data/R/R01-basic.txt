R语言基础

防bug大法:
1. 运行R之前一定先执行: > options(stringsAsFactors=FALSE)



程序设计的思想就是：复用==减少重复。
措施就是提取变化，封装不变。
实施方案就是：
	函数化 function
	面向对象化 OOP
	包 scope & environment
#


本文是基础部分，高级部分请参考
- OOP 专题: 函数 scope、environment
- R 原生可视化 专题: 
	表达式、数学公式与特殊符号
- R grid 包 
- R 统计
- R 元编程
#




Rstudio环境配置：
1. Rstudio可以做到R版本的切换选择。
点击Tools->Global options,然后在R generals里选择R versions，就可以切换R版本。
现在免费版没这个功能了，只有付费版有该功能。


2.



《R语言编程艺术》目录
Acknowledgments ........................................xvii
Introduction ...........................................xix
Chapter 1: Getting Started .............................1
Chapter 2: Vectors .....................................25
Chapter 3: Matrices and Arrays..........................59
Chapter 4: Lists........................................85
Chapter 5: Data Frames .................................101
Chapter 6: Factors and Tables ..........................121
Chapter 7: R Programming Structures ....................139
Chapter 8: Doing Math and Simulations in R .............189
Chapter 9: Object-Oriented Programming .................207
Chapter 10: Input/Output ...............................231
Chapter 11: String Manipulation ........................251
Chapter 12: Graphics ...................................261
Chapter 13: Debugging ..................................285
Chapter 14: Performance Enhancement: Speed and Memory ..305
Chapter 15: Interfacing R to Other Languages ...........323
Chapter 16: Parallel R .................................333
Appendix A: Installing R................................353
Appendix B: Installing and Using Packages ..............355




========================================
R语言资源: 从入门到精通
----------------------------------------
1.《R语言快速入门系列教程》
该手册博主编写，实战为主，包含大量生信相关案例。 
未公开发行，购买请发邮件咨询 jimmymall at 163 dot com


全书由本博客直接生成，动态更新。主要知识点如下

运算符
- 加减乘除等运算（计算器）

数据类型
- 常量和变量
- 数据类型（数值，字符，逻辑，因子）: class(F)
- 数据结构（向量，矩阵，数组，数据框，列表）: class(mtcars)

控制结构
- 条件分支
- 循环 
- apply() 家族函数
- dplyr 包的函数式编程

字符串与正则
函数
- 内置函数: 统计
- 自定义函数

文件IO
- 文件读取和写出

可视化
- 原生画图
- ggplot2 包画图
	* https://github.com/jennybc/ggplot2-tutorial


高级 
- OOP
- 变量的作用域
- 环境与命名空间
- C/C++接口
- 写R包
- 日志 log
- 排错 debugging
- 测试 testing




机器学习
- mlr3verse (足以媲美 Python 的 sklearn 的机器学习R包): https://github.com/mlr-org/mlr3
- tidymodels
- [Principles of Machine Learning R](https://github.com/MicrosoftLearning/Principles-of-Machine-Learning-R)


统计:
- 参考[Learning Statistics with R](https://learningstatisticswithr.com/), [github](https://github.com/djnavarro/rbook)





R官方文档： https://cran.r-project.org/manuals.html
R Tutorial：http://www.r-tutor.com/r-introduction/data-frame
R自然科学: https://bstaton1.github.io/au-r-workshop/
R tips: https://github.com/erikaduan/r_tips
R pkg: later: https://github.com/r-lib/later






2.R语言进阶教程
《高级R语言编程指南》, Hadley Wickham, 2016.
第一版 http://adv-r.had.co.nz/
第二版 https://adv-r.hadley.nz/

https://github.com/hadley/adv-r


《R语言编程—基于tidyverse》目录 https://zhuanlan.zhihu.com/p/198185888








3.哈佛大学数据课程 http://tutorials.iq.harvard.edu
https://dss.iq.harvard.edu/blog/resources-learning-r

There are several excellent tutorials not listed on r-project.org. Some of these are listed below.
http://www.statmethods.net/
"Quick-R" aims to get you up and running in R quickly.

http://personality-project.org/r/r.guide.html
Notes on "Using R for psychological research".

http://r4ds.had.co.nz/
"R for Data Science" by R luminary Hadley Wickham. Includes a ggplot tutorial.

http://adv-r.had.co.nz/
Advanced R programming by Hadley Wickham.

http://rmarkdown.rstudio.com/lesson-1.html
A comprehensive RMarkdown tutorial.



https://github.com/RosebudAnwuri/TheArtandScienceofData
The Art and Science of Data



(2) 基础篇

https://github.com/Rabia-Shafiq/R_Programming 





4. 其他视频
https://www.imooc.com/learn/546






5.
HT Sequence Analysis with R and Bioconductor
http://manuals.bioinformatics.ucr.edu/home/ht-seq


Learn about Bioinformatics and Computational Tools for Biology
http://jura.wi.mit.edu/bio/education/







R语言镜像站
https://cran.rstudio.com/bin/windows/contrib/3.4/Cairo_1.5-9.zip
https://mirrors.tuna.tsinghua.edu.cn/bioconductor/packages/3.4/BiocViews.html#___Software
http://mirrors.ustc.edu.cn/bioc/3.4/BiocViews.html#___Software











========================================
运算符
----------------------------------------
1.
求助符：
	?mtcars #查看该数据集mtcats的帮助文档
	help()
	??ggplot2 #如果前两者不行
	find("fun") #得到名为“fun”函数所在的程序包，只在载入的包中找;
	args("fun") #得到名为“fun”函数的自变量列表.
	使用Rstudio时，光标停在函数上，按F1键
			按着ctrl，单击函数名，能打开函数的定义;
系统符号：
	> 命令或运算提示符
	+ 续行符
基本算数运算：
	加 +，	 减-，	乘*，	除/，	乘方^(或者**)，	求余数(取模)%%， x%/%y 整数除法
	57%%7 #1
	57%/%7 #8
赋值：
	= 或 <-
	->
	<<-
	assign(paste0("a",1),100) #a1=100
	get(paste0("a",1)) #100
逻辑运算符
	&&    与（优先计算第一个元素）
	||    或（优先计算第一个元素）

	&    与
	|    或
	!    非

	==   是否相等
	>    大于
	>=   大于等于
	<    小于
	<=    小于等于
三元表达式：类似js中的 a>b?a:b;
	ifelse(a>b, a, b)
数据类型查看
	class()
	str()
输出函数 
	print("str1")
	message("str1", "str2") #str1str2
	cat("str1", "str2", "\n") #str1 str2
字符串连接
	paste("this ", "is a book", sep="") #[1] "this is a book"
#





==> &&和&的有什么差异呢？
(1)
x | y	element-wise OR
x || y	Logical OR
x & y	element-wise AND
x && y	Logical AND

> c(0,1,2) & c(1,1,1) #逐个元素的比较
[1] FALSE  TRUE  TRUE
> c(0,1,2) && c(1,1,1) #只比较第一个元素
[1] FALSE

(2) 使用2个有优先性，在if中可以节省判断第二个的时间; 而在which()只能使用&。
a=1;if(4<3 & (a=a-1) ){print("No")};a #0
a=1;if(4<3 && (a=a-1) ){print("No")};a #1 计算第一个元素，false了就不在继续
#
a=1;if(4>3 | (a=a-1) ){print("Yes")};a # Yes, 0
a=1;if(4>3 || (a=a-1) ){print("Yes")};a # Yes, 1 #计算第一个元素，true了就不在继续
#





2.运算符“逻辑与”和“逻辑或”存在两种形式：
“&”和“|”作用在对象中的每一个元素上并且返回和比较次数相等长度的逻辑值；
“&&”和“||”只作用在对象的第一个元素上.

a1=c(1,2,3)
a2=c(0,-2,6)
a1 && a2 #[1] FALSE
a1 & a2 #[1] FALSE  TRUE  TRUE







3. 赋值运算符 = 和 <- 的区别

大多数时候一样。
个人建议使用 =，优先使用更通用的符号，特别是效果一样的时候。

下面记录不一样的特例:

(1) 计算程序运行时间

system.time(expr1 <- rnorm(10e5))
system.time(expr2 = rnorm(10e5)) # error


(2) 元编程 expression() 函数中的表达式
注意看参数1中的赋值符号。
> x=1; eval(expression(x<-2, x>1))  #这里使用<-会修改全局变量的值，而使用=则不会
[1] TRUE
> x
[1] 2

> x=1; eval(expression(x=2, x>1)) #使用=则不修改全局变量的值
[1] FALSE
> x
[1] 1






========================================
|-- 显示输出函数: print(), sprintf(), cat(), warning(), stop()
----------------------------------------
1. 数字输出

(1) 每三位逗号分割
https://stackoverflow.com/questions/29242011/add-comma-to-numbers-every-three-digits-in-datatable-r
library(scales)
comma_format()(1234567890) #"1,234,567,890"

(2) 小数位数
> x=0.12345
> round(x, 2)
[1] 0.12

> format(x, digits = 2) #输出是字符串
[1] "0.12"




2. 普通打印输出
> print("hello")
[1] "hello"

> warning("hi", "hello", "Tom") #没有空格
Warning message:
hihelloTom 

> cat('hi', 'world', '\n')  #有空格，没有末尾换行
hi world 


> stop("hi", "hello", " Tom")  #运行后直接退出
Error: hihello Tom



3. 格式化打印
> sprintf("this is a %s, num=%d", "cat", 100)
[1] "this is a cat, num=100"







========================================
|-- 集合运算：交集intersect、并集union、找不同setdiff、判断相同setequal
----------------------------------------
在R语言进行数据分析时，经常需要找不同组间的相同和不同，那你应该掌握如下几个函数，让你事半功倍。


1. 子交并集

tips: 输出顺序时优先按照第一个参数中的顺序


(1) 交集intersect
两个向量的交集，集合可以是数字、字符串等

# 两个数值向量取交集
intersect(x=1:4, y = 2:6)
# [1] 2 3 4

# 两个字符向量取交集
intersect(x=letters[1:4], y = letters[2:6])
# [1] "b" "c" "d"

# 混合向量
intersect(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "4"



注意：取交集的输出，是按照元素在intersect第一个参数中出现的顺序输出的。
a1=c(10,5,4,3,2,100)
a2=c(-1,2,100,5)
intersect(a1, a2) #[1]   5   2 100
intersect(a2, a1) #[1]   2 100   5




(2) 并集union
求两个向量的并集，集合可以是任何数值类型

# 两个数值向量取并集
union(x=1:4, y = 2:6)
# [1] 1 2 3 4 5 6

# 两个字符向量取并集
union(x=letters[1:4], y = letters[2:6])
# [1] "a" "b" "c" "d" "e" "f"

# 混合向量
union(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "b" "c" "4" "2" "3"




(3) 找不同setdiff
求向量x与向量y中不同的元素(只取x中不同的元素) ，相当于是差集x-y

x = 1:4
y = 2:6
# 找x中不同于y的元素
setdiff(x, y)
# [1] 1
# 找y中不同于x的元素
setdiff(y, x)
# [1] 5 6




(4) 判断相同setequal
x = 1:4
y = 2:6
# 判断x与y是否相同，结果为假
setequal(x, y)
# [1] FALSE
# 找y与x是否相同，结果为假
setequal(y, x)
# [1] FALSE

# 只有完全相同的才返回TRUE
y = 1:4
setequal(x, y)
# [1] TRUE

setequal(c(1,2,3),c("1","2","3")) #[1] TRUE







2. 集合常见问题
(1)
# 2个集合，一个比另一个少了哪些?
set1=c('a', 'b','c','d')
set2=c('a', 'c','d')
#
for(tmp in set1){
  if(! (tmp %in% set2) ){
    print(tmp)
  }
}
# [1] "b"


精简版: setdiff(set1,set2) #[1] "b"



(2)







ref:
https://blog.csdn.net/woodcorpse/article/details/80494605








========================================
*** 数据结构，及其查看 ***
----------------------------------------
基本数据类型(4种)：数值（numeric）、字符（character）、逻辑值（logical）、复数型（complex）。
还有其他类型，如函数型、表达式、数据库连接等，但是一般不表示数据；
	由基本数据类型构成对象，对象包括向量、列表、矩阵、数组、数据框、时间序列等；
	- 向量是基础;

1.数据类型、结构、细节的查看 
str()
length() #只有一维的，获得长度
dim() #多维度的，获得维度

mode()
class()
attributes()
typeof()
names(mtcars) #返回mtcars中11个变量名；如果是list则返回其包含的变量名。就是$后面会出现的内容。

head(mtcars) 预览前几行
tail() 预览后几行

无论什么类型的数据，缺失数据总是用NA(Not Available的意思)来表示; 
R可以正确地表示无穷的数值，如用Inf和-Inf表示正负无穷大；
或者用NaN(Not a Number 的意思)表示不是数字的值.


变量是否存在
exists("tt") #注意：要查询的变量名必须加引号




2.数据类型的判断与转换
x="1"
is.character("1") #TRUE
is.numeric("1") #FALSE
is.logical(x)
is.complex(x) 

#转换类型
is.numeric(as.numeric("1")) #[1] TRUE

向量是否相等
all.equal(c(1,2),c(1,2)) #[1] TRUE
identical(c(1,2),c(1,2)) #[1] TRUE #精确相等




3.查看对象、删除对象
ls() #显示内存中的对象名字
ls(pat="m") #pattern(缩写为pat)实现只显示带有某个指定字符的对象名字
ls(pat="^m") #显示以m开头的对象名
ls(pattern = "^acc") #显示以acc开头的对象
ls.str( ) #显示内存中所有对象的详细信息

rm(x) #删除内存中的对象x
rm(x,y) #删除内存中的对象x和y
rm(list=ls()) #删除内存中的所有对象
rm(list=ls(pat="^m")) #删除对象中以字母m开头的对象

	# 模式匹配变量名
	> ls(pattern = "^H_*")
	 [1] "H_AACGGGTT" "H_AAGAAGGA" "H_AATAGGTC" "H_ACGGTGCA" "H_CACGGCCT" "H_CAGCGCTT" "H_GCCCATCC" "H_TAGAGGAG" "H_TCCCTCCG"
	[10] "H_TGGAGATG"

	# 删除变量
	> rm(list= ls( pattern = "^H_*"))



4. 复合类型的数据

对象的类是对象的属性之一。对于简单的对象而言，其类和类型是有紧密联系的。
然而，对于复合型对象，两者则可能不同（最常见的是数据框，你创建一个然后用class与typeof函数看看就知道了）。

> typeof(mtcars)
[1] "list"
> class(mtcars)
[1] "data.frame"








========================================
1. 数据类型：向量vector、因子factor
----------------------------------------
4.向量的建立
(1)常规示例
1) seq( )或“:” # 若向量(序列)具有较为简单的规律
	1:3 #1 2 3
	1:3+2 #3 4 5
	1:(3+2) # 1 2 3 4 5
	seq(1,10,by=2) #1 3 5 7 9 
	seq(1,2,length=5) #[1] 1.00 1.25 1.50 1.75 2.00 # 等价于seq(1,2,length.out=5)
	
	sequence(2:4) #[1] 1 2 1 2 3 1 2 3 4
	
2) rep( ) # 若向量(序列)具有较为复杂的规律
	rep(1:3,2) #1 2 3 1 2 3 #等价于 rep(1:3, times=2)
	rep(1:3,rep(1:3)) # 1 2 2 3 3 3
	rep(1:3, times = 2, each = 2) #1 1 2 2 3 3 1 1 2 2 3 3
	
3) c( ) # 若向量(序列)没有什么规律
	z <- x<-c(42,7)
	z # 42  7
	x # 42  7

4) scan( ) # 通过键盘逐个输入



############
# 向量的增删改查
############
arr=c("X","A", "B","C","D","Apple")
1)arr[-2] #删除第二个元素，就是"B"

2)删除某个值，比如"D"
index=grep( paste0("^D$"), arr)
arr2=arr[-index]
arr2 #[1] "X"     "A"     "B"     "C"     "Apple"

3)新增元素
arr3=c(arr, "Z") #末尾新增Z
arr4=c('0', arr) #开头新增0

4)查找某个值的位置，比如查找D的位置:
grep( paste0("^D$"), arr)
查不到则返回integer(0);






(2)因子型向量的建立
一个因子或因子向量不仅包括分类变量本身, 还包括变量不同的可能水平(即使它们在数据中不出现). 因子利用函数factor( )创建.
factor(x, levels = sort(unique(x), na.last = TRUE),labels = levels, exclude = NA, ordered = is.ordered(x))
参数说明：
	levels用来指定因子的水平（缺省值是向量x中不同的值；如果x中有levels中没有指定的值，则x中该值会被记作NA）；
	labels用来指定水平的名字（并显示出来）；
	exclude表示从向量x中剔除的水平值；
	ordered是一个逻辑型选项，用来指定银子的水平是否是有次序。
	这里x可以是数值型或字符型，这样对应的因子也就称为数值型因子或字符型因子。因此，因子的建立可以通过字符型向量或数值型向量来建立，且可以转化。
#


1).将字符型向量转换成因子
a=c("green", "blue", "green","yellow")
a1=factor(a)
a1 #或使用 str(a1) 或 attributes(a1)查看因子顺序
## [1] green  blue   green  yellow
## Levels: blue green yellow


因子默认是按照字母顺序排序的，这个实际情况很可能不一致。可以使用levels选项人为指定顺序。

#使用levels选项人为指定顺序
a2=factor(a, levels=c("green", "blue","yellow"))
a2
##[1] green  blue   green  yellow
##Levels: green blue yellow


# 把普通列变为 factor 列
data.plot$id <- factor(x = data.plot$id, levels = id.levels)






2).将数值型向量转换成因子
b=c(1,2,3,1)
b1=factor(b)
b1
#[1] 1 2 3 1
#Levels: 1 2 3


为了对人类更友好，可以用labels为数值型贴上标签。此后显示的时候按标签设置显示：
> gender=factor(b, levels=c(1,2,3), labels=c("M","F","U") )
> gender
[1] M F U M
Levels: M F U # 男、女、不清楚。






3).将字符型因子转换为数值型因子
a2=a1;a2
## [1] green  blue   green  yellow
## Levels: blue green yellow

levels(a2)=c(1,2,3,4)
a2
## [1] 2 1 2 3 ## 因子4没有出现过
## Levels: 1 2 3 4

ff=factor(c("A","B","C"), labels=c(1,2,3));ff
## [1] 1 2 3
## Levels: 1 2 3




4).将数值型因子转换为字符型因子
b2=b1;b2  ## Levels: 1 2 3
levels(b2)=c("low","middle","high");b2  #Levels: low middle high

ff=factor(1:3, labels=c("A","B","C"));ff  #Levels: A B C

#注: 函数levels( )用来提取一个因子中可能的水平值
ff <- factor(c(2, 4), levels=2:5); ff
levels(ff)  #[1] "2" "3" "4" "5"




5).函数gl()能产生规则的因子序列. gl(k,n)，其中k是水平数, n是每个水平重复的次数. 
# 此函数有两个选项：length指定产生数据的个数, label指定每个水平因子的名字.
gl(3,5)
gl(3,5,length=30)
gl(2,6,label=c("Male","Female"))
#[1] Male   Male   Male   Male   Male   Male   Female Female Female Female Female Female
#Levels: Male Female




6)因子转为数字

把数据框中的因子变为数值: 把X000001.SH转变成数值类型，可以试试

先构建因子
DATA=data.frame(
	id=c(1,2,3,4,5),
	X000001.SH=c(1,2,1,1,2)
)
> DATA$X000001.SH=factor(DATA$X000001.SH)
> DATA$X000001.SH
## [1] 1 2 1 1 2
## Levels: 1 2
上述是因子。如何转为数值呢？

因子转数字1：
> rs=as.numeric(levels(DATA$X000001.SH))[DATA$X000001.SH];rs
## [1] 1 2 1 1 2
> str(rs)
## num [1:5] 1 2 1 1 2


因子转数字2：简单一行也能搞定。
> as.numeric(DATA$X000001.SH)
## [1] 1 2 1 1 2












(3)向量的截取，构建逻辑值截取。
x=10:50
x>45
x[x>45]
x[x %in% 1:15] #求交集 [1] 10 11 12 13 14 15

#按照某一列筛选
x=data.frame(
  a=c(1,2,3,4),
  b=c('a','b','c','d')
)

x[which(x$a>2),] #逻辑判断
#  a b
#3 3 c
#4 4 d

x$a %in% c(2,4,100) #在某个范围，返回逻辑值
x[x$a %in% c(2,4,100),] #
#  a b
#2 2 b
#4 4 d





========================================
|-- 检查 vector 是否有重复，并去重
----------------------------------------
> genelist[duplicated(genelist)]

如果有重复
genelist_new<-unique(genelist)  #去除重复




========================================
|-- 获得元素在数组中的位置, 把一个(cell_type)字符串映射成另一个(color)字符串
----------------------------------------
#(1) find the index of a string in a array;
indexOf=function(value, arr){
    i=0
    for(item in arr){
        i=i+1
        if(value==item){
            return(i)
        }
    }
    return(-1)
}
indexOf('CD14+ Mono', c('B',   'CD14+ Mono',        'CD8 T')) # 2






#(2) get color list from cell type list
mapReplace=function(arr, mapList=NULL){
    if(is.null(mapList)){
        print('Get default color as no color input.')
        uniqItem=unique(arr);
        mapColorArr=rainbow(length(uniqItem)*1.2)
        for(i in 1:length(uniqItem) ){
            item=uniqItem[i]
            mapList[[item]]=mapColorArr[i]
        }
    }
    # map color from string;
    arrN=arr;
    for(key in names(mapList) ){
        value=mapList[[key]]
        arrN[which(arr==key)]=value
    }
    return(arrN)
}

colorDict=list(
    'B'=rainbow(20)[1],
    'CD14+ Mono'=rainbow(20)[2],
    'CD8 T'=rainbow(20)[3],
    'DC'=rainbow(20)[4],
    'FCGR3A+ Mono'=rainbow(20)[5],
    'Memory CD4 T'=rainbow(20)[6],
    'Naive CD4 T'=rainbow(20)[7],
    'NK'=rainbow(20)[8],
    'Platelet'=rainbow(20)[9]
)

mapReplace(pDat$celltype, colorDict)
#mapReplace(pDat$celltype)






========================================
|-- 因子(factor)转换成数值型(numeric)的规则与陷阱
----------------------------------------
1. 陷阱实例

> # R语言中因子(factor)转换成数值型(numeric)的问题
> w1=c(1,1,0,0,1)
> w2=as.factor(w1); w2
[1] 1 1 0 0 1
Levels: 0 1
> as.numeric(w2) #神奇的事情发生了，竟然不是0和1：因子 转 数字 的陷阱
[1] 2 2 1 1 2

> as.numeric( as.factor( c(1,9,1) ) ) #再测试一个，竟然没有9
[1] 1 2 1






2. 陷阱解析

# 因子(factor)转换成数值型(numeric)的规则是这样的：
# 一共有n个数，那么转换后的数字就会在1——n中取值，数字最小的取一，次小的取二，以此类推。
# 那么如何让因子(factor)类型里的数值转换对应的数值型呢？
# method 1.  as.numeric(as.character(factorname))
# method 2.  as.numeric(levels(factorname)[factorname])

> w2
[1] 1 1 0 0 1
Levels: 0 1

方法1
> as.numeric( as.character(w2))
[1] 1 1 0 0 1

方法2
> levels(w2)
[1] "0" "1"
> as.numeric(levels(w2)[w2])
[1] 1 1 0 0 1













========================================
2.数据类型：矩阵 matrix，稀疏矩阵与 Matrix 包
----------------------------------------
1.矩阵常用的函数
转置 t()
提取对角线元素 diag()
矩阵按行合并 rbind()，按列合并 cbind()

a2=matrix(1:6,2,3);a2
a2*a2 #矩阵的逐元乘积
a2 %*% t(a2) #矩阵的代数乘积


(1) 矩阵的定义
Seurat::AverageExpression 函数中：
category.matrix <- matrix(data = 1, nrow = ncol(x = object), 
      dimnames = list(Cells(x = object), "all"))

参数解释:
1) nrow 指定行数

> matrix(1:6, nrow=3)
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
> matrix(1:6, nrow=2)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

2) 默认按列填充 byrow=F
> matrix(1:6, nrow=2, byrow = T)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6


3) dimnames=list(行名，列名) 定义行名和列名
> matrix(1:6, nrow=2, byrow = T, dimnames = list(c('a1', 'a2'),  paste0("rep", 1:3)))
   rep1 rep2 rep3
a1    1    2    3
a2    4    5    6





(2) 高阶函数 apply, scale, sweep
m<-matrix(1:12, nrow=3); m
apply(m, MARGIN=1, FUN=mean) # 求各行的均值
apply(m, MARGIN=2, FUN=mean) # 求各列的均值
scale(m, center=T, scale=T) #标准化

# 所谓中心化就是将数据减去均值后得到的，比如有一组数据(1,2,3,4,5,6,7)，它的均值是4，中心化后的数据为(-3，-2，-1，0，1，2，3)
# 而标准化则是在中心化后的数据基础上再除以数据的标准差
# 在R语言中可以通过scale函数直接进行数据的中心化和标准化：Scale(x,center,scale)
# 参数解释：x—即需要标准化的数据
#   center—表示是否进行中心化
#   scale—表示是否进行标准化
c1=c(1,2,3,4,5,6,7)
t( scale(c1,scale=F) ) #仅中心化 -3 -2 -1 0 1 2 3
c1.sd=sd(c1) #标准差
scale(c1,scale=F)/c1.sd == scale(c1)


#sweep(X, MARGIN, STATS, FUN) #表示从矩阵X中按MATGIN计算STATS，并从X中除去(sweep out).
#减去中位数:
m
#     [,1] [,2] [,3] [,4]
#[1,]    1    4    7   10
#[2,]    2    5    8   11
#[3,]    3    6    9   12

row.med <- apply(m, MARGIN=1, FUN=median); row.med
sweep(m, MARGIN=1, STATS=row.med, FUN='-') #
sweep(m, MARGIN=1, STATS=1:3, FUN='+') #按行分别加上1 2 3
#     [,1] [,2] [,3] [,4]
#[1,]    2    5    8   11
#[2,]    4    7   10   13
#[3,]    6    9   12   15











2. 稀疏矩阵

(1) 构建稀疏矩阵 Matrix::sparseMatrix

使用三列：行、列、值，表示矩阵的方式。适合表示大片为0的矩阵。

> c(1,3:8)
[1] 1 3 4 5 6 7 8
> c(2,9,6:10)
[1]  2  9  6  7  8  9 10

> 7 * (1:7)
[1]  7 14 21 28 35 42 49

> Matrix::sparseMatrix(i=c(1,3:8), j=c(2,9,6:10), x = 7 * (1:7) )
8 x 10 sparse Matrix of class "dgCMatrix"
                             
[1,] . 7 . . .  .  .  .  .  .
[2,] . . . . .  .  .  .  .  .
[3,] . . . . .  .  .  . 14  .
[4,] . . . . . 21  .  .  .  .
[5,] . . . . .  . 28  .  .  .
[6,] . . . . .  .  . 35  .  .
[7,] . . . . .  .  .  . 42  .
[8,] . . . . .  .  .  .  . 49




(2) sparse.model.matrix 构建稀疏矩阵，求 单细胞的 cluster 表达水平均值

Seurat::AverageExpression 函数中：
category.matrix <- sparse.model.matrix(object = as.formula(object = paste0("~0+", 
      paste0("data[,", 1:length(x = group.by), "]", collapse = ":") )) )


解析：
> t1=data.frame(ident=c(1,2,2,3,3,3)); t1
  ident
1     1
2     2
3     2
4     3
5     3
6     3

> paste0("data[,", 1:length(x = 'ident'), "]", collapse = ":")
[1] "data[,1]"

> paste0("t1[,", 1:length(x = 'ident'), "]", collapse = ":")
[1] "t1[,1]"

> paste0("~0+", paste0("t1[,", 1:length(x = 'ident'), "]", collapse = ":") )
[1] "~0+t1[,1]"

> as.formula( paste0("~0+", paste0("t1[,", 1:length(x = 'ident'), "]", collapse = ":") ) )
~0 + t1[, 1]


> Matrix::sparse.model.matrix(object=as.formula("~0+t1[,1]") )
6 x 1 sparse Matrix of class "dgCMatrix"
  t1[, 1]
1       1
2       2
3       2
4       3
5       3
6       3
> t1$ident=as.factor(t1$ident)
> t2=Matrix::sparse.model.matrix(object=as.formula("~0+t1[,1]") )
> t2
6 x 3 sparse Matrix of class "dgCMatrix"
  t1[, 1]1 t1[, 1]2 t1[, 1]3
1        1        .        .
2        .        1        .
3        .        1        .
4        .        .        1
5        .        .        1
6        .        .        1


(2) 每列归一化到1
> Seurat:::Sweep(x = t2, MARGIN = 2, STATS = colSums(x = t2), FUN = "/")
6 x 3 sparse Matrix of class "dgCMatrix"
  t1[, 1]1 t1[, 1]2  t1[, 1]3
1        1      .   .        
2        .      0.5 .        
3        .      0.5 .        
4        .      .   0.3333333
5        .      .   0.3333333
6        .      .   0.3333333


如果手动，就不是稀疏矩阵了
> apply(t2, 2, function(x){x/sum(x)})
  t1[, 1]1 t1[, 1]2  t1[, 1]3
1        1      0.0 0.0000000
2        0      0.5 0.0000000
3        0      0.5 0.0000000
4        0      0.0 0.3333333
5        0      0.0 0.3333333
6        0      0.0 0.3333333


查看原包，就是引用了 sweep 函数，能保持稀疏矩阵
> sweep(x = t2, MARGIN = 2, STATS = colSums(x = t2), FUN = "/")
6 x 3 sparse Matrix of class "dgCMatrix"
  t1[, 1]1 t1[, 1]2  t1[, 1]3
1        1      .   .        
2        .      0.5 .        
3        .      0.5 .        
4        .      .   0.3333333
5        .      .   0.3333333
6        .      .   0.3333333









========================================
3.数据类型：数据框data.frame
----------------------------------------
(5)数据框操作
head(Puromycin)
str(Puromycin)
dim(Puromycin)

#变量之间的关系可以通过成对数据散点图考查
pairs(Puromycin, panel = panel.smooth)

#使用xtabs( )函数由交叉分类因子产生一个列联表:
xtabs(~state + conc, data = Puromycin)
xtabs(~state, data = Puromycin)

#取子集
subset(Puromycin, state == "treated" & rate > 160)
subset(Puromycin, conc > mean(conc))


#添加新列的三种方法。iconc=1/conc
a=head(Puromycin);a
#方法1
a$iconc=1/a$conc;a
#方法2：使用with
a$iconc=with(a,1/conc);a
#方法3：用transform( )函数, 且可一次性定义多个变量
a=transform(a, iconc=1/conc, sqrtconc=sqrt(conc));a






========================================
4.数据类型：列表list，R中的复杂数据类型
----------------------------------------
list可以保存各种数据类型。
list可以模拟键值对存储模式，只是速度跟不上。
函数可以通过返回list，实现实质上返回多个值。
apply 家族函数中有几个专门处理list的。


1. 创建list
(1) 只有值的列表
> list1=list(1:3, letters[1:5])
> list1
[[1]]
[1] 1 2 3

[[2]]
[1] "a" "b" "c" "d" "e"

(2) 给列表命名
> list1a=list1
> names(list1a)=c("name1", "name2");
> list1a
$name1
[1] 1 2 3

$name2
[1] "a" "b" "c" "d" "e"


(3) 直接创建带名字的list
键值对形式。
> list2=list(id1=1:3, id2=letters[1:5])
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"





2. 获取列表中的值
(1) 使用名字索引，使用[[]]或者$
获取列表名字
> names(list2)
[1] "id1" "id2"

获取该名字对应的值
> list2[['id1']]
[1] 1 2 3

使用$获取
> list2$id2
[1] "a" "b" "c" "d" "e"


访问不存在的键
> list2[['id3']]
NULL

> list2$id3
NULL




(2) 通过下标索引
> list2[[1]] #返回的是向量，不是list。
[1] 1 2 3

使用下标访问不存在的下标则会报错，所以优先使用键获取值。
> list2[[3]]
Error in list2[[3]] : subscript out of bounds


如果使用一层[]获取，则返回的是一个元素的list
> list2[1]
$id1
[1] 1 2 3

> class(list2[1])
[1] "list"

> length(list2)
[1] 3
> length(list2[1])
[1] 1




(3) 获取某个键下某个位置的值
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"

> list2[['id2']][3]
[1] "c"

访问不存在的下标，则返回NA。
> list2[['id2']][10]
[1] NA




3. 添加新的键值
> list2[["day"]]="good"
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"

$day
[1] "good"




4. 修改值 
> list2[['day']]='bad'
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"

$day
[1] "bad"




5. 删除值
> list2$day=NULL
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"




6. 合并列表
l2=list(x=1, y=2)
l3=list(a=100, b=200, c=300)
list4=c(l2, l3)
> list4
$x
[1] 1

$y
[1] 2

$a
[1] 100

$b
[1] 200

$c
[1] 300




7. 转换list为向量
> list2
$id1
[1] 1 2 3

$id2
[1] "a" "b" "c" "d" "e"

> unlist(list2)
id11 id12 id13 id21 id22 id23 id24 id25 
 "1"  "2"  "3"  "a"  "b"  "c"  "d"  "e" 

结果为一个 named vector.
> class(unlist(list2))
[1] "character"

> str(unlist(list2))
 Named chr [1:8] "1" "2" "3" "a" "b" "c" "d" "e"
 - attr(*, "names")= chr [1:8] "id11" "id12" "id13" "id21" ...








ref:
https://blog.csdn.net/sinat_26917383/article/details/51123214






========================================
|-- 尝试R中的(模拟)字典 数据类型: 键值对
----------------------------------------
字典有一个非常重要的作用，就是实现映射。
字典，就是一个键值对映射。


Lists are the only key-value mapping type provided in base R: there are no dictionaries or associative arrays.
list是R语言中包容性最强的数据对象，几乎可以容乃所有的其他数据类型。
我们可以在一个列表中储存不同的类型数据，还可以储存不同的长度数据，每一个插槽中都是一个向量（vector）。
但是基于list的hash效率很低。

更高效的是使用 environment 来定义key是字符串的hash变量。其中hash包和hashmap包就是这么做的，但是...
我们先尝试原生R的实现，最后再试试各种R包。




1. R 模拟字典: 命名向量 named vector 

# 命名向量
obj=c('apple'=10, 'banana'=6, 'orange'=3)
obj

# 获取值
obj[['apple']] #10

# 修改值
obj[['apple']]=150
obj[['apple']] #150

# 添加新的键值对
obj[['peach']]=5
obj

# 获取全部键
names(obj) #"apple"  "banana" "orange" "peach" 

# 获取全部值
unname(obj) #150   6   3   5

# 删除一个键
> obj = obj[which(names(obj) !='apple' )]; obj
banana orange  peach 
     6      3      5 









2. data.frame的行列用字符串索引就类似于字典了

df1=data.frame(
  row.names = c("apple", 'banana', 'orange'),
  value=c(20, 6, 3)
)
df1

# 获取值
df1['apple',] #20

# 修改值
df1['apple',]=150
df1['apple',] #150

#添加新的键值对
df1['peach', ]=5
df1

# 获取全部键
rownames(df1) #[1] "apple"  "banana" "orange" "peach" 

#获取全部值
df1$value #[1] 150   6   3   5

# 删除某一个键 //todo 暂时不知道怎么做
df1=df1[which(rownames(df1)!='peach'),, drop=F]
df1









3. Environments as hash maps 使用环境作为(键值对)字典
https://riptutorial.com/r/example/18339/environments-as-hash-maps

(1) 创建
H <- new.env() #等价于 H <- new.env(hash = TRUE) 

object.size(new.env())
# 56 bytes

object.size(new.env(size = 10e4))
# 56 bytes 



(2) 插入值：使用 [[<- or $<- 而不能使用 [<-。
(object[[key]] <- value) is generally preferred to the second (object$key <- value)，因为第一种方法允许key是变量。

H[["key"]] <- rnorm(1)

key2 <- "xyz"
H[[key2]] <- data.frame(x = 1:3, y = letters[1:3])

H$another_key <- matrix(rbinom(9, 1, 0.5) > 0, nrow = 3)

H["error"] <- 42
#Error in H["error"] <- 42 : 
#  object of type 'environment' is not subsettable 


# 同一个key会覆盖掉旧的
H[["key3"]] <- "original value"
H[["key3"]] <- "new value"
H[["key3"]]
#[1] "new value"


(3) 根据键查找值： [[ or $, but not with [。
H[["key"]]
#[1] 1.630631
 
H[[key2]]   ## assuming key2 <- "xyz"
#   x y
# 1 1 a
# 2 2 b
# 3 3 c

H$another_key
#       [,1]  [,2]  [,3]
# [1,]  TRUE  TRUE  TRUE
# [2,] FALSE FALSE FALSE
# [3,]  TRUE  TRUE  TRUE

H[1]
#Error in H[1] : object of type 'environment' is not subsettable


(4) 查看所有的key
names(H)
#[1] "another_key" "xyz"         "key"         "key3"       

ls(H)
#[1] "another_key" "key"         "key3"        "xyz"        
 
str(H)
#<environment: 0x7828228> 
 
ls.str(H)
# another_key :  logi [1:3, 1:3] TRUE FALSE TRUE TRUE FALSE TRUE ...
# key :  num 1.63
# key3 :  chr "new value"
# xyz : 'data.frame':    3 obs. of  2 variables:
#  $ x: int  1 2 3
#  $ y: chr  "a" "b" "c"



(5) 删除 Elements can be removed using rm:
rm(list = c("key", "key3"), envir = H)

ls.str(H)
# another_key :  logi [1:3, 1:3] TRUE FALSE TRUE TRUE FALSE TRUE ...
# xyz : 'data.frame':    3 obs. of  2 variables:
#  $ x: int  1 2 3
#  $ y: chr  "a" "b" "c"


(6) 好处 Flexibility
使用 environment 对象能保存几乎所有R数据类型，包括另一个 environment 对象。

H2 <- new.env()

H2[["a"]] <- LETTERS
H2[["b"]] <- as.list(x = 1:5, y = matrix(rnorm(10), 2))
H2[["c"]] <- head(mtcars, 3)
H2[["d"]] <- Sys.Date()
H2[["e"]] <- Sys.time()
H2[["f"]] <- (function() {
    H3 <- new.env()
    for (i in seq_along(names(H2))) {
        H3[[names(H2)[i]]] <- H2[[names(H2)[i]]]
    }
    H3
})()

ls.str(H2)
ls.str(H2$f)


(7) Limitations 限制
One of the major limitations of using environment objects as hash maps is that, unlike many aspects of R, vectorization is not supported for element lookup / insertion:
不支持查找和插入向量key。

names(H2)
#[1] "a" "b" "c" "d" "e" "f"

H2[[c("a", "b")]]
#Error in H2[[c("a", "b")]] : 
#  wrong arguments for subsetting an environment
 
Keys <- c("a", "b")
H2[[Keys]]
#Error in H2[[Keys]] : wrong arguments for subsetting an environment


(8) 使用 vapply or list2env 不简洁

Depending on the nature of the data being stored in the object, it may be possible to use vapply or list2env for assigning many elements at once:


E1 <- new.env()
invisible({
    vapply(letters, function(x) {
        E1[[x]] <- rnorm(1)
        logical(0)
    }, FUN.VALUE = logical(0))
})

all.equal(sort(names(E1)), letters)
#[1] TRUE

Keys <- letters
E2 <- list2env(
    setNames(
        as.list(rnorm(26)),
        nm = Keys), 
    envir = NULL,
    hash = TRUE
)

all.equal(sort(names(E2)), letters)
#[1] TRUE

Neither of the above are particularly concise, but may be preferable to using a for loop, etc. when the number of key-value pairs is large.













100. 探索尝试 list 能否保存长度不同的数据类型?可以。
list完全可以作为R中的hash结构来使用(太低效??)//等待验证

#创建
#初始化一个list
mydict1=list(a=c(1,2,3),h=c(0))
class(mydict1)

#后文每一步都需要检查效果，后文每句后面都省略该命令
#1.直接查看，或者2.用str查看list的数据结构
mydict1 
str(mydict1)


#拼接一个字符串作为key，并赋值和引用
mydict1[[paste0('c',1)]]=data.frame(a=c(1,2,3), b=c(10,20,30))
mydict1[[paste0('c',1)]] #引用

#增加一个key并赋值，在末尾
mydict1[['c']]=100

#修改：重新对value赋值
mydict1[['a']]=c(12,34)

#修改：在向量value中插入新元素
mydict1[["h"]]=c(mydict1[["h"]], 15)

#修改：#对这个key的value进行自增
mydict1[['c']]=mydict1[['c']]+2

#获得键列表
names(mydict1) 

#检测是否有某个键，可以用于hash的自增
key="c2"
key="c1"
if(key %in% names(mydict1)){
  print(mydict1[[key]])
}else{
  print("Not in")
}

#删除某个key
mydict1[["a"]]=NULL #好吧，a的键值对都被删除了


#可以用数字直接查找，说明是有序的，不是真正的hash结构
mydict1[[2]] 















#######
尝试 R 包中的hash结构：hash包和hashmap包都报错
install.packages("hashmap")
library("hashmap")
help(hashmap)
#
mydict = hashmap( keys=c(1,2,3),values=c(10,20,30) )
#Error in (function (env, objName)  : 
#  argument to 'findVar' is not an environment
mydict[["a"]]
# 也找不到解决办法。。。










refer:
1.R's Lists and its Detestable Dearth of Data-Structures
https://www.refsmmat.com/posts/2016-09-12-r-lists.html

2.Environments
http://adv-r.had.co.nz/Environments.html





========================================
5.数据类型：类 class
----------------------------------------

具体见 R OOP。










========================================
6.特殊的R变量: 表达式(formula)
----------------------------------------
summary(aov(mpg~cyl*disp, mtcars))

等价于:
a="disp"; (f <- as.formula(paste("mpg ~ cyl*", a )))
class(f)
summary(aov(f, mtcars))




ref: https://site.douban.com/widget/notes/10567181/note/318916395/





========================================
7.动态变量名：R中拼接成的字符串做变量名，并赋值
----------------------------------------

> assign( paste0("cell",1),100)
> cell1
[1] 100


#但是怎么引用呢？
> eval( 'a=paste0("cell",1)' ) #失败
[1] "a=paste0(\"cell\",1)"

> eval( parse(text='a=paste0("cell",1)' )) #失败
> a
[1] "cell1"


> get("cell1")
[1] 100 #成功
> get( paste0("cell", 1) )
[1] 100





========================================
8.使用 structure 构建数据类型，能保存数据结构函数是dput()
----------------------------------------
踏破铁鞋无觅处，得来还是得多看书。


1. structure 定义结构
structure returns the given object with further attributes set.

attributes(x)
attributes(x) <- value


(1) 默认是定义矩阵
a1=structure(1:6, dim = 2:3)
a1
class(a1) #[1] "matrix"


(2) 还可以定义数据框
df <- structure(
  list(
    V1 = c(56, 123, 546, 26, 62, 6, NA, NA, NA, 15), 
    V2 = c(21, 231, 5, 5, 32, NA, 1, 231, 5, 200), 
    V3 = c(NA, NA, 24, 51, 53, 231, NA, 153, 6, 700), 
    V4 = c(2, 10, NA, 20, 56, 1, 1, 53, 40, 5000)
  ), 
 .Names = c("c1", "c2", "c3", "c4"), 
 row.names = c(NA, 10L), 
 class = "data.frame"
)
df
head(df)
#   c1  c2  c3 c4
#1  56  21  NA  2
#2 123 231  NA 10
#


(3) 也可以写成一行
refdf = structure(list(Start = c(1L, 25L, 60L), End = c(10L, 50L, 75L
)), .Names = c("Start", "End"), class = "data.frame", row.names = c(NA, 
-3L))
refdf
#  Start End
#1     1  10
#2    25  50
#3    60  75






2. 隆重推荐导出数据结构供重复使用的函数dput 

mydata <- data.frame('id'=c(10,12,3,4,5),'clazz'=c("a","b","c","d","e"))
mydata
#  id clazz
#1 10     a
#2 12     b
#3  3     c
#4  4     d
#5  5     e

dput(mydata)
#structure(list(id = c(10, 12, 3, 4, 5), clazz = structure(1:5, .Label = c("a", 
#"b", "c", "d", "e"), class = "factor")), class = "data.frame", row.names = c(NA, -5L))




ref:
https://r4ds.had.co.nz/introduction.html












========================================
*** 控制结构（顺序、循环、条件）***
----------------------------------------
#if, else, ifelse, switch:分支
#for, while, repeat, break, next:循环
#apply, lapply, sapply, tapply, sweep: 替代循环的函数
#
#function: 函数定义   source 调用文件
#call 函数调用
#.C   .Fortran 调用C或者Fortran子程序的动态链接库。Recall：递归调用；
#browser, debug, trace, traceback:程序调试：
#option:指定系统参数
#missing: 判断虚参是否对应实参
#nargs:参数个数   stop:终止函数执行
#eval(expr) 表达式计算
#system.time: 表达式计算计时
#menu: 选择菜单（字符列表菜单）
#





========================================
|-- 条件分支: if else, ifelse
----------------------------------------
1.
##分支语句
x=1;
if(x == 1) 
    print(x)
else print("not 1");

##分支语句2
s=1;
if(s == 1) {
  print(s)
}else if(s==2){
  print(2)
}else{
  print("last else");
}


########
注意: R中执行if else报错：unexpected 'else' in "else"
多行(包括注释)语句必须使用{}包裹，

注意if else的结构写法，有以下三种，除此之外，会不识别else。
结构  1： if()  xx  else    yy   # 一行；
结构  2： if()  {xx} else  {yy}  
	或者 
	if(){
		xx
	}else    #此处不能两行写
		yy
结构3：
{
	if   
	else
}





========================================
|-- 分支语句switch
----------------------------------------
1. R 的 switch 语句功能强大，使用得当能可以大大简化代码。

switch(statment, list) #首先判断条件的不同而执行不同的分支语句。
#首先执行statment，其返回值范围为1到list的长度; 然后switch语句执行list中包含的某一行语句，并将结果返回。

解释2:
switch(expr, list) #其中，expr为表达式，其值或为一个整数值或为一个字符串；list为一个列表。
运行机理：若expr的计算结果为整数，且值在1~length(list)之间时，则switch()函数返回列表相应位置的值。若expr的值超出范围，则没有返回值（老版本的R中返回NULL）。



#例1：第一个参数是n，就执行list的第n个语句片段。
(1)
xx=1
switch(xx,
	{print("A")},
	{print("B")},
	{print("C")});
#将打印A
xx也可以是布尔值，TRUE就是数字1，FALSE就是数字0；

(2)
switch(2,mean(1:10),rnorm(4))  #执行rnorm(4)
#由switch(x)来选择执行那个函数



# 例2: 如果第一个参数是字符串，则后面列表需要指定字符串的名字
you.like<-"fruit"
switch(you.like, drink="water", meat = "beef", fruit = "apple", vegetable="cabbage")
# [1] "apple"


###应用: 十分好用的switch()函数
for( i in c('b','a') ){
	rs=switch(i, a='aaa',b='bbb',c="ccc")
	print(rs)
}
#[1] "bbb"
#[1] "aaa"


#### 实例片段：根据不同的值，设置不同的条件。类似python中的字典的效果。
col=RColorBrewer::brewer.pal(n = 5,name = "Set2")
plot(density(DPAU[which( !is.na(DPAU[,1]) ),1]), col="white",
     xlab="DPAU", ylim=c(0, 0.07), main="DPAU distribution of all genes in each cell")
for(i in seq(1,ncol(DPAU))){
  cid=colnames(DPAU)[i]
  cellCycle=cellInfo[cid, 'cellCycle']
  color=switch(cellCycle,G1S=col[1], S=col[2], G2M=col[3], M=col[4], MG1=col[5])
  
  lines(density(DPAU[which( !is.na(DPAU[,i]) ),i]), col=color)
}



例3: 如果字符后是代码片段呢？
library(ggplot2)
g=ggplot(diamonds[1:1000,], aes(clarity, price, color=cut))
#
plotType='boxplot'
g2=switch(plotType, #这个返回值可要可不要
       boxplot=g+geom_boxplot(),
       jitter=g+geom_jitter(),
       violin=g+geom_violin()
)
g2 






实例1: (Seurat 4.0 R包的代码) 检查是否含有异常值，有了就警告
CheckMatrix.dMatrix <- function(
  object,
  checks = c('infinite', 'logical', 'integer', 'na'),
  ...
) {
  checks <- match.arg(arg = checks, several.ok = TRUE)
  x <- slot(object = object, name = 'x')
  for (i in checks) {
    switch(
      EXPR = i,
      'infinite' = if (any(is.infinite(x = x))) { #有无穷大，就警告
        warning("Input matrix contains infinite values")
      },
      'logical' = if (any(is.logical(x = x))) { #有逻辑值，就警告
        warning("Input matrix contains logical values")
      },
      'integer' = if (!all(round(x = x) == x, na.rm = TRUE)) { #有非整数，就警告
        warning("Input matrix contains non-integer values")
      },
      'na' = if (anyNA(x = x)) { #有NA，就警告
        warning("Input matrix contains NA/NaN values")
      },
    )
  }
  return(invisible(x = NULL))
}



1) match.arg(arg = checks, several.ok = TRUE) 能自动补齐参数，第二个参数是支持多个参数
# 就是只输入长字符串的开头几个字母，自动补齐其余部分
fn1=function( checks = c('infinite', 'logical', 'integer', 'na'), flag=T){
  checks= match.arg(arg = checks, several.ok = flag)
  print(checks)
}

# several.ok 默认是F，只支持一个参数匹配
fn1(c("inf", "n"), F) #'arg' must be of length 1 
fn1(c("inf", "n"), T) #"infinite" "na"

fn1(c("l")) #"logical"
# 如果输入有歧义，则无法自动补齐
fn1(c("in"), T) #Error: 'arg' should be one of “infinite”, “logical”, “integer”, “na” 
fn1(c("int"), T) #[1] "integer"

> fn1(flag=T) # 空白可以匹配全部参数
[1] "infinite" "logical"  "integer"  "na"



2) anyNA() 有NA就返回T
> anyNA
function (x, recursive = FALSE)  .Primitive("anyNA")
> anyNA(c(1,2,3))
[1] FALSE
> anyNA(c(1,2,NA))
[1] TRUE



3) invisible() 在没有左变量时隐藏函数的返回值
fn2=function(x){
  return(x)
}

fn2i=function(x){
  return(invisible(x))
}

> rs2=fn2(2)
> fn2(2) #输出返回值
[1] 2
> rs2
[1] 2
> #
> rs2i=fn2i(2)
> fn2i(2) #不输出返回值
> rs2i
[1] 2





实例2: (Seurat4的NNHelper()内部函数) 根据 method 字符串，决定使用哪个函数计算细胞的最近邻？
  results <- (
    switch(
      EXPR = method,
      # 不是默认方法
      "rann" = {
        args <- args[intersect(x = names(x = args), y = names(x = formals(fun = nn2)))]
        do.call(what = 'nn2', args = args)
      },
      # 默认是"annoy"
      "annoy" = {
      	# 获取参数列表的名字(names())，和 求 NN的函数的参数名字求交集，然后获取这些参数及其值，见本文 3.9
        args <- args[intersect(x = names(x = args), y = names(x = formals(fun = AnnoyNN)))]
        do.call(what = 'AnnoyNN', args = args) #调用 what 函数，使用args 参数列表
      },
      # 求最近邻的方法，目前只能二选一，否则报错
      stop("Invalid method. Please choose one of 'rann', 'annoy'")
    )
  )













========================================
|-- 循环: for, while, repeat
----------------------------------------
1. 示例
#######################
#for循环语句(类似js)
#
for(name in expr1){
  expr2;
}
#name:循环变量；
#expr1:一个向量表达式，如1:10;
#expr2:一组表达式；

x=0;
for(i in 1:5){
  if(x==1) next; # 跳过，继续下一个循环数
  x=x+1;
  print(x);
  if(x==3) break;#终止循环语句
}


#for循环，演示cat函数的用法；
for(n in c(1,2,3,4,5)){
  x=rnorm(n);
  #print(x)
  cat(n,":",x,"\n");#输出函数
  #cat();
  #cat(n, ":",x,":", sum(x^2), "\n");
}
#循环中，next 结束本次循环，继续下一次循环；break 跳出循环；


#######################
#while循环语句(类似js)
while(condition){
  expr
}

x=0;
while(x<=5){
  x=x+1
  print(x)  
}



#######################
#repeat语句
repeat{
  expr
}

x=0;
repeat{
  if(x<=5){
    x=x+1;
    print(x);
  }else
    break;
}




ref:
https://blog.csdn.net/sinat_26917383/article/details/51191916




========================================
|-- 循环与输出时间戳 / 进度条
----------------------------------------

1. 示例1
start=as.numeric(Sys.time())

now=function(){
  format(Sys.time(), '[%Y%m%d_%H%M%S]')
}

for(i in 1:12000){
  if(i%%3000==0){
    cat( now(), ">> i=", i, " | Elapse:", round(as.numeric(Sys.time())-start,2), 'seconds', "\n")
    Sys.sleep(1)
  }
    
  # task
}


输出:
[20240225_164559] >> i= 3000  | Elapse: 0.88 seconds 
[20240225_164600] >> i= 6000  | Elapse: 1.9 seconds 
[20240225_164601] >> i= 9000  | Elapse: 2.9 seconds 
[20240225_164602] >> i= 12000  | Elapse: 3.91 seconds 


另一种写法：
> cat(difftime(Sys.time(), start, units="sec"), "\n")
103.2165 






========================================
字符串
----------------------------------------

1. 获取字符串长度：nchar()能够获取字符串的长度，它也支持字符串向量操作。注意它和length()的结果是有区别的。
nchar(50); #2 字符串长度
length(50);#1 向量元素个数




2. 字符串粘合：paste/paste0/sprintf

(1)
paste()负责将若干个字符串相连结，返回成单独的字符串。其优点在于，就算有的处理对象不是字符型也能自动转为字符型。
paste0(a,b,c) 则能无缝连接字符串a和b和c。


> u=paste("hello world","R environment");u
[1] "hello world R environment"

> x=c("apple","google","microsoft","alibaba");x
[1] "apple"     "google"    "microsoft" "alibaba"  
> y=1:4
> y
[1] 1 2 3 4
> paste(x,y,sep='-')
[1] "apple-1"     "google-2"    "microsoft-3" "alibaba-4"  
> paste(x,y,sep='-',collapse='|')
[1] "apple-1|google-2|microsoft-3|alibaba-4"

> paste(x,y,sep=':',collapse=',') #输出json数据格式
[1] "apple:1,google:2,microsoft:3,alibaba:4" 




(2) C语言 风格的输出
sprintf("this is a %s with %d legs.", "dog", 4)

# 可用于字符串需要出现的位置
plot(c(1), col="white", 
     ylab=sprintf("this is a %s with %d legs.", "dog", 4), 
     main="")

1) 字符串 占位符 %s
a <- "string"
sprintf("This is where a %s goes.", a)
#> [1] "This is where a string goes."

2) 整数，可以使用%d或它的变体：
x <- 8
sprintf("Regular:%d", x)
#> [1] "Regular:8"

# 可以输出到字符串，以空格开头。
sprintf("Leading spaces:%4d", x)
#> [1] "Leading spaces:   8"

# 也可以使用0替代
sprintf("Leading zeros:%04d", x)
#> [1] "Leading zeros:0008"


3) 对浮点数，使用%f进行标准释义，而%e 或者 %E则代表指数。
也可以使用%g或者%G让程序自动帮你进行两种格式的转换，这取决于有效位数。
sprintf("%f", pi)         # "3.141593"
sprintf("%.3f", pi)       # "3.142"
sprintf("%1.0f", pi)      # "3"
sprintf("%5.1f", pi)      # "  3.1"
sprintf("%05.1f", pi)     # "003.1"
sprintf("%+f", pi)        # "+3.141593"
sprintf("% f", pi)        # " 3.141593"
sprintf("%-10f", pi)      # "3.141593  "   (左对齐)
sprintf("%e", pi)         #"3.141593e+00"
sprintf("%E", pi)         # "3.141593E+00"
sprintf("%g", pi)         # "3.14159"
sprintf("%g",   1e6 * pi) # "3.14159e+06"  (指数化)
sprintf("%.9g", 1e6 * pi) # "3141592.65"   ("修正")
sprintf("%G", 1e-6 * pi)  # "3.14159E-06"

在%m.nf格式规范中：m代表域宽，它是输出字符串中字符的最小位数，可以以空格或0开头。n代表精度，它指小数点后的数字位数。


# To print a percent sign, use "%%"
sprintf("A single percent sign here %%")
#> [1] "A single percent sign here %"






3. 字符串分割：strsplit()负责将字符串按照某种分割形式将其进行划分，它正是paste()的逆操作。
v=strsplit("this is a book."," ");v
[[1]]
[1] "this"  "is"    "a"     "book."

建议使用方式：
v=strsplit("this is a book."," ")[[1]];v
[1] "this"  "is"    "a"     "book."


> strsplit("This is Rstudio",'')[[1]];#分割成单字母
 [1] "T" "h" "i" "s" " " "i" "s" " " "R" "s" "t" "u" "d" "i" "o"

 
 
 
 
 
4. 字符串截取：substr()能对给定的字符串对象取出子集，其参数是子集所处的起始和终止位置。
Usage
	substr(x, start, stop)
	substring(text, first, last = 1000000L)
	substr(x, start, stop) <- value
	substring(text, first, last = 1000000L) <- value

> substr("abcdefg",0,4)
[1] "abcd"
> substr("abcdefg",1,4) #R语言中编号从1开始，与主流语言（C、java、php、Python）从0开始的惯例不同
[1] "abcd"
> substr("abcdefg",2,4)
[1] "bcd"

> substring("abcdefg",2)
[1] "bcdefg"


#首字母大写的函数
camelize=function(word){
  a1=toupper(substring(word,1,1));
  a2=substring(word,2);
  paste(a1,a2,sep="");
}
camelize('that')







5. 字符串替代：gsub(),sub().
gsub()负责搜索字符串的特定表达式，并用新的内容加以替代。sub()函数是类似的，但只替代第一个发现结果。
注：g是global全局的意思。


> x="this is a cat, I love cats."
> y=gsub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> y
[1] "this is a dog, I love dogs."
可见，原字符串并没有修改！只是返回新字符串。

> z=sub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> z
[1] "this is a dog, I love cats."#仅替换了第一个






6. 字符串匹配：grep()负责搜索给定字符串对象中特定表达式 ，并返回其位置索引。
grepl()函数与之类似，但其后面的"l"则意味着返回的将是逻辑值。
Usage
	grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
		 fixed = FALSE, useBytes = FALSE, invert = FALSE)

	grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
		  fixed = FALSE, useBytes = FALSE)

	sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		fixed = FALSE, useBytes = FALSE)

	gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		 fixed = FALSE, useBytes = FALSE)

	regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

	gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			 fixed = FALSE, useBytes = FALSE)

	regexec(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

#扫描文本
grep("the", scan("aa.txt", what="") );

#regexpr(pattern,x)#在字符串x中检索pattern，返回与pattern
#匹配的第一个子字符串的起始字符位置

regexpr("us","you_user_name_usa")
#返回首个与pattern匹配的字符串的其实位置

gregexpr("us","you_user_name_usa")
#返回所有与pattern匹配的字符串的其实位置





7. 大小写转化
text="This is China."
toupper(text)
tolower(text)
text #不影响原文

casefold(text,upper=FALSE) #转成小写
casefold(text,upper=TRUE) #转成大写
text #不影响原文

> DNA <- "AtGCtttACC" 
> tolower(DNA) 
[1] "atgctttacc" 
> toupper(DNA) 
[1] "ATGCTTTACC" 
> chartr("Tt", "Uu", DNA) 
[1] "AuGCuuuACC" 
> chartr("Tt", "UU", DNA) 
[1] "AUGCUUUACC" 



比如strtrim、strwrap、charmatch、match和pmatch等，甚至是 %in% 运算符都是可以使用的。R的在线帮助很全，自己看吧。













========================================
|-- 正则表达式 Regular Expression
----------------------------------------
1.简介
正则表达式不是R的专属内容，所以用0作为起始编号，这里也只简单介绍，更详细的内容请查阅其他文章。
正则表达式是用于描述/匹配一个文本集合的表达式。

正则表达式具有神奇的功能，让你不得不用，并且每次用的时候都需要重新学习一遍。




2.细节
(1).  所有英文字母、数字和很多可显示的字符本身就是正则表达式，用于匹配它们自己。比如 'a' 就是匹配字母 'a' 的正则表达式

(2).  一些特殊的字符在正则表达式中不再用来描述它自身，它们在正则表达式中已经被“转义”，这些字符称为“元字符”。perl类型的正则表达式中被转义的字符有：. \ | ( ) [ ] { } ^ $ * + ?。被转义的字符已经有特殊的意义，如
    点号 . 表示任意字符；
    方括号表示选择方括号中的任意一个（如[a-z] 表示任意一个小写字符）；
    ^ 放在表达式开始出表示匹配文本开始位置，放在方括号内开始处表示非方括号内的任一字符；
    大括号表示前面的字符或表达式的重复次数；
    | 表示可选项，即 | 前后的表达式任选一个。

(3).  如果要在正则表达式中表示元字符本身，比如我就要在文本中查找问号‘?’， 那么就要使用引用符号（或称换码符号），一般是反斜杠 '\'。
需要注意的是，在R语言中得用两个反斜杠即 ‘\\’，如要匹配括号就要写成 ’\\(\\)‘

(4).  不同语言或应用程序（事实上很多规则都通用）定义了一些特殊的元字符用于表示某类字符，如 
    \d 表示数字0-9， \D 表示非数字，
    \s 表示空白字符（包括空格、制表符、换行符等），\S 表示非空白字符，
    \w 表示字（字母和数字），\W 表示非字，
    \< 和 \> 分别表示以空白字符开始和结束的文本。

(5).  正则表达式符号运算顺序：
    圆括号括起来的表达式最优先，
    然后是表示重复次数的操作（即：* + {} ），
    接下来是连接运算（其实就是几个字符放在一起，如abc），
    最后是表示可选项的运算（|）。

所以 'foot|bar' 可以匹配’foot‘或者’bar‘，但是 'foot|ba{2}r'匹配的是‘foot’或者‘baar’。

量词：  *表示{0,},		 +表示{1,},	?表示{0,1}.



3. 正则表达式语法规则

数量词:
	{}前面的字符或表达式的重复次数。如{5,12}表示重复的次数不能小于5，不能多于12，否则都不匹配
	* 零个或者多个之前的字符 {0,}
	+ 一个或者多个之前的字符 {1,}
	? 零个或者一个之前的字符 {0,1}



\ 转义字符，R中使用 \\
\\转义字符，如果要匹配就要写成“\\(\\)”
. 除了换行以外的任意字符

^ 放在句首，表示一行字符串的起始; 放在[]内则表示 非匹配
$ 放在句尾，表示一行字符串的结束

|表示可选项，即|前后的表达式任选一个
()提取匹配的字符串，(\\s*)表示连续空格的字符串
[]选择方括号中的任意一个(如[0-2]和[012]完全等价，[Rr]负责匹配字母R和r)
方括号[],代表可以匹配其中任何一个字符。而^在[]中代表“非”, -代表“之间”

– [qjk]:q,j,k中任意一个字符
– [^qjk]:非q,j,k的任意其它字符
– [a-z]:a至z中任意一个小写字符
– [^a-z]: 非任意一个a至z小写字符的其它字符(可以是大写字符)
– [a-zA-Z]:任意一个英文字母
– [a-z]+: 一个或者多个小写英文字母
| 或者
小括号()与花括号{}配合“|”使用


特别注意：保留字符都需要转义字符 \ 来转义表示；且R中需要2个反斜杠来转义，也就是\\

例如：
常用的特殊转义字符含义
  \n:换行符
  \r回车符
  \t:tab
  \w:任意字母(包括下划线)或者数字 即 [a-zA-Z0-9_]
  \W:\w的反义 即[^a-zA-Z0-9_]
  \d:任意一个数字 即[0-9]
  \D:\d的反义 即[^0-9]
  \s:任意一个空格,比如space, tab, newline 等
  \S:\s的反义,任意一个非空格

注：\r\n是windows所用的文本行结束符，Unix和Linux只是用一个换行符来结束一个文本行


POSIX 字符类：R中使用要加上两层方括号
	[:alnum:]任何一个字母或数字（等价于[a-ZA-Z0-9]）
	[:alpha:]任何一个字母（等价于[a-ZA-Z]）
	[:blank:]空格或制表符（等价于[\t ]） 注:t后面有一个空格
	[:cntrl:]ASCII控制字符（ASCII 0到31，再加上ASCII 127）
	[:digit:]任何一个数字（等价于[0-9])
	[:graph:]和[:print:]一样，但不包括空格
	[:lower:]任何一个小写字母（等价于[a-z])
	[:print:]任何一个可打印字符
	[:punct:]既不属于[:alnum:]，也不属于[:cntrl:]的任何一个字符
	[:space:]任何一个空格字符，包括空格（等价于[f\n\r\t\v ] 注:v后面有一个空格
	[:upper:]任何一个大写字母（等价于[A-Z])
	[:xdigit:]任何一个十六进制数字(等价于[a-fA-F0-9])


正则表达式的常用函数: 这几个函数用法不那么统一，最好现查文档
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,  
     fixed = FALSE, useBytes = FALSE, invert = FALSE)  

grepl(pattern, x, ignore.case = FALSE, perl = FALSE,  
      fixed = FALSE, useBytes = FALSE)  

sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,  
    fixed = FALSE, useBytes = FALSE)  

gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,  
     fixed = FALSE, useBytes = FALSE)  

regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,  
        fixed = FALSE, useBytes = FALSE)  

gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,  
         fixed = FALSE, useBytes = FALSE)  

regexec(pattern, text, ignore.case = FALSE, perl = FALSE,  
        fixed = FALSE, useBytes = FALSE)  


作用、返回值的差异
	grepl:返回一个逻辑值。 	grep("i", c("this",'is','a','book') ) #[1] 1 2
	grep:返回匹配的id。	   grepl("i", c("this",'is','a','book') ) #[1] TRUE  TRUE FALSE FALSE
	agrep:返回匹配的id。

	正则替换:sub和gsub， 两者的区别是前者仅替换一次，后者全局替换。

	regexpr:返回一个数字,1表示匹配,-1表示不匹配,以及两个属性,匹配 的长度和是否使用useBytes

	regexec:返回一个list,字符串中第一个匹配及其长度以及是否使用useBytes

	gregexpr:返回一个list, 每一个匹配及其长度以及是否使用useBytes

	regmatches(): Extract or Replace Matched Substrings 提取/置换 匹配的子串




(2) 贪婪与非贪婪匹配
//js中的贪婪匹配与非贪婪匹配
var str = "abcabc92123abc"
str.match(/.*abc/) #默认是贪婪匹配 ["abcabc92123abc"]
str.match(/.*?abc/) #非贪婪匹配 ["abc"]

#########
#R语言基于正则表达式的获取
str = "abcabc92123abc"

gregexpr('.*abc',str)[[1]]  #默认是贪婪匹配
 # [1] 1
 # attr(,"match.length")
 # [1] 14
 # attr(,"index.type")
 # [1] "chars"
 # attr(,"useBytes")
 # [1] TRUE

gregexpr('.*?abc',str)[[1]] #加?后也是惰性
 # [1] 1 4 7
 # attr(,"match.length")
 # [1] 3 3 8
 # attr(,"index.type")
 # [1] "chars"
 # attr(,"useBytes")
 # [1] TRUE
没有竞争，就没有贪婪与否。所以想要实现非贪婪，需要后续有匹配任务。






(3) 正则表达式中的\1、\2含义
#\1表示重复第一个括号里面的内容,\2表示重复第二个括号里面的内容
#\1、\2必须和()配合使用

x=c('abbbbccccaaba')
m <-regexpr("(a).*?\\1", x)	#?非贪婪匹配失效
regmatches(x, m)		#"abbbbccccaaba"

# 后续加上竞争任务呢？
x=c('abbaabbaabbaabba')
m <-regexpr("(a).*?\\1", x)	#?非贪婪匹配失效
m
regmatches(x, m)		#"abbaabbaabbaabba"

#
x=c('aaaaaaaaabbbbcccc')
m <-regexpr("(a)\\1+?", x)
m
m <-regexpr("(a)\\1+", x)	#与上式等价,用\1或\2时不能识别非贪婪匹配
m

#
x=c('aaaaaaaaabbbbcccc')
m <-regexpr("(\\w)\\1+", x) #同样的字母才行
m
regmatches(x, m)	#'aaaaaaaaa'

#
x=c('abbbbcccc')
m <-regexpr("(\\w)\\1+", x) #开头没有同样的字母就跳过去
m
regmatches(x, m)	#'bbbb'






(4) regmatches(x, m): 提取/替换 匹配的子串
m1=regexec(pattern="^S.*", text=colnames(iris))
class(m1) #list
length(m1) #5
m1[[1]]

# Extract or Replace Matched Substrings
key=regmatches(
  x=colnames(iris),
  m=m1
)
key
unique(x = unlist(x = key, use.names = FALSE))
# [1] "Sepal.Length" "Sepal.Width"  "Species"     



# 替换
df1=iris
regmatches(
  x=colnames(df1),
  m=regexec(pattern="\\.Length$", text=colnames(iris))
) <- ".Height"

> head(df1) #注意: 列标题后缀名变了，原来的 .Length 变为 .Height
  Sepal.Height Sepal.Width Petal.Height Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa



(5) 拼接正则表达式、使用 POSIX 字符类
> key="Pe"
> grepl(pattern = paste0('^', key, "[[:alnum:]]+"), x = colnames(x = iris) )
[1] FALSE FALSE  TRUE  TRUE FALSE








4. 实例
查找 grep
例1： 查找PD开头的基因名字
genes=c("TP53","PDL1","PDL2","PTEN","pd1")
genes[grep("^PD",genes,ignore.case=T)]
## [1] "PDL1" "PDL2" "pd1"


替换 gsub
例2：替换_为-
cnames=c("Row-1","Row-2","Row-3");
gsub("Row-",'Cell_', cnames) #[1] "Cell_1" "Cell_2" "Cell_3"


在每一个元素中，sub只替换一次，而gsub则全部替换。
cnames2=c("R-ow-1","R-ow-2","R-ow-3");
gsub("-",'_', cnames2) #"R_ow_1" "R_ow_2" "R_ow_3"
sub("-",'_', cnames2) #"R_ow-1" "R_ow-2" "R_ow-3"




分割 strsplit
例3：将一串基因字符分割成单个的基因构成的数组：
inputUp="C4BPB, BASP1,VIM,    BEX3, EMP3, PRSS21";
geneUp=strsplit(inputUp,'[^a-zA-Z0-9]+')[[1]];
geneUp
#[1] "C4BPB"  "BASP1"  "VIM"    "BEX3"   "EMP3"   "PRSS21"





综合实例
例4：找到aatt开头、ggcc结尾的序列之间的序列。
my_find=function(startPattern,endPattern,x){
  #内函数1：获取开头位置
  i_start=function(pattern,x){
    bb=gregexpr(pattern,x,perl=TRUE);
    site=bb[[1]][1];
    start=attr(bb[[1]],"match.length") + site;
    return(start)
  }
  #内函数2：获取结尾位置
  i_end=function(pattern,x){
    bb=gregexpr(pattern,x,perl=TRUE);
    site=bb[[1]][1];
    return(site-1)
  }
  #获取开头和结尾
  a1=i_start(startPattern,x);
  a2=i_end(endPattern,x);
  #截取并返回开头和结尾
  return(substring(x,a1,a2));
}

aa ="aaatt123adsfasfa456ggccsdfa"
my_find('aatt','ggcc',aa); #adsfasfa





ref:
https://blog.csdn.net/qq_38984677/article/details/83960593
https://zhuanlan.zhihu.com/p/470315856
https://zhuanlan.zhihu.com/p/25132130






========================================
|-- 将一个分数的字符串数字转换成数值: eval(parse(text="1/2"))
----------------------------------------
https://bbs.pinggu.org/thread-4961503-1-1.html


很有趣的问题。
先说答案：eval(parse(text="1/2"))

解释：这个问题本质上是说，如何计算字符串形式的算式。那么，这样想就比较容易找答案了。
先把字符串表示成expression，即parse(text="1/2")；
然后计算，eval(parse(text="1/2"))









========================================
函数：R语言是函数式编程的
----------------------------------------
在R语言中采用函数式编程。需要对R的函数进行深入的学习。

To understand computations in R, two slogans are helpful:
 * Everything that exists is an object.
 * Everything that happens is a function call.
		— John Chambers
# https://adv-r.hadley.nz/functions.html#function-forms


> 1+2
[1] 3

> "+"(1, 2)
[1] 3




1. 函数=函数名+参数
exp(1)

参数还可以接收向量：
exp( c(1,2,3,4) )


自定义函数
fn=function(xx){
	return(xx+10);
}





2. 在函数内对参数进行验证，如果不是指定的值，则退出

  if( !(keyword %in% c('value1','value2')) ){
    stop("Error: keyword must in c('value1','value2')")
  }
#




3. 获取函数的源代码

- 直接在R console中敲函数 的名字，有些函数是可以直接显示所有代码，但是有些却不能。
- 对于那些不能的，使用函数 getAnywhere(函数名）可以返回这个函数的代码。
	对于同名函数，还需要使用[n]指定顺序编号，才能正确返回函数源代码:

> getAnywhere(add)[1]
function (x) 
{
    return(x + 7)
}
<bytecode: 0x8f948c0>
<environment: namespace:wjl007>






refer:
https://www.douban.com/note/279077707/
https://www.cnblogs.com/foreverycc/archive/2013/04/18/3028422.html




========================================
|-- 数学函数、科学计数法
----------------------------------------
1. 常用函数

exp()
log() #自然对数为底，就是 ln(2.718291829)=1
log10()

sqrt()
abs()
sin()，cos() 等三角函数
min()，max()：向量的最小、最大值
which.min()，which.max()：向量的最小、最大元素的位置索引
pmin()，pmax()：多个向量逐元素对比
sum()，prod()
cumsum()，cumprod()
round()，floor()，ceiling()

factorial()：阶乘








2. 保留n位小数、保留n位有效数字 

(1) 科学计数法 数字
a). 有效数字位数signif
x4= signif(0.0000000000133, 4)
# signif rounds the values in its first argument to the 
# specified number of significant digits.
x4 #[1] 1.33e-11

例: 获取p值 p.value<-signif(x$wald["pvalue"], digits=2)


b). round, 保留4位小数，末尾是0的就没了
x1=round(12.345678, 4)
x1 #[1] 12.3457




(2) 科学计数法 字符串
a). sprintf, 返回字符串，最后一位是0也保留
x2=sprintf("%0.4f", 12.345006) #保留4位小数
x2  #[1] "12.3450"

b). 保留有效数字, 返回字符串，末尾是0不保留
x3=formatC(12.3456, digits = 4)
x3 #[1] "12.35"













========================================
|-- 一、R函数定义与调用，匿名函数与闭包
----------------------------------------
定义：
funcName=function(para[,para]){
	#many statements;
	return(something);
}

参数可以0到多个。
支持默认参数。

返回值可选，使用return则必须使用()，否则默认使用最后一个数字返回。

调用： 
funcName();#不带参数
funcName(1,2);#带参数


#函数本身也是是对象，可以查看其形参部分和函数体
formals(test)#查看形参列表
body(test)#查看函数体


#函数也可以不加{}
f1=function(x)x*2+3;
print( f1(2) )

#甚至这么写
f2=function(x)x
body(f2)=quote(x^3);#重新改写函数；
print( f2(3) )

#输入函数名，
page(nls) #查询函数代码；
edit(nls) #编辑函数代码；
#由于一些基本函数是C编写的，不能用上述方法查看和修改。



(1)函数声明与调用
func=function(){
	print("hello!")
}
func();

multi2=function(x,y){
	return(x*y);
}
multi2(5,6)#30


(2)允许函数嵌套。
add3=function(a,b,c){
	add2=function(x,y){
		return(x+y);
	}
	return(add2(add2(a,b),c))
}
add3(1,2,3) #6

(3)支持默认参数。
func1=function(x=10){
	print(x)
}

func1() #10
func1(25) #25

(4)默认返回最后一行表达式的值。
func2=function(){
	a=1
	b=2
	c=3
	c+a
}
func2() #4


(5)函数递归
累加
cumulate=function(n){
	if(n==1) return(1);
	return(n+cumulate(n-1))
}
cumulate(100);
[1] 5050

累乘(https://www.zhihu.com/question/43378587)
funr <- function(x) {
  return(ifelse(x>1, x*funr(x-1), x))
}
funr(5)
[1] 120



(10)返回函数的函数
outer=function(){
  x=2
  inc=function(increment){
    x=x+increment#并不能改变
    return(x)
  }
  inc; #返回函数
}

x=2
fn=outer()
fn(100) #102
fn(100) #102 #确实没有修改外函数中的x



(11)R语言版本的闭包：返回函数，并能私有的使用外函数的变量
(写过js的对闭包应该很熟悉)

x=1
outer=function(){
  x=2
  inc=function(increment){
    x<<-x+increment #能改变outer内的x值，因为 <<- 符号能穿透作用域，给上一层赋值。
    return(x)
  }
  get=function(){
    return(x)
  }
  set=function(a){
    x<<-a;
  }
  list(inc=inc,get=get,set=set);#返回函数列表
}
fns=outer()
fns2=outer() #两个闭包有着不同的环境，两个闭包中的变量不会共享。

str(fns)
fns$get() #2
fns$inc(100) #102
fns$get() #102
fns$set(-30)
fns$get() #-30
fns$inc(100) #70
fns$inc(100) #170
fns$get() #170
x #1
fns2$get() #2


2) 闭包，使用立即执行函数(function(){})()，节省代码。缺点：不能实例化多个实例了。
#立即执行函数
fns=(function(){
  x=10;
  get=function()x;
  set=function(a){
    x <<- a;
  }
  inc=function(i=1){
    x<<-x+i;
    x;
  }
  fns=list(get=get,set=set,inc=inc);
  return(fns);
})()
fns$get() #10
fns$set(0)
fns$inc(100) #100
fns$inc(10) #110
fns$inc() #111
fns$get() #111


3) 更精简的，函数内直接定义一个list，由于是最后一条语句，直接返回该list
fns=(function(){
  x=10;
  list(
    get=function()x,
    set=function(a){
      x <<- a;
    },
    inc=function(i=1){
      x<<-x+i;
      x;
    }
  )
})()

使用该方法，可以仿写类了。返回的就是一个类名。



4) 直接使用立即执行函数，不污染函数外的变量空间
rm(a,b)
a=10
(function(){ # 立即执行的匿名函数，就像不存在过。
    a=1;
    b=2
    print(a) #1
    print(b) #2
})()
print(a) #10
print(b) #not found




refer:
1. 《高级R语言编程指南》, Hadley Wickham, 2016.
2. R语言学习1：R中的匿名函数、闭包与函数工厂 https://blog.csdn.net/hdyshr/article/details/82744681



========================================
|-- 二、变量的作用域
----------------------------------------
一个形象的比喻，就是大夏天的你进入了一家有空调冷气的超市，你出来后感觉不到冷气了，因为空调的作用区域就是这家超市。

R语言的作用域也是这样，你在作用域内能获得该作用域内的变量，而在作用域外就不能。
R的作用域是包含关系，层层包裹，内部能访问外部的变量，而外部不能访问内部变量。

最小的作用域就是函数内，函数结束，里面定义的变量就销毁了，除非返回值是内部函数。



1.内函数可以取出外函数的变量
a=c(1,2);
fun0=function(){
  print(a);
}
fun0() #1 2
R语言采用的是Lexical Scoping(词法作用域)。词法作用域，又称静态作用域，即变量定义后的作用域是不变的。

函数里碰到一个变量时，如果在函数里有定义或者调用的时候给了定义，就用这个定义（这个和dynamic scoping一样）；
否则就到定义函数的环境里（不是被调用的环境）找，有定义的话就用那个定义（这个和dynamic scoping 不一样）；
实在找不到了才会给出error。

实例1：
x=1
fa=function(){
  x=2
  fi=function(){
    print(x)
  }
  x=3
  fi()
}

x=100
fa() 
#3

实例2：
f=function(x){
	g=function(y){
		y+z;
	}
	z=4;
	x+g(x)
}
z=10;
f(3)

我的结果是：
f(3)=3+g(3)=3+(3+z)=3+(3+4)=10


实例3：如果去掉函数内部的z赋值呢？
f=function(x){
	g=function(y){
		y+z;
	}
	x+g(x)
}
z=10;
f(3)
我的结果：
f(3)=3+g(3)=3+(3+z)=3+(3+10)=16 



2.但是内函数不能修改外函数的变量
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    a=c(b,200)
    print(a) #[1]   1   2   3   4 100 200 #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1  2  3  4 10
  #并没有改变
}

fun()
print(a) #[1] 1 2 #毫不影响

#a就属于全局变量；b就是局部变量；

顶层的a并没有改变，即使看起来在fun()中被修改了。只有fun()中局部变量a发生了改变。
实际上，局部变量a与相应的全局变量a共享一个内存地址，直到局部变量的数值发生了变化。
这种情况下，会分配给局部变量a新的内存地址。




3.再次尝试
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
}

fun()
print(a) #[1] 1 2 #依旧毫不影响



4.想改变最外层的a怎么办？
在fun函数内使用一次<<-符号。
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
  a<<-a #再次穿透一层作用域
}

fun()
print(a) #[1]    2   3   4 100 200 #也受到了影响






##
More: 更多关于函数scope和环境environment部分请参考 R/R-OOP;


========================================
|-- 三、自定义二元运算符: "%myname%"=function(){}
----------------------------------------
#以为%开始和结束，函数的参数和返回值都是某种数据类型

"%myname%"=function(a,b)return(a^b)
2%myname%10   #1024






========================================
|-- R语言的函数中的特殊参数"...": 所有值
----------------------------------------
1. ...参数是一种特殊的参数，表明一些可以传递给另一个函数的参数。
常用于当你需要扩展另一个函数，而你又不想复制原函数的整个参数列表时。

如下例，你希望修改plot()函数中的个别参数，而其他参数保持不变，将其应用于一个新定义的函数中myplot()：
myplot <- function(x, y, type = "l", ...) {
    plot(x, y, type = type, ...) ## Pass '...' to 'plot' function
}


更拗口的一个说法: “...”用来引用从被调用函数传递下来的参数。当所有匹配“...”的参数来自特定的类或者特定类的子类，为这些函数定义的方法会被选择和调用。
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {
  [omitted statements]
  if (graph)
    par(pch="*", ...)
  [more omissions]
}





(2)获取这些参数

当一个函数需要引用“...”中的成分时，表达式列表list(...）将获取所有这样的参数，返回的是一个命名列表。

例
x = function(a){2*a}
y = function(a, b){a+b}
#定义新函数，用到旧函数
z = function(c, ...){
  args = list(...)
  return(x(args$a) + y(args$a, args$b) +c)
}
z(c = 2, b = 2, a =2 ) #2*2+(2+2)+2=10




2.在泛型函数（generic function）中，...还有另一种用法，它的作用是根据数据类型使用合适的方法

泛型函数是一个函数族，其中的每个函数都有相似的功能，但是适用于某个特定的类。
> mean
standardGeneric for "mean" defined from package "base"

function (x, ...) 
standardGeneric("mean")
<environment: 0x0000000003049880>
Methods may be defined for arguments: x
Use  showMethods("mean")  for currently available ones.




3. 还有一种情况下，...参数必须使用：
那就是，当传递到函数的参数数量不能事先确定的时候。

比如paste()函数，他的作用是将一连串字符串连接起来，然后新建一个字符串或向量，所以无法预知参数个数：
> args(paste)
function (..., sep = " ", collapse = NULL) 
NULL


还有cat()函数，它的功能是和paste相似，也是连接字符串。
> args(cat)
function (..., file = "", sep = " ", fill = FALSE, labels = NULL, 
    append = FALSE) 
NULL


注意：任何出现在...之后的参数列表必须明确的给出名称。而且不能够部分匹配或位置匹配。
比如，paste() 指定参数后，后面的分隔符sep参数必须使用完整形式，不能省略。
paste('a','b',sep=":") #"a:b"
paste('a','b',":") #"a b :" 不符合预期。






refer:
https://blog.csdn.net/Intelligebce/article/details/83958973





========================================
|-- R语言中do.call(fn, list)的用法
----------------------------------------
定位: 高端话题。前置知识: apply 家族函数。



1. 简介 
do.call这个函数经常能在别人的回答或者R包源码中看到。
简单参数设置就能搞定的事情，是不会用到do.call的。

(1) 使用场景 
do.call /call 函数与 for/while/apply/自定义函数 结合使用，especially powerful
适用2个场景：
	- 使用它更优: 节省体力
	- 或不得不使用它。

某些情况下，你知道某个函数接受参数的明确个数，但是太多了，你懒，所以用do.call；但更多的情况是你迫不得已，必须用它。

虽然R语言有类型很丰富的数据结构，但是很多时候数据结构比较复杂，那么基本就会用到list这种结构的数据类型。但是list对象很难以文本的形式导出，因此需要一个函数能快速将复杂的list结构扁平化成dataframe。这里要介绍的就是do.call函数。


(2) 作用
do.call 构造并执行来自字符串名称或直接函数调用来的函数, 并将其传递给它的参数列表。参数列表 即 list, 所以 do.call 针对的就是 list。

do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.

# do.call 根据名称或函数以及要传递给它的参数列表构造并执行函数调用。
# 一句话: do.call(fn, list) 是告诉list一个函数，然后把list里的所有元素当参数来执行这个函数。

简单的讲，do.call 的功能就是执行一个函数，而这个函数的参数呢，放在一个list里面, 是list的每个子元素。


(3) 用法
## Usage
## do.call(what, args, quote = FALSE, envir = parent.frame())

what可以是一个函数也可以是一个 字符串形式的函数名称(eg. kmeans or ‘kmeans’). 
args 供函数调用的参数设置，这些参数都将被 what 识别并调用. 
quote 逻辑值, 是否引用参数. 
envir 评估函数调用时所处的环境. 对于what是字符串形式函数名称且对应的参数都是符号或者引用的表达式时会非常有用.

# 鉴于第三个参数(environment/环境)水太深，我们先忽略。








2. 实例入门: 用法示例
这里主要讲 do.call() 用法，这些场景中 do.call 不一定是更好的选择。

(1) 对数组求和(单个参数)
x1=1:5
x1
sum(x1) #15

# 如果使用 do.call
do.call(sum, list(x1)) #15
# 第一个是函数，第二个是list格式的参数列表，可以是命名参数或者普通参数

# 第一个函数可以是字符串，使用 函数名字符串 调用函数，增加了很多灵活性
do.call("sum", list(x1)) #15


# 第一个函数使用自定义函数
do.call(function(x){
  sum(x+1) #对每个元素加1，然后求和
}, list(x1)) #20


# 第一个函数能使用变量
FN1=sum
do.call(FN1, list(x1)) #15
do.call(FN2, list(x1)) #object 'FN2' not found

FN2="max"
do.call(FN2, list(x1)) #5




(2) 对数组求和，忽略NA值(2个参数)
x2=c(1:5, NA); x2
sum(x2) #NA
sum(x2, na.rm=T) #15

#
do.call(sum, list(x2)) #NA
do.call(sum, list(x2, na.rm=T)) #15



(3) do.call 也不是万能的，有时甚至不能达到想要的效果，它只有在合适的场景才能事半功倍。

1) 比如简单合并字符串
> do.call(paste, list(as.name("A"), as.name("B")), quote = T) #太繁琐，不推荐
[1] "A B"
> paste("A", "B") #简洁，推荐
[1] "A B"


2) do.call() 不达预期的例子: list to data.frame 
> x4=list(A=1:5, B=letters[1:5]); x4
$A
[1] 1 2 3 4 5

$B
[1] "a" "b" "c" "d" "e"

> as1= as.data.frame(x4); as1
  A B
1 1 a
2 2 b
3 3 c
4 4 d
5 5 e
> str(as1)
'data.frame':	5 obs. of  2 variables:
 $ A: int  1 2 3 4 5
 $ B: chr  "a" "b" "c" "d" ...
#
> as2=as.data.frame( do.call(cbind, x4) ); as2
> str(as2) #不好: 繁琐，且第一列变为字符串了
'data.frame':	5 obs. of  2 variables:
 $ A: chr  "1" "2" "3" "4" ...
 $ B: chr  "a" "b" "c" "d" ...


3) do.call() 太繁琐的例子
x1 = 1:10
x2 = 11:20
x3 = 21:30
data.frame(x1,x2,x3) #返回三列构成的数据框
# 基本等价于
do.call("data.frame",list(x1=x1, x2=x2, x3=x3)) #把list中每个元素拿出来，给函数data.frame(理论上传无限参数)
# https://www.jianshu.com/p/078071c12e77









3. do.call() 优势案例
案例欣赏: 使用list()单独设置函数的参数列表，然后再用do.call("pheatmap", hm.parameters )的形式执行。
# 摘抄自其他人的代码
plotCycle <- function  ( phaseCorsMatrix ) {
    library("pheatmap")
    library("RColorBrewer")
    breaks <- seq ( -1 , 1 , length.out = 31 )
    heatColors <- rev (brewer.pal ( 9, 'RdBu'))
    heatColors <-colorRampPalette(heatColors)
    colorPallete <- heatColors((length ( breaks ) - 1 ))
    
    # create heatmap
    hm.parameters <- list(phaseCorsMatrix,
    color = colorPallete,
    breaks = breaks,
    cellwidth = NA, cellheight = NA, scale = "none",
    treeheight_row = 50,
    kmeans_k = NA,
    show_rownames = T, show_colnames = F,
    main = "",
    clustering_method = "average",
    cluster_rows = FALSE, cluster_cols = FALSE,
    clustering_distance_rows = "euclidean",
    clustering_distance_cols = NA ,
    legend = T , annotation_legend = F )
    
    do.call("pheatmap", hm.parameters )
}




(1) 怎么传入不确定的参数? 适合封装函数
# 给生成随机数的函数传递参数
> do.call(runif,list(n=10))

如果想传入更多参数呢？已经把部分参数写成list形式了，可以使用c()拼接list。
> params <- list(min=10, max=20)
> do.call(runif,list(n=10,min=10,max=20)) # works
> do.call(runif,list(n=10,params)) # doesn't work
> do.call(runif,c(n=10,params)) # work


## 执行未知个数的参数
# https://adv-r.hadley.nz/quasiquotation.html
exec <- function(f, ..., .env = caller_env()) {
  args <- list2(...)
  do.call(f, args, envir = .env)
}


# 2) 比如一个画 hist 的函数，如果可选参数很多，会很多重复
my_hist=function(arr, xlim=NULL, n=100){
	if(!is.null(xlim)){
		hist(arr, n, xlim=xlim)
	}else{
		#hist(arr, n, xlim=xlim) #invalid 'xlim' value
		hist(arr, n)
	}
}
set.seed(1); arr1=rnorm(1e4)
my_hist(arr1)
my_hist(arr1, xlim=c(-1, 5)) #限定显示范围



#########
#set.seed(1); arr1=rnorm(1e2)
params=list(x=arr1, n=100)
#
hist(arr1, n=100)
do.call(hist, params) #处理xlab 和main中的变量失败，直接替换了该变量，导致满屏幕的数字
do.call(hist, c(params, main="", xlab="X") )


#########
# 使用 do.call() 简化
my_hist2=function(arr, xlim=NULL, n=100){
  params=list(x=arr, 
              n=n,
              xlab="X", #要设置xlab和main，否则图像上满是数字
              main="")
  if(!is.null(xlim)){
    params$xlim=xlim
  }
  do.call(hist, params)
}
set.seed(1); arr1=rnorm(1e4)
my_hist2(arr1)
my_hist2(arr1, xlim=c(-1, 5)) #限定显示范围










(2) 合并list中的n个相同字段名的数据框，n不确定
# create a list containing 5 data.frames of different rows
allframes=lapply(1:5, function(x){
  data.frame(
    key=paste0("name", x),
    value=1:x
  )
})
allframes
sapply(allframes, nrow) #[1] 1 2 3 4 5

# 1)如何合并该list中5个数据框呢？
rbind(allframes) #not work
lapply(allframes, rbind) #not work

rbind(allframes[[1]], allframes[[2]], allframes[[3]], allframes[[4]], allframes[[5]] ) #ok

# 2)如果list中数据框个数n是会变动的呢？
answer=NULL;
for(i in 1:length(allframes)){
  answer=rbind(answer, allframes[[i]])
}
answer
# 这个代码完美实现了“按行合并list中的n个数据框，且n可变”。
# 我认为已经很好了，直到我遇到了 do.call

# 3) 更精简的
do.call(rbind, allframes)

# 4) Reduce 也能解决本问题，不过它不能接收更多参数
Reduce(rbind, allframes)




(3) do.call / lapply 组合: 分类-处理-合并结果，一行搞定。
# lapply(df, function(x){}) return a list;
# do.call(rbind, list)

The use of the do.call / lapply combination is a powerful way to leverage functional programming in R. In short, you write a function that performs some actions and apply it to a list of inputs, which can then be fed into a function that combines everything into a single object.

鸢尾花各类指标的均值
head(iris)
# 1)method1: 使用apply家族函数 sapply + apply
as1=sapply( split(iris[,1:4], iris[,5]), function(x){
  apply(x, 2, mean)
} )
as1
#             setosa versicolor virginica
#Sepal.Length  5.006      5.936     6.588
#Sepal.Width   3.428      2.770     2.974
#Petal.Length  1.462      4.260     5.552
#Petal.Width   0.246      1.326     2.026


# 2)method2: 使用 do.call + lapply实现
as1=do.call(rbind, lapply( split(iris[,1:4], iris[,5]), function(x){
  colMeans(x)
}))
as1
#           Sepal.Length Sepal.Width Petal.Length Petal.Width
#setosa            5.006       3.428        1.462       0.246
#versicolor        5.936       2.770        4.260       1.326
#virginica         6.588       2.974        5.552       2.026








##################################
# 补充练习题: do.call()
##################################
1. 直接读取同字段的文件并合并为大数据框 https://www.stat.berkeley.edu/~s133/Docall.html
#allframes = lapply(1:20,function(x)read.csv(paste(x,'csv',sep='.')))
#answer = do.call(rbind,allframes)


2. 合并若干个数据框，相当于split的反操作
mtcars_byGear = split(mtcars, mtcars$gear)
mtcars_byGear #按 gear 不同，把数据框分成3个，放到一个list中

do.call(rbind, mtcars_byGear) #缺点：行名都加了gear前缀


3. 画列之间的相关系数热图
library(corrplot)
do.call('corrplot.mixed',list(cor(iris[,1:4])))


4. 用kmeans给每一行元素贴一个聚类标签
set.seed(100)
t1=do.call('kmeans',list(x=iris[,1:4],centers=3))
t1$cluster
# 等价于
set.seed(100)
t2=kmeans(x=iris[,1:4],centers=3)
t2$cluster


5. 定义复数
complex(imag=1:3)
# 等价于
do.call("complex", list(imag = 1:3))


6. 数据框操作(求和，合并)
aa 		<- 	data.frame(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
aa
aa_sum 	<- 	do.call(sum,aa);aa_sum #[1] 1550
aa_bind <-	do.call(cbind,aa);aa_bind #拿出来每列，按照列合并，所以和aa一模一样，不过是"matrix"
#

bb 		<- 	list(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
bb
bb_sum 	<- 	do.call(sum,bb);bb_sum #[1] 1550
bb_bind <-	do.call(cbind,bb);bb_bind #把list的每一个元素拿出来，列之间合并，变宽了。

# do.call(fn, list) 是告诉list一个函数fn，然后list里的所有元素来执行这个函数。
# do.call() 的第二个参数传入 list和data.frame都是可以的



7. 把df的每一行拼接成一个字符串
> tmp <- data.frame('letter'=letters[1:8],number=seq(1:8), 'value' = c('+','-'))
> tmp
  letter number value
1      a      1     +
2      b      2     -
3      c      3     +
4      d      4     -
5      e      5     +
6      f      6     -
7      g      7     +
8      h      8     -
> tmp[[1]]
[1] a b c d e f g h
Levels: a b c d e f g h
> tmp[[2]]
[1] 1 2 3 4 5 6 7 8
> tmp[[3]]
[1] + - + - + - + -
Levels: - +
> do.call('paste', c(tmp, sep=""))
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"
#
这里的tmp使用data.frame函数创建的，其实它本质上还是一个list，这里分别用[[]]符号显示他的2个元素，可以看到do.call函数把tmp的3个元素（3个向量）作为paste函数的参数。这个例子我们也可以这样写：

> paste(tmp[[1]],tmp[[2]],tmp[[3]], sep = "")
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"

但是：为什么这样不行呢？
> do.call('paste', list(tmp,sep="") ) 
[1] "1:8"                       "1:8"                       "c(2, 1, 2, 1, 2, 1, 2, 1)"



8. 对于一系列不确定个数的list，怎么给出每个成员的size呢？
(1) 长度为1的list
do.call("dim", args=list(iris) )
等价于 
dim(iris)
# [1] 150   5

(2) 不定长度的list
aa=list(
  iris,
  mtcars
)
str(aa)
length(aa) #2

# 获取list x中每个元素的行列数(df),或长度(numeric)
getSize=function(x){
  do.call(function(...){
    args = list(...)
    len=length(args)
    for(i in 1:len){
      if("data.frame"==class(args[[i]]))
        print( dim(args[[i]]) )
      else
        print( length(args[[i]]) )
    }
  },args=x)
}

getSize(aa)
# [1] 150   5
# [1] 32 11

getSize( iris ) #按列的长度
# [1] 150
# [1] 150
# [1] 150
# [1] 150
# [1] 150






refer:
https://bbs.pinggu.org/thread-3802000-1-1.html

# https://adv-r.hadley.nz/quasiquotation.html
# https://statisticsglobe.com/do-call-and-call-functions-in-r/
# https://qiita.com/TomokIshii/items/a34e0a8f86a8c3ff4c42 日语的，看不懂
# https://www.r-bloggers.com/2021/05/do-call-lapply/
# 怎么使用"::" https://stackoverflow.com/questions/10022436/do-call-in-combination-with
# do.call使用merge和eapply https://www.5axxw.com/questions/content/wxiql1
# R 语言如何实现函数柯里化? https://segmentfault.com/a/1190000010377489






========================================
|-- 函数式编程: 函数作为参数、返回函数的函数
----------------------------------------

1. 几个示例

(1) 传入函数

我们创建一个略显奇怪的函数：
f <- function(x, fun) {
  fun(x)
}

它可以将常见的数值计算函数作为参数计算相应的结果，在讲解之前我们先看看效果：

f(1:10, sum) # [1] 55
f(1:10, mean) # [1] 5.5

f(1:10, quantile)
#    0%   25%   50%   75%  100% 
#  1.00  3.25  5.50  7.75 10.00

上述代码中发挥计算功效的是函数的第 2 个参数。
在我们创建的函数 f() 中，我们可以理解为对传入函数的 mean()、sum() 等函数重命名成 fun() 并进行调用。



(2) 一个函数作为返回值的例子：

f2 <- function(type) {
  switch(type,
         mean = mean,
         sum = sum,
         quantile = quantile)
}

f() 函数使用了 switch 语句，如果使用 if-else 语句实现该函数也是可以的（读者不妨一试），但此处 switch 让代码更加简明。

下面看看效果：
> f2("mean")
function (x, ...) 
UseMethod("mean")
<bytecode: 0x565130eded28>
<environment: namespace:base>

> f2("sum")
function (..., na.rm = FALSE)  .Primitive("sum")

> f2("quantile")
function (x, ...) 
UseMethod("quantile")
<bytecode: 0x5651304f7fc8>
<environment: namespace:stats>

返回的全部都是函数，那么我们是不是可以直接调用它呢？
f2("mean")(1:10) #[1] 5.5

事实证明是可以的。










========================================
|-- with 函数: with(data, fn) (不推荐，避免使用!)
----------------------------------------
1. 实例

原始版:
plot(mtcars$mpg, mtcars$wt, col='red')


(1) 使用 with 后
with(mtcars, 
	plot(mpg, wt, col='red') )

第一个参数是数据集，第二个是函数。
也就是with()内部可以省略 data$ 这个取数据的操作，简化代码。



(2) 使用 attach , 中间可以放更多的语句

attach(mtcars)

plot(mpg, wt, col='red')

detach(mtcars)



2. 因为容易引起各种莫名其妙的错误，应该避免使用该函数。







========================================
|-- 函数参数的校验与 通知 message()、警告warning()、报错 stop()
----------------------------------------
1. 只能用于函数内的方法

(1) 如果没传入实参则报错
stopifnot(!missing(x))
- missing(x): Does a Formal Argument have a Value? | 函数虚参是否传入对应的实参
- stopifnot(): Ensure the Truth of R Expressions | 确保R表达式是正确的
翻译一下:
	missing(x) 如果没有传入实参，则返回T
	!missing(x) 如果没有实参，则返回F
	stopifnot(y) 如果y不是T，则停止程序执行







2. 来自Seurat 4 的示例

(1) 如果检验方法不需要 latent 变量，且提供了，则警告:
  if (!(test.use %in% DEmethods_latent()) && !is.null(x = latent.vars)) {
    warning(
      "'latent.vars' is only used for the following tests: ",
      paste(DEmethods_latent(), collapse=", "),
      call. = FALSE,
      immediate. = TRUE
    )
  }



(2) 检查一个R包是否安装

#' Check the existence of a package
#'
#' @param ... Package names
#' @param error If true, throw an error if the package doesn't exist
#'
#' @return Invisibly returns boolean denoting if the package is installed
#'
#' @export
#'
#' @examples
#' PackageCheck("SeuratObject", error = FALSE)
#'
PackageCheck <- function(..., error = TRUE) {
  # 获取每个参数，不要名字，只要值: 包名
  pkgs <- unlist(x = c(...), use.names = FALSE)
  # 对每个R包名，加载其命名空间，要求返回值是 logical 类型，长度为1
  package.installed <- vapply(
    X = pkgs,
    FUN = requireNamespace,
    FUN.VALUE = logical(length = 1L),
    quietly = TRUE
  )
  
  # 如果允许报错，且至少有一个没安装，则报错
  if (error && any(!package.installed)) {
    stop(
      "Cannot find the following packages: ",
      paste(pkgs[!package.installed], collapse = ', '),
      ". Please install"
    )
  }
  # 返回R包安装情况，是一个 named vector
  invisible(x = package.installed)
}




(3) 如果没有安装某R包，则提醒安装，并且一个R session 只提醒一次。

  #(A3) 检查是否溢出?? 
  overflow.check <- ifelse(
  	# 第一行 *  第一行，是na吗？ 是na则表示溢出内存了；不是na表示可以继续运算
    test = is.na(x = suppressWarnings(length(x = data.use[1, ]) * length(x = data.use[1, ]))),
    yes = FALSE,
    no = TRUE
  )

    if (getOption('Seurat.limma.wilcox.msg', TRUE) && overflow.check) {
      message(
        "For a more efficient implementation of the Wilcoxon Rank Sum Test,",
        "\n(default method for FindMarkers) please install the limma package",
        "\n--------------------------------------------",
        "\ninstall.packages('BiocManager')",
        "\nBiocManager::install('limma')",
        "\n--------------------------------------------",
        "\nAfter installation of limma, Seurat will automatically use the more ",
        "\nefficient implementation (no further action necessary).",
        "\nThis message will be shown once per session"
      )
      options(Seurat.limma.wilcox.msg = FALSE)
    }















========================================
文件I/O: 小文件、单列文件、大文件、R对象、源代码的读写
----------------------------------------
1.  小文件读到内存(几行)

(1)本文件内读取示例数据
Input =("
        Distance    Trill  No.trill
        10m        16     8
        100m        3    18
        ")
Matriz = as.matrix(read.table(textConnection(Input),
                              header=TRUE,
                              row.names=1))
Matriz
#     Trill No.trill
#10m     16        8
#100m     3       18




(2)更简洁的写法：
# 直接在程序中嵌入数据
mydatatxt="
age gender
1 M
2 F
3 F
"
mydata=read.table(text=mydatatxt, header=T) # text设置了，file就要留空。
mydata
#  age gender
#1   1      M
#2   2      F
#3   3      F


以上适合小数据及，大型数据集还是要从文件读取。







2. 单列文件的读写

(1)读入一列基因名字:
geneList2=readLines("geneList2.txt")


(2) 把id写入文件，一个id一行，不要行列标题
#最简单形式
writeLines(ls(), 'ls.txt')
# 输出:
# e1
# p1
# p2


# 复杂形式（不建议使用）
write.table(rownames(tmp),file="xx.Right.cellID",
            quote=F,row.names = F,col.names = F)
#
write.csv(data, file = "data.csv")






3. 大文件读写

(1) 一次读入数据框
fileName="D:/coding/Java/CCDS.20160908.txt";
#a=read.table(choose.files(),sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件
a=read.table(fileName,sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件

newdata <- read.csv(file = "data.csv", row.names=1, stringsAsFactors = F, sep = ",")

教训：一定要加入 stringsAsFactors = F，否则数据可能会异常。

R认为列名的短横线-是无效的，所以如果读入的列名中包含了-，它会默认将其替换为点号“.”。
匹配或获取列名时要特别注意检查。





(2) R语言逐行读取并处理
大文件最好逐行读取。  

用R语言作分析时，有时候需要逐行处理非常大文件，各种教材中推荐的read.table 和scan都是一次性读入内存，如果文件有好几个Gb大小，一般电脑肯定吃不消。

其实R中可以逐行读取的行数，这里示例一个函数，作为备忘：

con <- file("e:/data.txt", "r")
line=readLines(con,n=1)
while( length(line) != 0 ) {
     print(line)
     line=readLines(con,n=1)
}
close(con)

如果需要将一行的文字劈成多段，再进行处理，可以用strsplit函数，除此之外，还有一些常用的字符串处理函数，记录如下：
substr(),nchar(), grep(), regexpr(), sub(), gsub()


这样在异常时可能不能及时关闭资源，有博文建议如下方式写：
http://stackoverflow.com/questions/6304073/warning-closing-unused-connection-n

getCommentary <- function(filepath) {
    con <- file(filepath) 
    on.exit(close(con)) #这样，不管函数因为什么原因结束，都会关闭该资源链接。
    Commentary <-readLines(con)
    Commentary
}

getCommentary("foo.txt")







4. 数据对象(object)的读写

(1) R对象的保存: RData 格式，原样读写
save(objectlist, file="myfile")	保存指定对象到一个文件中

i) 整个工作空间的对象都写入硬盘
save.image("myfile.RData")	#保存工作空间到文件 myfile 中(默认值为.RData)
load("myfile.RData")	#读取一个工作空间到当前会话中(默认值为.RData)


ii) 单个对象写入硬盘
str(ttr.varSA)
## List of 4 ...

对象写入硬盘：
save(ttr.varSD, file='ttr.varSD.RData')



(2) R对象的保存: Rds 格式，读到指定变量汇总
> p2
Class:Person: name=Lily, age=18

> saveRDS(p2, "p2.obj.Rds")
> wjl=readRDS("p2.obj.Rds") #读到新变量中
> wjl
Class:Person: name=Lily, age=18






5.执行外部(函数)源码文件

> source("xx.func.R")




6. 直接编辑文件，如果不存在就新建该文件

> file.edit( paste0(rootPath, keyword, ".R5.Colon_nue.cluster3VS5.DEG.txt"))





7. 使用 sink() 函数把 R 输出导出到文本文件(You want to write output to a file.)
http://www.cookbook-r.com/Data_input_and_output/Writing_text_and_output_from_analyses_to_a_file/

(1) 使用方法
getwd()
dir("my_output/")

# Start writing to an output file
output_file='my_output/analysis-output-test.txt'
sink(output_file)

set.seed(12345)
x <-rnorm(10,10,1)
y <-rnorm(10,11,1)
# Do some stuff here
cat(sprintf("x has %d elements:\n", length(x)))
print(x)
cat("y =", y, "\n")

cat("======= ============ ==========\n")
cat("T-test between x and y\n")
cat("======= ============ ==========\n")
t.test(x,y)

# Stop writing to the file
sink()



# Append to the file
sink(output_file, append=TRUE)
cat("Some more stuff here...\n")
sink()

(2) 查看文件内容
x has 10 elements:
 [1] 10.585529 10.709466  9.890697  9.546503 10.605887  8.182044 10.630099  9.723816  9.715840  9.080678
y = 10.88375 12.81731 11.37063 11.52022 10.24947 11.8169 10.11364 10.66842 12.12071 11.29872 
======== =========== ==========
T-test between x and y
======== =========== ==========

	Welch Two Sample t-test

data:  x and y
t = -3.8326, df = 17.979, p-value = 0.001222
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 -2.196802 -0.641042
sample estimates:
mean of x mean of y 
 9.867056 11.285978 

Some more stuff here...





8. 读取 gz 压缩过的文本文件 gzfile()

Files compressed using the gzfile method can also be compressed and uncompressed using the UNIX gzip and gunzip commands (respectively).

gzfile(description, open = "", encoding = getOption("encoding"),
       compression = 6)

For gzfile the description is the path to a file compressed by gzip: it can also open for reading uncompressed files and those compressed by bzip2, xz or lzma.

For bzfile the description is the path to a file compressed by bzip2.

For xzfile the description is the path to a file compressed by xz (https://en.wikipedia.org/wiki/Xz) or (for reading only) lzma (https://en.wikipedia.org/wiki/LZMA).


(1) 读取gz实例
outputRoot="/home/wangjl/data/chenxi/batch0/"

df1=read.table(gzfile( paste0(outputRoot, "fastq/counts.tsv.gz")), header = T)
head(df1)
输出:
                  gene     cell count
1 ENSMUSG00000000001.5 AAACACCA    25
2 ENSMUSG00000000001.5 AAACGAGA    78
3 ENSMUSG00000000001.5 AAACTTAG    11

(2) 写gz文件
write.table(tst.df, gzfile("test.dat.gz")) # write a compressed file

# https://rce-docs.hmdc.harvard.edu/faq/how-do-i-use-compressed-data-r


(3) 完整的关闭文件方法

zzfil <- tempfile(fileext=".gz")
zz <- gzfile(zzfil, "w")  # compressed file
cat("TITLE extra line", "2 3 5 7", "", "11 13 17", file = zz, sep = "\n")
close(zz)

readLines(zz <- gzfile(zzfil))
close(zz)
unlink(zzfil)
zz # an invalid connection








========================================
|-- 大型脚本的组织架构 (我自己的R工具包)
----------------------------------------
1. 文件结构 
projectName/
 |-script/
 |-src/
 |-result/
 |-data/
#
原始数据放到data/中，设置为可读不可写。

结果放到result中，关键词加日期命名文件夹。

代码放到 script中，函数定义放到 src中。



2. 带个格式化
(1)在 script/ 中写代码 
# Project Name: xx
# Aim: get correlation
# email: jimmymall at 163 dot com 
# Version: v0.0.1
# 
setwd("xx/result/") #这里用绝对路径，后面都尽可能用相对路径。
getwd()

source("../src/base/tool.df.R")







(2) src/base 中写常用函数，及测试，要有详细的文档


########################
# src/base/tool.df.R 
########################
# aim: tools to deal with data frame, to df, or from df;
# version:



########################
# src/base/tool.color.R 
########################
# add alpha to color hex;
addAlpha=function(hex, alpha='33'){
  paste0(substr(hex,1,7),alpha)
}



更详尽的实现请移步: https://github.com/DawnEve/bioToolKit





========================================
|-- 读文件时，防止字符变因子: stringsAsFactors=FALSE
----------------------------------------
1.
> options("stringsAsFactors") #查询

> options(stringsAsFactors=FALSE) #设置


字符型数据读入时自动转换为因子，因子是R中的变量，它只能取有限的几个不同值，将数据保存为因子可确保模型函数能够正确处理。But当变量作为简单字符串使用时可能出错。要想防止转换为因子：
1.令参数stringsAsFactors=FALSE,防止导入的数据任何的因子转换。
2.更改系统选项options(stringsAsFactors=FALSE)
3.指定抑制转换的列：as.is=参数。通过一个索引向量指定，或者一个逻辑向量，需要转换的列取值FALSE,不需要转换的列取值TRUE。

data5<-read.csv('item.csv',stringsAsFactors=FALSE)




2. 如果数据集中含有中文，直接导入很有可能不识别中文，这时加上参数fileEncoding='utf-8'
read.csv('data.csv',fileEncoding='utf-8')





ref:
https://www.cnblogs.com/zhangduo/p/4440314.html












========================================
|-- 读取 excel 文件：xlsx包(win), readxl(Ubuntu)
----------------------------------------
1. read xlsx on Win

(1) 安装
装Java: 百度吧。

装包:
install.packages('xlsx')




(2) 使用
library(xlsx)
dat <- read.xlsx("data.xlsx", sheetName = "Sheet1", encoding = 'UTF-8')

一个标准的数据读取如上所示，下面将几个常用的参数：

"data.xlsx"：表示读取数据的名称。
sheetName：表示读取表中表的名称，通常第一个就是Sheet1。
encoding：这个在读取中文数据的时候是一定要加上的，不然读取数据会出现乱码。

sheetIndex：表示读取文件中第几个表，sheetIndex = 1表示读取文件中第一个表。需要特别注意：当文件中我们的表明为中文字时，不能使用类似sheetName = "表1"进行读取，即使加上encoding = 'UTF-8'也会出现读取错误，这时就需要使用sheetIndex来进行读取。








2. read xlsx on Ubuntu

(1) 安装
install.packages("readxl")

(2) 使用

# 载入包
library(readxl)
 
# 读取整个工作簿
data <- read_excel("data.xlsx")
 
# 读取特定工作表
data <- read_excel("data.xlsx", sheet = "Sheet1")







ref:
https://www.r-bloggers.com/read-excel-files-from-r/
https://blog.csdn.net/weixin_35755434/article/details/129490910






========================================
|-- R的list数据传给python：jsonlite包输入输出json中间文件
----------------------------------------

1. 准备工作
要先安装R包jsonlite 

# R中的list示例数据
colorSets=list(
  "group1"=c('red','blue','#FF9600'),
  "group2"=c('brwon', 'green', '#F000F0'),
  "group3"=c("purple")
)

> colorSets
$group1
[1] "red"     "blue"    "#FF9600"

$group2
[1] "brwon"   "green"   "#F000F0"

$group3
[1] "purple"





2. R和python内部和之间通过 json中间格式 交换数据
(1) R list to json file

library("jsonlite")
jsonlite::toJSON(colorSets)

setwd("~/data/r-pkg/wjl009/")
writeLines(jsonlite::toJSON(colorSets), "data/colors.json")

查看文件内容：
{"group1":["red","blue","#FF9600"],"group2":["brwon","green","#F000F0"],"group3":["purple"]}




(2) json file to R list
## json file to R list
colorsSet2=jsonlite::fromJSON("data/colors.json")
str(colorsSet2) ## List of 3




(3) json file to python dict
>>> import json
>>> fr=open("/home/wangjl/data/r-pkg/wjl009/data/colors.json",'r')
>>> load_jn = json.load(fr)
>>> print(type(load_jn), load_jn)
## <class 'dict'> {'group1': ['red', 'blue', '#FF9600'], 'group2': ['brwon', 'green', '#F000F0'], 'group3': ['purple']}
>>> load_jn['group2']
['brwon', 'green', '#F000F0']






========================================
|-- 文件夹 操作: 是否存在、新建 文件夹
----------------------------------------

片段分析

for(wd in filepath){
  files<-dir(path=wd,pattern="gz$")
  #查看满足条件文件
  fromfilepath<-paste(wd,"\\",files,sep="")
  file.copy(fromfilepath,tofilepath)
}









rm(list=ls()) 
path = '~/dir/' 
setwd(path) 

## 写入文本文件
cat("file A\n", file="A.txt") #创建一个文件A.txt，文件内容是’file A’,’\n’表示换行，这是一个很好的习惯 

whole_article="this is a html"
write(whole_article, file = "index.html")   #把某个字符串写入文件

cat("file B\n", file="B.txt") #创建一个文件B.txt 

file.append("A.txt", "B.txt") #将文件B的内容附到A内容的后面，注意没有空行 
检查
$ cat A.txt 
file A
file B

file.create("A.txt") #创建一个文件A.txt, 注意会覆盖原来的文件 
file.append("A.txt", rep("B.txt", 10)) #将文件B的内容复制10便，并先后附到文件A内容后 
file.show("A.txt") #新开工作窗口显示文件A的内容 
file.copy("A.txt", "C.txt")  #复制文件A保存为C文件，同一个文件夹 


dir.create("tmp") #创建名为tmp的文件夹 
file.copy(c("A.txt", "B.txt"), "tmp") #将文件夹拷贝到tmp文件夹中 

list.files("tmp") #查看文件夹tmp中的文件名 
unlink("tmp", recursive=F) #如果文件夹tmp为空，删除文件夹tmp 
unlink("tmp", recursive=TRUE) #删除文件夹tmp，如果其中有文件一并删除 
file.remove("A.txt", "B.txt", "C.txt") #移除三个文件


file.create("mytest.R") #创建mytest.R文件 
file.exists("mytest.R") #查询文件是否存在 
dir.exists(aa) ##查询目录aa是否存在 

file.info("mytest.R") #查询文件包含信息
file.info("mytest.R")$mode #特定信息 

file.rename("mytest.R", "mytest2.R") #重命名 文件
file.remove("mytest.R") #删文件
file.copy("mytest2.R", "mytest3.R") #复制为mytest3.R文件 

file.copy("D.txt", "C.txt", overwrite = TRUE)  #C.txt已存在，设置overwrite = TRUE进行覆盖

#复制D.txt中的内容10遍，添加到文件A.txt和B.txt
file.append(c("A.txt", "B.txt"), rep("D.txt", 10))


file.path("mytest3.R")  #在众多工作文件中，指定提供某个文件的相对路径。 
> file.path("some", "path", "to","index.html")  #构建路径，有点像字符串拼接函数
[1] "some/path/to/index.html"

> file.path("folder1", "folder2")  #最后一个结尾没有/
[1] "folder1/folder2"







1. 工作目录
setwd("/home/wangxx/proj1/") #设置
getwd() #获取 


设置相对目录
outputRoot="/home/wangxx/proj1/"
pdf( paste0(outputRoot, "xx1/01_yy.pdf"), width=4, height=4)
plot(c(1))
dev.off()




(2) 文件管理主要函数：

setwd( )：设定R软件当前工作目录。
getwd( )：查看R软件当前工作目录。
list.files( ): 查看当前目录下文件。
file.show( ): 显示文件。
file.access( ): 查看文件是否可读可写。
file.create( ): 创建一个文件。例如：file.create(“D:/lesong.xls”).
dir.create( ): 创建一个目录。例如：dir.create(D:/lesong).
file.remove( ):删除一个文件。
File.choose( ):选择一个文件。






2. 文件夹操作 dir 

(1)dir是否存在？

> dir.exists("pdf")
[1] TRUE

> dir.exists("output")
[1] FALSE



(2) 创建目录和文件
创建目录使用dir.create()
当创建多级目录时，令recursive = TRUE即可。
创建空文件使用file.create()

dir.create("output")
saveRDS(pbmc, file = "output/pbmc_tutorial.rds")



(3) 获取路径下的文件和目录
list.files()
dir()  #查看当前目录下的子目录和文件
list.dirs() #查看当前目录下的子目录
These functions produce a character vector of the names of files or directories in the named directory.

示例:
> dir('./')
[1] "4cluster"   "c1.bam"     "c1.bam.bai"


函数的完整形式: 
dir(path = ".", pattern = NULL, all.files = FALSE,
           full.names = FALSE, recursive = FALSE,
           ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)

参数解释:
path 指定路径 > dir(path="/etc/")
pattern 指定文件名字的模式，支持正则表达式，比如o结尾的
	> dir(path="/etc/", pattern = "o$")
	[1] "rstudio"  "terminfo"



(4) 是否是文件夹 
> file_test("-f", "mytest2.R") #"-f"判断是否为文件, "-d"判断是否为目录
[1] TRUE
> file_test("-d", "tmp2")
[1] TRUE


(5) 删除目录和文件
有两个函数可以使用 file.remove 和 unlink ，其中unlink函数使用同删除目录操作是一样的。



(6) 调用系统命令查看文件结构
> system("tree") #通过系统命令查看目录结构
.
├── mytest2.R
├── mytest3.R
└── tmp2
    └── index.html

> system("ls -lth")


(7) 获取路径、获取文件名
返回上一级路径
dirname(myaddress)

> dirname("/p1/p2/p3/a.txt")
[1] "/p1/p2/p3"

> basename("/p1/p2/p3/a.txt")
[1] "a.txt"

> file.path("", "p1", "p2", "p3", "a.txt")
[1] "/p1/p2/p3/a.txt"







3. 文件操作 file 

(1) 文件复制
file.copy(fromfilepath, tofilepath) #就是把文件 fromfilepath 复制到 tofilepath

> file.copy("/etc/rstudio/rsession.conf", "/home/rstudio/")
[1] TRUE


(2) 文件改名字

> filename<-list.files()   #可以设置参数pattern="*.txt",选择特定文本类型
> filename
[1] "aaa.pdf"     "Rplot01.pdf" "Rplot02.pdf"
> file.rename(filename,c("11.pdf","22.pdf","33.pdf"))  # 重命名

> list.files()
[1] "11.pdf" "22.pdf" "33.pdf"


# 使用全名
> list.files(full.name = TRUE)
[1] "./mytest2.R" "./mytest3.R" "./tmp2"


(3) 查看某路径下有几个文件/文件夹
> filename<-list.files("/etc/")
> table(dir.exists( paste0("/etc/", filename) )) 
FALSE  TRUE 
   70    57
70个文件，57个文件夹。






ref:
http://www.360doc.com/content/18/0425/07/21698478_748532218.shtml
https://www.r-bloggers.com/2021/05/working-with-files-and-folders-in-r-ultimate-guide/




========================================
|-- R的底层读写函数: 连接(Connection)
----------------------------------------
1. 连接(Connection)
连接(connect)是R语言中用于多种I/O操作的基本机制。R提供了9种函数用于为不同输入建立连接，file/url/gzfile/bzfile/xzfile/unz/pipe/fifo/socketConnection，基本上从名字上就能看出这些函数的使用场景。

举个例子，如果想要爬取一个网页，我们可以用url构建目标站点的连接

url_con <- url(description="http://www.baidu.com", open="r", encoding = "UTF-8")
class(url_con)
[1] "url"        "connection"
该url_con就可以作为read.table/readLines的文件参数。

上述的description就是指用于将要被建立的连接，可以是一个文件名或URL地址，例子中用的就是一个URL。也可以是其他类型输入。


(2) 如果需要在命令行中使用R脚本，让R读取管道的输入，就是"stdin"
std_in <- file("stdin", "r")


例:
$ cat test.R 
std_in <- file("stdin", "r")
arr=readLines(std_in)
print(arr)
close(std_in)

$ echo "who are you" | Rscript test.R 
[1] "who are you"


(3) 如果要读取剪切板的内容，则是"clipboard"
clip_text <- file("clipboard", "r")  #对Rstudio server，不靠谱

其最终返回一个"connection"对象。







2. "特殊"连接
这里的"特殊"连接指的是不怎么用的到建立连接的方式，可能在某些特殊的情况下使用。

(1) 场景一: 从控制台(console)里获取输入
我们可以用stdin()来从console中获取输入

> a <- readLines(stdin(), n=2)
hello
Tom
> a
[1] "hello" "Tom"
这里的n=2表示读取两行的输入。该方法不能用于shell命令行读取管道的输入

与stdin()对应的还有stdout()，stderr()和nulffile()，这几个命令很少使用。



(2) 场景二: 从复制的文本中获取输入
使用clipboard有些时候不清楚自己到底会从剪切板里读取什么样的输入，而且Linux命令行未必有X11支持，所以更好的方法是能够将文本粘贴到脚本中，然后进行读取。

为了解决这一问题，我们需要借助于textConnection将字符串中转成连接。

tmp <- "a   b   c   d
1   1   1   B
2   1   2   C
3   1   3   C
4   1   4   C
5   1   5   B
6   1   6   B
7   1   7   C
8   1   8   A
9   1   9   B
10  1   10  C
"
df <- read.table(textConnection(object = tmp),sep="\t", header = T) #如果只有一列，尝试换成 sep=""
和textConnection类似的，还有一个rawConnection用于构建raw对象的连接






3. 读取/输出函数
构建的连接取决于模式可以进行读取和输出操作。R自带函数中和读取/输出相关的可以分成两类

文本模式: readLines, writeLines, cat, sink, scan, parse, read.dcf, dput, dump

二进制模式: readBin, readChar, writeBin, writeChar, load, save

连接管理
对于连接对象，除了读写以外，还有一些列的函数用于查看和管理连接。

open: 打开连接
close(): 关闭连接
seek(): 在连接中进行跳转
isOpen判断连接是否打开
isIncomplete判断连接的读取最后一次是否完整， 写出时是否有未输出的内容
flush刷新连接的输出流，保证内容都完全写出。用close()安全的关闭连接
showConnections: 显示目前的所有连接
getConnection: 获取指定连接
closeAllConnections: 关闭所有连接

大部分函数都不好找到使用场景，除非你要编写某些数据类型的读取函数。






ref:
https://xuzhougeng.top/archives/R-basic-Input-Output-function








========================================
日志: 时间 Time/timezone、sink()函数
----------------------------------------
1. 获取时间，设置时区
> now=Sys.time();now
[1] "2020-04-17 10:52:38 CST"

> as.numeric(now)
[1] 1587091959
> as.numeric(Sys.time()) #时间戳，单位是秒
#[1] 1638604184

> str(now)
 POSIXct[1:1], format: "2020-04-17 10:52:38"
#


(1) 在循环中显示进度条和耗时
start=as.numeric(Sys.time())
for(i in 1:100){
  if(i%%10==0){
    print(paste(i, '; Elapse', round(as.numeric(Sys.time())-start,2), 'seconds'))
  }
  
  # time consuming task
  Sys.sleep(0.05) #休眠0.05s
}




(2) 修改时区
你可能发现输出的时间和windows右下角不一致。这主要时区不一致导致的。

> Sys.time() #现在的时间
# [1] "2021-12-04 07:49:19 UTC"

> Sys.timezone() #查看当前时区
# [1] "Etc/UTC"

> OlsonNames() #所有R支持的时区
> OlsonNames()[grep("Shanghai", OlsonNames())]
#[1] "Asia/Shanghai"


# 改变时区
> Sys.setenv(TZ = "Asia/Shanghai")
> Sys.timezone() # 查看时区
#"Asia/Shanghai"
> Sys.time() #现在的时间和windows右下角一致了
# [1] "2021-12-04 15:59:50 CST"


# https://statisticsglobe.com/change-default-time-zone-r
# https://www.r-bloggers.com/2018/07/a-tour-of-timezones-troubles-in-r/
# https://stackoverflow.com/questions/6374874/how-to-change-the-default-time-zone-in-r





2. 时间和字符串的转换
(1). 时间字符串变时间戳
#包装成函数形式
timeString2stamp=function(timeStr){
  #as.numeric(as.POSIXlt("2020-04-13 23:00:00 CST"));
  as.numeric(as.POSIXlt( paste0('2020-',timeStr,":00:00 CST") ));
}
timeString2stamp('04-13 23') #[1] 1586790000


(2). 时间戳变日期格式
> as.Date(as.POSIXct(1587322649, origin="1970-01-01"))
[1] "2020-04-19"

完整形式: //为什么日期不一样，上面是19日，下面是20日？
as.POSIXct(1587322649, origin="1970-01-01")
[1] "2020-04-20 02:57:29 CST"





3. 用时间戳新建目录、sink记录参数日志
每次使用函数所用的参数都不同，因此需要一些方法能够将每次这些不同的结果以及参数存储起来。

(1). 首先使用一个R内置的时间函数Sys.time()：
> Sys.time()
[1] "2021-01-02 10:27:37 CST"

#这里更改设置，输出成自己喜欢的格式：
> format(Sys.time(), '_%Y_%b_%dth_%H_%M')
[1] "_2021_Jan_02th_10_28"


#因此，可以每次程序都能够新建一个以时间为名称的文件夹（避免重复问题） 
dir = '/media/Research/RData/Gene_Data_Mining/' 
Gene_DIR = paste(dir, GeneName, format(Sys.time(), '_%Y_%b_%dth_%H_%M'),'/', sep = '') 
dir.create(Gene_DIR)  #创建目录
setwd(Gene_DIR)




(2) 更方便记录日志的时间形式
> format(Sys.time(), '_%Y%m%d_%H%M%S')
[1] "_20220701_110029"

> format(Sys.time(), '%Y%m%d_%H%M%S')
[1] "20220701_110035"

> format(Sys.time(), '[%Y%m%d_%H%M%S]')
[1] "[20220701_110046]"




# simple1
now=function(){
  format(Sys.time(), '[%Y%m%d_%H%M%S]')
}
# test
message(now(), "warning:", "xxx") #[20220701_110759]warning:xxx




# simple2
now=function(style=3){
  switch(
    EXPR = style,
    "1"={format(Sys.time(), '_%Y%m%d_%H%M%S')},
    "2"={format(Sys.time(), '%Y%m%d_%H%M%S')},
    "3"={format(Sys.time(), '[%Y%m%d_%H%M%S]')},
    stop("Invalid style. Please choose one of 1,2,3")
  )
}
# test
now(1) #"_20220701_111522"
now(2) #"20220701_111525"
now(3) #"[20220701_111529]"
message(now(), "warning:", "xxx") #[20220701_111547]warning:xxx





(3). 接下来，使用一个sink函数，能够将该函数的参数记录下来：

Gene_Integrate_Analysis = function(GeneName, NSF_Cut = 0.3, 
                                   Standardize = c('mean','none', 'median'),
                                   GO_hgCutoff = 0.001,KEGG_hgCutoff = 0.01, PFAM_hgCutoff = 0.01, 
                                   QQ_Pos_Cut = 3.29, QQ_Neg_Cut = -3.29,
                                   Perm_Num = 10000, Perm_Pval_Cut = 0.001){

   #......   
   setwd(Gene_DIR)
  
  #write the log file
  sink('log.txt') ## 屏幕输出也会同步记录到文件中
  
  print(paste('Gene Name:', GeneName))
  print(paste('Non-specific filtering cutoff:', NSF_Cut))
  print(paste('Standardize method:', Standardize))
  print(paste('GO Hypergeometric Test cutoff:', GO_hgCutoff ))
  print(paste('KEGG Hypergeometric Test cutoff:', KEGG_hgCutoff ))
  print(paste('PFAM Hypergeometric Test cutoff:', PFAM_hgCutoff ))
  print(paste('GSEA analysis QQ plot Positive Cutoff: ', QQ_Pos_Cut)) 
  print(paste('GSEA analysis QQ plot Negative Cutoff: ', QQ_Neg_Cut))
  print(paste('GSEA analysis Permutation Number:', Perm_Num))
  print(paste('GSEA analysis Permutation Pvalue Cut:',Perm_Pval_Cut))
  
  sink()
}

这样我们就能够把每一次运用函数的参数及其相应结果都保存下来！





ref:
https://www.cnblogs.com/foreverycc/archive/2013/04/27/3046188.html
https://www.cnblogs.com/shalijiang/p/4523863.html











========================================
查看R环境中的变量 ls()、ls.str()
----------------------------------------
1.你希望知道目前工作空间中存在哪些已定义的变量和函数。
> ls()
[1] "a"  "fn" "x"  "y" 


(2) 则通过设定选项pattern(可简写为pat) 来筛选变量:
ls(pattern = "x")
ls(pat = "^m") #支持正则表达式






2.如果你除了变量名称以外还想对变量有更多的了解，那么你可以使用ls.str函数，该函数会返回变量的一些其他信息：
> ls.str()
a :  num [1:6] 0 48 48 100 150 250
fn : function (x, y)  
x :  num [1:1000, 1:30] -0.877 -0.746 1.376 0.238 0.109 ...
y :  num [1:1000, 1:2] 1.7688 0.5453 0.0449 0.8503 0.6149 ...

ls.str函数之所以写为ls.str，原因在于其功能既显示了所有变量的名称，又对所有变量使用了str函数。


(2)选项pattern在这里同样适用。
M <- data.frame(n1=c(1,2), n2=c(20,30), m=c('A','B'))
ls.str(pat = "M")


(3) 按照mode显示现有数据

> ls.str(mode = "function") 
fn : function (x, y)

> ls.str(mode = "list") 
M : 'data.frame':	2 obs. of  3 variables:
 $ n1: num  1 2
 $ n2: num  20 30
 $ m : Factor w/ 2 levels "A","B": 1 2
#






3. ls函数不会显示以点（.）开头的变量名，以点开头的变量一般作为隐藏变量不为用户所知（这一输出规定来源于UNIX系统）。在R软件中，可以通过将ls.str函数中的all.names参数设定为TRUE，强制列出所有变量：
> ls(all.names=TRUE)
[1] ".hidvar"      ".Random.seed" "a"            "fn"           "x"            "y" 


> ls.str(all.names=TRUE)
.hidvar :  num 10
.Random.seed :  int [1:626] 10403 427 1930864435 1259062582 -539819294 -2087501084 1001909850 -1788871087 1372516555 1104797631 ...
a :  num [1:6] 0 48 48 100 150 250
fn : function (x, y)  
x :  num [1:1000, 1:30] -0.877 -0.746 1.376 0.238 0.109 ...
y :  num [1:1000, 1:2] 1.7688 0.5453 0.0449 0.8503 0.6149 ...















========================================
R高级教程: What They Forgot to Teach You About R
----------------------------------------
https://rstats.wtf/


1. 复杂对象
(1)
library(here)

saveRDS(my_precious, here("results", "my_precious.rds")) #保存对象
my_precious <- readRDS(here("results", "my_precious.rds")) #读取对象



(2) 使用相对路径
library(ggplot2)
library(here)

df <- read.delim(here("data", "raw_foofy_data.csv"))
p <- ggplot(df, aes(x, y)) + geom_point()
ggsave(here("figs", "foofy_scatterplot.png"))







========================================
极客篇： R 疑难杂症 刁钻问题
----------------------------------------
1. “=”、“<-”、“<<-” ，三者有什么区别，分别在什么时候用？




2. R 核心包

R语言同其他语言一样，在软件启动时，为我们提供了7个核心包，包括了众多的基础函数，如 数学计算函数，统计计算函数，日期函数，包加载函数，数据处理函数，函数操作函数，图形设备函数等。

> search()
 [1] ".GlobalEnv"        "tools:rstudio"     "package:stats"     "package:graphics" 
 [5] "package:grDevices" "package:utils"     "package:datasets"  "package:methods"  
 [9] "Autoloads"         "package:base"
#

这7个核心包，就是我们构建复杂模型的基础。由于这几个核心包比较底层，很多函数都是用C语言封装的没有R的源代码，而且除了官方文档，几乎没有其他更详细的文档介绍，所以这几个核心包就是学习的门槛，不要觉得某些函数会用了就行了，背后还有更深一层意义。


问题，R的所有操作都是函数操作，那么“a<-1:10” 语句会被解析对应什么函数？
> a<-1:10;a
[1] 1 2 3 4 5 6 7 8 9 10

答案是，"1:10"对应"seq()“，”<-“对应assign()。
> assign('b',seq(1:10));b
[1] 1 2 3 4 5 6 7 8 9 10


掌握这种对应关系的意义在于，因为R是解释型语言，我们可以通过传递一个函数A的句柄，让其他的函数B动态调用这个函数A，这就是动态语言中的闭包特性的使用思路。在Javascript中，已经被广泛使用了，但在R语言中，却只有核心包的一些函数在使用这种语法。在R语言中，这种需要有计算机背景知识的地方还有很多，特别是在考虑如何提升R性能的部分。所以，不要太轻易就说自己掌握了R语言，多想想如何才能把其他语言的基础带到R语言的世界里。

#实例: 可以传递函数给另一个函数
add=function(a,b){a+b}
multiply=function(a,b){a*b}
doOperator=function(operator, a, b){
  operator(a,b)
}
doOperator(add, 2,3) #5
doOperator(multiply, 2,3) #6

wjl评论：这个好像不叫闭包。这个虽然在js中很普遍，只是函数时以及公民的体现。
闭包是函数的子函数直接返回，从而可以调用母函数内的变量，但是其他地方无法访问这些变量的情况。




3.R语言的内核编程

R语言的内核编程，又是一个比较复杂的计算机学科的问题。R的内核编程应该包括哪些内容呢，除了刚才说的R的语法和R的核心包，还有面向对象编程，向量化计算，特殊数据类型，环境空间等。


(1) 向量化计算，是R语言特有的一种并行计算方式。
在R中，向量是R的基本数据类型(vector)，当你对一个向量进行操作时，程序会对向量中每个元素进行分别计算，计算结果以向量的形式返回。比如，最常见的两个等长的向量相加。
> 1:10+10:1
[1] 11 11 11 11 11 11 11 11 11 11


向量化计算，在R中有很广泛的应用场景，基本可以取代循环计算，高效的完成计算任务。我们定义两个向量，先相加再求和，run1()函数用向量化计算实现，run2()用循环方法实现。


a<-1:100000
b<-100000:1
run1<-function(){ # 向量化计算
  sum(as.numeric(a+b))
}

run2<-function(){ # 循环计算
  c2<-0
  for(i in 1:length(a)){
    c2<-c2 + a[i]+b[i]
  }
  c2
}

system.time(run1())
#user  system elapsed 
# 0.001   0.001   0.000
system.time(run2())
#user  system elapsed 
# 0.013   0.000   0.012



(2) OOP 
S3类型，S4类型，RC类型分别对应R语言支持的三种面向对象编程的数据结构。



(3) 
环境类型(environment)，由内核定义的一个数据结构，由一系列的、有层次关系的框架(frame)组成，每个环境对应一个框架，用来区别不同的运行时空间(scope)。

环境空间，在进行R包开发时，是必备的一个知识点。每个环境空间都是环境类型的一个实例。每个R包都会被加载到一个环境空间中，形成有层次关系的、可调用的空间结构。

我们定义的函数和变量，都会存在于R的环境空间中，通过ls()就可以看到当前环境空间中的这些变量，比如，刚才量向化计算定义的变量和函数。


除了我们自己定义的变量和函数，环境空间中还有很多其他的变量和函数，比如sum(), length(), system.time()等，这些函数我们可以直接使用，但是它们并不在当前环境空间中，所以直接用ls()是查看不到的。当我们切换到base的环境空间时，就可以找到sum()的函数定义了。
> ls(pattern="^sum$",envir=baseenv()) #sum

由于缺少文档，同时R核心技术的不普及。






4. R语言包的开发

(1) R包既要符合R语言，又要符合CRAN的要求。

技术问题虽然难，花时间还是可以解决的，但想要在CRAN上发布，那就只能用“难于上青天”来形容了。R语言发展了20多年，只有5000多个包在CRAN上发布，审核不是一般严格啊！我写的gridgame游戏包和chinaWeather天气包，改了很多次，都没能通过，都到了要放弃的边缘了。

换个角度想，只有审核严格才能保证用户在安装第三方的R包时候不会出错。由于CRAN的审核过于严格，Hadley Wickham也受不了了，又开发了devtools包，不仅提供了简化R包的开发的工具函数，还支持Github社区发布。这样就可以脱离CRAN的束缚，以个人的名义发布各种奇思妙想的R包。



(2) 强大的元编程（metaprogramming）工具。
R语言的元编程功能可以让你写出简洁而神奇的函数，并为设计特定领域的语言（domain-specific language）（例如ggplot2、dplyr、data.table等）提供了出色的环境。

元编程是一把双刃剑。有太多的R函数通过使用一些技巧来减少代码的输入量，由此造成的结果就是使代码变得很难理解，有些还会以意想不到的方式失败。

欣赏元编程这把双刃剑。你将能在遵守原则的前提下使用tidy运算（tidy evaluation）来创建函数，从而减少代码的输入量并创建优雅的代码来表达重要的运算，还将理解元编程的危险并知道何时避免它。





(3)
使用新的R包，如rlang（http：//rlang.r-lib.org）和purrr（http.//purrr.tidyverse.org／）进行函数式编程。包rlang为低级操作提供了简洁的接口。


(4) 开发基于C/C++的扩展包
提高R语言的执行效率，一个比较简答的方法就是把复杂的工作留给C/C++在低层完成。




5. R语言的虚拟机

终于到我不熟悉话题了，已我3年多R语言使用经验来说，还碰不到R语言的虚拟机。不过，网上看到很多高手在生产环境都会重新编译R软件，比如 用OpenBLAS加速R的矩阵运算，在虚拟机层实现矩阵的并行化计算，也有用GPU实现矩阵并行计算的；还有牛人把R实现的各种算法，都用C++重新实现，然后通过Rcpp封装，直接与R的虚拟机进行连接调用。

我看着各种大神走远不送了，希望他们把虚拟机优化好了，免费发布个补丁包什么的。







========================================
R语言中高级难度面试题
----------------------------------------
1. 2023 R 初级
https://www.cnblogs.com/xiaomandujia/p/17927858.html
* 请解释一下R语言是什么？它的主要特点和用途是什么？
* R语言中的向量（vector）是什么？请举例说明如何创建和操作向量。
* 请介绍一下R语言中的数据框（data frame）是什么？它与矩阵（matrix）有什么区别？
* R语言中的因子（factor）是什么？它在数据分析中有什么作用？
* 请解释一下R语言中的函数（function）是什么？如何定义和调用函数？
* R语言中如何进行数据的读取和导入？请举例说明如何读取CSV文件。
* 请介绍一下R语言中的条件语句（if-else语句）是什么？如何使用条件语句进行逻辑判断？
* R语言中的循环结构有哪些？请举例说明如何使用for循环和while循环。
* 请解释一下R语言中的向量化操作（vectorized operation）是什么？它的优势是什么？
* R语言中的数据可视化工具有哪些？请举例说明如何使用ggplot2包进行数据可视化。



2.2023 R 中级
https://www.cnblogs.com/xiaomandujia/p/17929126.html
* 请解释一下R语言中的向量（vector）和列表（list）有什么区别？
* 在R语言中，如何使用apply()函数来对一个数据框的每一列应用同一个函数？
* 请说明一下R语言中的因子（factor）变量是如何工作的，并举一个例子进行说明。
* R语言中的循环结构有哪些？请举例说明如何使用for循环来遍历一个向量。
* 如何在R语言中读取并处理大型的数据集，以避免内存溢出的问题？
* R语言中的正则表达式是什么？请举例说明如何使用正则表达式来匹配和替换字符串。
*  请解释一下R语言中的NA值是什么，并举一个例子说明如何处理含有NA值的数据。
* R语言中的数据透视表（pivot table）是什么？请举例说明如何使用reshape2包中的dcast()函数创建数据透视表
* 在R语言中，如何使用ggplot2包来创建一个漂亮的统计图形？
* 请解释一下R语言中的函数式编程是什么，并举一个例子说明如何使用函数作为参数传递给另一个函数。



3. 2023 R 高级
https://www.cnblogs.com/xiaomandujia/p/17929130.html

* 请解释一下R语言中的闭包（closure）是什么，并举一个例子说明如何使用闭包来实现柯里化（currying）函数。
* R语言中的高性能计算方法有哪些？请举例说明如何使用Rcpp包将C++代码集成到R中提高计算效率。
* 如何在R语言中进行大规模数据处理，并且使用data.table包进行高效的数据操作和聚合？
* 请解释一下R语言中的泛型编程（generic programming）是什么，并举一个例子说明如何使用S3和S4类定义自己的泛型函数。
* R语言中的并发编程方法有哪些？请举例说明如何使用future和promises包进行并发计算和异步编程。

* 如何在R语言中进行图像处理，并且使用OpenCV库进行图像增强、边缘检测和图像分割？
* 请解释一下R语言中的函数编译（function compilation）是什么，并举一个例子说明如何使用compiler包对函数进行即时编译优化。
* R语言中的多核并行计算方法有哪些？请举例说明如何使用parallel和doParallel包进行多核计算和任务调度。

* 如何在R语言中进行大数据分析，并且使用sparklyr包连接Apache Spark进行分布式计算和机器学习？
* 请解释一下R语言中的异步编程是什么，并举一个例子说明如何使用async和await包进行异步任务处理和并发控制。





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

