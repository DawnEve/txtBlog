grid 包简介：随心所欲的布局神器

主要内容：
	grid 来生成图形输出
	图形窗口的布局
	grid 函数来创建和操作图形对象




========================================
grid包简介
----------------------------------------
R 中主要存在两种绘图系统：
- base R 传统图像系统
- grid 图像系统
传统的图像系统是由 graphics 包所提供的一系列函数组成，grid 系统是 grid 包提供的

grid 包是一个底层的绘图系统，提供的都是底层的绘图函数，没有用于绘制复杂图形的高级函数。
像 ggplot2 和 lattice 两个顶层的绘图包都是基于 grid 系统的，所以，了解 grid 包对于理解 ggplot2 的顶层函数的工作方式是很有帮助的
同时，也可以使用 grid 包来灵活地控制图形的外观和布局

grid包能画图，还能控制布局。


Paul Murrell's Home Page: https://www.stat.auckland.ac.nz/~paul/



1. 官方资料
https://www.stat.auckland.ac.nz/~paul/grid/grid.html
https://www.stat.auckland.ac.nz/~paul/Talks/Tokyo/grid.pdf

Grid is an add-on package for the R language and environment for statistical computing and graphics. It provides a set of graphical functions which support a great deal of flexibility in the layout of graphics.

lattice 是基于 grid 的。

- type vignette() 


(2)
https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html
https://www.stat.auckland.ac.nz/~paul/RG2e/

- Part II of my forthcoming book R Graphics will contain the most comprehensive description of grid (in a single document) to date.  
	* https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html


- gridBase 包 能整个grid包和base包的图片。


(3) pdf/html 书
http://jse.amstat.org/v18n3/zhou.pdf
https://stat.ethz.ch/R-manual/R-patched/library/grid/doc/viewports.pdf
https://stat.ethz.ch/R-manual/R-patched/library/grid/html/00Index.html

开发文档
https://stat.ethz.ch/R-manual/R-devel/library/grid/doc/index.html

课程
https://www.stat.auckland.ac.nz/~paul/useR2011-grid/
https://www.stat.auckland.ac.nz/~paul/useR2011-grid/gridHandout.print.pdf






2. 其他资料
(1) 神仙级的解释：入门到深入
R 数据可视化 —— grid 系统（一） https://zhuanlan.zhihu.com/p/370904286
R 数据可视化 —— grid 系统（二） https://zhuanlan.zhihu.com/p/371124820


(2) 
https://bookdown.org/rdpeng/RProgDA/the-grid-package.html




========================================
grid包的绘图功能
----------------------------------------
1. grid 提供了一些函数用于绘制简单的图形

(1)基本上 base 有的在grid中都有对应。

# 文字
grid.text(label = "Let's us begin!")

# 圆圈
grid.circle(x=0.5, y=0.5, r=0.2) #默认是相对单位，0-1之间。

grid.circle(
  x=seq(0.1, 0.9, length=100),
  y=0.5 + 0.4*sin(seq(0, 2*pi, length=100)),
  r=abs(0.1*cos(seq(0, 2*pi, length=100)))
)



(2) 每一个功能还有对应的 生成对象 形式。

比如 grid.text() 函数的 声称对象 形式是 textGrob() 函数。

#
grid.rect() - creates a rectangle grob and draws it.
grid.circle() - creates a circle grob and draws it.
grid.polygon() - creates a polygon grob and draws it.
grid.text() - creates a text grob and draws it.
grid.lines() - creates a line segment and draws it.
#
rectGrob() - creates a rectangle grob but does not draw it.
circleGrob() - creates a circle grob but does not draw it.
polygonGrob() - creates a polygon grob but does not draw it.
textGrob() - creates a text grob but does not draw it.
linesGrob() - creates a line segment grob but does not draw it.
#
If we want to draw one of these grobs, we could use the grid.draw() function. 

画图函数 / 生成对象的函数: 功能
grid.move.to / moveToGrob: 设置当前位置
grid.line.to / lineToGrob: 绘制一条从当前位置到指定位置的线并
grid.line /linesGrob: 绘制直线
grid.segments/ segmentsGrob: 绘制线段
grid.rect/rectGrob: 在指定位置绘制矩形
grid.circle/circleGrob: 根据位置和半径绘制圆圈
grid.polygon/ polygonGrob: 根据顶点绘制多边形
grid.text/textGrob: 在指定位置和角度绘制文本
grid.arrows/ arrowsGrob: 绘制带箭头的线
grid.points/ pointsGrob: 绘制散点
grid.xaxis/xaxisGrob: 绘制x轴
grid.yaxis/yaxisGrob: 绘制y轴



# 例1: 画出 grid 对象
library(grid)

grid.newpage()
obj.text=textGrob("good")
grid.draw(obj.text)

tg <- textGrob('Title', y=0.7, gp = gpar(fontsize = 13, fontface = 'bold'));tg
sg <- textGrob('Subtitle', gp = gpar(fontsize = 10, col="red"));sg

grid.newpage()
grid.draw(tg)
grid.draw(sg)


# 或画到指定的视窗中
grid.newpage()
vp <- viewport(x=0.4,y=0.7,width=0.5,height=0.4) #默认是相对center
pushViewport(vp)
grid.rect()
grid.draw(obj.text)






# 例2: 修改grid对象
We can modify a grob by using the functions grid.edit() and editGrob(). 
We demonstrate this in the following example.

# First we construct a .1×.1 rectangle grob centered at (.5,.5) and called gr. We do not draw it yet.
gr <- rectGrob(width=0.1,height=0.1, name="gr")
# x= 0.5, y=0.5 by default.

# Now, we can use editGrob to make a copy of this rectangle, which will be put in a different place, centered at (.2,.6):
gr1 <- editGrob(gr, vp=viewport(x=0.2, y=0.6), name="gr1")

# Then we draw the copy using:
grid.newpage()
grid.draw(gr1)

# and we can create a 2nd rectangle, gr2, centered it at (.7,.75), and red color
gr2 <- editGrob(gr, vp=viewport(x=0.7, y=0.75), name="gr2", gp=gpar(col="red"))
grid.draw(gr2)

# We can create a third rectangle, gr3 centered at(.5,.4), rotate 30 degree, bold line
gr3 <- editGrob(gr, vp=viewport(x=0.5, y=0.4, angle =30), name="gr3", 
                gp=gpar(lwd=3, lty=2))
grid.draw(gr3)








(3) grid包的所有函数
一共212多个。
> rs=ls("package:grid");
> length(rs) #共212个

其中 带有 grid.前缀的有 68个，大多是可以直接画图的。
> rs[grep("grid.", rs)]
 [1] "grid.abline"          "grid.add"             "grid.arrows"          "grid.bezier"          "grid.cap"            
 [6] "grid.circle"          "grid.clip"            "grid.collection"      "grid.convert"         "grid.convertHeight"  
[11] "grid.convertWidth"    "grid.convertX"        "grid.convertY"        "grid.copy"            "grid.curve"          
[16] "grid.delay"           "grid.display.list"    "grid.DLapply"         "grid.draw"            "grid.edit"           
[21] "grid.force"           "grid.frame"           "grid.function"        "grid.gedit"           "grid.get"            
[26] "grid.gget"            "grid.grab"            "grid.grabExpr"        "grid.gremove"         "grid.grep"           
[31] "grid.grill"           "grid.grob"            "grid.layout"          "grid.legend"          "grid.line.to"        
[36] "grid.lines"           "grid.locator"         "grid.ls"              "grid.move.to"         "grid.multipanel"     
[41] "grid.newpage"         "grid.null"            "grid.pack"            "grid.panel"           "grid.path"           
[46] "grid.place"           "grid.plot.and.legend" "grid.points"          "grid.polygon"         "grid.polyline"       
[51] "grid.pretty"          "grid.raster"          "grid.record"          "grid.rect"            "grid.refresh"        
[56] "grid.remove"          "grid.reorder"         "grid.revert"          "grid.roundrect"       "grid.segments"       
[61] "grid.set"             "grid.show.layout"     "grid.show.viewport"   "grid.strip"           "grid.text"           
[66] "grid.xaxis"           "grid.xspline"         "grid.yaxis" 
> rs1=rs[grep("^grid.", rs, invert = T)]; length(rs1) #剩下144


而带有 Grob 后缀的有36个，都是生成作图对象。
> rs1[grep("Grob$", rs1)]
 [1] "addGrob"       "arrowsGrob"    "bezierGrob"    "circleGrob"    "clipGrob"      "curveGrob"     "delayGrob"     "editGrob"     
 [9] "forceGrob"     "frameGrob"     "functionGrob"  "getGrob"       "legendGrob"    "linesGrob"     "lineToGrob"    "moveToGrob"   
[17] "nullGrob"      "packGrob"      "pathGrob"      "placeGrob"     "pointsGrob"    "polygonGrob"   "polylineGrob"  "rasterGrob"   
[25] "recordGrob"    "rectGrob"      "removeGrob"    "reorderGrob"   "roundrectGrob" "segmentsGrob"  "setGrob"       "showGrob"     
[33] "textGrob"      "xaxisGrob"     "xsplineGrob"   "yaxisGrob"
> rs1=rs1[grep("[Gg]rob", rs1, invert = T)]; length(rs1)  #剩下95个



单位函数 10 个
> rs1[grep("unit", rs1)]
> rs1[grep("unit", rs1, ignore.case = T)]
 [1] "convertUnit" "is.unit"     "unit"        "unit.c"      "unit.length" "unit.pmax"   "unit.pmin"   "unit.psum"   "unit.rep"   
[10] "unitType"
> rs1=rs1[grep("unit", rs1, invert = T,  ignore.case = T)]; length(rs1)  #剩下85个


viewport 函数 13个
> rs1[grep("[Vv]iewport$", rs1)]
[1] "current.viewport" "dataViewport"     "downViewport"     "editViewport"     "plotViewport"     "pop.viewport"     "popViewport"     
[8] "push.viewport"    "pushViewport"     "seekViewport"     "showViewport"     "upViewport"       "viewport" 
> rs1=rs1[grep("[Vv]iewport$", rs1, invert = T)]; length(rs1)  #剩下72个

> rs1
 [1] "absolute.size"       "applyEdit"           "applyEdits"          "arcCurvature"        "arrow"               "ascentDetails"      
 [7] "bezierPoints"        "calcStringMetric"    "childNames"          "convertHeight"       "convertNative"       "convertWidth"       
[13] "convertX"            "convertY"            "current.parent"      "current.rotation"    "current.transform"   "current.vpPath"     
[19] "current.vpTree"      "depth"               "descentDetails"      "deviceDim"           "deviceLoc"           "draw.details"       
[25] "drawDetails"         "editDetails"         "emptyCoords"         "engine.display.list" "explode"             "gEdit"              
[31] "gEditList"           "get.gpar"            "getNames"            "gList"               "gpar"                "gPath"              
[37] "gTree"               "heightDetails"       "isEmptyCoords"       "layout.heights"      "layout.torture"      "layout.widths"      
[43] "layoutRegion"        "linearGradient"      "makeContent"         "makeContext"         "nestedListing"       "pathListing"        
[49] "pattern"             "postDrawDetails"     "preDrawDetails"      "radialGradient"      "resolveHJust"        "resolveRasterSize"  
[55] "resolveVJust"        "setChildren"         "stringAscent"        "stringDescent"       "stringHeight"        "stringWidth"        
[61] "valid.just"          "validDetails"        "viewport.layout"     "viewport.transform"  "vpList"              "vpPath"             
[67] "vpStack"             "vpTree"              "widthDetails"        "xDetails"            "xsplinePoints"       "yDetails" 








========================================
|-- 坐标系统: unit对象
----------------------------------------
在grid包中，unit对象用于表示：长度和单位。
grid 的坐标系统是用来确定数值的单位，同样的数值在不同的单位中表示不同的大小，看起来叫单位系统应该会更恰当些。

1. 坐标系统的单位
unit对象: 用unit对象表示长度的大小和单位：
unit(x, units, data=NULL)
参数注释：
	x：数值向量
	units：单位向量


坐标系统：描述
native: 位置和大小相对于当前 viewport 的x、y轴的范围
npc: 定义当前 viewport 的左下角(0,0)，右上角(1,1)
snpc: 位置和大小被表示为当前 vewport 的宽度和高度中更小的值的比例
inches: 英寸，(0,0)表示 viewport 的左下角
cm: 厘米
mm: 毫米 
points: 点，每英寸相当于 72.27 个点
bigpts: 大点，每英寸相当于72个大点
picas: 1 pica 相当于12个点
dida: 1157 个 dida 相当于 1238 个点
cicero: 1 cicero 相当于 12 个 dida
scaledpts: 相当于一个点的 65536 分之一
char: 相当于字体大小为单位(由 fontsize 和 cex 确定)
lines: 相当于以线条高度为单位(由 fontsize, cex, lineheight 确定)
strwidth, strheight: 相当于以字符串的宽高为单位(由 fontsize, cex, fontfamily, fontface 确定)
grobwidth, grobheight: 以给定图形对象的宽高位单位。


(1)使用 unit 函数来设置不同的系统
> unit(1, "cm")
[1] 1cm
> unit(1:4, "mm")
[1] 1mm 2mm 3mm 4mm
> unit(1:4, c("npc", "mm", "native", "lines"))
[1] 1npc    2mm     3native 4lines 



(2) 坐标系统之间的运算将会以表达式的方式返回
> unit(1:4, "mm")[1] - unit(1:4, "mm")[4]
[1] -3mm
> unit(1, "npc") - unit(1:4, "mm")
[1] sum(1npc, -1mm) sum(1npc, -2mm) sum(1npc, -3mm) sum(1npc, -4mm)
> max(unit(1:4, c("npc", "mm", "native", "lines")))
[1] max(1npc, 2mm, 3native, 4lines)



(3) 对于字符串及对象长度坐标系统
> unit(1, "strwidth", "some text")
[1] 1strwidth
> unit(1, "grobwidth", textGrob("some text"))
[1] 1grobwidth

有对应的简便函数可以使用
> stringHeight("some text")
[1] 1strheight
> grobHeight(textGrob("some text"))
[1] 1grobheight



(4) 可以使用 convertWidth 和 convertHeight 实现单位之间的转换
> convertHeight(unit(1, "cm"), "mm")
[1] 10mm
> convertHeight(unit(1, "dida"), "points")
[1] 1.07000864304235points
> convertHeight(unit(1, "cicero"), "points")
[1] 12.8401037165082points
> convertHeight(unit(1, "cicero"), "dida")
[1] 12dida
> convertHeight(unit(1, "points"), "scaledpts")
[1] 65536scaledpts
> convertWidth(stringWidth("some text"), "lines")
[1] 3.61246744791667lines
> convertWidth(stringWidth("some text"), "inches")
[1] 0.722493489583333inches


(5) 对于一个图形对象，如果修改了图形对象属性，则对应的大小也会改变
> grid.text("some text", name="tgrob")
> convertWidth(grobWidth("tgrob"), "inches")
[1] 0.722493489583333inches
# 修改图形对象的 fontsize 属性
> grid.edit("tgrob", gp=gpar(fontsize=18))
> convertWidth(grobWidth("tgrob"), "inches")
[1] 1.083740234375inches


(6) 我们可以使用不同的单位系统来绘制一个矩形
grid.rect(
  x=unit(0.5, "npc"), 
  y=unit(1, "inches"),
  width=stringWidth("very snug"), 
  height=unit(10, "lines"), 
  just=c("left", "bottom")
)






2. 设置坐标轴的数字范围

library(grid)
plotvp <- viewport(x=unit(5, "lines"),
                   y=unit(5, "lines"),
                   width =unit(1, "npc") - unit(8, "lines"),
                   height=unit(1, "npc") - unit(8, "lines"),
                   just=c("left", "bottom"),
                   xscale=c(0, 4),
                   yscale=c(0, 4),
                   name="plotRegion")
grid.newpage()
pushViewport(plotvp)
# showViewport(plotvp)#可视化

# 边框
grid.rect(x=0.5, y=0.5, width=1, height=1)

# 画点
grid.points(1:3, 1:3, default.units="native")


# 添加坐标轴
grid.xaxis(at=0:4)
grid.yaxis(at=0:4)











========================================
|-- 设置 图形参数: gpar()对象
----------------------------------------
grid包使用gpar对象用于设置 图形参数。


1. 所有的图形原语函数都有一个 gp(graphical parameters) 参数，用来接收一个 gpar 对象，该对象包含一些图形参数用于控制图像的输出

(1) gpar 对象可以使用 gpar() 函数来生成，例如
> gpar(col="red", lty="dashed")
$col
[1] "red"

$lty
[1] "dashed"


(2) 这些图形参数包括
参数: 描述 
	col: 线条、文本、矩形边框等的颜色
	fill: 矩形、圆形、多边形的填充色
	gamma: 颜色的 gamma 校正值
	alpha: 不透明度。越大越不透明: 0完全透明，1完全不透明
	lwd: 线条宽度
	lex: 线条扩展乘子
	lty: 线条类型
	lineend: 线段点类型：round, butt, square 
	linejoin: 线连接点类型: round, mitre, bevel 
	linemitre: 线条斜率限制
	cex: fontsize 的扩展乘子
	fontsize: 字体大小(points)
	fontface: 字体样式(bold, italic/oblique, plain, bold.italic 或整数1-4)
	fontfamily: 字体家族
	lineheight: 线高

用gapr对象表示图形参数：
	col: Colour for lines and borders.
	fill: Colour for filling rectangles, polygons, ...
	alpha: Alpha channel for transparency
	lty: Line type
	lwd: Line width
	lex: Multiplier applied to line width
	lineend: Line end style (round, butt, square)
	linejoin: Line join style (round, mitre, bevel)
	linemitre: Line mitre limit (number greater than 1)
	fontsize: The size of text (in points)
	cex: Multiplier applied to fontsize
	fontfamily: The font family
	fontface: The font face (bold, italic, ...)
	lineheight: The height of a line as a multiple of the size of text
	font: Font face (alias for fontface; for backward compatibility)




(3) 使用 get.gpar 可以获取当前图形参数的值，如果未指定要获取的参数，将会返回所有的参数值
> get.gpar(c("lty", "fill"))
$lty
[1] "solid"

$fill
[1] "white"


(4) 因此，我们可以在绘制图像时，传递 gp 参数来设置图像参数
grid.newpage()
grid.rect(
  x=0.66, 
  height=0.7, 
  width=0.2,
  gp=gpar(fill="blue")
)

grid.rect(
  x=0.33, 
  height=0.7, 
  width=0.2
)

# alpha 不透明度，越大越不透明
grid.rect(x=0.4, y=0.8, height=0.2, width=0.9, gp=gpar(fill="red", alpha=0.8))
grid.rect(x=0.4, y=0.2, height=0.2, width=0.9, gp=gpar(fill="red", alpha=0.2))



# 例2: 画一个近大远小的走廊效果，填充色完全透明
grid.newpage()
pushViewport(viewport())
grid.lines(c(.05, .95), c(.95, .05))
grid.lines(c(.05, .95), c(.05, .95))

for (i in 1:60) {
  vp <- viewport(h=.9, w=.9, gp=gpar(fill="#FFFFFF00"))
  pushViewport(vp)
  grid.rect()
}





(5) 在 grid 中，cex 参数是累积的，也就是说当前的 cex 值等于当前设置的值乘上之前的 cex 值
例如
pushViewport(viewport(gp=gpar(cex=0.5)))
grid.text("How small do you think?", gp=gpar(cex=0.5))
# 在一个 viewport 中设置了 cex = 0.5，之后的文本又设置了 cex = 0.5，最后文本的大小就是 0.5*0.5 = 0.25

alpha 参数与 cex 类似，也是累积的





(6) 传入向量
注意: 这些图形参数都可以接受一个向量值，比如，你可以将一个颜色向量传递给 col 或 fill 参数，如果向量的长度小于绘制的图形的个数，则参数会进行循环赋值

如，我们绘制 100 个圆形，但是只传递了一个长度为 50 的颜色向量给 col 参数

grid.newpage()
grid.circle(
  x = seq(0.1, 0.9, length=100),
  y = 0.5 + 0.4*sin(seq(0, 2*pi, length=100)),
  r = 0.01, #abs(0.1*cos(seq(0, 2*pi, length=100))),
  gp = gpar(col=rainbow(50))
)





(7) 对于多边形 grid.polygon() 函数，有一个 id 参数可以将多边形的点进行分组，如果某一分组点中包含 NA 值，则又会将在 NA 处将点分为两组

grid.newpage()
# 设置均等分的角度，并删除最后一个角度
angle <- seq(0, 2*pi, length=11)[-11]

grid.polygon(
  x = 0.25 + 0.2*cos(angle), 
  y = 0.5 + 0.3*sin(angle),
  id = rep(1:2, c(7, 3)),
  gp = gpar(
    fill=c("grey", "white")
    )
  )

# 将其中一个角度设置为 NA
angle[4] <- NA

grid.polygon(
  x = 0.75 + 0.2*cos(angle), 
  y = 0.5 + 0.3*sin(angle),
  id = rep(1:2, c(7, 3)),
  gp = gpar(
    fill=c("grey", "white")
    )
  )

从图中可以看出，本来根据 id 值分为两组，第一组为灰色填充，第二组为白色填充。
但是在添加 NA 之后，在 NA 处将 id 为 1 的分组又一分为二，但是填充色还是灰色，并不是接续白色




========================================
|-- 快速入门： grid 基本图形(Basic Shapes) 与 viewport 布局
----------------------------------------
1. The following basic shapes can be drawn using grid:

circles 
	grid.circle(x, y, r)
lines 
	grid.lines(x, y)
	grid.segments(x0, y0, x1, y1)
	grid.polylines(x, y, id)
rectangles 
	grid.rect(x, y, width, height)
	grid.roundrect(x, y, width, height, r)
text 
	grid.text(label, x, y)

polygons 
	grid.polygon(x, y, id)
	grid.path(x, y, id)

curves 
	grid.xspline(x, y, shape)
	grid.curve(x1, y1, x2, y2)

raster images 
	grid.raster(image, x, y, width, height)
data symbols 
	grid.points(x, y, pch)


(1) 示例
t <- seq(90, 0, -30)
x <- .2 + cos(t/180*pi)*.6
y <- .8 - sin(t/180*pi)*.6

grid.newpage()
grid.points(x, y, pch=19, gp=gpar(lwd=10, col="red")) #貌似不对 //todo

grid.circle(x, y, r=1:4/30) #画圆
grid.lines(x, y) #折线

grid.segments(.2, .8, x, y, arrow=arrow()) #带箭头的线段

grid.polyline(c(x+0.1, x - .1), c(y-0.1, y + .1), id=rep(1:2, each=4), gp=gpar(col="red")) #一次画2条线

grid.rect(x, y, width=.2, height=.1, just="bottom") #相对于点，画矩形

grid.roundrect(x[1], y[1], width=.4, height=.3, just=c("left", "bottom")) #圆角矩形



# Text can also be justified relative to x and y.
> LETTERS[1:4]
[1] "A" "B" "C" "D"
> grid.text(LETTERS[1:4], x, y, just=c("left", "bottom")) #添加文字，相对于点的左下方

grid.polygon(x, y) #多边形会自动闭合

grid.path(c(x, x - .1), c(y, y + .1), id=rep(1:2, each=4)) #路径，就是多个不连接的点连起来


# Xsplines describe a smooth curve relative to control points.
grid.xspline(x, y, shape=1) # 相对于控制点的光滑曲线

grid.curve(.2, .8, x, y, square=FALSE, curvature=.5, shape=1) #从一个点到某几个点的曲线


# Raster images can be vectors or matrices or (with help from an extension package) external files.
grid.raster(t(1:10/11), x, y, width=.2, interpolate=FALSE, just="bottom") # //todo 位置不对





2. 坐标(unit)与绘图参数(gp)

(1)单位：coordinate system.
The main coordinate systems are:
	"npc" Normalised Parent Coordinates
	"native" Relative to the current x-scale/y-scale
	"in" or "cm" Inches or centimetres
	"lines" Lines of text

> unit(1, "in")
[1] 1in
> unit(.2, "npc")
[1] 0.2npc
> grid.rect(width=unit(1, "in"), height=unit(.2, "npc"))

坐标可以进行基本的运算
> unit(1, "npc") - unit(1, "cm")
[1] 1npc-1cm
> grid.text("Label",
	x=unit(1, "npc") - unit(1, "cm"),
	y=unit(1, "npc") - unit(1, "cm"),
	just=c("right", "top"))

(2) 绘图参数 
Every basic shape has a gp argument that allows graphical parameters to be specified.
The main graphical parameters are:
	col colour (for borders)
	fill colour (for interiors)
	lwd line width
	lty line type
	cex text size multiplier

The gpar() function creates a list of graphical parameter settings.
> grid.circle(r=.3,
	gp=gpar(col="red", fill="pink",	lwd=3, lty="dashed"))



可以使用多个向量来提供绘图参数，这样每个图形都有自己的个性化属性。
When drawing multiple shapes with a single function call,
graphical parameter settings can be vectors so that different
shapes can have different appearances.

> hcl(1:3/2*180, 60, 60)
[1] "#90972B" "#00A698" "#9188D1"
# hcl(h = 0-360, c = 35, l = 0-100, alpha, fixup = TRUE) 
#hue, /chroma of the color, /lightness

> grid.circle(x=1:3/4, r=.3,
	gp=gpar(lwd=3,
		col=hcl(1:3/2*180, 60, 60),
		fill=hcl(1:3/2*180, 80, 80)))


练习: 画一个竖着的堆叠矩形，每个颜色逐步加深。
y1=1:10
prop <- function(x) {
  x/sum(x)
}
p1 <- prop( y1)
fills <- hcl(240, 60, seq(10, 100, 10))

grid.newpage()
grid.rect(x=0.5, y=cumsum(p1), width=0.2, height=p1, just="top",  gp=gpar(fill=fills))




3. viewport 就是一个可以画图的矩形

vp <- viewport(x=.5, y=.5,
	width=.5, height=.5,
	just=c("left", "bottom"))
pushViewport(vp)
grid.rect(gp=gpar(fill="grey"))

# 新推送的视口的尺寸和位置都相当于当前窗口
pushViewport(vp)
grid.rect(gp=gpar(fill="black"))


(1) 可以使用 popViewport 或 upViewport 返回上一个视口。
# 但是前者会删除当前视口，而后者不删除。推荐使用后者
popViewport(2)
pushViewport(viewport(width=.5, height=.5, just=c("right", "top")))
grid.rect(gp=gpar(fill="cyan"))


(2) 自带的坐标轴，单位是“native”
library(grid)
grid.newpage()
pushViewport(viewport(x=0.1, y=0.1, just=c("left", "bottom"), 
                      width=0.85, height=0.85,  
                      xscale=c(0, 4), yscale=c(0, 4)) )
grid.rect()
grid.points(unit(1:3, "native"), unit(1:3, "native"))
grid.xaxis()


(3) 视口也有 gp 属性，是该视口内对象的默认值
pushViewport(viewport(x=.5, y=.5,
	width=.5, height=.5,
	just=c("left", "bottom"),
	gp=gpar(lwd=3, col="green")))
grid.rect(gp=gpar(fill="grey"))



(4) 两个视口辅助函数，能简化坐标位置和标度的计算
The plotViewport() function creates a viewport with margins around the outside.
The dataViewport() function creates a viewport with the x-scale and y-scale based on data values.

x <- 1:10
y <- 1:10
grid.newpage()
pushViewport(plotViewport(c(4, 4, 2, 2)), dataViewport(x, y)) #
grid.points(x, y)
grid.xaxis()
grid.yaxis()
grid.rect(gp=gpar(fill="#00000000", lwd=2))


练习: 创建2个百分比图，然后再之间连线，显示百分比的变化。
y1=1:10
prop <- function(x) {
  x/sum(x)
}
p1 <- prop( y1)
fills <- hcl(240, 60, seq(10, 100, 10))

grid.newpage()
grid.rect(x=0.2, y=cumsum(p1), width=0.2, height=p1, just=c("left","top"),  gp=gpar(fill=fills))
grid.rect(x=0.6, y=cumsum(rev(p1) ), width=0.2, height=rev(p1), just=c("left","top"),  gp=gpar(fill=rev(fills) ))

# 难点：怎么连线？
grid.segments(0.4, cumsum(p1), 0.6, cumsum(rev(p1) ), gp=gpar(lwd=3))



# 方法2 使用3个视口
prop <- function(x) {
  x/sum(x)
}
cprop <- function(x) {
  cumsum( x/sum(x) )
}

spine <- function(x) {
	px <- prop(x)
	cpx <- cprop(x)
	grid.rect(y=cpx, height=px, just="top")
}

connector <- function(x1, x2) {
	cp1 <- cprop(x1)
	cp2 <- cprop(x2)
	grid.segments(0, cp1, 1, cp2)
}

//todo 






4. 布局 A layout divides a viewport into rows and columns

lyt <- grid.layout(1, 3, widths=unit(c(1, 1, 1), c("null", "in", "null")))

pushViewport(viewport(layout=lyt))
pushViewport(viewport(layout.pos.col=3))
grid.rect(gp=gpar(fill="grey"))


练习：使用布局重做3的练习。






5. Viewports 的树状结构和导航
Viewports can have names and a record is kept of all viewports on the page.
- The upViewport() function reverts to the parent viewport context, but leaves the current viewport on the page.
- The current.viewport() function shows the current viewport.
- The current.vpTree() function shows all viewports on a page.
- The downViewport() function can be used to return to an existing viewport on the page.

# Use upViewport() not popViewport(). Leave your viewports for others to use.
查看视口 showViewport()


vp <- viewport(x=.5, y=.5,
		width=.5, height=.5,
		just=c("left", "bottom"),
		name="top-right-vp")
pushViewport(vp)
grid.rect(gp=gpar(fill="grey"))

# 返回上一层，并画红边
upViewport()
grid.rect(gp=gpar(col="red", lwd=3, fill="#11223300"))

> current.viewport()
viewport[ROOT]
> current.vpTree()
viewport[ROOT]->(viewport[top-right-vp])

# 再回到灰色视口
> downViewport("top-right-vp")
> grid.text("back again", gp=gpar(col="red"))

练习：修改一个 lattice 包的输出。






6. 图形对象 Grobs
两步画图:
- 创建 grob 对象
- grid.draw() 画出来。

grid.ls() 查看当前页的 grobs 对象。
grid.edit() 通过名字编辑 grobs 对象。

(1) grid.ls() 能查看 grob 对象。
vp <- viewport(x=.5, y=.5,
		width=.5, height=.5,
		just=c("left", "bottom"),
		name="top-right-vp")
pushViewport(vp)
grid.rect(gp=gpar(fill="grey"), name="top-right-rect")

> grid.ls()
top-right-rect

> upViewport()
> grid.edit("top-right-rect", gp=gpar(col="red", lwd=3, fill="pink"))


(2) grid.ls() 也能查看视口
The grid.ls() function can also lists viewports.

> grid.ls(viewports=TRUE, fullNames=TRUE)
viewport[ROOT]
  viewport[top-right-vp]
    rect[top-right-rect]
    upViewport[1]
#

(3) showViewport() 会半透明显示页面中视口的位置和名字。

(4) showGrob() 半透明显示页面中的grob对象。

作业: 修改 lattice 图的背景色。

注意：为自己的 viewport 和 grob 命名，方便修改。





7. 裁切 clip：两种方式
It is possible to set a rectangular clipping region so that drawing can only occur inside that region.
- Viewports have a clip argument to indicate whether drawing should be clipped to the viewport.
- The grid.clip() function sets the clipping region within a viewport.

(1) 给一组文字染上有艺术气息的颜色，甚至渐变色
# 黑字白底
grid.newpage()
grid.text("Clipping", gp=gpar(cex=8))

# 黑底白字，使用 viewport()的clip参数
pushViewport(viewport(width=0.5, clip=TRUE))
grid.rect(gp=gpar(fill="black"))
grid.text("Clipping", gp=gpar(col="white", cex=8))

# 灰底 重灰字，使用 grid.clip() 函数实现
grid.clip(width=0.5)
grid.rect(gp=gpar(fill="grey80"))
grid.text("Clipping", gp=gpar(col="grey60", cex=8))





8. 查询 grob 的位置和大小  //失败 todo

It is possible to ask a grob about its location and size.
- The grobWidth() function returns the width of a grob. There is also grobHeight().
- The grobX() function returns an x-location on the boundary of a grob. There is also grobY().

> ggplot(aes(x=disp, y=mpg), data=mtcars) +
		geom_point() +
		geom_smooth(method="lm")
> current.vpTree()
... viewport[panel.7-5-7-5], ...


> downViewport("panel.7-5-7-5")
> sline <- grid.get(gPath("smooths", "polyline"), grep=TRUE) #获取元素失败 //error
> grid.segments(.7, .8,
		grobX(sline, 45), grobY(sline, 45),
		arrow=arrow(angle=10, type="closed"),
		gp=gpar(fill="black"))
> grid.text("line of best fit",
	x=unit(.7, "npc") + unit(2, "mm"),
	y=unit(.8, "npc") + unit(2, "mm"),
	just=c("left", "bottom"))





(2) 尝试依次查看位置
library(ggplot2)
library(grid)

# 获取所有的 视口，然后逐个加红边，看是哪个
getNames_vp=function(){
  vps=current.vpTree()
  vps=as.character(vps)
  vps=sub("^[^\\[]*", "", vps, perl = T)
  vps=strsplit(vps, "\\]([^\\[]*):?", perl = T)[[1]]
  vps=substring(vps, 2)
  vps
}

test=function(i, vp=null){
  seekViewport(vp[i])
  
  message( vp[i], "\n\tW, H:", grobWidth(vp[i]),"\t", grobHeight(vp[i]) )
  message( "\tx, y: ", grobX(vp[i], "west"),"\t", grobY(vp[i], "west") )
  grid.rect(gp=gpar(fill="#11223300", col="red"))
}

g1=	ggplot(aes(x=disp, y=mpg), data=mtcars) +
  geom_point() +
  geom_smooth(method="lm")
print(g1)
vp=getNames_vp()
vp

# vp=vp[grep("GRID", vp)]
vp

test(5, vp)


# 输出宽高，为什么都一样？
for(i in 1:length(vp)){
  test(i, vp)
}


> seekViewport( gPath(vp[5]) )
> grid.rect(gp=gpar(fill="#11223300", col="blue"))



(2) 再次尝试 grid.force() 和 grid.ls()


> grid.ls(fullNames=TRUE)
gtable[layout]
> grid.force()
# This does not change the appearance of the plot, but the low-level grobs that draw the plot are now visible.

> grid.ls(fullNames=TRUE)
forcedgrob[layout]
  forcedgrob[background.1-6-6-1]
  forcedgrob[spacer.4-3-4-3]
  forcedgrob[panel.3-4-3-4]
...










========================================
grid 的布局功能
----------------------------------------
2. grid中文翻译为网格，可将其解释为画布分割，通过设定相应的参数，从而可以任意的摆放图形

(1) 常用函数：
	grid.newpage() 创建新的画布
	grid.layout() 分割画布，使用参数widths和heights指定分割比例 ,从上到下，从左到右排列
	viewport() 在画布中创建视窗
	grid.show.viewport() 在画布中展示视窗
	grid.show.layout() 展示分割的画布
	pushViewport() 将新建的viewport推出去，即将工作区域切换到新的viewport
	popViewport() 将当前的viewport删除，其父viewport作为新的工作区域, 子viewport中的绘制的图形不会被删除
	downViewport() 导航到子viewport，并作为工作区域，原viewport不会删除
	upViewport() 导航到父viewport，父viewport变为工作区域, 原viewport不会被删除
	seekViewport() 导航到name参数所在的viewport,并作为工作区域
	grid.text() 输出文本标签,坐标只与画布有关，与viewport无关

	showViewport() #查看布局

画一个ggplot2图，然后执行
current.vpTree() #查看树状结构
# 好可怕！半屏幕的输出！说明 ggplot2 底层全是grid的视口！连坐标轴都是。


(2) 语法：
viewport(x = unit(0.5, "npc"), y = unit(0.5, "npc"), 
         width = unit(1, "npc"), height = unit(1, "npc"), 
         default.units = "npc", 
         just = "centre", 
         gp = gpar(), 
         clip = "inherit", 
         xscale = c(0, 1), yscale = c(0, 1), 
         angle = 0, 
         layout = NULL, 
         layout.pos.row = NULL, layout.pos.col = NULL, name = NULL) 

grid.layout(nrow = 1, ncol = 1, 
            widths = unit(rep_len(1, ncol), "null"), 
            heights = unit(rep_len(1, nrow), "null"), 
            default.units = "null", 
            respect = FALSE, 
            just="centre")


(3) 参数解释
(viewport 视口，有的翻译为视窗。)

name：此视口(viewport)的名字，用于搜索和定位
x,y 为起点坐标，默认是矩形视窗中心坐标，为0 - 1的数字，表示占newpage的比例
	x：绘图区域相对页面左下角原点的x坐标，默认单位为npc，Normalised Parent Coordinates，含义是归一化的父区域坐标
	y：绘图区域相对页面左下角原点的y坐标
width, height 为矩形视窗的长宽，同样是占newpage的比例

default.units：默认单位为npc (Normalised Parent Coordinates)，含义是规范化化的父区域坐标
angle 把视口逆时针旋转的角度，从-360到360,正数表示逆时针旋转，负数表示顺时针旋转
just 表示指定视窗起点位置，默认“centre”, 还可以设置左下角c(“left”, “buttom”), 右上角c(“right”, “top”) 等
	x和y所指的位置，默认为矩形中心位置

layout 布局(grid.layout)对象，用于将当前的viewport拆分为子区域
layout.pos.row，layout.pos.col：子区域在父布局中的行位置和列位置
nrow 表示将该区域拆分为几行
ncol 表示将该区域拆分为几列
widths 表示每个子区域的宽度,向量长度等于ncol
heights 表示每个子区域的高度，向量长度等于nrow
gp = gpar() 表示传递其它参数，如: col/fill颜色,lty线型, lwd线宽, fontsize文本尺寸, fontfamily字体, fontface字型等， 可以通过?gpar查询
	gpar对象，用于设置图形参数；

clip：裁剪区域，有效值是“on”，“inherit”或“off”，指示剪裁到视口范围内，从父视口继承剪裁区域，或者完全关闭剪裁。 为了后向兼容性，逻辑值TRUE对应于“on”，而FALSE对应于“inherit”
xscale，yscale：两个数值元素的向量，用于表示坐标轴的最小值和最大值。




(4) 什么是 viewport?
通常使用 grid.newpage() 函数来新建一个空白画布
在画布中，又可以定义很多个独立的矩形绘图窗口，在每个矩形窗口中都可以绘制任意你想要绘制的内容，这样的窗口就是 viewport

有了viewport这个工具，我们就可以很灵活的在图形中画出任意区域分割的子图了。
例1: viewport是绘图的基础，创建一个viewport
vp = viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=45)

通过函数grid.show.viewport()查看创建的视口：
grid.show.viewport(viewport(x=0.6, y=0.6, width=unit(1, "inches"), height=unit(1, "inches"), angle=30))

height和width是矩形的长和宽，x和y是视口中心点（也就是，矩形的几何中心点）距离x坐标抽和y坐标轴的距离




默认情况下，整个画布就是一个 viewport，如果新增一个 viewport，那么默认会继承所有默认的图形参数值。

例2: 使用 viewport() 函数来新建一个 viewport，并接受位置参数(x 和 y) 和大小参数(width 和 height)，以及对齐方式(just)
> vp2=viewport(
   x = unit(0.4, "npc"), 
   y = unit(1, "cm"),
   width = stringWidth("very very snug indeed"), 
   height = unit(6, "lines"), 
   just = c("left", "bottom")
)
> vp2
# viewport[GRID.VP.4] 
viewport() 函数返回的是一个 viewport 对象，但其实你会发现，什么东西都没有画出来

> grid.show.viewport(vp2)





(5) 基于viewport绘制图形
library(grid)

# 使用grid包绘图时，首先要创建一个空的画布：
grid.newpage()

#在画布中创建viewport对象：
vp = viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=45)

#此时，画布中是空的，需要把viewport推到画布中：
pushViewport(vp)

#viewport是绘图的区域，也就是说，基于viewport绘制图形，在视口规定的范围内作图，例如，向视口中绘制矩形。
grid.rect() #默认情况下grid.rect画出viewport的边界。



(6) 可视化 viewport 
labelvp <- function(name, col="gray", tcol="white", clipOff=TRUE) {
  seekViewport(name)
  if (clipOff)
    pushViewport(viewport(clip="off"))
  grid.rect(gp=gpar(col=col, lwd=5, fill=NA))
  grid.rect(x=0, y=1, width=unit(1, "strwidth", name) + unit(2, "mm"),
            height=unit(1, "line"), just=c("left", "top"),
            gp=gpar(fill=col, col=NA))
  grid.text(name, x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
            just=c("left", "top"), gp=gpar(col=tcol))
  upViewport(0)
}

vplay <- grid.layout(3, 3, 
                     respect=rbind(c(0, 0, 0), 
                                   c(0, 1, 0), 
                                   c(0, 0, 0)))

pushViewport(viewport(width=0.95, height=0.95))
grid.rect(gp=gpar(col="light gray"))
pushViewport(viewport(layout=vplay))

pushViewport(viewport(layout.pos.col=2, name="col2"))
upViewport()
pushViewport(viewport(layout.pos.row=2, name="row2"))

labelvp("col2", "black")
labelvp("row2")












========================================
|-- viewport 树与 viewport 的切换
----------------------------------------
1. grid可以创建多个viewport，所有的viewport组织成一棵树。
任何一个时刻，有一个当前viewport对象，初始状态下为树的根节点viewport。
grid提供了一套函数用于管理viewport对象。


grid包为每一个画布维护了一个由viewport构成的树，树的根节点是由系统创建的，名字是ROOT的viewport，每一个节点都是一个viewport。活跃viewport是树的当前位置，在树中是唯一的，用户只能向活跃viewport中绘图，所有的操作都是基于活跃viewport。viewport()函数用于创建viewport，而一个viewport只有被push到viewport树中，才能在其区域中绘图。


(1)通过5个函数实现对viewport树的遍历和更新：

使用pushViewport()可以将指定的viewport插入到当前viewport的子节点中，同时当前viewport对象移动为刚刚插入的viewport；
使用popViewport()可以删除当前viewport，同时当前viewport改为刚刚删除的viewport的父节点；
使用upViewport()当前viewport移动到父节点；
使用downViewport()当前viewport移动到指定name的子节点；
使用seekViewport()在整棵树范围内搜索指定name的viewport，将其设置为当前viewport。

注意：当向树中push一个viewport时，如果树中存在一个级别（level）相同，名字相同的viewport，那么push操作会把该viewport替换掉。


(2) 查看当前的viewport树结构：
current.vpTree()


例如，下面我们连续push三个viewport到一个图形中。
绘制的图形依次嵌套，这说明，每push一次，原活跃viewport都变成父节点，把当前的veiwport作为子viewport：
grid.newpage()
colors=c("red", "green", "blue")
xvec=c(0.3,0.4,0.5)
for(i in 1:3){
  vp=viewport(x=xvec[i], y=0.5, 
              width=0.4, height=0.4,
              gp=gpar(col=colors[i])
  )
  pushViewport(vp)
  grid.rect()
}

current.vpTree() #查看树状结构
# viewport[ROOT]->(viewport[GRID.VP.4]->(viewport[GRID.VP.5]->(viewport[GRID.VP.6]))) 




(3) pushViewport() 函数可以将一个 viewport 对象 push 到图像设备中
实例: 新建一个带旋转角度的视口，然后在里面添加文字
grid.newpage()
grid.text(
  "top-left corner", 
  x=unit(1, "mm"),
  y=unit(1, "npc") - unit(1, "mm"),
  just=c("left", "top")
)

# 新建一个视口：旋转30度
pushViewport(
  viewport(
    width=0.8, 
    height=0.5, 
    angle=30,
    name="vp1"
    )
)
grid.rect() #视口边框

# 添加文字，角度和视口一致
grid.text(
  "top-left corner", 
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top")
)

# 如果继续旋转， 则是相对于当前视口的
pushViewport( viewport(width=0.8, height=0.5, angle=30, name="vp2") )
grid.rect(gp=gpar(col="red", lty=2, fill="#FFFFFF00")) #设置填充色为全透明的
grid.text(
  "top-left corner", 
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top"),
  gp=gpar(col="red")
)


(4) popViewport() 函数：删除当前视口，并返回到其上一层
每次 push 一个 viewport 之后，都会将该 viewport 作为当前活动的窗口，如果要回滚到之前的 viewport，可以使用 popViewport() 函数，该函数会将当前活动窗口删除

popViewport()

grid.text(
  "bottom-right corner",
  x=unit(1, "npc") - unit(1, "mm"),
  y=unit(1, "mm"), 
  just=c("right", "bottom")
)

从图片中可以看到，活动窗口已经切换到第二个 viewport，并将文本绘制在其右下角

查看当前 视口树，发现 vp2已经被删:
> current.vpTree()
viewport[ROOT]->(viewport[vp1]) 


popViewport() 还可接受一个参数 n，用于指定需要 pop 几个 viewport。默认 n = 1，传递更大的值可以跳转到更上层的 viewport，如果设置为 0 则会返回到最外层图形设备上。



(5) 另一个更改活动窗口的方法是，使用 upViewport() 和 downViewport() 函数。
upViewport() 函数与 popViewport() 类似，不同之处在于，upViewport() 函数不会删除当前活动 viewport。
这样，在重新访问之前的 viewport 时，不用再 push 一遍，而且能够提升访问的速度。

重新访问 viewport 使用的是 downViewport() 函数，通过 name 参数来选择指定的 viewport

# 切换到最外层
upViewport()
# 在右下角添加文本
grid.text(
  "bottom-right corner",
  x=unit(1, "npc") - unit(1, "mm"),
  y=unit(1, "mm"), 
  just=c("right", "bottom")
  )
# 返回 vp1
downViewport("vp1")
# 添加外侧框线
grid.rect(
  width=unit(1, "npc") + unit(2, "mm"), 
  height=unit(1, "npc") + unit(2, "mm"),
  gp = gpar(fill = NA)
)

如果想要访问 vp2 会报错，不存在该 viewport

> downViewport("vp2")
Error in grid.Call.graphics(C_downviewport, name$name, strict) : 
  Viewport 'vp2' was not found


(6) 还可以直接使用 seekViewport() 函数来切换到指定名称的 viewport.






========================================
|-- viewport 的裁剪(clip)
----------------------------------------
2. 裁剪 viewport
我们可以将图形限制在当前 viewport 之内，如果绘制的图形大小超过了当前 viewport 则不会显示，我们可以使用 clip 参数

该参数接受三个值：
	on：输出的图形必须保持在当前 viewport 内，超出的部分会被裁剪
	inherit：继承上一个 viewport 的 clip 值
	off：不会被裁剪


grid.newpage()
# 在画布中心添加一个 viewport，并设置允许剪切
pushViewport(viewport(w=.5, h=.5, clip="on"))
# 添加矩形框和线条很粗的圆形
grid.rect(
  gp = gpar(fill = "#8dd3c7")
  )
grid.circle(
  r = .7, 
  gp = gpar(
    lwd = 20,
    col = "#fdb462"
    )
)

# 在当前 viewport 中添加一个 viewport，继承方式
pushViewport(viewport(clip="inherit"))
# 添加线条更细一点的圆形
grid.circle(
  r = .7, 
  gp = gpar(
    lwd = 10, 
    col = "#80b1d3",
    fill = NA)
)
# 关闭裁剪
pushViewport(viewport(clip="off"))
# 显示整个圆形
grid.circle(
  r=.7,
  gp = gpar(
    fill = NA,
    col = "#fb8072"
  )
)
# 只有最后一个圆显示出了全部，前面两个圆形只显示在 viewport 内的部分





========================================
|-- viewport 的3种排列: vpList /vpStack /vpTree
----------------------------------------
1. viewport 的排布方式有三种：
	vpList：viewport 列表，以平行的方式排列各 viewport
	vpStack：以堆叠的方式排列，俗称套娃，与使用 pushViewport 功能相似
	vpTree：以树的方式排列，一个根节点可以有任意个子节点

例如，我们新建三个 viewport
vp1 <- viewport(name="A")
vp2 <- viewport(name="B")
vp3 <- viewport(name="C")

(1) vpList 平行方式
然后，我们以列表的方式将这些 viewport push 到图形设备中
grid.newpage()
pushViewport(vpList(vp1, vp2, vp3))

可以使用 current.vpTree 函数来查看当前的 viewport 排列树
> current.vpTree()
viewport[ROOT]->(viewport[A], viewport[B], viewport[C]) 
可以看到，这三个 viewport 是并列的关系


(2) 我们再看看以堆叠(vpStack)的方式放置
> grid.newpage()
> pushViewport(vpStack(vp1, vp2, vp3))
> current.vpTree()
viewport[ROOT]->(viewport[A]->(viewport[B]->(viewport[C]))) 

可以看到，根节点是整个画布，画布的子节点是 A，A 的子节点是 B，B 的子节点是 C，这就是堆叠的方式，一个套一个


(3) 树形排列
> grid.newpage()
> pushViewport(vpTree(vp1, vpList(vp2, vp3)))
> current.vpTree()
viewport[ROOT]->(viewport[A]->(viewport[B], viewport[C]))

根节点是整个画布，然后是子节点 A，A 的子节点是 B、C


(4) 根据父节点找子节点
我们知道，画布中的所有 viewport 是以树的方式存储的，那么我们就可以根据 viewport 的父节点来定位某一个 viewport

例如，我们想查找名称 C 的 viewport，其父节点为 B，再上层父节点为 A，则可以使用 vpPath 函数来构造检索路径
> vpPath("A", "B", "C")
A::B::C 
同时也可以消除同名 viewport 的干扰






========================================
|-- 将 viewport 作为图形原语(grid绘图命令)的参数
----------------------------------------
1.每个原语函数都有一个 vp 参数

例如，在一个 viewport 中绘制文本
vp1 <- viewport(width=0.5, height=0.5, name="vp1")
pushViewport(vp1)

grid.text("Text drawn in a viewport")
popViewport()

也可以下面的代码代替，将文本绘制到指定的 viewport 中
grid.text("Text drawn in a viewport", vp=vp1)





========================================
|-- viewport 的图形参数 gp=gpar(col="red")
----------------------------------------
viewport 也有一个 gp 参数，用来设置图形属性，设置的值将会作为 viewport 中所有的图形对象的默认值

grid.newpage()
pushViewport(
  viewport(
    gp = gpar(fill="grey")
    )
  )

grid.rect( x = 0.33, height = 0.7, width = 0.2  )
grid.rect( x = 0.66, height = 0.7, width = 0.2, gp = gpar(fill="black") )
popViewport()





========================================
|-- viewport 行列布局 viewport(layout=grid.layout(...)) 
----------------------------------------
viewport 的 layout 参数可以用来设置布局，将 viewport 区域分割成不同的行和列，行之间可以有不同的高度，列之间可以有不同的宽度。

1. viewport 还支持行列布局，前面提到viewport函数，还有几个参数我们还没涉及：
	layout：grid.layout对象，用于将当前viewport拆分为子区域
	layout.pos.row：创建的viewport在父节点layout的行位置
	layout.pos.col：创建的viewport在父节点layout的列位置

grid.layout(nrow = 1, ncol = 1,
    widths = unit(rep_len(1, ncol), "null"), heights = unit(rep_len(1, nrow), "null"),
    default.units = "null", respect = FALSE, just="centre")

我们来看一下grid.layout()的参数：
	nrow, ncol：布局分为多少个行和列，每一个行和列构成的单元叫做分区（subdivision）
	widths，heights：每一个分区的宽和高
		widths：每个子区域的宽度，向量长度等于ncol
		heights：每个子区域的高度，向量长度等于nrow
	default.units：默认单位
	respect：逻辑值，如果为true，指定行高度和列宽度都遵守。
	just：指定对齐方式，有效的值是："left", "right", "centre", "center", "bottom", 和 "top".


(1) grid 布局使用 grid.layout() 函数来构造，例如
grid.newpage()

vplay <- grid.layout(
  nrow = 3, 
  ncol = 3, 
  respect=rbind(
    c(0, 0, 0),
    c(0, 1, 0),
    c(0, 0, 0))
  )

我们构造了一个 3 行 3 列的布局，中间的位置是一个正方形
构造了布局之后，就可以添加到 viewport 中了
pushViewport(viewport(layout=vplay))



(2) 我们可以使用 layout.pos.col 和 layout.pos.row 参数来指定 viewport 放置的位置
# 新建一个 viewport 并放置在第二列
pushViewport(
  viewport(
    layout.pos.col = 2, 
    name = "col2")
  )
grid.rect(
  gp = gpar(
    lwd = 10,
    col = "black",
    fill = NA
  ))
grid.text(
  label = "col2",
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top")
  )

upViewport()

# 新建一个 viewport 并放置在第二行
pushViewport(
  viewport(
    layout.pos.row = 2, 
    name = "row2")
  )

grid.rect(
  gp = gpar(
    lwd = 10,
    col = "grey",
    fill = NA
  ))
grid.text(
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  label = "row2",
  just = c("left", "top")
)



(3) 也可以使用 unit 来设置行列的高度和宽度，例如

unitlay <- grid.layout(
  nrow = 3, 
  ncol = 3, 
  widths = unit(
    c(1, 1, 2),
    c("inches", "null", "null")
  ),
  heights = unit(
    c(3, 1, 1),
    c("lines", "null", "null"))
  )

我们定义了一个 3 行 3 列的布局，
- 列宽通过 widths 分配，即第一列宽度为 1 inches，剩下的两列的宽度的占比为 1:2
- 行高通过 heights 分配，第一行为 3 个 lines 单位，剩下的两行高度为 1:1

布局应该是这样子的
grid.show.layout(unitlay)



(4) grid 布局也可以嵌套

假设我们有这样一个，1 行 2 列的 viewport
gridfun <- function() { 
  # 1*2 的布局
  pushViewport(viewport(layout=grid.layout(1, 2))) 
  
  # 第一行第一列的 viewport
  pushViewport(viewport(layout.pos.col=1)) 
  # 绘制矩形和文本
  grid.rect(gp = gpar(fill = "#80b1d3")) 
  grid.text("black")
  grid.text("&", x=1)
  popViewport()
  
  # 第一行第二列的 viewport
  pushViewport(viewport(layout.pos.col=2, clip="on"))
  grid.rect(gp=gpar(fill="#fb8072"))
  grid.text("white", gp=gpar(col="white"))
  grid.text("&", x=0, gp=gpar(col="white"))
  
  popViewport(2)
}
# view
grid.newpage()
gridfun()



新建一个 5 行 5 列的 viewport
grid.newpage()
pushViewport(
  viewport(
    layout = grid.layout(
      nrow = 5, 
      ncol = 5, 
      widths=unit(
        c(5, 1, 5, 2, 5), 
        c("mm", "null", "mm", "null", "mm")),
      heights=unit(
        c(5, 1, 5, 2, 5), 
        c("mm", "null", "mm", "null", "mm"))
      )
    )
  )

然后，分别在 2 行 2 列和 4 行 4 列 中放置一个刚定义的 viewport
pushViewport(
  viewport(
    layout.pos.col=2, 
    layout.pos.row=2)
  )
gridfun()
popViewport()

pushViewport(
  viewport(
    layout.pos.col=4, 
    layout.pos.row=4)
  )
gridfun()
popViewport(2)






2. 模仿R base的绘图区创建一个布局并绘图
(1) 九宫格布局
layout = grid.layout(nrow=3, ncol=3,
                   widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
                   heights=unit(c(5, 1, 4), c("lines", "null", "lines")))

top.vp = viewport(layout=layout, name="top")
grid.show.layout(layout)


(2) 为边距命名
创建一系列的viewport，占用布局的各个分区，由于没有push任何viewport，因此画布中没有绘制任何图形。
在为每个视口命名时，使用统一的格式：margin+数值。

margin1 = viewport(layout.pos.col = 2, layout.pos.row = 3, name = "margin1") #(3,2)
margin2 = viewport(layout.pos.col = 1, layout.pos.row = 2, name = "margin2") #(2,1)
margin3 = viewport(layout.pos.col = 2, layout.pos.row = 1, name = "margin3") #(1,2)
margin4 = viewport(layout.pos.col = 3, layout.pos.row = 2, name = "margin4") #(2,3)
plot = viewport(layout.pos.col = 2, layout.pos.row = 2, name = "plot")       #(2,2)

# 其他四个都是 top.vp 的子元素
splot <- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
pushViewport(splot)


# grid.show.viewport(margin1)

R用数字来表示位置，数值代表的含义是：1=Buttom，2=Left，3=Top，4=Right，视口被布局分割的分区如下图所示：
grid.show.viewport(top.vp) # ?? //todo



(3) 创建 viewport 树
使用vpList()把视口排列成一个树形结构，并把top.vp作为视图的父节点，把所有其他视口作为子节点，使用vpTree()创建一个viewport树：
> splot = vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))

把整个viewport树push到活跃视口中，这样，在绘图区域中，我们可以在不同的散点视口中绘制图形。
> pushViewport(splot)

在把整个树push到活跃视口之后，就可以在不同的区域内绘制图形，使用seekViewport()函数按照视口名称切换到指定的视口，并把当前视口激活。
seekViewport("plot")
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y)


完整代码如下: 创建布局，并画散点图，在边距添加坐标轴。
library(grid)
layout = grid.layout(nrow=3, ncol=3,
                      widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
                      heights=unit(c(5, 1, 4), c("lines", "null", "lines")))
#grid.show.layout(layout)

top.vp =viewport(layout=layout,name="top")
#grid.show.viewport(top.vp)

x = runif(10)
y = runif(10)
xscale = extendrange(x)
yscale = extendrange(y)

margin1 = viewport(layout.pos.col = 2, layout.pos.row = 3, name = "margin1")
margin2 = viewport(layout.pos.col = 1, layout.pos.row = 2, name = "margin2")
margin3 = viewport(layout.pos.col = 2, layout.pos.row = 1, name = "margin3")
margin4 = viewport(layout.pos.col = 3, layout.pos.row = 2, name = "margin4")
plot = viewport(layout.pos.col = 2, layout.pos.row = 2, name = "plot",xscale = xscale, yscale = yscale)

splot = vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
#grid.show.viewport(splot)



grid.newpage()
pushViewport(splot)

seekViewport("plot")
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y,pch=20)

seekViewport("margin1")
grid.text("Random X", y = unit(1, "lines"))

seekViewport("margin2")
grid.text("Random Y", x = unit(1, "lines"), rot = 90)


# 回到顶层
upViewport(0)

# 顶部添加标题
seekViewport("margin3")
grid.text("The user adds a title!", gp = gpar(fontsize = 20))













========================================
grid 函数来创建、编辑、操作图形对象
----------------------------------------
1. 控制图像输出
我们可以使用图形原语来绘制图形输出，并返回一个图形对象(grobs)，例如

library(RColorBrewer)
grid.newpage()
grid.circle(
  name = "circles",
  x = seq(0.1, 0.9, length = 40),
  y = 0.5 + 0.4 * sin(seq(0, 2 * pi, length = 40)),
  r = abs(0.1 * cos(seq(0, 2 * pi, length = 40))),
  gp = gpar(col = brewer.pal(8, "Set2"))
)
# 这段代码将会绘制一串圆形
# 同时也会生成一个 circle grob，该对象保存了当前绘制的这些圆形的信息



(2) 怎么查看该对象？
grid 保留了一个显示列表，用于记录当前画布中的所有的 viewport 和 grobs。因此，grid.circle() 函数构造的对象也会保存在显示列表中，意味着我们可以根据对象的名称 circles 来获取、修改该对象

使用 grid.get() 函数，可以获取该 circle 对象的拷贝

> grid.get("circles") #就是创建时的 name 属性
circle[circles]


(3) 修改该对象 
使用 grid.edit() 可以用来修改该 circle 对象的图像属性

grid.edit(
  "circles",
  gp = gpar(
    col = brewer.pal(10, "RdBu")
    )
  )
# 修改颜色属性之后，会直接显示在图形输出中


(4) 删除对象 
还可以使用 grid.remove() 函数，从显示列表中删除图形对象的输出

grid.remove("circles")
# 画布一片空白，什么也没有








2. 标准的函数及参数
控制 grobs 的函数包括：

输出函数/对象函数: 描述 
grid.get()/ getGrob(): 返回一个或多个 grobs 的拷贝
grid.edit()/editGrob(): 修改一个或多个 grobs 
grid.add()/addGrob(): 添加一个或多个 grobs 
grid.remove()/removeGrob(): 删除一个或多个 grobs 
grid.set()/setGrob(): 替换一个或多个 grobs 

# 只要我们知道了 grobs 的名称，就可以对其获取、修改或删除
# 而 getNames() 函数，可以帮助我们获取当前图形中所有 grobs 的名称

(1) 所有图像输出函数的第一个参数都是图像对象的名称
# 我们绘制了 8 个同心圆，并根据奇偶顺序将 circle grob 命名为 circle.odd 和 circle.even
grid.newpage()
suffix <- c("even", "odd")

for (i in 1:8)
  grid.circle(
    name = paste0("circle.", suffix[i %% 2 + 1]),
    r = (9 - i) / 20,
    gp = gpar(
      col = NA, 
      fill = grey(i / 10)
      )
  )


(2) 修改对象
然后，我们可以使用 grid.edit() 函数，修改所有名为 circle.odd 的 grobs 的颜色
# 如果 global = TRUE，则会返回显示列表中所有匹配的对象，例如
grid.edit(
  "circle.odd", 
  gp = gpar(
    fill = brewer.pal(4, "Set3")[4]),
  global = TRUE #返回所有匹配的对象
)


# 如果参数 grep = TRUE，可以接受正则表达式对象名称
或者，用正则表达式来匹配带有 even 的 grob
grid.edit(
  "even", 
  gp = gpar(
    col = "#80b1d3", 
    fill = "#fdb462"
    ),
  grep=TRUE, #使用正则表达式
  global=TRUE
)









========================================
|-- grob 排布结构(gList, gTree) 与子对象的获取
----------------------------------------
1. grob 的排布结果包括：
	gList：包含多个 grobs 的 list
	gTree：grobs 的树形结构，即一个 grob 中包含其他的 grob

例如，对于 xaxis grob

grid.newpage()
pushViewport(viewport(y = 0.5, height = 0.5, width = 0.5))
grid.rect()
pushViewport(viewport(y = 0.5, height = 0.5, width = 0.5))

grid.xaxis(name="axis1", at=1:4/5)


(1) 会包含有多个子 grob，如线条，文本等
> childNames(grid.get("axis1"))
[1] "major"  "ticks"  "labels"

# 如果把 xaxis grob 看作为一棵树的根，那么它包含三个子 grob。
其中 major 和 ticks 是 lines grob，labels 为 text grob。

(2) 其中 at 参数设置了轴刻度，我们可以使用 grid.edit 来修改
grid.edit("axis1", at=1:3/4)

(3) 那想要修改 labels 的格式，怎么办？即如何访问一个对象的子对象呢？

可以使用 gPath(grob path) 函数，类似于 vpPath，可以使用父节点名称加子节点名称来访问
> grid.edit(gPath("axis1", "labels"), rot=45)

或者，也可以使用 axis1::labels 方式来访问
> grid.edit( "axis1::labels", rot=-45)


注意：grobs 的搜索是深度优先，也就是说，如果在显示列表中遍历到了一个 gTree grob，且未找到匹配项，则会对该 grob 执行深度优先遍历



(4) 这种 gTree 结构对象，也包含 gp 和 vp 参数。

在父节点上设置对应的 gp 参数值，会作为默认值传递给子对象。例如
> grid.xaxis(gp=gpar(col="grey"))

也可以将一个 viewport 直接作为参数值传递
> grid.xaxis(vp=viewport(y=0.75, height=0.5))








========================================
|-- 图形对象
----------------------------------------
1. 在前面的章节中，我们介绍的都是如何使用函数直接生成图形输出并返回图形对象（grob）
在这一节，我们将介绍如果创建 grob，但不绘制图形，通过对 grob 创建及修改，并在最后使用 grid.draw() 函数来绘制出图形。

(1) 每个能产生图形输出和图形对象的 grid 函数都有一个对应的只创建图形对象，没有图形输出的函数
例如，grid.circle() 对应于 circleGrob()，grid.edit() 对应于 editGrob()，在前面的函数表中都有列出

例如
grid.newpage()
pushViewport(viewport(width = 0.5, height = 0.5))
# 创建 x 轴对象
ag <- xaxisGrob(at=1:4/5)
# 修改对象，将标签的字体变为斜体、紫色、大字体
ag <- editGrob(ag, "labels", gp=gpar(fontface="italic", col="purple", cex=1.2))
# 绘图
grid.draw(ag)




(2) 我们可以将不同的 grob 组合在一起，生成一个复杂的图形。比如
grid.newpage()

# 我们构建一个名为 boxedText 的 gTree 对象，包含其子对象包括一个文本和一个矩形
tg <- textGrob("sample text")
rg <- rectGrob(
  width = 1.2*grobWidth(tg),
  height = 1.5*grobHeight(tg)
)
boxedText <- gTree(
  children = gList(rg, tg)
)

# 我们直接可以绘制组合对象
grid.draw(boxedText)





(3) 而对该对象的图形属性的修改，会反映到具体的子对象中

# 修改颜色
grid.draw(
  editGrob(
    boxedText, 
    gp=gpar(col="skyblue")
    )
)


# 指定 viewport
grid.draw(
  editGrob(
    boxedText, 
    vp = viewport(angle=45), #旋转角度
    gp = gpar(fontsize=18, col="red")
    )
)





========================================
|-- 捕获输出 的对象：grid.grab()
----------------------------------------
在上面的例子中，我们先构建了一个组合对象，然后绘制该对象
还可以反着来，先绘制图形对象，然后对它们进行组合。

1. 使用 grid.grab() 函数，可以获取当前画布中所有输出的图形对象，并以 gTree 的形式返回

例如，我们使用 ggplot2 绘制一个直方图，并获取所有图形对象
library(ggplot2)
ggplot(mpg) + geom_histogram(aes(displ, fill = class), bins = 10, position = "dodge")
histTree <- grid.grab()


(2) 然后，你可以尝试运行下面的代码，重绘该对象
grid.newpage()
grid.draw(histTree)


(3) 或者指定一个视口，画在画布上半部分：
grid.newpage()
vp1=viewport(x=0, y=1, width=1, height=0.5, just=c("left", "top"))
pushViewport(vp1)
grid.draw(histTree)


(4) 测试一下这个ggplot2对象有多少视口
> histTree
gTree[GRID.gTree.113] 
> current.vpTree()
viewport[ROOT]->(viewport[GRID.VP.7]->(viewport[GRID.VP.8]), viewport[GR...密密麻麻十几行

> childNames(histTree)
[1] "layout"
> childNames(grid.get("ROOT"))
Error in childNames(grid.get("ROOT")) : 
  it is only valid to get 'children' from a "gTree"




(5) 也可以使用 grid.grabExpr 来获取表达式的输出图形对象
grid.grabExpr(
  print(
    ggplot(mpg) + 
      geom_histogram(
        aes(displ, fill = class), 
        bins = 10, 
        position = "dodge")
    )
  )
# gTree[GRID.gTree.208] 





========================================
|-- 图形对象的放置：grid.frame/grid.pack/grid.place/placeGrob
----------------------------------------
1. 假设我们有一个复杂图形

# 文本对象
label <- textGrob(
  "A\nPlot\nLabel ",
  x = 0, 
  just = "left"
)

x <- seq(0.1, 0.9, length=50)
y <- runif(50, 0.1, 0.9)

# gTree 结构图形对象，包括矩形、线图、点图
gplot <- gTree(
  children = gList(
    rectGrob(
      gp = gpar(
        col = "grey60",
        fill = "#cbd5e8",
        alpha = 0.3)
    ),
    linesGrob(
      x, 
      y,
      gp = gpar(
        col = "#33a02c"
      )),
    pointsGrob(
      x, y, 
      pch = 16, 
      size = unit(5, "mm"),
      gp = gpar(
        col = "#fb8072"
      ))
  ),
  vp = viewport(
    width = unit(1, "npc") - unit(5, "mm"),
    height = unit(1, "npc") - unit(5, "mm")
  )
)


(1) 我们可以使用上一章节提到的布局方法，将该图像设计为 1 行 2 列的布局

layout <- grid.layout(
  nrow = 1, 
  ncol = 2, 
  widths = unit(
    c(1, 1), 
    c("null", "grobwidth"), 
    list(NULL, label)
    )
  )

然后将图形绘制到指定位置中
grid.newpage()
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.col=2))
grid.draw(label)
popViewport()

pushViewport(viewport(layout.pos.col=1))
grid.draw(gplot)
popViewport(2)


(2) 但其实，grid 提供了更简便的函数用于放置 grobs

grid.frame() 函数创建一个没有子对象的 gTree，可以使用 grid.pack() 向其中添加子对象，同时确保为每个子对象保留足够的绘图空间

上面的代码可以改写成

grid.newpage()

# 新建一个空 frame
grid.frame(name="frame1")
# 放置 gplot 对象，在这一阶段，gplot 会占据整个 frame
grid.pack("frame1", gplot)
# 在 frame 的右边放置 label 对象
grid.pack("frame1", label, side="right")


# 这种动态的方式很简便，但是也带来了时间上的花费，随着需要放置的对象越来越多，速度会越来越慢。


(3) 另一种替代的方式是，先定义一个布局，然后再放置对象
grid.newpage()
grid.frame(name="frame1", layout=layout)

grid.place("frame1", gplot, col=1)
grid.place("frame1", label, col=2)


(4) 安静模式
在上面两个例子中，每次放置一个 grob 都会更新一遍图形输出。所以，一个更好的方式是，在安静模式下创建一个 frame，然后放置 grobs。

安静模式，即使用对象函数 frameGrob() 和 placeGrob()/packGrob 创建 frame、放置 grobs，但是不会输出图形，只有在所有设置完成之后，使用 grid.draw 一次性绘制

grid.newpage()

# 创建 frame
fg <- frameGrob(layout=layout)
# 添加 grob
fg <- placeGrob(fg, gplot, col=1)
fg <- placeGrob(fg, label, col=2)
# 一次性绘制
grid.draw(fg)








========================================
base 绘图：与 grid 绘图能否共存到一张图？怎么旋转一个base图?
----------------------------------------

1. 可以有条件的共存
library(grid)

plot(1:10)
par(new = TRUE)
grid.rect(width = 0.5, height = 0.5, gp = gpar(lwd = 3), name = "gr")
# 到这一步还是共存的。


grid.edit("gr", gp = gpar(col = "red", lwd = 3)) #编辑后，grid矩形重绘了，但是base图形并没有

grid.rect(width = convertWidth(unit(1, "inches"), "npc")) #每次缩放，都重新计算宽度


(2) 使用 drawDetails() 函数
drawDetails.mylegend <- function(x, recording) {
	x <- 0:64/64
	y <- sin(3*pi*x)
	plot(x, y, type = "l", col = "blue",
		main = "points with bg & legend(*, pt.bg)")
	points(x, y, pch = 21, bg = "white")
	legend(.4,1, "sin(c x)", pch = 21, pt.bg = "white", lty = 1, col = "blue")
}
grid.draw(grob(cl = "mylegend"))



(3) 能输出原生的树图吗？可以
drawDetails.myclust <- function(paras, recording) {
	out.clust=hclust( dist(paras$x), method="ward.D2")
	plot(out.clust)
}
grid.newpage()

vp=viewport(width=0.5) #失败，不能绘制到这个框中
pushViewport(vp)
grid.rect()

grid.draw(grob(x=mtcars, cl = "myclust"))
grid.draw(grob(x=mtcars, cl = "myclust", vp=vp)) #也不行


# 怎么传参数？
grid.draw(grob(x=x1, y=y2, c=c3, cl = "myclust"))
# 怎么接收参数？
drawDetails.xx的内部，第一个参数是个list列表，它里面就是传入的各种参数 params$x, params$y, ...



(4) 我想把这个函数增强一下，加一个树的方向参数

drawDetails.myclust <- function(paras, recording) {
	out.clust=hclust( dist(paras$x), method="ward.D2")
	plot(out.clust)
}
grid.newpage()
vp=viewport(angle=90) #失败，不能绘制到这个框中
pushViewport(vp)
grid.draw(grob(x=mtcars, cl = "myclust"))







2. 使用 gridBase 包 
gridBase is on CRAN and the author is Paul Murrell, the author of the grid package.

https://cran.r-project.org/web/packages/gridBase/vignettes/gridBase.pdf






3. gridGraphics 包：Redraw Base Graphics Using 'grid' Graphics

base画图 plotrix->【graphics】->  |grDevices->pdf/png/svg
grid画图 lattice/ggplot2-> 【grid】->  |grDevices->pdf/png/svg
现在的 gridGraphics 包在哪里呢？
plotrix->graphics-> 【gridGraphics】 ->grid-> |grDevices->pdf/png/svg


library(gridGraphics)
> ls("package:gridGraphics")
[1] "echoGrob"       "grid.echo"      "plotdiff"       "plotdiffInit"   "plotdiffResult"

(1) 使用 grid 包重绘base图形
plot(mpg ~ disp, mtcars, pch=16)
library(gridGraphics)
grid.echo()


(2) 重绘到右下角位置的视口中
grid.newpage()
pf <- function() plot(mpg ~ disp, mtcars, pch=16)
pushViewport(viewport(x=0, y=0, width=2/3, height=2/3,
                      just=c("left", "bottom")))
grid.echo(pf, newpage=FALSE)


比较一下，基本没差异:
plot(mpg ~ disp, mtcars)
grid.echo()


(3) 把一个base图旋转-80度：就是顺时针旋转80度，差不多由朝下变为朝左了。
(数学上的规定一致，x轴正方向为0度，逆时针旋转为正角度，y轴正方向为90度)

pf <- function(){
  opar=par(mar=c(0,0,0,0)) #边距为0
  on.exit(par(opar)) #离开函数恢复边距
  plot( hclust( dist(mtcars) ), ann=F, axes=F, labels = F)
}

library(grid)
grid.newpage()
pushViewport(viewport(x=0.4, y=0, width=2/3, height=2/3, 
                      angle=-80, #+逆时针旋转，-则顺时针旋转。和数学上坐标轴的规定一致
                      #gp=gpar(mar=c(0,0,0,0)),
                      just=c("right", "bottom")))
grid.rect() #画视口边框

library(gridGraphics)
grid.echo(pf, newpage=FALSE)
# 看到一个倾斜的树状图，但是会有很多警告。





#2) 尝试先捕获对象
grid.newpage()
pf()
grid.echo()
pg <- grid.grab() #捕获对象

grid.newpage()
pushViewport(viewport(x=0.4, y=0, width=2/3, height=2/3, 
                      angle=-80, #+逆时针旋转，-则顺时针旋转。和数学上坐标轴的规定一致
                      #gp=gpar(mar=c(0,0,0,0)),
                      just=c("right", "bottom")))
grid.rect() #画视口的边框
grid.draw(pg) #视口的边框消失，这里有警告



(4) 查看背后干了啥
grid.newpage()
pf <- function() plot(mpg ~ disp, mtcars, pch=16)
pushViewport(viewport(x=0, y=0, width=2/3, height=2/3,
                      just=c("left", "bottom")))
grid.echo(pf, newpage=FALSE)

> grid.ls()
graphics-plot-1-points-1
graphics-plot-1-bottom-axis-line-1
graphics-plot-1-bottom-axis-ticks-1
graphics-plot-1-bottom-axis-labels-1
graphics-plot-1-left-axis-line-1
graphics-plot-1-left-axis-ticks-1
graphics-plot-1-left-axis-labels-1
graphics-plot-1-box-1
graphics-plot-1-xlab-1
graphics-plot-1-ylab-1

> current.vpTree()
viewport[ROOT]->(viewport[GRID.VP.2]->(viewport[graphics-root]->(viewport[graphics-inner]->(viewport[graphics-figure-1-clip]->(viewport[graphics-plot-1]->(viewport[graphics-window-1-0], viewport[graphics-window-1-1])), viewport[graphics-figure-1]->(viewport[graphics-plot-1]->(viewport[graphics-window-1-0], viewport[graphics-window-1-1]), viewport[graphics-plot-1-clip]->(viewport[graphics-window-1-0], viewport[graphics-window-1-1])))))) 

确实是用 grid 对base的作图重绘了一遍。

# 编辑元素
> grid.edit("graphics-plot-1-bottom-axis-labels-1", rot=45) #x轴刻度文字立刻倾斜了
> grid.edit("graphics-plot-1-left-axis-ticks-1", gp=gpar(col="red") ) #y轴刻度变红色





(5) 另一个例子：泰坦尼克号 马赛克图，使用 grid 重绘后旋转顶部文字标签方向。
df1=as.data.frame(Titanic)
dim(df1)
head(df1)

df2=NULL
for(i in 1:nrow(df1)){
  if(df1[i,5]==0) next()
  for(j in 1:df1[i, 5])
    df2=rbind(df2, df1[i,])
}
dim(df2)
head(df2)

library(grid)
grid.newpage()
par(mfrow=c(2,2), oma=rep(1, 4), mar=c(1,1,1,1))
for( j in unique(df1$Class) ) {
  df3=df2[which(df2$Class==j), 1:4]
  print( head(df3) )
  mosaicplot( Survived ~ Age + Sex , data = df3, color = TRUE, main=j)
}

# grid重绘，并旋转标签
library(gridGraphics)
grid.echo()
grid.edit("text-1", grep=TRUE, global=TRUE,
          y=unit(1, "npc"), hjust=.2, vjust=0, rot=30)














4. gridSVG 包：连接 grid 和 SVG，绕过了 grDevices。
路线: grid->gridSVG->SVG


(1) 导出
plot(mpg ~ disp, mtcars, pch=16)

library(gridGraphics)
grid.echo()

library(gridSVG) #没试过
grid.export("plot.svg")





========================================
|-- 操作位图/栅格图：放入、旋转
----------------------------------------
1. 读取并显示一张位图
library(png)
img <- readPNG("001.png")
grid.raster(img)


2. 倾斜显示一张位图
grid.raster(img, .1, .1, width=.5, just=c("left", "bottom"))
pushViewport(viewport(.75, .75, .25, .25, angle=45))
grid.raster(img)
popViewport()





========================================
与 ggplot2 对象的交互与操作
----------------------------------------




========================================
|-- 使用 grid 拼接 ggplot2 对象
----------------------------------------
1. 我们之前拼接 grid 对象，是新建视口，并打印图形。
优点和缺点是要手动计算每个视口的位置，更灵活了，但是也更不自动化了。

实例: 带边缘分布的散点图
# step1: prepare ggplot charts
library(ggplot2)
library(grid)
p.hist.len <- ggplot(iris) + geom_histogram(aes(x=Sepal.Length))
p.hist.wid <- ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) + coord_flip()
p.scatter <- ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))

# step2: 直接按百分比创建视口，然后画图
# top left panel
grid.newpage()
vp.len <- viewport(x=0, y=0.66, width=0.66, height=0.34, just=c("left", "bottom"))
pushViewport(vp.len)
print(p.hist.len, newpage=F)
upViewport() # 返回父节点

# bottom right panel
vp.wid <- viewport(x=0.66, y=0, width=0.34, height=0.66, just=c("left", "bottom"))
pushViewport(vp.wid)
print(p.hist.wid, newpage=F)
upViewport()

# bottom left panel
vp.scatter <- viewport(x=0, y=0, width=0.66, height=0.66, just=c("left", "bottom"))
pushViewport(vp.scatter)
print(p.scatter, newpage=F)
upViewport()





2. 使用 layout 布局，把 ggplot2 图形逐个打印到视口中
利用布局在同一个画布中绘制多个图形的另外一种方法是使用print()函数，代码摘抄于《R统计绘图（2）：grid布局》。

我们来演示下这种方法生成前言统计图形的过程：

step1，创建多个图形
library(ggplot2)
# prepare ggplot charts
p.hist.len = ggplot(iris) + geom_histogram(aes(x=Sepal.Length))
p.hist.wid = ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) + coord_flip()
p.scatter = ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))

step2，创建布局，分割视口，并push当前视口
library(grid)
grid.newpage()
pushViewport(viewport(layout = grid.layout(3, 3)))

step3，把图形输出到布局的不同区域中
print(p.scatter, vp=viewport(layout.pos.row=2:3, layout.pos.col=1:2))
print(p.hist.len, vp=viewport(layout.pos.row=1, layout.pos.col=1:2))
print(p.hist.wid, vp=viewport(layout.pos.row=2:3, layout.pos.col=3))










ref: 
https://blog.csdn.net/albh81462/article/details/101662498
https://segmentfault.com/a/1190000007955532





========================================
|-- 使用 cowplot 包获取 ggplot2 图例，并在另一个位置重绘
----------------------------------------

g1=ggplot(mtcars, aes(x=gear, y = carb, fill = mpg)) +
  geom_tile()+
  theme_bw(); g1

# 获取图例
library(cowplot)
g2=get_legend(g1)
g2
print(g2)

# 画另一个图例
library(grid)
pushViewport(viewport(x=1, y=1, just = c("right","top"), width=0.2, height=0.3, name="legend_0"))
grid.draw(g2)
upViewport()
# 







========================================
|-- ggplot2设置坐标轴范围：用grid包在图中加入自定义要素 //todo
----------------------------------------
1. 需求： 有3张数据来源完全不同，theme什么的一大堆设置都调好的ggplot，把这三张图拼起来，然后共用一个x跟y轴，让他们变成一张图。

https://blog.csdn.net/weixin_39617685/article/details/109920035




2. 在 ggplot2 图中添加文字
https://www.stat.auckland.ac.nz/~paul/Reports/gggrid/gggrid.html

library(grid)
grid.newpage()

label <- textGrob("Label",
                  x=unit(1, "npc") - unit(5, "mm"),
                  y=unit(1, "npc") - unit(5, "mm"),
                  just=c("right", "top"))

grid.rect()
grid.draw(label)

# 画 ggplot 图
library(ggplot2)
ggplot(mtcars, aes(disp, mpg))+geom_point()

grid.draw(label) #在图右上角标记上文字






(2) 使用 grid.text 标注文字
library(ggplot2)
qplot(disp, mpg, data=mtcars)

# 查看名字
> grid.ls()
layout
> current.vpTree()
viewport[ROOT]->(viewport[GRID.VP.1]->(viewport[GRID.VP.2]), ..., viewport[panel.7-5-7-5],...

# 开始定位和修改
downViewport("panel.7-5-7-5")
grid.rect( gp=gpar(fill="#11223300", col="red")) #用于定位，可跳过

grid.text("n=32",
	x=unit(1, "npc") - unit(2, "mm"),
	y=unit(1, "npc") - unit(2, "mm"),
	just=c("right", "top"))















========================================
grid包 分组、路径、蒙版 (R 4.1.0 的图形引擎支持)、填充图形pattern和渐变色 //todo
----------------------------------------
Groups and Paths and Masks in R Graphics
https://developer.r-project.org/Blog/public/2021/12/06/groups-and-paths-and-masks-in-r-graphics/index.html



渐变色填充、图形填充、蒙版： https://blog.r-project.org/2020/07/15/new-features-in-the-r-graphics-engine/index.html


蒙版: https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/masks/masks.html













========================================
grid包 实例
----------------------------------------
3. 实例

(1) 空白画布，一个倾斜的矩形。
library(ggplot2)
library(grid)

grid.newpage() # 创建一个空白画布
vp1 <-viewport(x =0.5, y =0.5, width =0.5, height =0.25, angle =45) # 设定视窗大小
grid.show.viewport(vp1) # 查看在画布中的的视窗，自动上色，方便观察



library(grid)
grid.show.viewport(
	viewport(x=0.6, y=0.6, width=unit(1, "inches"), height=unit(1, "inches"), angle=30)
)




# 画一个圆
library(grid)
grid.newpage() # 创建一个空白画布

vp <- viewport(width=0.9,height=0.9)
pushViewport(vp)
# a rectangle (with dashed lines) on the border of the viewport:
grid.rect(gp=gpar(lty="dashed"))
# a circle centered at (.6,.4) with radius .3:
grid.circle(x=0.6, y=0.4, r=0.3)





(2) 一个空画布，添加多个 viewport

有了viewport这个工具，我们就可以很灵活的在图形中画出任意区域分割的子图了。


library(ggplot2)
library(grid)

#library(showtext) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei", regular ="msyh.ttc", bold ="msyhbd.ttc")
# 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#showtext_auto() #### 父viewport

grid.newpage() #新建一个page

#1) 新建一个viewport，起点为左下角，
vp1 <-viewport(x =0, y =0.2, w =0.9, h =0.8, just =c("left", "bottom")) 
pushViewport(vp1) # 推出vp1
grid.rect(gp =gpar(col ="red")) # 新建一个矩形,gp=gpar()表示设置图形参数

grid.text("vp1_1", x =0.8, y =0.2, gp =gpar(col ="red", fontfamily ="YaHei", fontsize =15)) # 新建一个文本,输出到vp1


#2) 新建一个viewport，起点为左下角，
vp2 <-viewport(x =0, y =0.2, w =0.9, h =0.8, just =c("left", "bottom")) 
pushViewport(name =vp2) # 将工作区域设置到vp2

# 新建一个矩形,gp=gpar()表示设置图形参数
grid.rect(x =0.1, y =0.2, width =0.9, height =0.7, just =c("left", "bottom"), gp =gpar(col ="blue", lty ="dashed"))

# 新建一个文本,输出到vp2
grid.text("vp2_1", x =0.8, y =0.3, gp =gpar(col ="blue", fontfamily ="YaHei", fontsize =15))


#3) 新建一个viewport
vp3 <-viewport(x =0.1, y =0.2, width =0.9, height =0.7, just =c("left", "bottom"))
pushViewport(vp3)
grid.rect(x =0.1, y =0.2, width =0.7, height =0.7, just =c("left", "bottom"), gp =gpar(col ="orange", lty ="twodash", lwd =2))

# 新建一个矩形,gp=gpar()表示设置图形参数
grid.text("vp3_1", x =0.6, y =0.4, gp =gpar(col ="orange", fontfamily ="YaHei", fontsize =15)) # 新建一个文本,输出到vp2




(3) layout参数

library(ggplot2)
library(grid)

grid.newpage() 

# 设置分割的宽度和长度比例
g1 <-grid.layout(nrow =3, ncol =2, widths =c(2, 3), heights =c(2, 1, 3)) 

grid.show.layout(l =g1)






























(4) 上下两块，下面分左右两部分。
library(ggplot2)
library(grid)

#library(showtext) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei", regular ="msyh.ttc", bold ="msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#showtext_auto() 

# 准备三个ggplot对象
plot.iris <-ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point() +
  facet_grid(cols =vars(Species)) # 按Species列分面

plot.mpg <-ggplot(mpg, aes(x =cty, y =hwy, colour =factor(cyl))) +
  geom_point(size =2.5) +
  labs(title ="dot plot") 

plot.diamonds <-ggplot(diamonds, aes(clarity, fill =cut)) +
  geom_bar() +
  theme(axis.text.x =element_text(angle =70, vjust =0.5)) +labs(title ="bar plot")

# 新建画布
grid.newpage()

layout_1<-grid.layout(nrow =3, ncol =2, widths =c(1, 1), heights =c(1, 4, 5)) # 分成上下2*3共6个版块，最上面版块显示标题

pushViewport(viewport(layout =layout_1)) # 推出分成6个版块的视窗

print(plot.iris, vp =viewport(layout.pos.row =2, layout.pos.col =c(1, 2))) # 在中间一行子视窗中画plot.iris
print(plot.mpg, vp =viewport(layout.pos.row =3, layout.pos.col =1)) # 在左下角子视窗中画plot.mpg
print(plot.diamonds, vp =viewport(layout.pos.row =3, layout.pos.col =2)) #在右下角子视窗中画plot.diamonds
grid.text("This is title", x =0.5, y =0.95, gp =gpar(col ="orange", fontfamily ="YaHei", fontsize =15)) #增加画布标题






(5) grid 拼接蝴蝶图
library(ggplot2)
library(grid)
library(dplyr)

#library(showtext)
#library(Cairo) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei",regular ="msyh.ttc", bold ="msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#CairoPNG(file ="E:/R_input&output/images_output/蝴蝶图_exercing.png", width =1200, height =700)
#showtext_begin()

#生成图形所需数据集：
mydata<-data.frame(id=1:14,
                   A=c(5.0,14.7,2.5,8.5,5.1,6.9,7.7,6.8,4.4,4.9,5.3,1.0,0.9,7.8),
                   B=c(31.3,24.7,17.8,17.2,15.3,14.3,13.9,13.9,12.4,10.0,6.5,4.2,2.5,0.9),
                   Label=c("Website","Customer & Employee Referral","Webinar",
                           "Facebook/Twitter/Other Social","Marketting & Advertising","Paid Serch","Other",
                           "Sales generated","Tradeshows","Parter","Linkedin","Events","Lead list","Emial Campaign")) 

p1<-ggplot(mydata) +# 绘制右侧的柱形图
  geom_hline(yintercept=mean(mydata$A),linetype=2,size=.25,colour="grey")+
  geom_bar(aes(x=id,y=A),stat="identity",fill="#E2BB1E",colour=NA)+
  ylim(-5.5,16)+
  scale_x_reverse()+
  geom_text(aes(x=id,y=-4,label=Label),vjust=.5)+
  geom_text(aes(x=id,y=A+.75,label=paste0(A,"%")),size=4.5,family="YaHei",fontface="bold")+
  coord_flip()+
  theme_void() 
p1 

p2<-ggplot(mydata)+# 绘制左侧柱形图, 左侧图没有横坐标刻度标签
  geom_hline(yintercept=-mean(mydata$B),linetype=2,size=.25,colour="grey")+
  geom_bar(aes(x=id,y=-B),stat="identity",fill="#C44E4C",colour=NA)+
  # y=-B,绘制的图形在另一侧
  ylim(-40,0)+scale_x_reverse()+
  geom_text(aes(x=id,y=-B-1.75,label=paste0(B,"%")),size=4.5,family="YaHei",fontface="bold")+
  coord_flip()+
  theme_void()
p2

# 图形拼接
grid.newpage() # 新建画布
layout_1<-grid.layout(nrow =2, ncol =2, widths =c(2, 3), heights =c(1, 9)) # 分成2*2共4个版块
pushViewport(viewport(layout =layout_1)) # 推出分为4个版块的视窗
print(p1, vp =viewport(layout.pos.row =2, layout.pos.col =2)) # 将p1输出到右下角
print(p2, vp =viewport(layout.pos.row =2, layout.pos.col =1)) # 将p2输出到左下角

# 添加主标题和分标题
grid.text(label="main Title",x =0.5,y =0.97,gp=gpar(col="cyan",fontsize=15,fontfamily="YaHei",draw=TRUE,just ="centre"))
grid.text(label="left Title", x =0.15,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just =c("left", "top")))
grid.text(label="right Title",x =0.85,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just =c("right", "top")))
#showtext_end()
#dev.off()









========================================
改造：包装、扩展
----------------------------------------
https://www.stat.auckland.ac.nz/~paul/Reports/CustomGrobs/custom-grob.html

子母图，主要是形成局部放大的效果，既可以从整体上对比，又兼顾特别小的数据组，或特别密的数据点可以查看，而没有必要单独做2张图


1. 画一个椭圆

(1) 不能旋转的椭圆
ellipse <- function( x, y, ra=0.2, rb=0.5, ...) {
  angle <- seq(0, 2*pi, length=101)
  grid.polygon(x + ra*cos(angle),
               y + rb*sin(angle), ...)
}
ellipse(0.2, 0.8, 0.6, 0.1, gp=gpar(col="red", lwd=3))

grid.text("XX data")
ellipse(.5, .5, 0.2, 0.1, gp=gpar(col="red", fill="#11223300"))



(2) 带旋转角度的椭圆

ellipse2 <- function( x, y, ra=0.2, rb=0.5, angle=0, ...) {
  angle_S <- seq(0, 2*pi, length=101)
  
  pushViewport(viewport(x, y, width=2*ra, height=2*rb, name="vp", angle =angle))
  grid.polygon(x + ra*cos(angle_S),
               y + rb*sin(angle_S), ...)
  upViewport()
}
grid.newpage()
grid.text("XX data")
ellipse2(.5, .5, 0.3, 0.2, angle=30, gp=gpar(col="red", lty=2, fill="#11223300"))
ellipse2(0.5, 0.5, unit(.3, "npc"), unit(.1, "npc")) #为什么报错？//todo


(3) 造一个节点：中间是文字的椭圆
ellipse <- function(x, y, a, b, ...) {
    pushViewport(viewport(x, y,
                          width=2*a, height=2*b))
    angle <- seq(0, 2*pi, length=101)
    grid.polygon(.5 + .5*cos(angle),
                 .5 + .5*sin(angle), ...)
    popViewport()
}

node <- function(x, y, label, ...) {
    grid.text(label, x, y)
    ellipse(x, y, stringWidth(label),
            unit(1, "lines"), gp=gpar(fill="#00000000", ...)) #背景填充色默认是白色，要改为透明
}

node(2/4, 2/3, "CPI data")
node(1/4, 1/3, "code")
node(3/4, 1/3, "???")




(4) 画线，虚线，带箭头的线
grid.segments(.2, .2, .8, .2)
grid.lines(c(.2, .5, .8), c(.4, .5, .4))
grid.xspline(c(.2, .5, .8), c(.6, .9, .6), shape=1)

#2) Drawing a grey dotted line
grid.segments(.2, .2, .8, .2)
grid.lines(c(.2, .5, .8), c(.4, .5, .4),
           gp=gpar(lty="dotted"))
grid.xspline(c(.2, .5, .8), c(.6, .9, .6),
             shape=1,
             gp=gpar(lty="dotted", col="grey"))


#3) Drawing a line with an arrow
arrow <- arrow(angle=20, length=unit(.1, "in"), type="closed") #定义一个箭头
grid.segments(.2, .2, .8, .2, arrow=arrow)
grid.lines(c(.2, .5, .8), c(.4, .5, .4),
           arrow=arrow)
grid.xspline(c(.2, .5, .8), c(.6, .9, .6),
             shape=1, arrow=arrow)


(5) 创建一个 Grob 椭圆对象

ellipseGrob <- function(x=.5, y=.5, a, b) {
    vp <- viewport(x, y, width=2*a, height=2*b)
    angle <- seq(0, 2*pi, length=101)
    polygonGrob(.5 + .5*cos(angle), .5 + .5*sin(angle), vp=vp)
}
eg <- ellipseGrob(a=.3, b=.1)
# 画出来
grid.draw(eg)


# 画一圈小椭圆
for (i in seq(0, 360, length.out=9)) {
  grid.circle(x=grobX(eg, i), y=grobY(eg, i),
              r=unit(1, "mm"),
              gp=gpar(fill="white"))
}


(6) 创建一个带名字的 Grob 椭圆对象

ellipseGrob <- function(x=.5, y=.5, a, b, name) {
    vp <- viewport(x, y, width=2*a, height=2*b)
    angle <- seq(0, 2*pi, length=101)
    polygonGrob(.5 + .5*cos(angle), .5 + .5*sin(angle),
                vp=vp, name=name)
}
eg <- ellipseGrob(a=.3, b=.1, name="el")
grid.draw(eg)

for (i in seq(0, 360, length.out=9)) {
    grid.circle(x=grobX("el", i), y=grobY("el", i),
                r=unit(1, "mm"),
                gp=gpar(fill="white"))
}


grid.ls(grobs=FALSE, viewports=TRUE)


(7) 画一个路径
library(graph) #怎么把这个包写出来？
gnel <- new("graphNEL",
            nodes=c("CPI", "code", "data"),
            edgeL=list(CPI=list(
                         edges=c("code", "data")),
                       code=list(),
                       data=list()),
            edgemode="directed")



# 保存为 svg 格式
eg <- ellipseGrob(a=.3, b=.1, name="el")
grid.draw(eg)

svg("ellipse-svg.svg")
grid.draw(eg)
dev.off()




grid.get("box", grep=TRUE, global=TRUE)
grid.edit("box", grep=TRUE, global=TRUE,
          gp=gpar(fill="white"))







(100) 能旋转的椭圆
# From gCurve we generate a function called grid.mirror, which draws the mirror image of a curve.
"ellipse" <- function (w=1/10, h, angle, xrange = c(0, 1),
                       yrange = c(0,1), default.units = "native",
                       vp = viewport(xscale = xrange, yscale = yrange, height=h, width=w,
                                     angle=angle), gp1 = NULL, gp2 = NULL, name = NULL) {
  
  grid.mirror(0.5 + sqrt(0.5^2 - (0.5 - x)^2), 0, 1,
              default.units = default.units,
              return = FALSE, vp = vp, gp1 = gp1, gp2 = gp2, name = name)
}

vp <- viewport(width=0.9,height=0.9)
pushViewport(vp)
grid.rect(gp=gpar(lty="dashed"))
ellipse(h=0.5, angle=30)






========================================
|-- 怎么回车时画出该 Grob 对象？ 
----------------------------------------

1. 想像 ggplot2 一样，返回一个对象，该对象可以直接print或者回车画出来

my_fn=function(){
  obj=grid::circleGrob()
  # Set new class
  class(obj) <- c("my_class", class(obj))
  return(obj)
}


# Define an S3 print method
print.my_class <- function(x, newpage = TRUE) {
  if (newpage) {
    grid::grid.newpage()
  }
  grid::grid.draw(x)
  invisible(x)
}

output <- my_fn()
class(output) #"my_class" "circle"   "grob"     "gDesc"

# Outputs plot when printing elements of output
output

# 相当于是执行了函数
print(output)










ref:
https://stackoverflow.com/questions/66956370/r-programming-return-ggplot-object-instead-of-grob





========================================
|-- 自定义一个图标，并复用 //todo
----------------------------------------
burningtree <- function() {
	grid.rect(x=.5, y=.2, width=.2, height=.4, gp=gpar(fill="grey", col=NA)) #一个矩形，填充灰色，没有描边颜色
	grid.circle(x=.5, y=.5, r=.3, gp=gpar(fill="orange", col=NA)) #一个圆形，橙色
	pushViewport(viewport(clip="on")) #新视口，开启裁剪
	pushViewport(viewport(x=.5, y=0, angle=45)) #一个45度的视口
	grid.rect(x=.5, y=.5, width=.2, height=.2, gp=gpar(fill="grey", col=NA)) #一个方块
	upViewport(2)
}

grid.newpage()
pushViewport(viewport())
burningtree()






========================================
|-- 自定义函数 cplot: 展示百分比的变化，类似百分比化的桑基图
----------------------------------------
1. 基础函数
grid.newpage()

prop <- function(x) {
  x/sum(x)
}

cprop <- function(x) {
  cumsum( x/sum(x) )
}

# 画连线的
connector <- function(x1, x2, gp=gpar(), name=NULL) {
	cp1 <- cprop(x1)
	cp2 <- cprop(x2)
	grid.segments(0, cp1, 1, cp2, gp=gp, name=name)
}

connector(1:10, 10:1,
	gp=gpar(col=grey(1:10/11), lwd=3),
	name="connectorDemo")

# 画堆叠矩形的
spine <- function(x, gp=gpar(), name=NULL) {
	px <- prop(x)
	cpx <- cprop(x)
	grid.rect(y=cpx, height=px, just="top", gp=gp, name=name)
}

spine(1:10,
	gp=gpar(fill=grey(1:10/11)),
	name="spineDemo")




2. cplot 主函数

A cplot() function that draws a series of line segments and rectangles based on the columns of a data frame.
The width argument controls the widths of the spines.

cplot <- function(df, gp=gpar(), name="cplot") {
  for (i in 1:length(df)) {
    spineName <- paste(name, "spine", i, sep="-")
    pushViewport(viewport(x=unit(i, "native"),
                          width=unit(0.5, "native"),
                          name=spineName))
    spine(df[[i]], gp=gp, name=spineName)
    upViewport()
    if (i > 1) {
      conName <- paste(name, "con", i, sep="-")
      pushViewport(viewport(x=unit(i - 0.5, "native"),
                            width=unit(0.5, "native"),
                            name=conName))
      connector(df[[i - 1]], df[[i]], gp=gp, name=conName)
      upViewport()
    }
  }
}



3. 画图
(1) 测试数据
Some data preparation ...
library(lattice)

barley1931 <- subset(barley, year == 1931)
barley1931$variety <- reorder(barley1931$variety,
                              barley1931$yield,
                              FUN=function(x) {
                                prop(x)[1]
                              })

barley1931 <- barley1931[order(barley1931$variety), ]
col <- hcl(seq(0, 300, 60), 70, 50)
fill <- hcl(seq(0, 300, 60), 70, 70)


(2) 画图
grid.newpage()
pushViewport(plotViewport(c(5, 4, 2, 2),
			xscale=c(0, 11),
			yscale=0:1),
			viewport(clip=TRUE,
			xscale=c(0, 11),
			yscale=0:1))

df <- as.data.frame(split(barley1931$yield, barley1931$variety))
cplot(df, gp=gpar(col=col, fill=fill))
popViewport()
grid.text(colnames(df),
		x=unit(1:10, "native"),
		y=unit(-0.5 ,"lines"),
		rot=30, just="right")
grid.yaxis()
grid.rect(gp=gpar(fill="#11223300"))
popViewport()



# 查看 grob 对象
grid.ls(viewports=TRUE, fullNames=TRUE)

# 把名字含有 con 的线条加粗
grid.edit("con", grep=TRUE, global=TRUE, gp=gpar(lwd=3))


(3) 使用 lattice 可以直接画

barley$variety <- factor(barley$variety,  
		levels=levels(barley1931$variety))

panel.cplot <- function(x, y, groups, subscripts, ...) {
		cplot(as.data.frame(split(y, x)),
		gp=gpar(col=col, fill=fill))
	}

print(
	xyplot(yield ~ variety | year, barley,
		groups=site, layout=c(1, 2),
		scales=list(x=list(rot=20), y=list(limits=0:1)),
		panel=panel.cplot)
)



ref: https://www.stat.auckland.ac.nz/~paul/useR2011-grid/gridHandout.pdf 100/114



========================================
lattice 绘图系统
----------------------------------------
lattice主要记录在 http://www.biomooc.com/R/R-draw-adv-lattice.html
[R In Action(2nd Edtion), Chapter23] https://livebook.manning.com/book/r-in-action-second-edition/bonus-chapter-23-advanced-graphics-with-the-lattice-package/


1. lattice 包
	函数：xyplot, bwplot, histogram, stripplot, dotplot, splom, levelplot, contourplot
	格式： xyplot(y~x| f*g, data) # f和g是分类变量
	panel函数，用于控制每个面板内的绘图

grid包：
	实现了独立于base的绘图系统
	lattice包是基于grid创建的；很少直接从grid包调用函数

lattice和base的重要区别：
	base绘图函数直接在图形设备上绘图
	lattice绘图函数返回trellis类对象
		打印函数真正执行了在设备上绘图
		命令执行时，trellis类对象会被自动打印，看起来像是lattice函数直接完成了绘图

#



refer:
https://www.imooc.com/video/11578





========================================
gridExtra 包: 扩展了 grob 对象及一些对象的操作 //todo
----------------------------------------














========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

