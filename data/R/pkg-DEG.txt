分析差异表达基因的包 limma, edgeR, DESeq2



使用limma、Glimma和edgeR，RNA-seq数据分析易如反掌
https://www.cnblogs.com/wangprince2017/p/9937080.html
原版：https://www.bioconductor.org/packages/devel/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow_CHN.html

三个包比较的: https://www.freesion.com/article/752576024/


limma包使用到edgeR DGEList object作为输入。



========================================
RNAseq差异表达基因分析方法 limma/voom, DEseq2, edgeR, 
----------------------------------------
1. 做差异基因分析的方法
(1) https://ccb.jhu.edu/software/stringtie/index.shtml
StringTie's output can be processed by specialized software like Ballgown, Cuffdiff or other programs (DESeq2, edgeR, etc.).

(2) https://combine-lab.github.io/salmon/getting_started/
After quantification
Quantifying your RNA-seq data with salmon is that simple (and fast). Once you have your quantification results you can use them for downstream analysis with differential expression tools like DESeq2, edgeR, limma, or sleuth. 
定量后做差异表达分析：DESeq2, edgeR, limma, or sleuth. 


(3)Other Bioconductor packages with similar aims are edgeR, limma, DSS, EBSeq, and baySeq.


(4) 归一化方法
早期用于归一化的方法就是RPKM，但这种方法现在已经淘汰，它已经被那些能够校正样本之间更细微差异的方法所取代，例如四分位数法或中位数归一法。


基因水平的工具通常依赖于比对好的读长数目，使用广义线性模型(Generalized Linear Models)处理这些数据，从而能够评估复杂的实验设计。这些工具包括edgeR，DESeq2以及limma+voom，这些工具能够进行有效地计算，并提供比较结果。



(5)
- limma fits a so-called linear model; examples of linear models are (1) linear regression, (2) multiple linear regression and (3) analysis of variance.

- edgeR, DESeq and DESeq2 fits generalized linear models, specifically models based on the negative binomial distribution.

Extremely simplified, limma is useful for continuous data such as microarray data and edgeR / DESeq / DESeq2 are useful for count data such as high-throughput sequencing. But that is a very simplified statement.


https://kasperdanielhansen.github.io/genbioconductor/html/limma.html




(6) limma/voom，edgeR，DESeq2分析注意事项，差异分析表达矩阵与分组信息(万字长文)
https://cloud.tencent.com/developer/article/1492130






2. 理论基础：线性模型， 设计矩阵和比较矩阵

基本上，统计课都会介绍如何使用t检验用来比较两个样本之间的差异，然后在样本比较多的时候使用方差分析确定样本间是否有差异。当然前是样本来自于正态分布的群体，或者随机独立大量抽样。

对于基因芯片的差异表达分析而言，由于普遍认为其数据是服从正态分布，因此差异表达分析无非就是用t检验和或者方差分析应用到每一个基因上。高通量一次性找的基因多，于是就需要对多重试验进行矫正，控制假阳性。目前在基因芯片的分析用的最多的就是limma。

但是，高通量测序(HTS)的read count普遍认为是服从泊松分布（当然有其他不同意见），不可能直接用正态分布的t检验和方差分析。 当然我们可以简单粗暴的使用对于的非参数检验的方法，但是统计力不够，结果的p值矫正之估计一个差异基因都找不到。老板花了一大笔钱，结果却说没有差异基因，是个负结果，于是好几千经费打了水漂，他肯定是不乐意的。因此，还是得要用参数检验的方法，于是就要说到方差分析和线性模型之间的关系了。

(1)
线性回归和方差分析是同一时期发展出的两套方法。在我本科阶段的田间统计学课程中就介绍用方差分析（ANOVA）分析不同肥料处理后的产量差异，实验设计如下
肥料	重复1	重复2	重复3	重复4
A1	...	...	...	...
A2	...	...	...	...
A3	...	... ...	...

这是最简单的单因素方差分析，每一个结果都可以看成 yij = ai + u + eij， 其中u是总体均值，ai是每一个处理的差异，eij是随机误差。


注：方差分析(Analysis of Variance, ANAOVA)名字听起来好像是检验方差，但其实是为了判断样本之间的差异是否真实存在，为此需要证明不同处理内的方差显著性大于不同处理间的方差。


(2)
线性回归 一般是用于量化的预测变量来预测量化的响应变量。比如说体重与身高的关系建模：
图 略。

当然线性回归也可用处理名义型或有序型因子（也就是离散变量）作为预测变量，如果要画图的话，就是下面这个情况。
图 略。

如果我们需要通过一个实验找到不同处理后对照组和控制组的基因变化，那么基因表达可以简单写成， y = a + b · treament + e。 和之前的 yij = ai + u + eij 相比，你会发现公式是如此的一致。 这是因为线性模型和方差分析都是广义线性模型(generalizing linear models, GLM)在正态分布的预测变量的特殊形式。而GLM本身只要采用合适的连接函数是可以处理对任意类型的变量进行建模的。


目前认为read count之间的差异是符合负二项分布，也叫gamma-Possion分布。那么问题来了，如何用GLM或者LM分析两个处理件的差异呢？其实可以简单的用上图的拟合直线的斜率来解释，如果不同处理之间存在差异，那么这个拟合线的斜率必定不为零，也就是与X轴平行。但是这是一种便于理解的方式（虽然你也未必能理解），实际更加复杂，考虑因素更多。

注1 负二向分布有两个参数，均值(mean)和离散值（dispersion). 离散值描述方差偏离均值的程度。泊松分布可以认为是负二向分布的离散值为1，也就是均值等于方差（mean=variance）的情况。

注2 这部分涉及大量的统计学知识，不懂就用维基百科一个个查清楚。



(3)
聊完了线性模型和方差分析，下面的设计矩阵（design matrix）就很好理解了， 其实就是用来告诉不同的差异分析函数应该如何对待变量。比如说我们要研究的KD和control之间变化，设计矩阵就是

样本	处理
sample1	control
sample2	control
sample3	KD
sample4	KD


(4)
那么比较矩阵（contrast matrix)就是告诉差异分析函数应该如何对哪个因素进行比较， 这里就是比较不同处理下表达量的变化。




(5)
标准化一二事
其实read count如何标准化的方法有很多，最常用的是FPKM和RPKM，虽然它们其实是错的--FPKM/RPKM是错的(https://www.plob.org/article/11531.html 我不太认同这篇解释)。


我推荐阅读 Comparing the normalization methods for the differential analysis of Illumina high-throughput RNA-Seq data , 了解不同标准化方法之间的差异。


有一些方法是要求原始数据，有一些则要求经过某类标准化后的数据，记得区分。









3. 探索性分析一二事




========================================
|-- (1) 使用DESeq2进行差异基因分析
----------------------------------------
DESeq2差异基因分析和批次效应移除  原创： 易生信  生信宝典  2018-05-29
https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&mid=2247485368&idx=1&sn=12b20487e9014ce2e69f01d3efbc6ce8&scene=21


注意：
DESeq2只能输入原始counts矩阵，不能是标准化后的！所有基于负二项分布模型的都不能使用标准化后的矩阵作为input。
DESeq2 doesn’t actually use normalized counts, rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that peform differential expression analysis which use the negative binomial model.
https://www.jianshu.com/p/e2fae0f3db1a



1. 安装
library(BiocManager)
BiocManager::install("DESeq2")

if(0){
  #checking for gzopen in -lz... yes
  #checking for xmlParseFile in -lxml2... yes
  #You are trying to use a version 2.* edition of libxml
  #but an incompatible library. The header files and library seem to be
  #mismatched. If you have specified LIBXML_INCDIR, make certain to also
  #specify an appropriate LIBXML_LIBDIR if the libxml2 library is not in the default
  #directories.
  
  #ERROR: configuration failed for package ‘XML’
  #* removing ‘/home/wangjl/R/x86_64-pc-linux-gnu-library/4.2/XML’
  #https://zhuanlan.zhihu.com/p/606562491
  Sys.setenv(XML_CONFIG="/usr/bin/xml2-config") #指定安装时libxml2的目录
  install.packages("XML")
  
  # installation of package ‘RCurl’ had non-zero exit status
  install.packages("RCurl") 
  # 重启R，再次安装
}
library(DESeq2) #1.38.3 (2023.11)







2. 使用 
关于DESeq2分析差异表达基因，其实在https://www.bioconductor.org/help/workflows/rnaseqGene/ 里面介绍的非常清楚了。

我们已经准备好了count matrix，接下来就是把数据导入DESeq2。DESeq2导入数据的方式有如下4种，基本覆盖了主流read count软件的结果。

注 DESeq2要求的数据是raw count， 没必要进行FPKM/TPM/RPFKM/TMM标准化。
function	|package	|framework	|output	|DESeq2 input function
summarizeOverlaps	|GenomicAlignments	|R/Bioconductor	|SummarizedExperiment	|DESeqDataSet
featureCounts	|Rsubread	|R/Bioconductor	|matrix	|DESeqDataSetFromMatrix
tximport	|tximport	|R/Bioconductor	|list of matrices	|DESeqDataSetFromTximport
htseq-count	|HTSeq	|Python	|files	|DESeqDataSetFromHTSeq


本来我们是可以用DESeq2为htseq-count专门提供的 DESeqDataSetFromHTSeq ，然而很尴尬数据不够要自己凑数，所以只能改用 DESeqDataSetFromMatrix了

导入数据，构建 DESeq2 所需的 DESeqDataSet 对象

library(DESeq2)
countData <- raw_count_filt[,2:5]
condition <- factor(c("control","KD","KD","control"))
dds <- DESeqDataSetFromMatrix(countData, DataFrame(condition), design= ~ condition )

注： 这一步到下一步之间可以过滤掉一些low count数据，节省内存，提高运行速度
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)


使用DESeq进行差异表达分析： DESeq包含三步，
estimation of size factors（estimateSizeFactors)， 
estimation of dispersion（estimateDispersons)， 
Negative Binomial GLM fitting and Wald statistics（nbinomWaldTest），
可以分布运行，也可用一步到位，最后返回 results可用的DESeqDataSet对象。

dds <- DESeq(dds)
# 出现如下提示信息，说明运行成功
# estimating size factors
# estimating dispersions
# gene-wise dispersion estimates
# mean-dispersion relationship
# final dispersion estimates
# fitting model and testing

用results获取结果： results的参数非常的多，这里不好具体展开，但是你们会自己看的吧
res <- results(dds)

我们可用mcols查看每一项结果的具体含义，比如说log2FoldChange 表示倍数变化取log2结果，还能画个火山图。一般简单粗暴的用2到3倍作为阈值，但是对于低表达的基因，3倍也是噪音，那些高表达的基因，1.1倍都是生物学显著了。更重要的没有考虑到组内变异，没有统计学意义。padj 就是用BH对多重试验进行矫正。

mcols(res, use.names = TRUE)
## DataFrame with 6 rows and 2 columns
##                        type                                     description
##                 <character>                                     <character>
## baseMean       intermediate       mean of normalized counts for all samples
## log2FoldChange      results log2 fold change (MLE): condition KD vs control
## lfcSE               results         standard error: condition KD vs control
## stat                results         Wald statistic: condition KD vs control
## pvalue              results      Wald test p-value: condition KD vs control
## padj                results                            BH adjusted p-values


用summary看描述性的结果，大致是上调的基因占总体的11%，下调的是7.1%（KD vs control）
summary(res)
out of 29469 with nonzero total read count
adjusted p-value < 0.1
LFC > 0 (up)     : 3154, 11%
LFC < 0 (down)   : 2095, 7.1%
outliers [1]     : 0, 0%
low counts [2]   : 15111, 51%
(mean count < 22)
[1] see 'cooksCutoff' argument of ?results
[2] see 'independentFiltering' argument of ?results



画个MA图，还能标注p值最小的基因。

An MA plot is an application of a Bland–Altman plot for visual representation of genomic data. The plot visualises the differences between measurements taken in two samples, by transforming the data onto M (log ratio) and A (mean average) scales, then plotting these values. Though originally applied in the context of two channel DNA microarray gene expression data, MA plots are also used to visualise high-throughput sequencing analysis --From wikipeida
M表示log fold change，衡量基因表达量变化，上调还是下调。A表示每个基因的count的均值。根据summary可知，low count的比率很高，所以大部分基因表达量不高，也就是集中在0的附近（log2(1)=0，也就是变化1倍）.提供了模型预测系数的分布总览。


下图是没有经过 statistical moderation平缓log2 fold changes的情况

plotMA(res, ylim = c(-5,5))
topGene <- rownames(res)[which.min(res$padj)]
with(res[topGene, ], {
  points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
  text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})

图 略 logFC - Mean of normalized counts.



如果经过lfcShrink 收缩log2 fold change， 结果会好看很多

res.shrink <- lfcShrink(dds, contrast = c("condition","KD","control"), res=res)
plotMA(res.shrink, ylim = c(-5,5))
topGene <- rownames(res)[which.min(res$padj)]
with(res[topGene, ], {
  points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
  text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})

图 略 logFC - Mean of normalized counts.


当然还有火山图，不过留给其他方法作图，我们先把差异表达的基因找出来。

res.deseq2 <- subset(res, padj < 0.05)

一般p value 小于0.05就是显著了, 显著性不代表结果正确，只用于给后续的富集分析和GSEA提供排序标准和筛选而已。关于P值的吐槽简直无数， 请多注意。











========================================
|-- (2)使用edgeR进行差异基因分析
----------------------------------------
edgeR在函数说明中称其不但可以分析SAGE， CAGE的RNA-Seq，Tag-RNA，或RNA-seq， 也能分析ChIP-Seq和CRISPR得到的read counts数据。嗯，我信了。

edgeR使用DGEList函数读取count matrix数据，也就说你需要提供一个现成的matrix数据，而不是指望它能读取单独的文件，然后进行合并(当然机智的我发现，其实可以用 tximport 或 DESeqDataSetFromHTSeq 读取单独的文件，然后传递给DGEList)


第一步： 构建DGEList对象

library(edgeR)
group <- factor(c("control","KD","KD","control"))
genelist <- DGEList(counts=raw_count_filt[,2:5], group = group)



第二步： 过滤 low counts数据。
与DESeq2的预过滤不同，DESeq2的预过滤只是为了改善后续运算性能，在运行过程中依旧会自动处理low count数据，edgeR需要在分析前就要排除那些low count数据，而且非常严格。从生物学角度，有生物学意义的基因的表达量必须高于某一个阈值。从统计学角度上， low count的数据不太可能有显著性差异，而且在多重试验矫正阶段还会拖后腿。 综上所诉，放心大胆的过滤吧。

根据经验（又是经验）， 基因至少在某一些文库的count超过10 ~ 15 才被认为是表达。这一步全靠尝试， 剔除太多就缓缓，剔除太少就严格点。 我们可以简单的对每个基因的raw count进行比较，但是建议用CPM（count-per-million)标准化 后再比较，避免了文库大小的影响。

# 简单粗暴的方法
keep <- rowSums(genelist$count) > 50
# 利用CPM标准化
keep <- rowSums(cpm(genelist) > 0.5 ) >=2
table(keep)
genelist.filted <- genelist[keep, ,keep.lib.sizes=FALSE]

这里的0.5(即阈值）等于 10/(最小的文库的 read count数 /1000000)，keep.lib.size=FALSE表示重新计算文库大小。



第三步： 根据组成偏好(composition bias)标准化。edgeR的calcNormFactors函数使用TMM算法对DGEList标准化

genelist.norm <- calcNormFactors(genelist.filted)

注 大部分的mRNA-Seq数据分析用TMM标准化就行了，但是也有例外，比如说single-cell RNA-Seq(Lun, Bach, and Marioni 2016), 还有就是global differential expression， 基因组一半以上的基因都是差异表达的，请尽力避免，(D. Wu et al. 2013)， 不然就需要用到内参进行标准化了(Risso et al. 2014).



第四步： 实验设计矩阵(Design matrix)， 类似于DESeq2中的design参数。 edgeR的线性模型和差异表达分析需要定义一个实验设计矩阵。很直白的就能发现是1vs0

design <- model.matrix(~0+group)
colnames(design) <- levels(group)
design
  control KD
1       1  0
2       0  1
3       0  1
4       1  0




第五步： 估计离散值（Dispersion）。前面已经提到负二项分布（negative binomial，NB)需要均值和离散值两个参数。edgeR对每个基因都估测一个经验贝叶斯稳健离散值（empirical Bayes moderated dispersion），还有一个公共离散值（common dispersion，所有基因的经验贝叶斯稳健离散值的均值）以及一个趋势离散值

genelist.Disp <- estimateDisp(genelist.norm, design, robust = TRUE)
plotBCV(genelist.Disp)


还可以进一步通过quasi-likelihood (QL)拟合NB模型，用于解释生物学和技术性导致的基因特异性变异 (Lund et al. 2012; Lun, Chen, and Smyth 2016).

fit <- glmQLFit(genelist.Disp, design, robust=TRUE)
head(fit$coefficients)

注1 估计离散值这个步骤其实有许多estimate*Disp函数。当不存在实验设计矩阵(design matrix)的时候，estimateDisp 等价于 estimateCommonDisp 和 estimateTagwiseDisp 。而当给定实验设计矩阵(design matrix)时， estimateDisp 等价于 estimateGLMCommonDisp, estimateGLMTrendedDisp 和 estimateGLMTagwiseDisp。 其中tag与gene同义。

注2 其实这里的第三， 四， 五步对应的就是DESeq2的DESeq包含的2步，标准化和离散值估测。






第六步: 差异表达检验（1）。这一步主要构建比较矩阵，类似于DESeq2中的results函数的 contrast 参数。

cntr.vs.KD <- makeContrasts(control-KD, levels=design)
res <- glmQLFTest(fit, contrast=cntr.vs.KD)
ig.edger <- res$table[p.adjust(res$table$PValue, method = "BH") < 0.01, ]

这里用的是glmQLFTest而不是glmLRT是因为前面用了glmQLTFit进行拟合，所以需要用QL F-test进行检验。如果前面用的是glmFit，那么对应的就是glmLRT. 作者称QL F-test更加严格。多重试验矫正用的也是BH方法。

后续就是提取显著性差异的基因用作下游分析，做一些图看看

topTags(res,n=10)
is.de <- decideTestsDGE(res)
summary(is.de)
plotMD(res, status=is.de, values=c(1,-1), col=c("red","blue"),
       legend="topright")
# 图略



第六步：差异表达检验（2）。上面找到的显著性差异的基因，没有考虑效应值，也就是具体变化了多少倍。我们也可用找表达量变化比较大的基因，对应的函数是 glmTreat。

tr <- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))
s
# 图略 




ref:
1. R语言实战：edgeR-RNASeq差异基因鉴定 https://www.jianshu.com/p/cabee4bb7441







========================================
|-- (3)使用limma进行差异分析
----------------------------------------
经过上面两个方法的洗礼，基本上套路你也就知道了，我先简单小结一下，然后继续介绍limma包的 voom 。

1)导入read count， 保存为专门的对象用于后续分析
2)原始数据过滤，根据标准化read count 或者 raw count 作为筛选标准
3)raw read count 标准化
4)通过各种算法（如经验贝叶斯，EM）预测disperion离散值
5)广义线性模型拟合数据
6)差异分析，也就是统计检验部分




###################
# 第一步
vfit <- lmFit(v, design)
# 第二步
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit)
# 第三步
ofit <- topTable(efit, coef=1, n=Inf)
DEG <- na.omit(ofit)
head(DEG)





###################
1.  读取文件
读取基因在所有样本中的表达量文件，示例如下
gene_id ctrl-1 ctrl-2 ctrl-3 case-1 case-2 case-3
geneA 14  0  11  4  0  12
geneB 125 401 442 175 59 200
每一行为一个基因，每一列代表一个样本。读取数据的代码如下
# 读取表达量的表格
counts <- read.table(
  "gene.counts.tsv",
  header=T,
  sep="\t",
  row.names=1,
  comment.char="",
  check.names=F)

# 设置样本分组
group <- factor(rep(c("control", "case"), each = 3))
design <- model.matrix(~group)

# 构建edgeR中的对象
library(edgeR)
y <- DGEList(counts=count)
之所以采用edgeR来读取数据，是为了方便后续的预处理和归一化。


2. 过滤count数很低的基因
和edgeR中的预处理过程类似，根据CPM表达量对基因进行过滤，代码如下
keep <- rowSums(cpm(y)>1) >= 2
y <- y[keep, , keep.lib.sizes=FALSE]

3. 归一化
默认采用TMM归一化算法，计算每个样本的 sizefactor, 代码如下
y <- calcNormFactors(y)

4. 表达量转换
在进行差异分析前，需要对表达量进行转换，有以下两种选择
logCPM
voom

第一种转换就是计算logCPM值，第二种转换适用于样本间sizaFactors差异较大的情况。转换的代码如下
# logCPM
logCPM <- cpm(dge, log=TRUE, prior.count=3)
# voom
v <- voom(dge, design, plot=TRUE)

5. 差异分析
转换之后的表达量就可以进行差异分析了，代码如下
fit <- lmFit(logCPM, design)
fit <- eBayes(fit, trend=TRUE)
res<- topTable(fit, coef=ncol(design))
上述代码采用的是logCPM值，当然也可以采用voom转换后的值，当采用voom转换时，注意trend参数为FALSE。

这里只是介绍了最简单的用法，更多复杂案例，比如多个分组，时间序列的差异分析等，请参考官方文档。






###################
Limma原先用于处理基因表达芯片数据，可是说是这个领域的老大。如果你仔细看edgeR导入界面，你就会发现，edgeR有一部分功能依赖于limma包。Limma采用经验贝叶斯模型（ Empirical Bayesian model）让结果更稳健。

在处理RNA-Seq数据时，raw read count先被转成log2-counts-per-million (logCPM)，然后对mean-variance关系建模。建模有两种方法：
- 精确权重法（precision weights）也就是“voom"
- 经验贝叶斯先验趋势（empirical Bayes prior trend），也就是”limma-trend“

数据预处理： Limma使用edgeR的DGEList对象，并且过滤方法都是一致的，对应edgeR的第一步,第二步， 第三步

library(edgeR)
library(limma)
group <- factor(c("control","KD","KD","control"))
genelist <- DGEList(counts=raw_count_filt[,2:5], group = group)
 
### filter base  use CPM
keep <- rowSums(cpm(genelist) > 0.5 ) >=2
table(keep)
genelist.filted <- genelist[keep, ,keep.lib.sizes=FALSE]
### normalizaition
x <- calcNormFactors(x, method = "TMM")


# 差异表达分析: 使用”limma-trend“
design <- model.matrix(~0+group)
colnames(design) <- levels(group)
logCPM <- cpm(genelist.norm, log=TRUE, prior.count=3)
fit <- lmFit(logCPM, design)
fit <- eBayes(fit, trend=TRUE)
topTable(fit, coef=ncol(design))


# 差异表达分析: 使用”limma-voom“
### DGE with voom
v <- voom(genelist.norm, design, plot=TRUE)
#v <- voom(counts, design, plot=TRUE)
fit <- lmFit(v, design)
fit <- eBayes(fit)
all <- topTable(fit, coef=ncol(design), number=10000)
sig.limma <- all[all$adj.P.Val < 0.01, ]
fit <- treat(fit, lfc=log2(1.2))
topTreat(fit, coef=ncol(design))

如果分析基因芯片数据，必须好好读懂LIMMA包。







========================================
|-- 4. 不同软件包分析结果比较
----------------------------------------
基本上每一个包，我都提取了各种的显著性基因，比较就需要用韦恩图了，但是我偏不，我要用UpSetR.

library(UpSetR)
input <- fromList(list(edgeR=rownames(sig.edger), DESeq2=rownames(sig.deseq2), limma=rownames(sig.limma)))

图略

感觉limma的结果有点奇怪，有生之年在折腾吧。




5. 使用GFOLD进行无重复样本的差异基因分析
参考文件
[1] Comparing the normalization methods for the differential analysis of Illumina high-throughput RNA-Seq data





三、总结
limma，edgeR，DESeq2三大包基本是做转录组差异分析的金标准，大多数转录组的文章都是用这三个R包进行差异分析。

edgeR差异分析速度快，得到的基因数目比较多，假阳性高（实际不差异结果差异）。

DESeq2差异分析速度慢，得到的基因数目比较少，假阴性高（实际差异结果不差异）。

需要注意的是制作分组信息的因子向量是，因子水平的前后顺序，在R的很多模型中，默认将因子向量的第一个水平看作对照组。



四、假如是多个分组呢
比如，大家都知道，TCGA的乳腺癌可以分成PAM50的5类，那么差异分析就复杂了。

这个时候有两个策略来做差异分析，当然，分组比较多的时候，差异分析并不是最好的策略啦，WGCNA等其它算法更好！



策略1：在分组信息里面挑选 
参考代码 https://github.com/jmzeng1314/my-R/tree/master/10-RNA-seq-3-groups

group_list
cont.matrix=makeContrasts(contrasts=c('treat_12-control','treat_2-control'),levels = design)
fit2=contrasts.fit(fit,cont.matrix)
fit2=eBayes(fit2)

tempOutput = topTable(fit2, coef='treat_12-control', n=Inf)
DEG_treat_12_limma_voom = na.omit(tempOutput)
write.csv(DEG_treat_12_limma_voom,"DEG_treat_12_limma_voom.csv",quote = F)

tempOutput = topTable(fit2, coef='treat_2-control', n=Inf)
DEG_treat_2_limma_voom = na.omit(tempOutput)
write.csv(DEG_treat_2_limma_voom,"DEG_treat_2_limma_voom.csv",quote = F)



使用WGCNA发表的文章：
[5.68] https://www.ncbi.nlm.nih.gov/pubmed/31382519
[2.53] https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6639467/






策略2：提取子矩阵和子分组信息 
这个很容易理解了，把表达矩阵根据自己想要进行的两两比对来筛选即可，这样就可以多次做差异分析啦，而且保证每次都只有两个分组。













refer:
https://www.plob.org/article/11506.html




========================================
|-- 是否需要(差异比较矩阵) makeContrasts函数？
----------------------------------------

做差异分析，需要三个数据：
- 表达矩阵
- 分组矩阵
- 差异比较矩阵

前面两个肯定是必须的，有表达矩阵，样本必须进行分组，才能分析，但是我看到过好几种例子，有的有差异比较矩阵，有的没有。
后来我仔细研究了一下limma包的说明书，发现这其实是一个很简单的问题。

design=model.matrix(~factor(sCLLex$Disease))
design=model.matrix(~0+factor(sCLLex$Disease))
有本质的区别！！！

前面那种方法已经把需要比较的组做出到了一列，需要比较多次，就有多少列，第一列是截距不需要考虑，第二列开始往后用coef这个参数可以把差异分析结果一个个提取出来。 

而后面那种方法，仅仅是分组而已，组之间需要如何比较，需要自己再制作差异比较矩阵，通过makeContrasts函数来控制如何比较！



refer:
答读者问第一弹:R里面差异分析的limma包用法细节 原创： jimmy  生信技能树  2017-06-01


========================================
limma 是GEO2R使用的筛选差异表达基因的包 (limma-voom方法支持RNAseq的count数据) 经验贝叶斯方法是limma的核心方法
----------------------------------------

1. Linear Models for Microarray Data
Data analysis, linear models and differential expression for microarray data.
http://www.bioconductor.org/packages/release/bioc/html/limma.html
limma Bioconductor单页教程 https://kasperdanielhansen.github.io/genbioconductor/html/limma.html


limma包以前只支持microarray的表达数据。考虑到大家都熟悉了它，作者又发了一个voom的方法，支持RNA-seq的count数据！

芯片数据跟RNA-seq数据的本质就是value的分布不一样，所以各种针对RNA-seq的差异分析包也就是提出来一个新的normalization方法而已。而我们limma本身就提出了一个voom的方法来对RNA-seq数据进行normalization



使用这个包也需要三个数据：
1.表达矩阵：就是熟知的matrix形式
2.分组矩阵：也就是实验设计（design）矩阵
3.差异比较矩阵：就是说那几个组之间进行比较
用法与limma分析芯片一模一样的，只是多了一个normalization而已。

总共只有三个步骤：
lmFit
eBayes
topTable
(基因芯片的做法见：https://www.plob.org/article/9963.html)


Limma-voom强大在于三个方面：
- False discovery rate比较低（准确性），异常值影响小
- 假阳性控制不错
- 运算很快



2.使用
(1)安装
> source("http://bioconductor.org/biocLite.R")
> biocLite("limma")
#
> library(limma)
> limmaUsersGuide()
打开pdf手册。
关于RNAseq的在chapter15，例子在chapter18.

In the limma approach to RNA-seq, read counts are converted to log2-counts-per-million (logCPM) and the mean-variance relationship is modelled either with precision weights or with an empirical Bayes prior trend.
read计数转换为logCPM，mean-variance的关系使用精确权重或者经验贝叶斯先验趋势建模。

The precision weights approach is called "voom" and the prior trend approach is called "limma-trend"[15].
精确权重方法叫Voom，先验趋势方法叫做Limma趋势。

In either case, the RNA-seq data can be analyzed as if it was microarray data. This means that any of the linear modelling or gene set testing methods in the limma package can be applied to RNA-seq data.



(2) 建立count矩阵
Read map到exon或者gene上，获得counts矩阵。
这一步可以用Rsubread包，方便而且快。
其他流行方法包括 RSEM和HTseq，featureCounts等。
一个例子subread-featureCounts-limma: http://bioinf.wehi.edu.au/RNAseqCaseStudy


RNA-Seq of PRMT1 overexpression ECA109 cells
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE128913
下载一个细胞系过表达与对照，各3个重复。

#读取矩阵
exprSet2=read.table("F://Temp/data/GSE128913_All.counts.txt",header=T,row.names = 1)
dim(exprSet2) #[1] 54261     6
head(exprSet2, n=10)
# 实验设计，前3列是对照，后三列是过表达
group_list2=c(rep("NC",3), rep('OE',3))
group_list2=factor(group_list2);group_list2
#
# 第一步：构建分组矩阵
library(limma)
design <- model.matrix(~factor(group_list))
colnames(design)=levels(factor(group_list))
rownames(design)=colnames(exprSet)
design
##           NC OE
## LV.GFP1    1  0
## LV.GFP2    1  0
## LV.GFP3    1  0
## LV.PRMT1A  1  1
## LV.PRMT1B  1  1
## LV.PRMT1C  1  1






(3) Normalization and fltering
输入read counts矩阵，行为gene列为sample，使用edgeR包创建DGEList对象：
> dge <- DGEList(counts=counts)

接着去除全是0或者很少counts的行。
> keep <- filterByExpr(dge, design)
> dge <- dge[keep,,keep.lib.sizes=FALSE]
这就过滤好了。


接着应用scale normalization to RNA-seq read counts, 以及在比较研究中表现很好的TMM标准化方法。
> dge <- calcNormFactors(dge)



(4) Differential expression: limma-trend
如果各个样品中测序深度比较一致，最简单、健壮的方法是使用limma-trend。
该方法在library size(max/min)<3倍时表现不错。

在limma-trend方法中，使用edgeR的cpm函数转换counts为logCPM：
> logCPM <- cpm(dge, log=TRUE, prior.count=3)
prior count是为了丢弃低counts的算法变异。

这个logCPM值可以被用于任何标准limma管线，运行eBayes或者treat时加上trend=T参数：
> fit <- lmFit(logCPM, design)
> fit <- eBayes(fit, trend=TRUE)
> topTable(fit, coef=ncol(design))


或者，在基因排序时给fold-change更多权重：
fit <- lmFit(logCPM, design)
> fit <- treat(fit, lfc=log2(1.2))
> topTreat(fit, coef=ncol(design))




(5) Dfferential expression: voom
不同样本库容量差异很大时，理论上voom方法比limma-trend要更强大。
该方法中，voom转换是使用到表转化、过滤过的DEGList对象上的：
v <- voom(dge, design, plot=TRUE)
voom转换使用实验设计矩阵，产生一个EList对象。


# voom到底做了什么转换？
- 首先原始counts转换成log2的CPM（counts per million reads ），这里的per million reads是根据之前calcNormFactors计算的norm.factors进行规定的；
- 然后根据每个基因的log2CPM制作了线性模型，并计算了残差 ；
- 然后利用了平均表达量（红线）拟合了sqrt(residual standard deviation)；
- 最后得到的平滑曲线可以用来得到每个基因和样本的权重
#
limma-voom method assumes that rows with zero or very low counts have been removed
如果横坐标接近0的位置出现迅速上升，说明low counts数比较多

Whether your data are "good" or not cannot be determined from this plot





也可以不用TMM表转化，直接给voom一个counts矩阵：
> v <- voom(counts, design, plot=TRUE)
如果数据噪声大，可以采用和芯片相同的、样本间标准化方法：
> v <- voom(counts, design, plot=TRUE, normalize="quantile")

这之后，可以使用常规limma管线了：
> fit <- lmFit(v, design)
## makeContrasts() https://www.jianshu.com/p/dee7346482e5 
> fit <- eBayes(fit)
> topTable(fit, coef=ncol(design))

或者，在基因排序时给fold-change更多权重：
> fit <- treat(fit, lfc=log2(1.2))
> topTreat(fit, coef=ncol(design))




(6) Voom with sample quality weights
如果multi-dimensional scaling plot显示RNAseq数据有离群样本，可能要结合(用于voom的)观察水平的权重策略，和样品特异的质量权重(在上文芯片质量权重Array Quality Weights讲过)，来给离群样本去权重。实现于voomWithQualityWeights函数中。

接下来的例子展示了，淋巴瘤细胞系(GSE64099)中表观调控子Smchd1敲除后RNAseq数据集。
总的来说，结合这个合并的权重策略我们获得了更多的差异表达，且被敲除的Smchd1基因的原始p值、FDR都变小了。

> plotMDS(x, labels=1:7, col=as.numeric(genotype), main="MDS plot")
> legend("topright", legend=c("WT", "KO"), col=1:2, pch=15)

图 MDS plot.

> # Analysis with voom only
> des[1:7,]
# (Intercept) Smchd1nullvsWt
# 1 1 1
# 2 1 1
# 3 1 1
# 4 1 1
# 5 1 0
# 6 1 0
# 7 1 0
> v <- voom(x, design=des)
> plotMDS(v, labels=1:7, col=as.numeric(genotype))
> vfit <- lmFit(v)
> vfit <- eBayes(vfit)
> options(digits=3)
> topTable(vfit,coef=2,sort.by="P")
## 	GeneID Symbols logFC AveExpr t P.Value adj.P.Val B
## 74355 74355 Smchd1 -3.12 6.067 -23.35 2.16e-08 0.000266 9.97
## 18028 18028 Nfib 8.98 1.714 12.60 2.17e-06 0.013355 3.15
## 75605 75605 Kdm5b -3.55 3.618 -11.75 3.62e-06 0.014857 5.06
## 667435 667435 Igkv17-121 -5.35 -1.435 -10.22 9.95e-06 0.025513 2.57
## 381126 381126 Garem 6.17 0.113 10.08 1.10e-05 0.025513 2.35
## 381413 381413 Gpr176 -4.02 1.328 -9.90 1.25e-05 0.025513 3.39
## 75033 75033 Mei4 6.44 0.259 9.69 1.45e-05 0.025513 2.23
## 69136 69136 Tusc1 5.67 -0.184 8.90 2.67e-05 0.040995 1.87
## 233552 233552 Gdpd5 -2.82 1.948 -8.56 3.49e-05 0.042754 2.81
## 80890 80890 Trim2 -1.43 4.491 -8.40 4.00e-05 0.042754 2.72



> top <- topTable(vfit,coef=2,number=Inf,sort.by="P")
> sum(top$adj.P.Val<0.05)
[1] 12
> # Analysis with combined voom and sample quality weights
> vwts <- voomWithQualityWeights(x, design=des, normalization="none", plot=TRUE)
> vfit2 <- lmFit(vwts)
> vfit2 <- eBayes(vfit2)
> topTable(vfit2,coef=2,sort.by="P")
##       GeneID Symbols logFC AveExpr t P.Value adj.P.Val B
## 74355 74355 Smchd1 -3.17 6.067 -28.5 1.61e-09 1.98e-05 12.57
## 18028 18028 Nfib 9.23 1.714 19.0 4.44e-08 2.73e-04 6.91
## 381126 381126 Garem 6.45 0.113 15.9 1.85e-07 7.58e-04 6.02
## 75033 75033 Mei4 6.56 0.259 15.0 2.84e-07 8.73e-04 5.83
## 69136 69136 Tusc1 5.88 -0.184 13.6 6.16e-07 1.11e-03 5.31
## 54354 54354 Rassf5 5.74 4.554 13.6 6.26e-07 1.11e-03 6.63
## 75605 75605 Kdm5b -3.80 3.618 -13.5 6.53e-07 1.11e-03 6.67
## 58998 58998 Pvrl3 7.69 0.961 13.1 8.46e-07 1.11e-03 5.33
## 320398 320398 Lrig3 7.39 1.584 13.1 8.49e-07 1.11e-03 5.32
## 17069 17069 Ly6e 2.63 7.605 13.0 9.01e-07 1.11e-03 6.26

> top2 <- topTable(vfit2,coef=2,number=Inf,sort.by="P")
> sum(top2$adj.P.Val<0.05)
## [1] 1478

#可能还要过滤na值
> DEG <- na.omit(top2)
> head(DEG, 5)
#
# 如果以logFC=2，Pvalue=0.05为阈值进行过滤
> length(which(DEG$adj.P.Val < 0.05 & abs(DEG$logFC)>2 ))


图 voom:Mean-variance trend 
图 Sample-specific weights



Tips:

怎么区分logFC正负的和样本的关系？cancer-normal(基准)中，logFC为正，则表示在cancer中高表达。
基准呢，看Levels部分哪个样本先出现，哪个就是基准。

如果想要改变reference组，可以用relevel()函数

还包括t检验数据、P值（P.Value 对于多组比较未校正）、校正的P值（adj.P.Val 默认使用Benjamini-Horchberg方法对多组进行P值校正）






(7) Differential splicing
差异化选择性剪切
需要exon水平的表达矩阵，一行是exon上的read counts，一列是一个样本。

> dge <- DGEList(counts=counts)
> dge$genes$GeneID <- GeneID
counts是一个exon水平的矩阵，GeneID描述了exon属于哪个基因。

接着过滤和标准化：Then filter and normalize:
> A <- rowSums(dge$counts)
> dge <- dge[A>10,, keep.lib.sizes=FALSE]
> dge <- calcNormFactors(dge)

Then apply the voom transformation and fit a linear model:
> v <- voom(dge, design, plot=TRUE)
> fit <- lmFit(v, design)

Now we can test for differential splicing associated with any coeficient in the linear model. First
run the diffSplice function:
> ex <- diffSplice(fit, geneid="GeneID")
Then
> topSplice(ex, coef=2, test="simes")
将显示线性模型中和第二个coefficient相关的差异剪切的证据。
输出和limma的topTable函数类似。更详细的：
> topSplice(ex, coef=2, test="t")
将会展示同一个基因中，相对于其他外显子被富集或者删除的外显子。
> plotSplice(ex)







refer:
http://www.bio-info-trainee.com/bioconductor_China/software/limma.html

差异分析是否需要比较矩阵
https://github.com/bioconductor-china/basic/blob/master/makeContrasts.md


更复杂的模型：多组比较，批次效应 https://www.jianshu.com/p/dee7346482e5


========================================
|-- 例子: 18章 RNA-Seq Case Studies
----------------------------------------

1. 研究目的和数据(Yoruba HapMap Data)
研究某地男女之间差异表达的基因。需要limma 3.9.19+, 现在用的是3.36.5

原始数据 
http://eqtl.uchicago.edu/RNA_Seq_data/unmapped_reads/ in FASTQ format, 46bp reads.


[这个数据现在没有性别了]Sample information are recorded at Pritchard Lab's eQTL resources at http://eqtl.uchicago.edu/RNA_Seq_data/list_lanes_pickrell_2010_plosgenetics.

Genders of the individuals are available at the International HapMap Project NHGRI Repository at http://ccr.coriell.org/.

性别从哪里下载？
https://www.coriell.org/Search?q=Yoruba%20HapMap%20Data&grid=0




(2) 推荐跳过map，直接下载中间数据 http://bioinf.wehi.edu.au/limma/
load("F:\\Temp\\data\\Yoruba.RData")
dim(y) #[1] 25702    86
names(y) #[1] "counts"  "samples" "genes"  





2.
chrom <- fit$genes$Chr
plotMD(fit, column=5, status=chrom, values=c("X", "Y", "X|Y"),
       hl.col=c("red","blue", "green3"), 
       main="Male vs Female",legend="bottomright")
abline(h=0,col="darkgrey")

参数解释
- object: an RGList, MAList, EList, ExpressionSet or MArrayLM object. Alternatively a numeric matrix.

- column: integer, column of object to be plotted.
对象的哪一个列，用来画图？head(fit$coefficients) #上文说的column就是这个的列


- status: character vector giving the control status of each point, of same length as x and y. If NULL, then all points are plotted in the background color, symbol and size.
给点按照该属性设置颜色。如果为空，则所有点都是同样的背景色、符号的大小。

- values: character vector giving values of status to be highlighted on the plot. Defaults to unique values of status in decreasing order of frequency, with the most frequent value set as the background value. Ignored if there is no status vector.
按照status，选择特定value的值设置颜色等。默认是按照频率设置不同的值，最高频率的设置为背景值。没有status则忽略values的设置。

- hl.pch: vector of plotting characters for highlighted points, either of unit length or of same length as values. Ignored is there is no status vector.
高亮显示点的符号。

- hl.col: vector of colors for highlighted points, either of unit length or of same length as values. Defaults to 1+1:length(values). Ignored if there is no status vector.
高亮显示点的颜色。




========================================
|-- 用limma包的voom方法来做RNA-seq 差异分析(果蝇)
----------------------------------------
https://www.plob.org/article/9966.html

需要3个矩阵：
表达矩阵
分组矩阵
差异比较矩阵


1. 输入数据
(1)表达矩阵
library("limma")
library("edgeR")
library(pasilla)
print(data(package='pasilla'))
data(pasillaGenes)
dim(pasillaGenes)
# Features  Samples 
#14470        7 
str(pasillaGenes)
exprSet=counts(pasillaGenes)
head(exprSet)  ##表达矩阵如下。前3列处理过，后4列没处理过;
#            treated1fb treated2fb treated3fb untreated1fb untreated2fb untreated3fb untreated4fb
#FBgn0000003          0          0          1            0            0            0            0
#FBgn0000008         78         46         43           47           89           53           27
#FBgn0000014          2          0          0            0            0            1            0
#FBgn0000015          1          0          1            0            1            1            2
#FBgn0000017       3187       1672       1859         2445         4615         2063         1711


(2)分组数据
group_list=pasillaGenes$condition; group_list
#[1] treated   treated   treated   untreated untreated untreated untreated
#Levels: treated untreated
##这是分组信息，7个样本，3个处理的，4个未处理的对照！






2. 开始比较
(1)构建分组矩阵
design <- model.matrix(~factor(group_list))
colnames(design)=levels(factor(group_list))
rownames(design)=colnames(exprSet)
design
##              treated untreated
## treated1fb         1         0
## treated2fb         1         0
## treated3fb         1         0
## untreated1fb       1         1
## untreated2fb       1         1
## untreated3fb       1         1
## untreated4fb       1         1
## attr(,"assign")
## [1] 0 1
## attr(,"contrasts")
## attr(,"contrasts")$`factor(group_list)`
## [1] "contr.treatment"




(2)根据分组信息和表达矩阵进行normalization
这里构建了一个对象 An object of class “EList”

v <- voom(exprSet,design,normalize="quantile")


## 下面的代码如果你不感兴趣不需要运行，免得误导你
## 就是看看normalization前面的数据分布差异
#png("RAWvsNORM.png")
exprSet_new=v$E
par(cex = 0.7)
n.sample=ncol(exprSet)
if(n.sample>40) par(cex = 0.5); cols <- rainbow(n.sample*1.2); par(mfrow=c(2,2))
#
boxplot(exprSet, col = cols,main="expression value",las=2) #pic1
boxplot(exprSet_new, col = cols,main="expression value",las=2) pic2
hist(exprSet) #pic3
hist(exprSet_new) #pic3
#dev.off()
图：略4个。
可以很明显看到normalization前后数据分布差异非常大！



(3) 做差异分析，提取差异分析结果
这里不需要差异比较矩阵了，因为我的分组矩阵表明样本就分成两组，直接提取coef=2的数据即可

fit <- lmFit(v,design)
fit2 <- eBayes(fit)
tempOutput = topTable(fit2, coef=2, n=Inf)
DEG_voom = na.omit(tempOutput)

head(DEG_voom)
##                  logFC  AveExpr         t      P.Value    adj.P.Val        B
## FBgn0029167  2.1608689 7.880589  41.19142 5.195806e-08 0.0007518331 9.065020
## FBgn0003137 -0.9560776 8.421903 -29.97211 2.920473e-07 0.0021129620 7.800063
## FBgn0003748 -1.0385933 6.395990 -23.78787 1.020682e-06 0.0049230892 6.652695



(4)设置条件，筛选差异表达基因(adj.p<0.05, FC>2或<1/2)，画火山图
library('dplyr')
DEG_voom$gid=row.names(DEG_voom)
head(DEG_voom)
rs1=DEG_voom %>% 
  filter(adj.P.Val < 0.05 & abs(logFC) > 1) %>%
  arrange(adj.P.Val, desc(abs(logFC)))

dim(rs1) #[1] 98  7
rs1
##        logFC    AveExpr          t      P.Value    adj.P.Val            B                     gid
## 1   2.160869  7.8805889  41.191418 5.195806e-08 0.0007518331  9.065020493             FBgn0029167
## 2  -1.038593  6.3959898 -23.787871 1.020682e-06 0.0049230892  6.652694753             FBgn0003748
## 3   4.480423  4.8386244  19.672363 2.844952e-06 0.0058809216  5.231714840             FBgn0039155
## 4   2.519026  5.2211825  21.013389 1.993995e-06 0.0058809216  5.870584692             FBgn0035085
## 5  -1.104098  3.9224377 -19.969538 2.624231e-06 0.0058809216  5.557559868             FBgn0015568


火山图，显著差异基因高亮，同时标注部分基因名称。
library(ggplot2)
diff=DEG_voom
##Highlight genes that have an absolute fold change > 2 and a p-value < Bonferroni cut-off
diff$threshold = as.factor( abs(diff$logFC) > 1 & diff$adj.P.Val< 0.05 )
table(diff$threshold)

##Construct the plot object
g = ggplot(data=diff, aes(x=logFC, y=-log10(adj.P.Val), colour=threshold)) +
  geom_point(alpha=0.4, size=1.75) +
  # opts(legend.position = "none") + 
  #xlim(c(-10, 10)) + ylim(c(0, 15)) +
  xlab("log2 fold change") + ylab("-log10 p-value")
g


#只标注显著基因的基因名
# 选出一部分基因：FC大且p小的基因
dd_text = diff[(abs(diff$logFC) > 2) & (diff$adj.P.Val < 0.05),] #更严格一些，标注几个基因名字
head(dd_text)

#添加文字-基因名
g + geom_text(data=dd_text, aes(x=logFC, y=-log10(adj.P.Val), label=dd_text$gid), colour="black")







(5)基因注释：怎么注释上 gene Symbol呢？
在NCBI搜索 FBgn0029167，https://www.ncbi.nlm.nih.gov/search/all/?term=FBgn0029167
得到这是fruit fly的基因名字: Dmel\Hml，又外链到 http://flybase.org/
果蝇的，不深究了。














========================================
[官方]使用limma、Glimma和edgeR，RNA-seq数据分析易如反掌(一套limma、edgeR的实战[小鼠3种类型的乳腺癌细胞])
----------------------------------------
https://www.bioconductor.org/packages/devel/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow_CHN.html
http://bioinf.wehi.edu.au/software/MSigDB/

http://www.imooc.com/article/269226
https://www.jianshu.com/p/f4b618354dc2


1. 概述
们通过分析来自小鼠乳腺的RNA测序数据，示范了如何使用流行的edgeR包载入、整理、过滤和归一化数据，然后用limma包的voom方法、线性模型和经验贝叶斯调节（empirical Bayes moderation）来评估差异表达并进行基因集检验。通过使用Glimma包，此流程得到了增进，实现了结果的互动探索，使用户得以查看单个样本与基因。 这三个软件包提供的完整分析突出了研究人员可以使用Bioconductor轻松地从RNA测序实验的原始计数揭示生物学意义。


对于RNA-seq数据，来自Bioconductor项目(Huber et al. 2015)的 edgeR (Robinson, McCarthy, and Smyth 2010)和limma包 (Ritchie et al. 2015)提供了一套用于处理此问题的完善的统计学方法。


在这篇文章中，我们描述了一个用于分析RNA-seq数据的edgeR - limma工作流程，使用基因水平计数作为输入，经过预处理和探索性数据处理，然后得到差异表达（DE）基因和基因表达特征（gene signatures）的列表。Glimma包(Su et al. 2017)提供的交互式图表可以同时呈现整体样本和单个基因水平的数据，使得我们相对静态的R图表而言，可以探索更多的细节。







========================================
|-- 2. 数据准备
----------------------------------------
(1)背景
选用GEO数据：GSE63310

Sheridan等（2015）(Sheridan et al. 2015)，从雌性小鼠乳腺中提取了三个细胞群，即基底（basal）、管腔祖细胞（liminal progenitor, LP）和成熟管腔（mature luminal, ML），各三个重复。
RNA利用Hiseq 2000+100bp单端测序；参考基因组选择mm10，Rsubread比对（具体而言，先使用align函数(Liao, Smyth, and Shi 2013)，然后使用featureCounts (Liao, Smyth, and Shi 2014)进行基因水平定量，利用其内置的mm10基于RefSeq的注释。

查看实验设计和样品制备信息： https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63310
转录组表达数据地址：http://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&format=file


浏览器下载并上传到linux
$ tar xvf GSE63310_RAW.tar
$ gunzip *.gz ### 设置好rstudio 的project
$ head GSM1545545_JMS9-P8c.txt
## EntrezID	GeneLength	Count
## 497097	3634	0
## 100503874	3259	0
## 100038431	1634	0

每一个文本文件均包含一个给定样品的原始基因水平计数。
需要注意的是，我们的分析仅包含了此实验中的basal、LP和ML样品（请查看下方相关文件名）。

## 转到R中
setwd("/home/wangjl/data/DEG_demo/") ##修改位置
files <- c("GSM1545535_10_6_5_11.txt", "GSM1545536_9_6_5_11.txt", "GSM1545538_purep53.txt","GSM1545539_JMS8-2.txt", "GSM1545540_JMS8-3.txt","GSM1545541_JMS8-4.txt", "GSM1545542_JMS8-5.txt","GSM1545544_JMS9-P7c.txt", "GSM1545545_JMS9-P8c.txt")
read.delim(files[1], nrow=5)
##   EntrezID GeneLength Count
##1    497097       3634     1
##2 100503874       3259     0
##3 100038431       1634     0
##4     19888       9747     0
##5     20671       3130     1


# 尽管这九个文本文件可以分别读入R然后合并为一个计数矩阵，edgeR提供了更方便的途径，使用readDGE函数即可一步完成。
#接下来利用edgeR的readDEG将所有表达矩阵读入并且组合成一个大的矩阵
#得到的DGEList对象中包含一个计数矩阵，它的27179行分别对应唯一的Entrez基因标识（ID），九列分别对应此实验中的每个样品。

library(limma)
library(Glimma)
library(edgeR)
library(Mus.musculus)

x <- readDGE(files, columns=c(1,3)) # 只要它的Entrez ID 和count值
dim(x) # x中有表达量和样本信息，样本信息又包括了group、libsize、lane等信息
#[1] 27179     9
class(x)
## [1] "DGEList"
## attr(,"package")
## [1] "edgeR"
# 如果一开始所有的表达量都存在一个矩阵中，那么直接用DEGList()转换该矩阵为一个DGEList对象。





(2)整理样本分组信息: 对DEGList x的列进行操作
为进行下游分析，与实验设计有关的样品水平信息需要与计数矩阵的列关联。
这里需要包括各种对表达水平有影响的实验变量，无论是生物变量还是技术变量。
例如，
细胞类型（在这个实验中是basal、LP和ML），
基因型（野生型、敲除），
表型（疾病状态、性别、年龄），
样品处理（用药、对照）和
批次信息（如果样品是在不同时间点进行收集和分析的，记录进行实验的时间）
测序日期、测序lane等。

这里的DEGList中包含的样本信息有：细胞类型group、批次信息（测序的lane），每种信息都包含三个不同的水平。
需要注意的是，在x$samples中，程序会自动计算每个样品的文库大小，归一化系数会被设置为1。 

# 先简化GEO的ID名称，也就是把GSM去掉
samplenames <- substring(colnames(x), 12, nchar(colnames(x)))
samplenames
##[1] "10_6_5_11" "9_6_5_11"  "purep53"  
##[4] "JMS8-2"    "JMS8-3"    "JMS8-4"   
##[7] "JMS8-5"    "JMS9-P7c"  "JMS9-P8c" 
colnames(x) <- samplenames

#然后我们可以自己设计分组信息
group <- as.factor(c("LP", "ML", "Basal", "Basal", "ML", "LP",
		"Basal", "ML", "LP"))
x$samples$group <- group
#自己添加lane 信息
lane <- as.factor(rep(c("L004","L006","L008"), c(3,4,2)))
x$samples$lane <- lane
x$samples
##                             files group lib.size norm.factors lane
##10_6_5_11 GSM1545535_10_6_5_11.txt    LP 32863052            1 L004
##9_6_5_11   GSM1545536_9_6_5_11.txt    ML 35335491            1 L004
##purep53     GSM1545538_purep53.txt Basal 57160817            1 L004
##JMS8-2       GSM1545539_JMS8-2.txt Basal 51368625            1 L006
##JMS8-3       GSM1545540_JMS8-3.txt    ML 75795034            1 L006
##JMS8-4       GSM1545541_JMS8-4.txt    LP 60517657            1 L006
##JMS8-5       GSM1545542_JMS8-5.txt Basal 55086324            1 L006
##JMS9-P7c   GSM1545544_JMS9-P7c.txt    ML 21311068            1 L008
##JMS9-P8c   GSM1545545_JMS9-P8c.txt    LP 19958838            1 L008





(3)整理基因注释信息: 对DEGList x的行进行操作
我们的DGEList对象中的第二个数据框名为genes，用于存储与计数矩阵的行相关联的基因水平的信息。 为检索这些信息，我们可以使用包含特定物种信息的包，
比如小鼠的Mus.musculus (Bioconductor Core Team 2016b)
或人类的Homo.sapiens (Bioconductor Core Team 2016a)；
或者也可以使用biomaRt 包 (Durinck et al. 2005, 2009)，它通过接入Ensembl genome数据库来进行基因注释。

可以检索的信息类型包括基因符号（gene symbols）、基因名称（gene names）、染色体名称和位置（chromosome names and locations）、Entrez基因ID（Entrez gene IDs）、Refseq基因ID（Refseq gene IDs）和Ensembl基因ID（Ensembl gene IDs）等。
biomaRt主要使用Ensembl基因ID进行检索，而由于Mus.musculus包含多种不同来源的信息，它允许用户从多种不同基因ID中选取检索键。

我们使用Mus.musculus包，利用我们数据集中的Entrez基因ID来检索相关的基因符号和染色体信息。


# 安装包
#source("https://bioconductor.org/biocLite.R")
#options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
#biocLite("Mus.musculus")

报错：installation of package ‘RMySQL’ had non-zero exit status
因为需要安装mysql 
安装mysql类库
~ sudo apt-get install libdbd-mysql libmysqlclient-dev
再安装 biocLite("RMySQL") 已经正常了。



# 开始注释
library(Mus.musculus)
geneid <- rownames(x)
genes <- select(Mus.musculus, keys=geneid, columns=c("SYMBOL", "TXCHROM"),
                keytype="ENTREZID") #转换基因id，用clusterProfiler的bitr函数也可以;另外这个还增加了染色体信息
##报错： 'select()' returned 1:many mapping between keys and columns
# select则是根据你提供的key值去查找注释数据库，返回你需要的columns信息。
head(genes)
##   ENTREZID  SYMBOL TXCHROM
##1    497097    Xkr4    chr1
##2 100503874 Gm19938    <NA>
##3 100038431 Gm10568    <NA>
##4     19888     Rp1    chr1
##5     20671   Sox17    chr1
##6     27395  Mrpl15    chr1
#基因注释资源(1) https://blog.csdn.net/weixin_39211343/article/details/83389249
#【Bioconductor系列】如何用Bioconductor对基因组注释 https://www.jianshu.com/p/ae94178918bc
#Bioconductor没想象的那么简单-part8-注释信息必知必会 https://www.jianshu.com/p/8f7f20371116



需要注意的是：Entrez ID可能并不是和基因信息一一匹配的，可能同样的ID会匹配到不同染色体，因此需要检查有没有重复出现的Entrez ID，以保证注释和我们的DEGList之间的基因顺序是一致的。

length(geneid) #[1] 27179
dim(genes)     #[1] 27220 3 这里面有重复行 220-179=41

我们的基因注释中包含28个匹配到不同染色体的基因（比如基因Gm1987关联于染色体chr4和chr4_JH584294_random，小RNA Mir5098关联于chr2，chr5，chr8，chr11和chr17）。 为了处理重复的基因ID，我们可以合并来自多重匹配基因的所有染色体信息，比如将基因Gm1987分配到chr4 and chr4_JH584294_random，或选取其中一条染色体来代表具有重复注释的基因。为了简单起见，我们选择后者，保留每个基因ID第一次出现的信息。

genes2 <- genes[!duplicated(genes$ENTREZID),]
dim(gene2) #[1] 27179     3

在此例子中，注释与数据对象中的基因顺序是相同的。如果由于缺失和／或重新排列基因ID导致其顺序不一致，可以用match来正确排序基因。然后将基因注释的数据框加入数据对象，数据即被整洁地整理入一个DGEList对象中，它包含原始计数数据和相关的样品信息和基因注释。

x$genes <- genes2
x
## An object of class "DGEList"
## $samples
##                              files group lib.size norm.factors lane
## 10_6_5_11 GSM1545535_10_6_5_11.txt    LP 32863052            1 L004
## 9_6_5_11   GSM1545536_9_6_5_11.txt    ML 35335491            1 L004
## purep53     GSM1545538_purep53.txt Basal 57160817            1 L004
## JMS8-2       GSM1545539_JMS8-2.txt Basal 51368625            1 L006
## JMS8-3       GSM1545540_JMS8-3.txt    ML 75795034            1 L006
## JMS8-4       GSM1545541_JMS8-4.txt    LP 60517657            1 L006
## JMS8-5       GSM1545542_JMS8-5.txt Basal 55086324            1 L006
## JMS9-P7c   GSM1545544_JMS9-P7c.txt    ML 21311068            1 L008
## JMS9-P8c   GSM1545545_JMS9-P8c.txt    LP 19958838            1 L008
## 
## $counts
##            Samples
## Tags        10_6_5_11 9_6_5_11 purep53 JMS8-2 JMS8-3 JMS8-4 JMS8-5 JMS9-P7c JMS9-P8c
##   497097            1        2     342    526      3      3    535        2        0
##   100503874         0        0       5      6      0      0      5        0        0
##   100038431         0        0       0      0      0      0      1        0        0
##   19888             0        1       0      0     17      2      0        1        0
##   20671             1        1      76     40     33     14     98       18        8
## 27174 more rows ...
## 
## $genes
##    ENTREZID  SYMBOL TXCHROM
## 1    497097    Xkr4    chr1
## 2 100503874 Gm19938    <NA>
## 3 100038431 Gm10568    <NA>
## 4     19888     Rp1    chr1
## 5     20671   Sox17    chr1
## 27174 more rows ...




#*** begin: 下面这个去重也行，就是太繁琐了
dup <- genes$ENTREZID[duplicated(genes$ENTREZID)]
genes[genes$ENTREZID %in% dup,][1:5,]
# 果然发现了不同染色体上重复的ID
##       ENTREZID    SYMBOL TXCHROM
##5360  100316809 Mir1906-1   chr12
##5361  100316809 Mir1906-1    chrX
##9563      12228      Btg3   chr16
##9564      12228      Btg3   chr17
##11350    433182     Eno1b    chr4
#
# 然后把重复的基因挑出来【重复的只统计一次】
mat <- match(geneid, genes$ENTREZID)
genes <- genes[mat,]
genes[genes$ENTREZID %in% dup,][1:5,]
#这时在看x这个DEGList，就是一个标准的包含原始count数据、样本信息的表达量矩阵
# end ***#













========================================
|-- 3. 数据预处理 
----------------------------------------
(1)原始数据尺度转换

进行差异表达一般都不会用raw counts的，因为存在测序深度、文库大小的差别，这样的结果是不准确的。

一般的做法是：利用标准化算法，如CPM（counts per million), log-CPM (log2-counts per million), RPKM (reads per kilobase of transcript per million), FPKM(fragments per kilobase of transcript per million)等去除文库大小、深度的影响。和RPKM、FPKM不同的是，CPM和log-CPM不需要考虑feature length的差异，也就是说基因长度在统计时被当成常数，只考虑不同处理下的不同，而不会受长度的影响


尽管CPM和log-CPM转换并不像RPKM和FPKM那样考虑到基因长度区别的影响，但在我们的分析中经常会用到它们。虽然也可以使用RPKM和FPKM，但CPM和log-CPM只使用计数矩阵即可计算，且已足以满足我们所关注的比较的需要。

假设不同条件之间剪接异构体（isoform）的使用没有差别，差异表达分析研究同一基因在不同条件下的表达差异，而不是比较多个基因之间的表达或测定绝对表达量。换而言之，基因长度在我们关注的比较中始终不变，且任何观测到的差异是来自于条件的变化而不是基因长度的变化。


使用edgeR中的cpm函数将原始计数转换为CPM和log-CPM值。如果可以提供基因长度信息，可以使用edgeR中的rpkm函数计算RPKM值，就像计算CPM值那样简单。

# cpm使用cpm()函数；RPKM使用rpkm函数，都属于edegR
cpm <- cpm(x)
lcpm <- cpm(x, log=TRUE, prior.count=2)


对于一个基因，CPM值为1相当于在测序深度最低的样品中（JMS9-P8c, 序列数量约2千万）有20个计数，或者在测序深度最高的样品中（JMS8-3，序列数量约7.6千万）有76个计数。

log-CPM值将被用于探索性图表中。当设置log=TRUE时，cpm函数会在进行log2转换前给CPM值加上一个弥补值。默认的弥补值是2/L，其中2是“预先计数”，而L是样本总序列数（以百万计）的平均值，所以log-CPM值是根据CPM值通过log2(CPM + 2/L)计算得到的。这样的计算方式可以确保任意两个具有相同CPM值的序列片段计数的log-CPM值也相同。弥补值的使用可以避免对零取对数，并能使所有样本间的log倍数变化（log-fold-change）向0推移而减小低表达基因间微小计数变化带来的巨大的伪差异性，这对于绘制探索性图表很有用。

在这个数据集中，平均的样本总序列数是4.55千万，所以L约等于45.5，且每个样本中的最小log-CPM值为log2(2/45.5) = -4.51。换而言之，在加上了预先计数弥补值后，此数据集中的零表达计数对应的log-CPM值为-4.51：

L <- mean(x$samples$lib.size) * 1e-6
M <- median(x$samples$lib.size) * 1e-6
c(L, M)
## [1] 45.5 51.4
summary(lcpm)
##   10_6_5_11          9_6_5_11          purep53             JMS8-2            JMS8-3       
## Min.   :-4.5074   Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074   Min.   :-4.5074  
## 1st Qu.:-4.5074   1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074   1st Qu.:-4.5074  
## Median :-0.6847   Median :-0.3589   Median :-0.09513   Median :-0.0901   Median :-0.4281  
## Mean   : 0.1714   Mean   : 0.3312   Mean   : 0.43559   Mean   : 0.4089   Mean   : 0.3225  
## 3rd Qu.: 4.2913   3rd Qu.: 4.5601   3rd Qu.: 4.60081   3rd Qu.: 4.5475   3rd Qu.: 4.5772  
## Max.   :14.7632   Max.   :13.4952   Max.   :12.95700   Max.   :12.8513   Max.   :12.9578  
##     JMS8-4            JMS8-5            JMS9-P7c          JMS9-P8c      
## Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074   Min.   :-4.5074  
## 1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074   1st Qu.:-4.5074  
## Median :-0.4064   Median :-0.07152   Median :-0.1704   Median :-0.3300  
## Mean   : 0.2529   Mean   : 0.40428   Mean   : 0.3708   Mean   : 0.2749  
## 3rd Qu.: 4.3199   3rd Qu.: 4.42513   3rd Qu.: 4.6031   3rd Qu.: 4.4355  
## Max.   :14.8520   Max.   :13.19491   Max.   :12.9413   Max.   :14.0102

在下游的线性模型分析中，使用limma的voom函数时也会用到log-CPM值，但voom会默认使用更小的预先计数重新计算自己的log-CPM值。











(2)删除低表达基因
所有的数据集中都会存在表达的和不表达的基因，我们感兴趣的是在一个条件下表达，另一个条件不表达的。
实际上，这个数据集中19%的基因在所有九个样品中的计数都是零。

#看下有多少基因在所有样本中表达量都为0
table(rowSums(x$counts==0)==9)
## FALSE TRUE
## 22026 5153

对log-CPM值的分布绘制的图表显示每个样本中很大一部分基因都是不表达或者表达程度相当低的，它们的log-CPM值非常小甚至是负的（下图A部分）。


在任何样本中都没有足够多的序列片段的基因应该从下游分析中过滤掉。这样做的原因有好几个。 从生物学的角度来看，在任何条件下的表达水平都不具有生物学意义的基因都不值得关注，因此最好忽略。 从统计学的角度来看，去除低表达计数基因使数据中的均值 - 方差关系可以得到更精确的估计，并且还减少了在观察差异表达的下游分析中需要进行的统计检验的数量。


##1) edgeR包中的filterByExpr函数提供了自动过滤基因的方法，可保留尽可能多的有足够表达计数的基因。
keep.exprs <- filterByExpr(x, group=group)
x <- x[keep.exprs,, keep.lib.sizes=FALSE]
dim(x) ## [1] 16624     9


此函数默认选取最小的组内的样本数量为最小样本数，保留至少在这个数量的样本中有10个或更多序列片段计数的基因。对基因表达量进行过滤时使用CPM值而不是表达计数，以避免对总序列数大的样本的偏向性。在这个数据集中，总序列数的中位数是5.1千万，且10/51约等于0.2，所以filterByExpr函数保留在至少三个样本中CPM值大于等于0.2的基因。

此处，一个具有生物学意义的基因需要在至少三个样本中表达，因为三种细胞类型组内各有三个重复。所使用的阈值取决于测序深度和实验设计。如果样本总表达计数量增大，那么可以选择更低的CPM阈值，因为更大的总表达计数量提供了更好的分辨率来探究更多表达水平更低的基因。

使用这个标准，基因的数量减少到了16624个，约为开始时数量的60%。过滤后的log-CPM值显示出每个样本的分布基本相同（下图B部分）。需要注意的是，从整个DGEList对象中取子集时同时删除了被过滤的基因的计数和其相关的基因信息。过滤后的DGEList对象为留下的基因保留了相对应的基因信息和计数。


##2) 另一种规则更明确的过滤基因的方法，标准就是cpm至少一组或整个实验中有三个样本大于1。但是过滤掉的也更多了。
#keep.exprs <- rowSums(cpm>1)>=3
#x <- x[keep.exprs,, keep.lib.sizes=FALSE]
#dim(x) ##[1] 14165     9






#作图检查：虚线就是cpm为1（即log cpm为0的时候）作为判断阈值，看超过这个线的有几个
lcpm.cutoff <- log2(10/M + 2/L)

library(RColorBrewer)
nsamples <- ncol(x)
col <- brewer.pal(nsamples, "Paired")

par(mfrow=c(1,2))
#pic1
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
     main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
#abline(v=0, lty=3)
abline(v=lcpm.cutoff, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
#pic2
lcpm <- cpm(x, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
     main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
#abline(v=0, lty=3)
abline(v=lcpm.cutoff, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
#
# 图略 2个密度分布图

# Figure 1: 每个样本过滤前的原始数据（A）和过滤后（B）的数据的log-CPM值密度。竖直虚线标出了过滤步骤中所用阈值（相当于CPM值为约0
2）。









(3)归一化基因表达分布

在准备试验样品或者测序的过程中，外界因素非常可能会引入误差，影响样本的基因表达水平。比如：第一批测序的样本可能比第二批测序的深度要深。标准化就是为了让每个样本的表达量分布在整个实验中是相似的。


- 如何判断是否标准了呢？
可以通过密度图density或者箱线图boxplot，比如上图就是密度分布，其中B图的log-CPM分布就比较一致，并且都在阈值的右侧

- 如何标准化？
尽管如此，我们依然需要使用edgeR中的calcNormFactors()函数，用TMM(trimmed mean of M-values)算法(Robinson and Oshlack 2010)方法进行归一化。

此处计算得到的归一化系数被用作文库大小的缩放系数。
当我们使用DGEList对象时，这些归一化系数normalisation factors 被自动存储在x$samples$norm.factors。
对此数据集而言，TMM归一化的作用比较温和，这体现在所有的缩放因子都相对接近1。

x <- calcNormFactors(x, method = "TMM")
x$samples$norm.factors
## [1] 0.896 1.035 1.044 1.041 1.032 0.922 0.984 1.083 0.979





为了更好地可视化表现出归一化的影响，我们复制了数据并进行了调整，使得第一个样品的计数减少到了其原始值的5%，而第二个样品增大到了5倍。

#画一个箱线图可以看到标准化前后差异【模拟数据】
#模拟一个数据
x2 <- x
x2$samples$norm.factors <- 1
x2$counts[,1] <- ceiling(x2$counts[,1]*0.05) #第一个样本count缩小到原来5%
x2$counts[,2] <- x2$counts[,2]*5 # 第二个样本扩大到原来5倍

#画图
par(mfrow=c(1,2))
lcpm <- cpm(x2, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="A. Example: Unnormalised data",ylab="Log-cpm")
x2 <- calcNormFactors(x2)
x2$samples$norm.factors
## [1] 0.0547 6.1306 1.2293 1.1705 1.2149 1.0562 1.1459 1.2613 1.1170
lcpm <- cpm(x2, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="B. Example: Normalised data",ylab="Log-cpm")


下图显示了没有经过归一化的与经过了归一化的数据的样本的表达分布，

其中归一化前的分布显然不同，而归一化后比较相似。此处，第一个样品的TMM缩放系数0.06非常小，而第二个样品的缩放系数6.08很大，它们都并不接近1。










(4)对样本的无监督聚类
用于检查基因表达分析的最重要的探索性图表之一便是MDS图或其余类似的图。

理想情况下，样本会在不同的实验组内很好的聚类，且可以鉴别出远离所属组的样本，并追踪误差或额外方差的来源。
如果存在技术重复，它们应当互相非常接近。

这样的图可以用limma中的plotMDS函数绘制。第一个维度表示能够最好地分离样品且解释最大比例的方差的引导性的倍数变化（leading-fold-change），而后续的维度的影响更小，并与之前的维度正交。当实验设计涉及到多个因子时，建议在多个维度上检查每个因子。如果在其中一些维度上样本可按照某因子聚类，这说明该因子对于表达差异有影响，在线性模型中应当将其包括进去。反之，没有或者仅有微小影响的因子在下游分析时应当被剔除。



在这个数据集中，可以看出样本在维度1和2能很好地按照实验分组聚类，随后在维度3按照测序道（样品批次）分离（如下图所示）。请记住，第一维度解释了数据中最大比例的方差，需要注意到，当我们向高维度移动，维度上的取值范围会变小。

尽管所有样本都按组聚类，在维度1上最大的转录差异出现在basal和LP以及basal和ML之间。因此，预期在basal样品与其他之间的成对比较中能够得到大量的DE基因，而在ML和LP之间的比较中得到的DE基因数量略少。在其他的数据集中，不按照实验组聚类的样本可能在下游分析中只表现出较小的或不表现出差异表达。

为绘制MDS图，我们为不同的因子赋予不同的色彩组合。维度1和2使用以细胞类型定义的色彩组合进行检查。

维度3和4使用以测序泳道（批次）定义的色彩组合进行检查。

#对样本的无监督聚类
lcpm <- cpm(x, log=TRUE)
par(mfrow=c(1,2))
col.group <- group
levels(col.group) <-  brewer.pal(nlevels(col.group), "Set1")
col.group <- as.character(col.group)
#
col.lane <- lane
levels(col.lane) <-  brewer.pal(nlevels(col.lane), "Set2")
col.lane <- as.character(col.lane)
#
plotMDS(lcpm, labels=group, col=col.group)
title(main="A. Sample groups")
#
plotMDS(lcpm, labels=lane, col=col.lane, dim=c(3,4))
title(main="B. Sequencing lanes")

图略2个。
Figure 3: log-CPM值在维度1和2的MDS图，以样品分组上色并标记（A）和
维度3和4的MDS图，以测序道上色并标记（B）。
图中的距离对应于最主要的倍数变化（fold change），默认情况下也就是前500个在每对样品之间差异最大的基因的平均（均方根）log2倍数变化。





作为另一种选择，Glimma包也提供了便于探索多个维度的交互式MDS图。其中的glMDSPlot函数可生成一个html网页（如果设置launch=TRUE，将会在浏览器中打开），其左侧面板含有一张MDS图，而右侧面板包含一张展示了各个维度所解释的方差比例的柱形图。点击柱形图中的柱可切换MDS图绘制时所使用的维度，且将鼠标悬浮于单个点上可显示相应的样本标签。也可切换配色方案，以突显不同细胞类型或测序泳道（批次）。此数据集的交互式MDS图可以从http://bioinf.wehi.edu.au/folders/limmaWorkflow/glimma-plots/MDS-Plot.html看到。


#####
#biocLite('Glimma')
library(Glimma)
glMDSPlot(lcpm, labels=paste(group, lane, sep="_"), 
          groups=x$samples[,c(2,5)], launch=FALSE)
# 在工作目录生成一个包含网页的文件夹










========================================
|-- 4. 差异表达分析
----------------------------------------
(1)创建设计矩阵和对比
在此研究中，我们想知道哪些基因在我们研究的三组细胞之间以不同水平表达。
在我们的分析中，假设基础数据是正态分布的，为其拟合一个线性模型。
在此之前，需要创建一个包含细胞类型以及测序泳道（批次）信息的设计矩阵。

design <- model.matrix(~0+group+lane)
colnames(design) <- gsub("group", "", colnames(design))
design
##   Basal LP ML laneL006 laneL008
## 1     0  1  0        0        0
## 2     0  0  1        0        0
## 3     1  0  0        0        0
## 4     1  0  0        1        0
## 5     0  0  1        1        0
## 6     0  1  0        1        0
## 7     1  0  0        1        0
## 8     0  0  1        0        1
## 9     0  1  0        0        1
## attr(,"assign")
## [1] 1 1 1 2 2
## attr(,"contrasts")
## attr(,"contrasts")$group
## [1] "contr.treatment"
## 
## attr(,"contrasts")$lane
## [1] "contr.treatment"


对于一个给定的实验，通常有几种等价的方法可以创建一个合适的设计矩阵。 
比如说，~0+group+lane去除了第一个因子group的截距，但第二个因子lane的截距被保留。 
此外也可以使用~group+lane，来自group和lane的截距均被保留。 

此处的关键是理解如何解释给定模型中估计得到的系数。 我们在此分析中选取第一种模型，因为在没有group的截距的情况下能更直截了当地设定模型中的对比。
用于细胞群之间成对比较的对比可以在limma中用makeContrasts函数设定。


contr.matrix <- makeContrasts(
   BasalvsLP = Basal-LP, 
   BasalvsML = Basal - ML, 
   LPvsML = LP - ML, 
   levels = colnames(design))

contr.matrix
##           Contrasts
## Levels     BasalvsLP BasalvsML LPvsML
##   Basal            1         1      0
##   LP              -1         0      1
##   ML               0        -1     -1
##   laneL006         0         0      0
##   laneL008         0         0      0

limma的线性模型方法的核心优势之一便是其适应任意实验复杂程度的能力。简单的设计，比如此工作流程中关于细胞类型和批次的实验设计，直到更复杂的因子设计和含有交互作用项的模型，都能够被相对简单地处理。

当实验或技术效应可被随机效应模型（random effect model）模拟时，limma中的另一种可能性是使用duplicateCorrelation函数来估计交互作用，这需要在此函数以及lmFit的线性建模步骤均指定一个block参数。






(2) 从表达计数数据中删除异方差
据显示对于RNA-seq计数数据而言，当使用原始计数或当其被转换为log-CPM值时，方差并不独立于均值(Law et al. 2014)。使用负二项分布来模拟计数的方法假设均值与方差间具有二次的关系。在limma中，假设log-CPM值符合正态分布，并使用由voom函数计算得到的精确权重来调整均值与方差的关系，从而对log-CPM值进行线性建模。

当操作DGEList对象时，voom从x中自动提取文库大小和归一化因子，以此将原始计数转换为log-CPM值。在voom中，对于log-CPM值额外的归一化可以通过设定normalize.method参数来进行。

下图左侧展示了这个数据集log-CPM值的均值-方差关系。通常而言，方差是测序实验中的技术差异和不同细胞类型的重复样本之间的生物学差异的结合，而voom图会显示出一个在均值与方差之间递减的趋势。 

>生物学差异高的实验通常会有更平坦的趋势，其方差值在高表达处稳定。 生物学差异低的实验更倾向于急剧下降的趋势。



不仅如此，voom图也提供了对于上游所进行的过滤水平的可视化检测。如果对于低表达基因的过滤不够充分，在图上表达低的一端，受到非常低的表达计数的影响，可以观察到方差水平的下降。如果观察到了这种情况，应当回到最初的过滤步骤并提高用于该数据集的表达阈值。

当前面观察的MDS图中具有明显的样本水平的差异时，可以用voomWithQualityWeights函数来同时合并样本水平的权重和voom(Liu et al. 2015)估算得到的丰度相关的权重。关于此种方式的例子参见Liu等(2016) (Liu et al. 2016)。


par(mfrow=c(1,2))
v <- voom(x, design, plot=TRUE)
v
## An object of class "EList"
## $genes
##   ENTREZID SYMBOL TXCHROM
## 1   497097   Xkr4    chr1
## 5    20671  Sox17    chr1
## 6    27395 Mrpl15    chr1
## 7    18777 Lypla1    chr1
## 9    21399  Tcea1    chr1
## 16619 more rows ...
## 
## $targets
##                              files group lib.size norm.factors lane
## 10_6_5_11 GSM1545535_10_6_5_11.txt    LP 29387429        0.894 L004
## 9_6_5_11   GSM1545536_9_6_5_11.txt    ML 36212498        1.025 L004
## purep53     GSM1545538_purep53.txt Basal 59771061        1.046 L004
## JMS8-2       GSM1545539_JMS8-2.txt Basal 53711278        1.046 L006
## JMS8-3       GSM1545540_JMS8-3.txt    ML 77015912        1.016 L006
## JMS8-4       GSM1545541_JMS8-4.txt    LP 55769890        0.922 L006
## JMS8-5       GSM1545542_JMS8-5.txt Basal 54863512        0.996 L006
## JMS9-P7c   GSM1545544_JMS9-P7c.txt    ML 23139691        1.086 L008
## JMS9-P8c   GSM1545545_JMS9-P8c.txt    LP 19634459        0.984 L008
## 
## $E
##         Samples
## Tags     10_6_5_11 9_6_5_11 purep53 JMS8-2 JMS8-3 JMS8-4 JMS8-5 JMS9-P7c JMS9-P8c
##   497097     -4.29    -3.86   2.519  3.293  -4.46  -3.99  3.287   -3.210    -5.30
##   20671      -4.29    -4.59   0.356 -0.407  -1.20  -1.94  0.844   -0.323    -1.21
##   27395       3.88     4.41   4.517  4.562   4.34   3.79  3.899    4.340     4.12
##   18777       4.71     5.57   5.396  5.162   5.65   5.08  5.060    5.751     5.14
##   21399       4.79     4.75   5.370  5.122   4.87   4.94  5.138    5.031     4.98
## 16619 more rows ...
## 
## $weights
##       [,1]  [,2] [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
## [1,]  1.08  1.33 19.8 20.27  1.99  1.40 20.49  1.11  1.08
## [2,]  1.17  1.46  4.8  8.66  3.61  2.63  8.76  3.21  2.54
## [3,] 20.22 25.57 30.4 28.53 31.35 25.74 28.72 21.20 16.66
## [4,] 26.95 32.51 33.6 33.23 34.23 32.35 33.33 30.35 24.26
## [5,] 26.61 28.50 33.6 33.21 33.57 32.00 33.31 25.17 23.57
## 16619 more rows ...
## 
## $design
##   Basal LP ML laneL006 laneL008
## 1     0  1  0        0        0
## 2     0  0  1        0        0
## 3     1  0  0        0        0
## 4     1  0  0        1        0
## 5     0  0  1        1        0
## 6     0  1  0        1        0
## 7     1  0  0        1        0
## 8     0  0  1        0        1
## 9     0  1  0        0        1
## attr(,"assign")
## [1] 1 1 1 2 2
## attr(,"contrasts")
## attr(,"contrasts")$group
## [1] "contr.treatment"
## 
## attr(,"contrasts")$lane
## [1] "contr.treatment"
图略1


vfit <- lmFit(v, design)
vfit2 <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit2)
plotSA(efit, main="Final model: Mean-variance trend")

图略1

Figure 4: 图中绘制了每个基因的均值（x轴）和方差（y轴），显示了在该数据上使用voom前它们之间的相关性（左），以及当运用voom的精确权重后这种趋势是如何消除的（右）。左侧的图是使用voom函数绘制的，它为进行log-CPM转换后的数据拟合线性模型从而提取残差方差。然后，对方差取平方根（或对标准差取平方根），并相对每个基因的平均表达作图。均值通过平均计数加上2再进行log2转换计算得到。右侧的图使用plotSA绘制了log2残差标准差与log-CPM均值的关系。平均log2残差标准差由水平蓝线标出。在这两幅图中，每个黑点表示一个基因，红线为对这些点的拟合。



值得注意的是，DGEList对象中存储的另一个数据框，即基因和样本水平信息所存储之处，保留在了voom创建的EList对象v中。v$genes数据框等同于x$genes，v$targets等同于x$samples，而v$E中所储存的表达值类似于x$counts，尽管它进行了尺度转换。此外，voom的EList对象中还有一个精确权重的矩阵v$weights，而设计矩阵存储于v$design。




(3)拟合线性模型以进行比较

limma的线性建模使用lmFit和contrasts.fit函数进行，它们原先是为微阵列而设计的。这些函数不仅可以用于微阵列数据，也可以用于RNA-seq数据。它们会单独为每个基因的表达值拟合一个模型。然后，通过利用所有基因的信息来进行经验贝叶斯调整，这样可以获得更精确的基因水平的变异程度估计(Smyth 2004)。

下一图为此模型的残差关于平均表达值的图。从图中可以看出，方差不再与表达水平均值相关。



(4)检查DE基因数量

为快速查看差异表达水平，显著上调或下调的基因可以汇总到一个表格中。显著性的判断使用校正p值阈值的默认值5%。在basal与LP的表达水平之间的比较中，发现了4648个在basal中相较于LP下调的基因和4863个在basal中相较于LP上调的基因，即共9511个DE基因。在basal和ML之间发现了一共9598个DE基因（4927个下调基因和4671个上调基因），而在LP和ML中发现了一共5652个DE基因（3135个下调基因和2517个上调基因）。在包括basal细胞类型的比较中皆找到了大量的DE基因，这与我们在MDS图中观察到的结果相吻合。

summary(decideTests(efit))
##        BasalvsLP BasalvsML LPvsML
## Down        4648      4927   3135
## NotSig      7113      7026  10972
## Up          4863      4671   2517



一些研究中不仅仅需要使用校正p值阈值，更为严格定义的显著性可能需要差异倍数的对数（log-FCs）也高于某个最小值。treat方法(McCarthy and Smyth 2009)可以按照对最小log-FC值的要求，使用经过经验贝叶斯调整的t统计值计算p值。当我们的检验要求基因的log-FC显著大于1（等同于在原本的尺度上不同细胞类型之间差两倍）时，差异表达基因的数量得到了下降，basal与LP相比只有3684个DE基因，basal与ML相比只有3834个DE基因，LP与ML相比只有414个DE基因。

#增加logFC限制abs(logFC)>1
#treat方法可以按照对最小log-FC值的要求，使用经过经验贝叶斯调整的t统计值计算p值。
tfit <- treat(vfit2, lfc=1) #注意，这里是vfit2了，如果用vfit则会有很多up的。
dt <- decideTests(tfit)
summary(dt)
##        BasalvsLP BasalvsML LPvsML
## Down        1632      1777    224
## NotSig     12976     12790  16210
## Up          2016      2057    190

在多种比较中皆差异表达的基因可以从decideTests的结果中提取，其中的0代表不差异表达的基因，1代表上调的基因，-1代表下调的基因。共有2784个基因在basal和LP以及basal和ML的比较中都差异表达，其中的20个于下方列出。write.fit函数可用于将三个比较的结果提取并写入到单个输出文件。

de.common <- which(dt[,1]!=0 & dt[,2]!=0)
length(de.common)
## [1] 2784 #我的 [1] 11424
head(tfit$genes$SYMBOL[de.common], n=20)
# 我的结果
## [1] "Xkr4"          "Rgs20"         "Cpa6"          "A830018L16Rik" "Sulf1"        
## [6] "Eya1"          "Msc"           "Sbspon"        "Pi15"          "Crispld1"     
## [11] "Kcnq5"         "Rims1"         "Khdrbs2"       "Ptpn18"        "Prss39"       
## [16] "Arhgef4"       "Cnga3"         "2010300C02Rik" "Aff3"          "Npas2"  

vennDiagram(dt[,1:2], circle.col=c("turquoise", "salmon"))
write.fit(tfit, dt, file="2019results.txt")


Figure 5: 韦恩图展示了仅basal和LP（左）、仅basal和ML（右）的对比的DE基因数量，还有两种对比中共同的DE基因数量（中）。在任何对比中均不差异表达的基因数量标于右下。





(5) 从上到下检查单个DE基因

使用topTreat函数可以列举出使用treat得到的结果中靠前的DE基因（对于eBayes的结果可以使用topTable函数）。默认情况下，topTreat将基因按照校正p值从小到大排列，并为每个基因给出相关的基因信息、log-FC、平均log-CPM、校正t值、原始及经过多重假设检验校正的p值。列出前多少个基因的数量可由用户指定，如果设为n=Inf则会包括所有的基因。基因Cldn7和Rasef在basal与LP和basal于ML的比较中都位于DE基因的前几名。

basal.vs.lp <- topTreat(tfit, coef=1, n=Inf)
basal.vs.ml <- topTreat(tfit, coef=2, n=Inf)

head(basal.vs.lp)
##        ENTREZID SYMBOL TXCHROM logFC AveExpr     t  P.Value adj.P.Val
## 12759     12759    Clu   chr14 -5.46    8.86 -33.6 1.72e-10  1.71e-06
## 53624     53624  Cldn7   chr11 -5.53    6.30 -32.0 2.58e-10  1.71e-06
## 242505   242505  Rasef    chr4 -5.94    5.12 -31.3 3.08e-10  1.71e-06
## 67451     67451   Pkp2   chr16 -5.74    4.42 -29.9 4.58e-10  1.74e-06
## 228543   228543   Rhov    chr2 -6.26    5.49 -29.1 5.78e-10  1.74e-06
## 70350     70350  Basp1   chr15 -6.08    5.25 -28.3 7.27e-10  1.74e-06

head(basal.vs.ml)
##        ENTREZID  SYMBOL TXCHROM logFC AveExpr     t  P.Value adj.P.Val
## 242505   242505   Rasef    chr4 -6.53    5.12 -35.1 1.23e-10  1.24e-06
## 53624     53624   Cldn7   chr11 -5.50    6.30 -31.7 2.77e-10  1.24e-06
## 12521     12521    Cd82    chr2 -4.69    7.07 -31.4 2.91e-10  1.24e-06
## 20661     20661   Sort1    chr3 -4.93    6.70 -30.7 3.56e-10  1.24e-06
## 71740     71740 Nectin4    chr1 -5.58    5.16 -30.6 3.72e-10  1.24e-06
## 12759     12759     Clu   chr14 -4.69    8.86 -28.0 7.69e-10  1.48e-06





(6) 差异表达结果的实用图形表示
为可视化地总结所有基因的结果，可使用plotMD函数绘制均值-差异（MD）图，其中展示了线性模型拟合所得到的log-FC与log-CPM平均值间的关系，而差异表达的基因会被重点标出。

plotMD(tfit, column=1, status=dt[,1], main=colnames(tfit)[1], xlim=c(-8,13))

# 交互式MD图 http://bioinf.wehi.edu.au/folders/limmaWorkflow/glimma-plots/MD-Plot.html
#使用Glimma生成的均值-差异图。左侧面板显示了总结性数据（log-FC与log-CPM值的关系），其中选中的基因在每个样本中的数值显示于右侧面板。下方为结果的表格，其搜索框使用户得以使用可行的注释信息查找某个特定基因，如基因符号Clu。

Glimma是以R和Javascript实现的，使用R代码生成数据，并在之后使用Javascript库D3（https://d3js.org）转换为图形，使用Bootstrap库处理界面并生成互动性可搜索的表格的数据表。 这使得图表可以在任何现代的浏览器中查看，对于从Rmarkdown分析报告中将其作为关联文件而附加而言十分方便。




前文所展示的图表中，一些展示了在任意一个条件下表达的所有基因（比如共同DE基因的韦恩图或均值-差异图），而另一些展示单独的基因（交互性均值-差异图右边面板中所展示的log-CPM值）。而热图使用户得以查看一部分基因的表达。这对于查看单个组或样本的表达很有用，而不至于在关注于单个基因时失去对于研究整体的注意，也不会造成由于上千个基因所取平均值而导致的失去分辨率。

使用gplots包的heatmap.2函数，我们为basal与LP的对照中前100个DE基因（按调整p值排序）绘制了一幅热图。热图中正确地将样本按照细胞类型聚类，并重新排序了基因，形成了表达相似的块状。从热图中，我们观察到对于basal与LP之间的前100个DE基因，ML和LP样本的表达非常相似。

#
library(gplots)
basal.vs.lp.topgenes <- basal.vs.lp$ENTREZID[1:100]
i <- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)
mycol <- colorpanel(1000,"blue","white","red")
heatmap.2(lcpm[i,], scale="row",
          labRow=v$genes$SYMBOL[i], labCol=group, 
          col=mycol, trace="none", density.info="none", 
          margin=c(8,6), lhei=c(2,10), dendrogram="column")
#

Figure 6: 在basal和LP的对比中前100个DE基因log-CPM值的热图。经过缩放调整后，每个基因（每行）的表达均值为0，并且标准差为1。给定基因相对高表达的样本被标记为红色，相对低表达的样本被标记为蓝色。浅色和白色代表中等表达水平的基因。样本和基因已通过分层聚类的方法重新排序。图中显示有样本聚类的树状图。






========================================
|-- 5. 使用camera的基因集检验
----------------------------------------
在此次分析的最后，我们要进行一些基因集检验。为此，我们将camera方法(Wu and Smyth 2012)应用于Broad Institute的MSigDB c2中的(Subramanian et al. 2005)中适应小鼠的c2基因表达特征，这可从http://bioinf.wehi.edu.au/software/MSigDB/以RData对象格式获取。 此外，对于人类和小鼠，来自MSigDB的其他有用的基因集也可从此网站获取，比如标志（hallmark）基因集。C2基因集的内容收集自在线数据库、出版物以及该领域专家，而标志基因集的内容来自MSigDB，从而获得具有明确定义的生物状态或过程。

# 使用camera的基因集检验
#biocLite("RNAseq123")
#library(RNAseq123) #安装不上 只好手工下载了
#load(system.file("extdata", "mouse_c2_v5p2.rda", package = "RNAseq123"))
#
# $ wget http://bioinf.wehi.edu.au/software/MSigDB/mouse_c2_v5p2.rdata
rdata=load("mouse_c2_v5p2.rdata")
idx <- ids2indices(Mm.c2,id=rownames(v))
cam.BasalvsLP <- camera(v,idx,design,contrast=contr.matrix[,1])
head(cam.BasalvsLP,5)
##                                           NGenes Direction       PValue          FDR
## LIM_MAMMARY_STEM_CELL_UP                     736        Up 6.466144e-22 3.057193e-18
## LIM_MAMMARY_STEM_CELL_DN                     613      Down 4.933998e-17 1.166397e-13
## LIM_MAMMARY_LUMINAL_PROGENITOR_UP             86      Down 7.987252e-16 1.258791e-12
## SOTIRIOU_BREAST_CANCER_GRADE_1_VS_3_UP       194        Up 4.494349e-13 5.312320e-10
## ZHOU_CELL_CYCLE_GENES_IN_IR_RESPONSE_24HR    163        Up 8.313638e-13 7.861376e-10


cam.BasalvsML <- camera(v,idx,design,contrast=contr.matrix[,2])
head(cam.BasalvsML,5)
##                                     NGenes Direction       PValue          FDR
## LIM_MAMMARY_STEM_CELL_UP               736        Up 4.300558e-26 2.033304e-22
## LIM_MAMMARY_STEM_CELL_DN               613      Down 1.882703e-21 4.450710e-18
## LIM_MAMMARY_LUMINAL_MATURE_UP          171      Down 4.358230e-16 6.868570e-13
## LIM_MAMMARY_LUMINAL_MATURE_DN          167        Up 5.818794e-16 6.877814e-13
## NAKAYAMA_SOFT_TISSUE_TUMORS_PCA2_UP    145        Up 3.928778e-12 3.639809e-09



cam.LPvsML <- camera(v,idx,design,contrast=contr.matrix[,3])
head(cam.LPvsML,4)
##                                         NGenes Direction       PValue          FDR
## LIM_MAMMARY_LUMINAL_MATURE_UP              171      Down 6.672535e-18 3.154775e-14
## LIM_MAMMARY_LUMINAL_MATURE_DN              167        Up 9.969904e-15 2.356885e-11
## LIM_MAMMARY_LUMINAL_PROGENITOR_UP           86        Up 1.823950e-13 2.874546e-10
## REACTOME_RESPIRATORY_ELECTRON_TRANSPORT     81      Down 9.883167e-10 1.168190e-06



camera函数通过比较假设检验来评估一个给定基因集中的基因是否相对于不在集内的基因而言在差异表达基因的排序中更靠前。 它使用limma的线性模型框架，并同时采用设计矩阵和对比矩阵（如果有的话），且在测试的过程中会使用来自voom的观测水平权重。 在通过基因间相关性（默认设定为0.01，但也可通过数据估计）和基因集的规模得到方差膨胀因子（variance inflation factor），并使用它调整基因集检验统计值的方差后，将会返回根据多重假设检验进行了校正的p值。



此实验是与Lim等人(2010)(Lim et al. 2010)的数据集等价的RNA-seq，而他们使用Illumina微阵列分析了相同的分选细胞群，因此该早期文献中的基因表达特征出现在每种对比的列表顶部正符合我们的预期。在LP和ML的对比中，我们为Lim等人（2010）的成熟管腔基因集（上调及下调）绘制了条码图（barcodeplot）。需要注意的是，由于我们的对比是将LP与ML相比而不是相反，这些基因集的方向在我们的数据集中是反过来的（如果将对比反过来，基因集的方向将会与对比一致）。


barcodeplot(efit$t[,3], index=idx$LIM_MAMMARY_LUMINAL_MATURE_UP, 
            index2=idx$LIM_MAMMARY_LUMINAL_MATURE_DN, main="LPvsML")
# 我认为index和index2对调一下，图才正确。


Figure 7: LIM_MAMMARY_LUMINAL_MATURE_UP （红色条形，图表上方）和LIM_MAMMARY_LUMINAL_MATURE_DN（蓝色条形，图表下方）基因集在LP和ML的对比中的条码图，每个基因集都有一条富集线展示了竖直条形在图表每部分的相对富集程度。

Lim等人的实验(Lim et al
2010)非常类似于我们的，用了相同的分选方式来获取不同的细胞群，只是他们使用的是微阵列而不是RNA-seq来测定基因表达。需要注意的是，上调基因集发生下调而下调基因集发生上调的逆相关性来自于对比的设定方式（LP相比于ML），如果将其对调，方向性将会吻合。



limma也有其他的基因集检验，比如mroast(Wu et al. 2010)的自包含检验。虽然camera非常适合检验基因集的大型数据库并观察其中哪些相对于其他的在排序上位次更高（如前文所示），自包含检验更善于集中检验一个或少个选中的集合是否本身差异表达。换句话说，camera更适用于搜寻具有意义的基因集，而mroast测试的是已经确定有意义的基因集的显著性。





========================================
|-- 6. 使用到的软件和代码
----------------------------------------

此RNA-seq工作流程使用了Bioconductor项目3.8版本中的多个软件包，运行于R 3.5.1或更高版本。

除了本文中重点提到的软件（limma、Glimma以及edgeR），亦需要一些其他软件包，
包括gplots和RColorBrewer还有基因注释包Mus.musculus。 

此文档使用knitr编译。所有用到的包的版本号如下所示。 

Bioconductor工作流程包RNAseq123（可访问https://bioconductor.org/packages/RNAseq123查看）内包含此文章的英文和简体中文版以及进行整个分析流程所需要的代码。

安装此包即可管理以上提到的所有需要的包。对于RNA-seq数据分析实践培训而言，此包也是非常有用的资源。


sessionInfo()
## R version 3.6.0 (2019-04-26)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 18.04.2 LTS












========================================
|-- 熟悉又陌生的limma (原创： shuang  生信人  2018-08-27)
----------------------------------------
对于每个基因g，我们有一个基因表达值的矢量（yg）和一个设计矩阵X，它将这些值与一些感兴趣的系数（g）联系起来。

limma包包括统计方法，其中
（i）利用经验贝叶斯方法促进信息借用以获得后验方差估计，
（ii）结合观察权重（wgj，其中j指样本）以允许数据质量的变化， 
（iii）允许方差建模以适应可能存在的技术或生物异质性，以及
（iv）预处理方法，例如方差稳定以减少噪声。
这些方法都有助于在小实验中改善基因和基因集水平的推断。


第一步：数据导入



第二步：预处理及质量评估

1、预处理RNA-seq和其他测序数据

limma以读数计数矩阵的形式接受RNA-seq数据，其中行为基因组特征和列为RNA样本，或者接受edgeR包中的DGEList对象。运用voom的算法处理后，RNAseq数据的后续分析即可与任何其他技术相同。


2、预处理microarray数据

limma可以接受多方microarray数据，如来自其他Bioconductor包的表达式数据的数据对象，来自marray包的marrayNormobjects，来自affyPLM包的PLMset对象，来自vsn包的vsn对象或继承自ExpressionSet的任何类的对象。或者，表达数据可以作为数字矩阵提供。当读取microarray图像时，通常读取每个探针的前景和背景强度，并进行背景矫正和归一化。

同时用户直观地检查来自设计实验的数据，以便识别潜在的质量问题，例如降级的样品，或由于阵列处理或样品处理而出现的问题。同时还可以揭示在后续分析之前应该去除的系统偏差。

图：limma的诊断图， log2(countsize+0.5) - sqrt(standard deviation), MAplot, PCA样本分析(看批次效应)。





第三步：寻找差异表达基因

limma包的核心组件是能够将基因方式的线性模型拟合到基因表达数据，以评估差异表达分析。基本思想是同时估计两个或多个靶RNA样品之间的对数比（对于双通道数据）或对数强度（对于单通道数据）。每个分析都以表达水平矩阵开始，行中的探针/基因/外显子和列中的不同样品（生物学/技术重复）。线性建模以行方式执行，回归系数和标准误差直接估计感兴趣的比较或通过对比。获得基因排序的测试统计，其可以在基因集水平进一步概括以进行基因标记/途径水平排序。线性建模方法的灵活性允许处理几乎任何实验设计。

使用lmFit函数可以对两个或多个组以及内部控制的实验进行建模和总结。一旦拟合了线性模型，makeContrasts函数就可用于形成对比矩阵，拟合模型对象和对比矩阵用于对比，拟合log2倍数变化和t-统计的感兴趣对比，这允许进行治疗之间的所有可能的成对比较。

为了可视化单个或多个对比的差异分析分析结果，limma提供了许多绘图选项。

图：
A、火山图显示单一条件下的差异分析结果；
B、维恩图显示多个实验条件下差异表达基因的数量；
C、富集图突出显示差异表达分析中的特定基因特征。

同时，当外显子水平表达数据可用时，limma的线性模型框架也可以检测microarray或者RNA-seq的外显子差异剪接事件。





第四步：更高层次的分析

1、估计真零假设的比例

目前描述的分析物根据FDR标准鉴定个体差异表达的基因。然而，对于大多数研究，可能存在假阴性：真正差异表达的基因未被检测为差异表达。propTrueNull函数该运用了许多不同的方法来估计真零点的比例，可估计仍有待鉴定的真正差异表达基因的数量。


2、真性的基因表达谱的关联

基因表达实验通常涉及许多不同的治疗条件。经常出现的一个问题是：两种不同的治疗方法在多大程度上产生相似或不同的表达谱？解决该问题的一种方法是计算来自两种处理的差异表达基因的重叠，但这种方法通常太粗糙。

genas函数用来测试线性模型中的两个不同对比是否以相似或不同的方式影响相同的基因，调整偏差，而不需要应用显着截止值来评估差异表达。从技术上讲，它估计了两种不同对比的log2倍变化之间的真实生物相关性。genas基于经验贝叶斯模型的二元推广，用于评估limma中的差异表达。当变化很小但是一致时，这种方法对于深入了解常见受影响的基因途径特别有用。



3、基因集测试

limma包含一系列通过goana，geneSetTest，camera，roast和romer函数进行基因集测试的选项。

goana使用广义超几何测试来检验差异表达基因列表中GO术语的富集，它直接在拟合的模型对象上运行，并自动提取差异表达的基因。

与goana不同，其他基因组选项不需要应用显着性阈值来鉴定差异表达的基因。

最简单的方法是在geneSetTest和wilcoxGST函数中实现的，它们执行基于秩的测试，这些测试评估指定的一组基因是否在所有基因的有序列表中排名高于偶然预期。

roast具有考虑集合中基因的方向注释信息的独特能力，它能够容纳与特定途径正相关和负相关的基因，以及每个基因的变化幅度，因此，对于在不同表达研究之间发现基因表达模式的相似性特别有用。

romer函数实现了基于旋转而不是置换的GSEA方法，它可以与一组基因组和任何线性模型一起使用。


同时，基因集的使用要求基因符号和注释在不同的数据库和研究之间匹配。基因符号随时间而变化，因此limma包含alias2Symbol和alias2SymbolTable函数，用于将基因符号别名映射到当前的官方基因符号。


上述就是被广泛使用的开源limma包的基因表达分析的特征啦，具体的代码使用还是需要更艰苦的摸索~





========================================
edgeR
----------------------------------------
1. 用途
edgeR 适用于RNA-Seq，SAGE-Seq，Chip-Seq，CRISPR-Cas9，DNA methylation研究。


(1)细胞特异性基因是用edgeR识别的。
The cell-specific genes between ESC and NIH-3T3 were identified using EdgeR (FDR < 0.05; fold change > 1.5 or greater than two-thirds)34.

(2)正常、肿瘤细胞特异性DHS是用edgeR识别的。
The normal- and tumourcell- specific DHSs were identified using EdgeR.

(3)paper: 
34. Robinson, M. D., McCarthy, D. J. & Smyth, G. K. edgeR: a Bioconductor package for differential expression analysis of digital gene expression data. Bioinformatics 26, 139–140 (2010).


官网
http://www.bioconductor.org/packages/release/bioc/html/edgeR.html
Differential expression analysis of RNA-seq expression profiles with biological replication. Implements a range of statistical methodology based on the negative binomial distributions, including empirical Bayes estimation, exact tests, generalized linear models and quasi-likelihood tests. As well as RNA-seq, it be applied to differential signal analysis of other types of genomic data that produce counts, including ChIP-seq, SAGE and CAGE.
带有生物学重复的RNA-seq表达谱差异表达分析。实现了一系列基于负二项分布统计方法，包括经验贝叶斯估计，精确检验，广义线性模型和quasi-likelihood检验。和RNA-seq一样，适用于其他产生counts的基因组数据的差异信号分析，包括ChIP-seq，SAGE和CAGE。


The package is especially suitable for analysing designed experiments with multiple experimental factors but possibly small numbers of replicates. It has unique abilities to model transcript specific variation even in small samples, a capability essential for prioritizing genes or transcripts that have consistent effects across replicates.
该包特别适合分析多个实验因子但是很少重复的实验设计。独有的从少量样本建模出特有转录变体，必要的排序重复之间有稳定效应的基因和转录本的能力。


查看帮助文档edgeRUsersGuide.pdf ：
> library(edgeR)
> edgeRUsersGuide()
at the R prompt to open the User’s Guide in a pdf viewer.










2. edgeR包是进行RNA-seq数据分析非常常用的一个R包。该包需要输入每个基因关于每个样本的reads数的数据，每行对应一个基因，每一列对应一个样本。建议使用htseq-count进行统计，输出文件即可直接使用。如果需要算RPKM，需要自己统计基因长度信息。

(0)快速入门
glm approach 相比经典方法更灵活。旗下包含quasi-likelihood F-test method 和 likelihood ratio。
quasi-likelihood： 建议用于大量RNA-seq数据的差异表达分析。
likelihood ratio： 建议用于单细胞RNA-seq分析和没有重复的实验分析中。


x = read.delim("TableOfCounts.txt",row.name = "Symbol")
group = factor(c(1,1,2,2))
y = DGEList(counts = x,group = group)
y = calcNormFactors(y)
design = model.matrix(~group)
y = estimateDisp(y,design)

运行quasi-likelihood F test：
fit = glmQLFit(y,design)
qlf = glmQLFTest(fit,coef = 2)
topTags(qlf)

运行likelihood ratio tests：
fit = glmFit(y,design)
lrt = glmLRT(fit,coef = 2)
topTags(lrt)






(1) 输入基因和分组信息
第一步：构建 DGEList类变量
edgeR的大多数操作都是对 DGEList类型变量进行，所以第一步必须构建该类型变量，使用函数：DGEList
y <- DGEList(counts=x)


这里的x就是每个行一个基因每列一个样本的reads数表达矩阵。
当然还需要一个分组信息的数据，需要自己建立，例如：

group <- c(1,1,2,2)
y <- DGEList(counts=x, group=group)


(2) 第二步：基因筛选
对于在大多数样本中表达数量都很少的基因，需要进行过滤，这一步可以根据自己定义的标准过滤，edgeR推荐使用该包的CPM（ count-per-million ）值进行过滤，命令：

keep <- rowSums(cpm(y)>1) >= 2#至少在两个样本里cpm大于1
y <- y[keep, , keep.lib.sizes=FALSE]


(3) 第三步：标准化
edgeR的标准化思想主要针对的是不同样本在建库时效应。这一点与RPKM不同，因为edgeR认为不同的基因对于所有样本的影响是相同的，所以不必考虑。因此为了消除这种建库时的效应，edgeR会更推荐你使用他的calcNormFactors函数，算出来的值叫做trimmed mean of M-values (TMM) ，命令为：

y <- calcNormFactors(y)
y$samples

# group lib.size norm.factors
# Sample1 1 10880519 1.17
# Sample2 1 9314747 0.86
# Sample3 1 11959792 1.32
# Sample4 2 7460595 0.91
# Sample5 2 6714958 0.83


(4) 第四步：聚类与热图
在表达量分析中经常会遇到根据基因表达量来对基因进行聚类分析的过程，edgeR建议使用logcpm这个指标来进行聚类和画热图，命令是：

logcpm <- cpm(y, prior.count=2, log=TRUE)


(5) 第五步：差异表达分析
edgeR的差异表达分析有两种方式，简单的一种是直接进行配对检验，命令是：

et <- exactTest(y, pair=c("A","B")) #检验A、B样本的差异表达基因
topTags(et)


另一种算法比较复杂，其思想是：首先表达值需要服从某个分布，然后与这个分布不相符的基因才是差异表达基因。具体做法如下：

design <- model.matrix(~Subject+Treat)#设计一个实验设计矩阵
fit <- glmFit(y, design)#构建一个基因表达值得广义线性模型
lrt <- glmLRT(fit) #通过似然比检验得到最后的结果







ref:
https://blog.csdn.net/hzau_yang/article/details/78118257
https://blog.csdn.net/weixin_44649331/article/details/103842532


========================================
DESeq2包适合count矩阵的分析 【推荐】
----------------------------------------
官方教程: Analyzing RNA-seq data with DESeq2
http://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

A basic task in the analysis of count data from RNA-seq is the detection of differentially expressed genes. The count data are presented as a table which reports, for each sample, the number of sequence fragments that have been assigned to each gene. Analogous data also arise for other assay types, including comparative ChIP-Seq, HiC, shRNA screening, mass spectrometry. An important analysis question is the quantification and statistical inference of systematic changes between conditions, as compared to within-condition variability. The package DESeq2 provides methods to test for differential expression by use of negative binomial generalized linear models(负二项广义线性模型); the estimates of dispersion(离散) and logarithmic fold changes incorporate data-driven prior distributions.

This vignette explains the use of the package and demonstrates typical workflows. An RNA-seq workflow[http://www.bioconductor.org/help/workflows/rnaseqGene/] on the Bioconductor website covers similar material to this vignette but at a slower pace, including the generation of count matrices from FASTQ files. DESeq2 package version: 1.23.8



https://mp.weixin.qq.com/s/Vmhx_TGxNkQzkekf93Xl4w
DESeq2差异基因分析和批次效应移除
原创： 易生信  生信宝典  2018-05-29



1.
差异分析的套路都是差不多的，大部分设计思想都是继承limma这个包，DESeq2也不例外。

DESeq2是DESeq包的更新版本，看样子应该不会有DESeq3了，哈哈，它的设计思想就是针对count类型的数据。

可以是任意features的count数据，比如对各个基因的count，或者外显子，或者CHIP-seq的一些feature，都可以用来做差异分析。


使用这个包也是需要三个数据：
	表达矩阵
	分组矩阵
	差异比较矩阵

总结起来三个步骤，我下面会一一讲解
	重点就是构造一个dds的对象，
	然后直接用DESeq函数进行normalization处理即可，
	处理之后用results函数来提取差异比较结果

(2) 数据预处理
采用DESeq2对表达量进行PCA和聚类分析 原创： lzyg  生信修炼手册  2018-09-25

得到基因/转录本的表达量之后，通常会通过以下三种类型的图表来检验和分析生物学样本和实验设计间关系。
- 样本的聚类树： 理论上如果样本和实验操作都没有问题，那么属于同一组的生物学重复样本会聚到一起
- PCA图：不同条件的样本区分的很明显，而生物学重复之间距离较近，表明生物学重复的一致性和不同分组的差异性较好。
- 热图： 相比样本的聚类树，热图可以直观的展示不同分组间表达量的差异

只要有样本的表达量矩阵，DESeq2可以轻松的画出以上3种图表。但是我们应该选择原始的表达量矩阵，还是归一化之后的表达量矩阵来画呢？或者有没有其他的选择呢？

输入的矩阵不同，得出的结论也会不同。由于基因的表达水平在不同样本间本身就存在一定的差异，所以无论是采用原始的还是归一化之后的表达量矩阵，效果都不理想。
针对这一问题，DESeq2提出了两种count值的转换算法，rlog和VST转换。

rld <- rlog(dds) #rlog 转换
vsd <- vst(dds) #VST 转换
两种转换本质上是在降低生物学重复之间的差异，使得样本聚类和PCA分析的效果更好。转换之后的表达量数据可以采用assay函数进行提取，代码如下

> head(assay(rld)[, 1:2])
       sample1   sample2
gene1 2.049029 1.6828707
gene2 8.151262 6.8552583
gene3 0.818971 0.2964686
gene4 5.340361 4.4766682
gene5 6.316175 6.8345783
gene6 2.157821 1.9264385

对于raw count定量表格，建议采用rlog或者VST转换之后的数据去进行PCA和聚类分析，效果会更好。

利用DESeq2提供的示例数据pasilla，分别用原始的count, 归一化之后的count, rlog, vst 转换的count 进行PCA分析，代码如下

使用DESeqDataSetFromMatrix建立对象之后：
## 接下来，分别使用两种vlog类型
dds3 <- estimateSizeFactors(dds)
raw <- SummarizedExperiment(counts(dds3, normalized=FALSE), colData=colData(dds3))
nor <- SummarizedExperiment(counts(dds3, normalized=TRUE), colData=colData(dds3))
vsd <- vst(dds3)
rld <- rlog(dds3)
pdf("PCA_condition.pdf")
#cond=c("condition", "type");
cond=c("condition");
plotPCA( DESeqTransform(raw), intgroup=cond)
plotPCA( DESeqTransform(nor), intgroup=cond )
plotPCA(vsd, intgroup=cond)
plotPCA(rld, intgroup=cond)
dev.off()

可以很明显看出，原始的count和归一化之后的count, 其PCA图是杂乱无序的，没什么明显规律，而VST和rlog转换之后，生物学重复之间更佳的接近，不同分组也区分的较为明显。






2.步骤
第一步在你的PC或者MAC上安装Rstudio
第二步安装deseq2工具并载入

#新版这样安装
# BiocManager::install("DESeq")
# BiocManager::install("DESeq2")
# BiocManager::install("pasilla")

library(DESeq2)
library(pasilla)

然后是读取数据，在这里需要说明一下
1)、读取的数据结构应该是
横行为基因（图示为ENSGxxx），列为样本。

2)、数据可以从txt或者csv等文件直接用read.table/csv读取
# setwd("~/data")
# setwd('G:\\c1_BR_analysis_code\\30_RE_cell_line')

data <- read.table("ehbio_trans.Count_matrix.xls", header=T, row.names=1, com='', quote='', check.names=F, sep="\t")


# 撇掉在多于两个样本中count<1的值，如果样本数多，这个数值可以适当增加
# 排除极低表达基因的干扰
data <- data[rowSums(data)>2,]
head(data)


3)、当然如果你看了下面的教程，你会得到data.out这个数据框，按照下面的命令即可得到用于deseq2分析的原始文件
# data.out1<-data.out[-(1:4),-2]
# raw.data<-data.out1[,-1]



进行条件设置
condition<-c(rep('Tumor',50),rep('Normal',50))
coldata<- data.frame(row.names=colnames(raw.count), condition)
此处要注意raw.count的排序需要与condition顺序一致

# 读入分组信息
#sample <- read.table("sampleFile", header=T, row.names=1, com='',
#    quote='', check.names=F, sep="\t", colClasses="factor")
# sample <- sample[match(colnames(data), rownames(sample)),, drop=F]
# sample_rowname <- rownames(sample)
# 下面的可以忽略，如果没遇到错误不需要执行
# 目的是做因子转换
#sample <- data.frame(lapply(sample, function(x) factor(x, levels=unique(x))))
#rownames(sample) <- sample_rowname
#sample







####################
# 数据实例：DESeq2自带的果蝇的RNAseq counts数据
####################
## 自于pasilla数据包，函数system.file告诉我们数据文件保存的路径。
library(DESeq2)
library(pasilla)
datafile = system.file( "extdata/pasilla_gene_counts.tsv", package="pasilla" );datafile
## [1] "/home/wangjl/R/x86_64-pc-linux-gnu-library/3.6/pasilla/extdata/pasilla_gene_counts.tsv"
# 在R中读取这个文件，使用read.table函数。
pasillaCountTable = read.table( datafile, header=TRUE, row.name=1);head( pasillaCountTable )
##             untreated1 untreated2 untreated3 untreated4 treated1 treated2 treated3
## FBgn0000003          0          0          0          0        0        0        1
## FBgn0000008         92        161         76         70      140       88       70
## FBgn0000014          5          1          0          0        4        0        0
raw.count=pasillaCountTable

#加载条件
library(DESeq)
data(pasillaGenes)
dim(pasillaGenes)
## Features  Samples 
## 14470        7

# 进行条件设置
# 此处要注意raw.count的排序需要与condition顺序一致
##元数据可以分为三组，分别是样本(行名)，特征(列)和整个实验的信息。
pasillaDesign = data.frame(
  names = colnames( pasillaCountTable ),
  condition = rev(pasillaGenes$condition),
  libType = rev(pasillaGenes$type),
  row.names = 1
)
pasillaDesign
##           condition     libType
## untreated1 untreated  paired-end
## untreated2 untreated  paired-end
## untreated3 untreated single-read
## untreated4 untreated single-read
## treated1     treated  paired-end
## treated2     treated  paired-end
## treated3     treated single-read
coldata=pasillaDesign
# data prepare end.






####################
# 开始使用DESeq2
####################
#DESeq2包采用DESeqDataSet存储原始的read count和中间计算的统计量。

#构建deseq2对象
dds <- DESeqDataSetFromMatrix(countData = raw.count, #表达矩阵
	colData = coldata, #样品分组信息表
	design = ~ condition) #实验设计信息，conditions必须是colData中的一列的colname

#设置对照
#dds$condition = relevel(dds$condition,'Normal')  
dds$condition = relevel(dds$condition,'untreated')
dds$condition #level中的两项，第一个是对照。
# Levels: untreated treated


#计算开始，样本量大的话，可以先去干点别的
dds2 <- DESeq(dds)
## estimating size factors
## estimating dispersions
## gene-wise dispersion estimates
## mean-dispersion relationship
## final dispersion estimates
## fitting model and testing
#
## 1.estimation of size factors: estimateSizeFactors
## 2.estimation of dispersion: estimateDispersions
## 3.Negative Binomial GLM fitting and Wald statistics: nbinomWaldTest

### more todo at last.


#get结果
res <- results(dds2)
head(res) # log2 fold change (MLE): condition treated vs untreated 果然是对的
## 校正后p-value为NA的赋值为1
#res$padj[is.na(res$padj)] = 1
# 按pvalue排序, 把差异大的基因放前面
res <- res[order(res$padj),]  #order函数是给出从小到大排序后的位置，默认decreasing = FALSE
head(res)


#设置cutoff
resSig <- subset(res, abs(log2FoldChange)>log2(1.5) & padj < 0.05) #需要先替换NA为0吧？不用NA替换为1，NA都会被过滤掉的。
dim(resSig) #[1] 479  6
head(resSig)
#	baseMean	log2FoldChange	lfcSE	stat	pvalue	padj
#FBgn0039155	730.5958061	-4.619013333	0.168706778	-27.37894349	4.89E-165	4.07E-161
#FBgn0025111	1501.410513	2.899864343	0.126920536	22.84787335	1.53E-115	6.38E-112
#FBgn0029167	3706.116531	-2.197000182	0.096988843	-22.65209194	1.33E-113	3.69E-110
#FBgn0003360	4343.035397	-3.179672196	0.1435264	-22.15391877	9.56E-109	1.99E-105


#输出结果，并记录到文件
resSig<-data.frame(resSig)
write.csv(resSig,file="DESeq2_DEG.csv")
res0=res

#end



############
## MA plot
res2=data.frame(res)
plotMA(res2 ,ylim=c(-5,5) )
# 标出p最显著的基因
topGene <- rownames(res2)[which.min(res2$padj)]
with(res2[topGene, ], {
   points(baseMean, log2FoldChange, col="dodgerblue", cex=6, lwd=2)
   text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})





############
# ?counts查看此函数功能
# normalized=T, 返回标准化的数据
normalized_counts <- counts(dds2, normalized=TRUE)
head(normalized_counts)

# 根据基因在不同的样本中表达变化的差异程度mad值对数据排序，差异越大的基因排位越前。
normalized_counts_mad <- apply(normalized_counts, 1, mad)
normalized_counts <- normalized_counts[order(normalized_counts_mad, decreasing=T), ]

# filter zeros
hist( log2( apply(normalized_counts,1,sum) ),n=100 )
keep=apply(normalized_counts,1,sum)!=0
# hist plot
pheatmap( log2(normalized_counts[keep,]+1),
          clustering_method="average",
          show_rownames=F,
          scale="row",
          
          annotation_col=df,
          
          cluster_rows=T, 
          cluster_cols=T)
# 这个热图分类效果还好
#
# 使用差异基因分类
ls()[grep('Sig',ls(), ignore.case=T)]
head(resSig)
dim(resSig) #479 6
pheatmap( log2(normalized_counts[rownames(resSig),]+1),
          clustering_method="average",
          show_rownames=F,
          scale="row",
          
          annotation_col=df,
          
          cluster_rows=T, 
          cluster_cols=T)
#






############
# 经过lfcShrink 收缩log2 fold change
res_order<-res[order(row.names(res)),]
res = res_order
res.shrink <- lfcShrink(dds2, contrast = c("condition","treated","untreated"), res=res)
#Note that type='apeglm' and type='ashr' have shown to have less bias than type='normal'.
#See ?lfcShrink for more details on shrinkage type,
res.shrink=as.data.frame(res.shrink)
##
plotMA(res.shrink, ylim = c(-5,5))
topGene <- rownames(res)[which.min(res$padj)]
with(res[topGene, ], {
  points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
  text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})
##
head(res.shrink)
#                 baseMean log2FoldChange      lfcSE         stat     pvalue      padj
# FBgn0000003    0.1715687    0.014108444 0.05709662  0.269612549 0.78745835        NA
# FBgn0000008   95.1440790    0.001752368 0.18253170  0.009611049 0.99233161 0.9969282


############
#(可选) log2FC(LFC) vs lfcShrink
# 为何采用lfcShrink？log2FC estimates do not account for the large dispersion we observe with low read counts.
#因此，两种数据特别需要：低表达量占比高的；数据特别分散的
#As with the shrinkage of dispersion estimates, LFC shrinkage uses information 
# from all genes to generate more accurate estimates.

#
## 即使两个基因的标准化count值相似，但也可能存在不同的LFC shrinkage
#注意：Shrinking the log2 fold changes不会改变显著差异的基因总数
#例如，如果要根据LFC值提取差异基因，需要shrunken values
#另外，进行功能分析例如GSEA时，需要提供shrunken values

# 作者还是非常推荐使用lfcShrink的https://support.bioconductor.org/p/95695/
# 对于新版本而言，可以这样手动操作

resultsNames(dds2) ## [1] "Intercept"  "condition_treated_vs_untreated" #coef的参数
#BiocManager::install("apeglm")
library(apeglm)
#resLFC <- lfcShrink(dds, coef="condition_treated_vs_untreated", type="apeglm")
resLFC <- lfcShrink(dds2,coef="condition_treated_vs_untreated", type="apeglm")
# 选择的apeglm参数(Zhu, Ibrahim, and Love 2018)进行effect size shrinkage,which improves on the previous estimator

# 发现shrink后少了一列stat
names(resLFC)
#[1] "baseMean"       "log2FoldChange" "lfcSE"          "pvalue"       "padj"          
names(res)
#[1] "baseMean"       "log2FoldChange" "lfcSE"          "stat"         "pvalue"         "padj" 





############
#Plot counts
# 不画图，只显示数据
# plotCounts(dds2, gene=which.min(res2$padj), intgroup="condition", returnData=TRUE) #这个好像是错的
plotCounts(dds2, gene=rownames(res2)[which.min(res2$padj)], intgroup="condition", returnData=TRUE)
#只画图，不显示数据
topGene #"FBgn0039155"
plotCounts(dds2, gene="FBgn0039155", intgroup="condition", returnData=FALSE)

# 下面用ggplot2来画基因 的box图和point图
#boxplot
library(dplyr)
library(ggplot2)
plotCounts(dds, gene="FBgn0039155", intgroup="condition", returnData=TRUE) %>% 
  ggplot(aes(condition, count)) + 
  geom_boxplot(aes(fill=condition)) + 
  scale_y_log10() + ggtitle("FBgn0039155")
#

## point plot
d <- plotCounts(dds, gene="FBgn0039155", intgroup="condition", returnData=TRUE)
ggplot(d, aes(x=condition, y=count)) + 
   geom_point(aes(color= condition),size= 4, position=position_jitter(w=0.5,h=0)) + 
   scale_y_log10(breaks=c(25,100,400))+ ggtitle("FBgn0039155")


##########
## PCA(principal components analysis)
vsdata <- vst(dds2, blind=FALSE)
#
detach("package:DESeq", unload=TRUE)
plotPCA(vsdata, intgroup="condition") 
##Error in (function (classes, fdef, mtable)  : 
##unable to find an inherited method for function ‘exprs’ for signature ‘"DESeqTransform"’
##报这个错，是因为包不对，消掉无关的包 https://bbs.pinggu.org/thread-1337086-1-1.html





##########
#热图：两部分
# 4.1 count matrix 热图
# BiocManager::install('pheatmap')
library("pheatmap")
select<-order(rowMeans(counts(dds2, normalized = TRUE)),
              decreasing = TRUE)[1:300]
df <- as.data.frame(colData(dds2)[,c("condition","sizeFactor")]) 
# this gives log2(n + 1)
ntd <- normTransform(dds2)
pheatmap(assay(ntd)[select,],
         show_rownames=F,
         scale="row",
         cluster_rows=T, 
         cluster_cols=T,
         annotation_col=df)
#
#
# 使用原始read画热图， 说明log2(cpm+1)画热图挺好的。
dim(raw.count) #14599
head(raw.count)
keep=apply(raw.count,1,sum)>0
table(keep)
#
count.standard=apply(raw.count[keep,],2,function(x){ x*1e6/sum(x) })
dim(count.standard)
head(count.standard)
pheatmap( log2(count.standard+1),
          clustering_method="average",
         show_rownames=F,
         scale="row",

         annotation_col=df,

         cluster_rows=T, 
         cluster_cols=T)
#
#

## 4.2 sample-to-sample distances热图
sampleDists <- dist(t(assay(vsdata)))
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsdata$condition, vsdata$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
#样本聚类到一起了


##













如果input没有gene symbol，则这个时候依旧是没有基因名字的，你需要参考下面的教程进行注释。果蝇的基因，不做了。
生信干货~ID(ENSGxx)转Gene name的方法~





refer:
#(推荐)  DESeq2差异基因分析和批次效应移除
https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ%3D%3D&mid=2247485368&idx=1&sn=12b20487e9014ce2e69f01d3efbc6ce8&scene=45

用DESeq2包来对RNA-seq数据进行差异分析
http://www.bio-info-trainee.com/bioconductor_China/software/DESeq2.html


RNA-seq实战(下)_数据可视化、GO/KEGG分析
https://www.jianshu.com/p/f73de8022cf9




========================================
|-- R代码: DESeq2 分析counts数据得到差异表达矩阵，并画火山图
----------------------------------------
前面读取文件。略。

##########################
# 1 get DE gene list, with DESeq2
##########################
library(DESeq2)

# matrix
countData <- cbind( RNA[,cid.norm], RNA[,cid.sync] )
dim(countData) #14675    56
countData[1:4,1:4]
#过滤掉5个细胞以下表达的基因
df=data.frame(
  gene=row.names(countData),
  num.N=apply(countData[, cid.norm]>0,1,sum),
  num.S=apply(countData[, cid.sync]>0,1,sum),
  row.names = 1
)
head(df)
df2=df[which(df$num.N>5 & df$num.S>5),]
dim(df2) #7487 2
#
countData=countData[rownames(df2),]
dim(countData) #[1] 7487   56

#条件
condition <- factor(c( rep('normal', length(cid.norm)), rep('sync', length(cid.sync))  ), 
                    levels=c('normal','sync'))
condition
#
dds <- DESeqDataSetFromMatrix(countData, DataFrame(condition), design= ~ condition )
# 过滤
nrow(dds) #7487
dds2 <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds2)#[1] 7487

keyword='sync_VS_normal_HeLa'
#
#一步法
dds3 <- DESeq(dds2) #耗时1min
## estimating size factors
## estimating dispersions
## gene-wise dispersion estimates
## mean-dispersion relationship
## final dispersion estimates
## fitting model and testing
## -- replacing outliers and refitting for 5164 genes
## -- DESeq argument 'minReplicatesForReplace' = 7 
## -- original counts are preserved in counts(dds)
## estimating dispersions
## fitting model and testin

#获取结果
res <- results(dds3)
head(res)
#log2 fold change (MLE): condition sync vs normal 
#Wald test p-value: condition sync vs normal 
#DataFrame with 6 rows and 6 columns
#baseMean     log2FoldChange             lfcSE               stat             pvalue
#<numeric>          <numeric>         <numeric>          <numeric>          <numeric>
#  AAAS  45.0706763507379 -0.286189288744119 0.984181112955205 -0.290789251060485  0.771212506698282
#AAGAB 37.6621410990222  0.761637086304566   1.1243489415785  0.677402768961818  0.498150441980007

#                   padj
#              <numeric>
# AAAS  0.941981213557402
#AAGAB 0.849654084021838

# 校正后p-value为NA的赋值为1
res$padj[is.na(res$padj)] = 1

# order
res <- res[order(res$padj),]
dim(res) #7487 6

# set cutoff
resSig <- subset(res, abs(log2FoldChange)>log2(2) & padj < 0.05)
dim(resSig) #[1] 252  6
head(resSig)

#save to file
resSig<-data.frame(resSig)
dim(resSig) #[1] 252   6
head(resSig)
write.csv(resSig, file=paste0("DESeq2_DEG_",keyword,".csv") )


#save all file for GSEA
res2=data.frame(res)
dim(res2) #7487 6
head(res2)
write.csv(res2, file=paste0("DESeq2_ALL_",keyword,".csv") )




##########################
# 2 volcano plot
##########################
library('ggplot2')
dif=data.frame(res)
dif$threshold= factor( abs(dif$log2FoldChange) > log2(1.5) & dif$padj < 0.05, #1.5倍, 0.05
                       levels=c(TRUE,FALSE) )
str(dif)
head(dif)
tb=table(dif$threshold);tb
#TRUE FALSE 
#304  7235

#
dif$threshold2="ns";
dif[which(dif$log2FoldChange > log2(1.5) & dif$padj < 0.05),]$threshold2="up";
dif[which(dif$log2FoldChange < (-log2(1.5)) & dif$padj < 0.05),]$threshold2="down";
dif$threshold2=factor(dif$threshold2, levels=c('down','ns','up'))
tb2=table(dif$threshold2);tb2
#down   ns   up 
#130 7183  174

# save up and down gene list
geneUp=row.names(dif[which(dif$threshold2=='up'),]);length(geneUp) #174
head(geneUp)
writeLines(geneUp, paste0('DESeq2_', keyword,'_genes_UP.txt') )
#
geneDown=row.names(dif[which(dif$threshold2=='down'),]);length(geneDown) #130
head(geneDown)
writeLines(geneDown, paste0('DESeq2_', keyword,'_genes_DOWN.txt') )

##############
g = ggplot(data=dif, aes(x=log2FoldChange, y=-log10(padj), color=threshold2)) +
  geom_point(alpha=0.4, size=0.4) +
  theme_bw() +
  theme(legend.box = "horizontal", #显著性图例，水平，标到底部
        legend.position="bottom") +
  #scale_color_manual('Significant',labels=c("TRUE","FALSE"), values=c("red", "grey") )+ 
  scale_color_manual('Significant',labels=c(paste0("down(",tb2[[1]],')'),'ns',
                                            paste0("up(",tb2[[3]],')' )),
                     values=c("blue", "grey",'red') )+
  xlab("log2(FoldChange)") + ylab("-log10(p.adj)") +
  labs(title= paste0("DEG: ",keyword) ); g
# add text to a few genes
dd_text = dif[ ((abs(dif$log2FoldChange) > 2) & (dif$padj < 1e-10) ) | 
                 abs(dif$log2FoldChange) > 5.5,]; dim(dd_text)
head(dd_text)
#add text
library(ggrepel)
g2=g + geom_text_repel(data=dd_text, aes(x=log2FoldChange, y=-log10(padj), label=row.names(dd_text)), 
                       size=2.5, colour="black",alpha=0.6); g2
#保存图片
CairoPDF(file=paste0('volcano_plot_',keyword,'.pdf'), width=3.6,height=4)
print(g2)
dev.off()
#

##########################
# 3 check the counts
##########################
showCounts=function(gene1){
  print(gene1)
  c0=as.numeric(RNA[gene1,cid.norm]);
  c1=as.numeric(RNA[gene1,cid.sync]);
  deltaCV=sd(c1)/mean(c1)-sd(c0)/mean(c0)
  df=data.frame(
    counts=c(c0,c1),
    type=c(rep('normal', length(c0)),   rep('sync', length(c1)) )
  )
  #library(ggplot2)
  g=ggplot(df, aes(type,log10(counts+1),color=type))+
    theme_bw()+
    geom_boxplot()+geom_jitter(size=0.5, alpha=1)+
    scale_color_manual(values=c('grey','#93BBFD'))+
    labs(title=gene1,x=paste0("deltaCV:",round(deltaCV,2) ) , y="log10(RNAcounts+1)")
  g
}
dd_text=dd_text[order(-dd_text$log2FoldChange),]
head(dd_text)
dim(dd_text) #21
geneUp2=rownames(dd_text[which(dd_text$log2FoldChange>0),] );length(geneUp2) #13
geneDown2=rownames(dd_text[which(dd_text$log2FoldChange<0),] );length(geneDown2) #8
#
CairoPDF(file=paste0("02-Check_counts_", keyword,".pdf"),width=7,height=5)
grid.arrange(
  showCounts(geneUp2[1]),
  showCounts(geneUp2[2]),
  showCounts(geneUp2[13]),
  
  showCounts(geneDown2[1]),
  showCounts(geneDown2[7]),
  showCounts(geneDown2[8]),
  nrow=2
)
dev.off()



接着做GO分析。略。




========================================
ID转换 
----------------------------------------
很多时候你得到的是GENCODE的ID，比如ENSGxxx之类的，怎样转换成gene symbol呢？往下看

https://mp.weixin.qq.com/s?__biz=MzI3MTM4NTAzOQ==&mid=2247483831&idx=1&sn=e53f0896514c3785c38773435a74e9af

详见 NGS/GO 分析专题。


========================================
WGCNA包:加权基因共表达网络分析 (WGCNA, Weighted correlation network analysis)
----------------------------------------
WGCNA是用来描述不同样品之间基因关联模式的系统生物学方法




refer:
WGCNA分析，简单全面的最新教程
https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&mid=2247485220&idx=1&sn=007188964e7c43d75dcd0b11b880bbfa


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
