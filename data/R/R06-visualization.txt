R的可视化：图片、pdf和网页等展示(略)



R绘图主要包括三部分：基础绘图命令、Lattice图形系统、ggplot包。

主要记录在 http://www.biomooc.com/R/R-draw-sketch.html


tips:
- 横坐标文字的方向改变，在画图之前加上par(las=2)，2表示垂直于坐标轴。
- 图形坐标离边缘的距离（调整图像位置）：par(mar=c(3,3,3,3))四个值分别表示下、左、上、右




========================================
R语言可视化概述与资源
----------------------------------------
1. 经典教材

R语言原生的绘图系统已经非常强大了，可以绘制非常炫目的图片，需要的仅仅是耐心。
其他绘图包ggplot2，plotly都很好用。

再近几年，R语言推出了Shiny框架，可以用R语言快速写成一个网页，这简直不能更方便。


数据可视化软件 Tableau http://www.tableau.com/zh-cn
数据可视化： d3库 https://github.com/d3/d3/wiki/Gallery

“高大尚图片包括（GNUplot，http://www.gnuplot.info/）和matlab，但是R包ggplot2作图秒杀以上二者。”


(1)《R语言实战》中的绘图章节
第3章 图形初步P40-64
	本章介绍了创建、修改图形的方法，以及如何将图形保存为各种格式的文件。
第6章 基本图形P108-129
	第6章演示了创建常见单变量图形的方法，例如柱状图、饼图、直方图、密度图、箱线图和点图。这些图形对于理解单变量的分布都很有用。
第11章 中级绘图P236-261
	第11章扩展了第5章的内容，介绍了创建表现两个或多个变量间关系的图形。这包括各种2D和3D的散点图、散点图矩阵、折线图、相关图和马赛克图。
第16章 高级图形P333-256
	第16章介绍了R中最先进、最有用的数据可视化方法，包括用lattice图形表现非常复杂的数据，简要介绍新的ggplot2包，并对各种跟图形实时交互的方法做了综述。


该书配套网站包含的图形
https://www.statmethods.net/graphs/index.html
Creating a Graph
Histograms and Density Plots
Dot Plots
Bar Plots
Line Charts
Pie Charts
Boxplots
Scatterplots

- 高水平画图命令；
- 低水平画图命令；
- 图形的交互与参数；
- 图形设备；
- 动态图形；


记录到： http://biomooc.dawneve.cc/R/R-draw-basic.html
参考： 
https://www.yiibai.com/r/r_pie_charts.html
https://blog.csdn.net/disappearedgod/article/details/8681312

https://www.flutterbys.com.au/stats/tut/tut5.1.html






2.图形示例
某种程度上，本博客txtBlog是一个文字为主的博客系统，不适合记录R可视化相关的教程。
请跳转查看-->
可视化部分： www.biomooc.com 找到R模块中的可视化部分即可。
( local url: http://biomooc.dawneve.cc )


(1).如何将枯燥的大数据呈现为可视化的图和动画？
https://www.zhihu.com/question/23416938


(2).R语言绘制日本老龄化：
https://github.com/walkerke/idbr


(3) 女儿的睡觉时间可视化(SVG)
https://www.zhihu.com/question/23416938
http://bl.ocks.org/abruzzi/d01a221df9cf79b918a00033695092c9





3. 视频教程
R语言之数据可视化 https://www.imooc.com/learn/640

录屏软件 oCam 









4.网络资源

R Graphics Essentials: 3个表格很好
http://www.sthda.com/english/articles/32-r-graphics-essentials/134-r-basics-for-data-visualization/



R Base Graphs
http://www.sthda.com/english/wiki/r-base-graphs

https://bookdown.org/rdpeng/exdata/the-base-plotting-system-1.html




Lattice Graphs
http://www.sthda.com/english/wiki/lattice-graphs


R语言绘图、高清保存、以及颜色系统
https://blog.csdn.net/jianjewl/article/details/69257841


R语言绘图样式设置（符号、线条、颜色、文本属性）
https://blog.csdn.net/glodon_mr_chen/article/details/79293615


R语言作图：坐标轴设置
https://blog.csdn.net/weixin_40628687/article/details/79254791


R语言高级绘图命令（标题-颜色等）
https://blog.csdn.net/hhtnan/article/details/54571975


https://www.cnblogs.com/xudongliang/tag/R%E8%AF%AD%E8%A8%80/default.html?page=2









========================================
R原生绘图 概述
----------------------------------------
R原生绘图也很强大。用一个高级绘图函数画出主体，然后用一系列低级绘图函数添加辅助元素。

1.简单图形绘制

attach(mtcars)
plot(wt,mpg) #散点图x,y
abline(lm(mpg~wt)) #拟合曲线y~x
title("Regression of MPG on Weight") #加标题
detach(mtcars)



2. 通过代码保存图片
setwd("F://Temp//") #设定工作目录

pdf("pic1.pdf") # 设定文件名
attach(mtcars)
plot(wt,mpg)
abline(lm(mpg~wt))
detach(mtcars)
dev.off() #关闭绘图设备

除了pdf()，还可以使用函数win.metafile()、png()、jpeg()、bmp()、tiff()、xfig()和postscript()将图形保存为其他格式。（注意，Windows图元文件格式仅在Windows系统中可用。）



3. 执行如plot()、hist()（绘制直方图）或boxplot()这样的高级绘图命令来创建一幅新图形时，通常会覆盖掉先前的图形。
如何才能创建多个图形并随时查看每一个呢？
方法1： dev.new()
方法2： 使用ggplot2绘图窗口的后退-前进箭头；
方法3: 数dev.new()、dev.next()、dev.prev()、dev.set()和dev.off()同时打开多个图形窗口，并选择将哪个输出发送到哪个窗口中。参考help(dev.cur)。


4.散点图 
语法： plot(x, y, type="p")
x and y: the coordinates of points to plot
type : the type of graph to create; Possible values are :

type="p": for points (by default)
type="l": for lines
type="b": for both; points are connected by a line
type="o": for both ‘overplotted’;
type="h": for ‘histogram’ like vertical lines
type="s": for stair steps
type="n": for no plotting
使用help(plot)可以查看其他选项.


x<-1:10; y=x*x
plot(x,y) #空心点图
plot(x, y, type="b") #空心点，用实线连接
plot(x, y, type="h") #竖直线
plot(x,y, type="s") #台阶图



5.图形参数：字体、颜色、线条、坐标轴、标题
(1)通过par()指定，除非被再次修改，该设定在进程结束前一直有效。该语句可一次性定义好，或使用多次。
添加par(no.readonly=T)可以生成一个不可以修改的当前图形参数列表，用于恢复设定。

oldPar=par(no.readonly = T) #记录当前设定
par(lty=2,pch=17) #修改设定：line type将默认实线改为虚线，pch将默认的点符号改为实心三角
plot(x,y,type="b")
par(oldPar) #恢复设定
plot(x,y,type="b")

##lty
 - The line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings "blank", "solid", "dashed", "dotted", "dotdash", "longdash", or "twodash", where "blank" uses ‘invisible lines’ (i.e., does not draw them).
 - Alternatively, a string of up to 8 characters (from c(1:9, "A":"F")) may be given, giving the length of line segments which are alternatively drawn and skipped. See section ‘Line Type Specification’.
 - Functions such as lines and segments accept a vector of values which are recycled.

##pch
 - plotting ‘character’, i.e., symbol to use. This can either be a single character or an integer code for one of a set of graphics symbols. The full set of S symbols is available with pch = 0:18, see the examples below. (NB: R uses circles instead of the octagons used in S.)
 - Value pch = "." (equivalently pch = 46) is handled specially. It is a rectangle of side 0.01 inch (scaled by cex). In addition, if cex = 1 (the default), each side is at least one pixel (1/72 inch on the pdf, postscript and xfig devices).
 - For other text symbols, cex = 1 corresponds to the default fontsize of the device, often specified by an argument pointsize. For pch in 0:25 the default size is about 75% of the character height (see par("cin")).



(2)通过高级绘图函数直接定义，仅对当前图形有效。
plot(x,y,type="b",lty=2,pch=17)



(3)指定符号和线条的参数
pch: 指定绘制时使用的符号
cex: 缩放倍数，默认是1；
lty: 指定线条类型；
lwd: 线条宽度。




1.画布分割

#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))

# par(mfrow=c(2,2),mar=c(1,1,2,1), mgp=c(2,.7,0), tck=-.01)#下、左、上、右的边距

par(mfrow=c(3,2)) #分割画布为3行2列
# http://blog.csdn.net/reallocing1/article/details/41726577

for(i in c(mean0,quantile2,quantile3,quantile4)){
  plot(x,y)
}








3.画图
library(Cairo)
CairoPNG(file=fname,width=1000)
plot(c(1,4,9,16))
dev.off()


4.调整坐标轴与刻度之间的距离：mgp=c(2.5,1,0)
http://blog.sina.com.cn/s/blog_4c7fada80102x3gd.html

mgp:坐标轴各部件的位置。第一个元素为坐标轴位置到坐标轴标签的距离，以文本行高为单位。第二个元素为坐标轴位置到坐标刻度标签的距离。第三个元素为坐标轴位置到实际画的坐标轴的距离，通常是0。





========================================
** 1. 高水平画图命令: plot, hist, barplot, boxplot, 
----------------------------------------
条形图、箱线图和点图
饼图和扇形图
直方图与核密度图

主要记录在
http://www.biomooc.com/R/R-draw-basic2.html
http://www.biomooc.com/R/R-draw-intermediate.html


========================================
|-- R语言中plot()函数
----------------------------------------
1. 基本作图

(1)




(2) 某数列的累积曲线
set.seed(1)
x=rnorm(1000) 
y=cumsum(x)
plot(y,type="l", col="red",xlab="x series")







2. 细节
(1). 6种边框
R语言中，设置plot(x,y,..., bty="o",..)里参数bty，就可以不同的6种边框了。

bty可以取6种字符，分别为“o”、“l”、“7”、“c”、“u”、“]”。这些字符代 表6种边框。

https://blog.csdn.net/sanqima/article/details/43022277







========================================
|-- 可视化查看数据分布: hist图和density图
----------------------------------------
1. hist() 查看数据的分布，重要参数是 n，就是分的区间个数。
hist(mtcars$mpg, 
     freq=FALSE, 
     breaks=12, 
     col="red", #柱子填充色
     border = NA, #去掉柱子的边框
     xlab="Miles Per Gallon", 
     main="Histogram, rug plot, density curve")  
rug(jitter(mtcars$mpg)) 
lines(density(mtcars$mpg), col="blue", lwd=2)





2. 对每个列染不同颜色
cl=colors()
set.seed(2)
x=runif(1000,-250,250) 
hist(x,breaks=seq(-250,250,5),col=cl[1:100]) 








========================================
|-- barplot(): 柱状图、堆叠图
----------------------------------------

1. R语言在柱状图上添加文字
画三组ABC，每组又两个柱子(空心、实心)


data <- data.frame(A = 1:2, B = 1:2, C = 1:2)
data <- data.matrix(data)

par(font = 2, lwd = 2)
pos=barplot(data, col = c("black", "white"), beside = T, ylim = c(0, 2.5), font = 2)
pos #返回坐标

# 使用pos 在柱子顶部添加文字
text( x = pos[,1], y = 0.05 + data[,1], adj = c(0.5, 0)) #A

text( x = pos[,2], y = 0.05 + data[,2], adj = c(0.5, 0), col="red") #B
text( x = pos[,3], y = 0.05 + data[,3], adj = c(0.5, 0), col=c("blue",'purple')) #C

axis(side = 2, lwd = 2, font = 2) #side=2左侧， lwd=2 加粗









2. R语言画barplot堆叠条形图

用于表现一个样本中有多少种亚型及其比例。
比如种群中的亚群比例，组织中的突变比例等信息。

数据实例：
province	cl1	cl2	cl3	cl4
10	0.927	0.012	0.023	0.038
10	0.894	0.057	0.009	0.04
15	0.03	0.277	0.262	0.431
15	0.032	0.768	0.042	0.159
16	0.021	0.731	0.058	0.19
16	0.017	0.914	0.042	0.027
17	0.011	0.945	0.011	0.033
17	0.013	0.96	0.014	0.013
18	0.207	0.148	0.223	0.422
18	0.677	0.084	0.119	0.12
19	0.064	0.124	0.223	0.589
19	0.539	0.194	0.027	0.24
20	0.021	0.041	0.058	0.879
20	0.027	0.046	0.106	0.821
21	0.018	0.102	0.051	0.829
21	0.026	0.122	0.167	0.685
22	0.015	0.012	0.956	0.017
22	0.063	0.018	0.905	0.014
23	0.015	0.018	0.93	0.038
23	0.018	0.025	0.938	0.018
23	0.023	0.046	0.864	0.067


代码：

#从剪切板读取数据
tbl2=read.table('clipboard',header=T)
#画条状图
barplot(t(as.matrix(tbl2))[-1,],col=rainbow(4), 
  #names.arg=(paste(substr(FirstName,1,1),".",LastName)),   #设定横坐标名称
  names.arg=tbl2$province,
  space=0, #条形间距
  xlab="Individual #", ylab="Ancestry",border=NA)
#axis(las=3,labels=tbl2$province)

#refer
#http://blog.sina.com.cn/s/blog_670445240102uwo3.html
#axis(1, lab=(t(as.matrix(tbl2))[1,]), cex.axis = 1.2)


问题：怎么在barplot图的上下标上文字注释？顶部标上分类，底部标上来源地。

这一步是structure软件的可视化部分。










========================================
|-- boxplot(): 箱线图 //todo
----------------------------------------






========================================
|-- curve(fn, x1, x2): 画函数曲线
----------------------------------------
1. Draws a curve corresponding to a function over the interval [from, to]. curve can plot also an expression in the variable xname, default x.

curve(expr, from = NULL, to = NULL, n = 101, add = FALSE,
      type = "l", xname = "x", xlab = xname, ylab = NULL,
      log = NULL, xlim = NULL, ...)
#




2. 实例
(1) 正弦曲线
curve(sin(x), -pi, pi)
abline(h=0, lty=2, col='grey')


(2) 二次曲线
pdf('123456wjl.pdf', width=4, height=4)
curve( (x-7)**2+2.25, 1,11, xlab="X", ylab="Y")

# arrow in a curve 用多边形画一个箭头
polygon(c(3,5,5,3), c(2,2,2.5,2.5), xpd=T, col='#FF000066', border = NA)
polygon(c(5,6,5), c(1.5,2.25,3), xpd=T, col='#FF000066', border = NA)
dev.off()







========================================
|-- R语言高/低级绘图函数-symbols: 圆形， 正方形，矩形，箱线图, 温度计图案 等
----------------------------------------
1. 严格意义上将symbols 并不能算是一个低级的绘图函数，因为它不仅可以在一幅已经存在的图标上添加元素，还可以创建一张新的图表
鉴于它绘图时的灵活性，我把它归入到低级绘图函数中

symbols 可以创建包括圆形， 正方形，矩形，箱线图，类似温度计的图形在内的多种图形

基本用法：
通过x和y坐标指定要创建的图形的中心，对于不同的形状，设置对应的参数
需要注意的是，图形的大小默认使用的单位是inches, 为了和坐标系中的坐标保持一致，可以通过inches = FALSE 将对应的参数和坐标系保持一致
add = TRUE 运行symbols 函数作为一个低级绘图函数来使用，在一张图表上添加对应的图形


(1)圆形：对于圆形来说，通过控制半径来控制其大小
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 1:5, y = 1:5, circles = rep(1, 5), inches = FALSE, add = TRUE)

(2)正方形：对于正方形来说，设置的参数是正方形边长的1/2
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 1:5, y = 1:5, squares = rep(2, 5), inches = FALSE, add = TRUE)

(3)矩形： 通过一个两列的矩阵来控制大小，第一列为宽度，第二列为长度
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), rectangles = matrix(c(2, 3, 3, 2), byrow = T, nrow = 2), inches = FALSE, add = TRUE)

(4)stars : 多边形，指定多边形的中心到各条边的距离，对于不同边数的多边形来说，对应的矩阵列数不同
par(oma = c(1, 1, 1, 1), mfrow = c(1, 3))
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 6), ncol = 3), inches = FALSE, add = TRUE)

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 8), ncol = 4), inches = FALSE, add = TRUE)

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 10), ncol = 5), inches = FALSE, add = TRUE)

(5)温度计图案：通过一个列数为3或者4的矩阵来控制其大小，前两列对应图形的宽度和长度，如果矩阵只有3列，第3列是一个百分比，在该百分比对应的高度，会有填充色；如果矩阵有第4列，则在第3列和第4列对应的百分比之间会有一个填充色

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 2, y = 3, thermometers = matrix(c(1, 3, 0.5), ncol = 3), inches = FALSE, add = TRUE)
symbols(x = 4, y = 4, thermometers = matrix(c(1, 3, 0.2, 0.8), ncol = 4), inches = FALSE, add = TRUE) 


(6)箱线图：通过一个列数为5的矩阵进行控制，前两列分别对应宽度和高度， 第三列和第四列对应箱线图的下限和上限，第五列为一个0到1之间的数，控制代表中位数的直线所处的位置

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE)

# fg : 设置图形边框的颜色
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE, fg = "red")


# bg: 设置图形的填充色
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE, bg = "red")


(7) 以上的用法都是通过add = TRUE , 将symbols 函数的输出添加到一个图形上，当add = FALSE 时，symbol 函数可以创建一张新的图表
除了前面的通用参数外，在创建新图表时，还有一些额外的参数
# xlim, ylim  : 设置新图表x轴和y轴的范围

symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, xlim = c(0, 6), ylim = c(0, 6))

(8)xlab, ylab , main : 分别设置新图表的x轴标签，y轴标签，标题
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, xlim = c(0, 6), ylim = c(0, 6),xlab = "x lab", ylab = "y lab", main = "title")







========================================
** 2. 低水平画图命令: legend, abline, text, axis, title
----------------------------------------
标题title
坐标轴axis
参考线abline
图例legend
文本标注text（绘图区域内部添加文字），mtext（图形四个边界添加文字）




1.散点图实例：自定义坐标轴及刻度，背景虚线，散点图，拟合的实线和虚线
来源：Fig 2C(Philip Brennecke, 2013: A ccounting for technical noise in single-cell RNARNARNA-seq experiments)

数据：#x=meansHeLa,y=cv2HeLa
> head(meansHeLa)
5_8S_rRNA       7SK      A1BG  A1BG-AS1       A2M   A2M-AS1 
2.8057377 0.3591766 0.6739348 0.3230381 1.1488078 0.3647032 
> head(cv2HeLa)
5_8S_rRNA       7SK      A1BG  A1BG-AS1       A2M   A2M-AS1 
19.335707  8.082797  6.597475  6.299504 28.000000 28.000000


画图命令
#2.4.1 Plot of the fit
CairoPDF(file="03-plotOfTheFit.pdf",width=5,height=5)
# Prepare the plot (scales, grid, labels, etc.)
plot( NULL, xaxt="n", yaxt="n",
      log="xy", xlim = c( 1e-1, 3e5 ), ylim = c( .005, 80 ),
      xlab = "average normalized read count", ylab = "squared coefficient of variation (CV^2)" )
axis( 1, 10^(-1:5), c( "0.1", "1", "10", "100", "1000",
                       expression(10^4), expression(10^5) ) )
axis( 2, 10^(-2:2), c( "0.01", "0.1", "1", "10","100" ), las=2 )
abline( h=10^(-2:2), v=10^(-1:6), col="#D0D0D0", lwd=2 )
title(main="nonSHela")
# Add the data points
points( meansHeLa, cv2HeLa, pch=20, cex=.2, col=colHeLa )
# Plot the fitted curve
xg <- 10^seq( -2, 6, length.out=1000 )
lines( xg, (xi+a1)/xg + a0, col="#FF000080", lwd=3 )
# Plot quantile lines around the fit
df <- ncol(countsERCC) - 1
lines( xg, ( (xi+a1)/xg + a0 ) * qchisq( .975, df ) / df,
       col="#FF000080", lwd=2, lty="dashed" )
lines( xg, ( (xi+a1)/xg + a0 ) * qchisq( .025, df ) / df,
       col="#FF000080", lwd=2, lty="dashed" )
dev.off()





========================================
|-- abline(截距, 斜率)函数为当前绘图添加直线，加背景虚线网格
----------------------------------------
1.abline(a = NULL, b = NULL, h = NULL, v = NULL, reg = NULL, coef = NULL, untf = FALSE, ...)

各参数的含义为：
（1）a 要绘制的直线截距
（2）b 直线的斜率
（3）h 绘制水平线时的纵轴值
（4）v 绘制垂直线时的横轴值
（5）reg 是一个具有coef方法的回归对象名称。若该对象返回的向量长度为1，则该值会作为该该函数的斜率，否则前两个值将会分别作为所绘直线的截距和斜率。
（6）coef 一个二维向量，给出截距和斜率
（7）untf 逻辑值，如果UNTF为真，且坐标轴中的一个或两个进行了对数变换，则会绘制对应于原始坐标系中的直线的曲线，否则在变换坐标系中绘制线。

abline()函数典型的用法
（1）abline(a, b, untf = FALSE, ...)
（2）abline(h =, untf = FALSE, ...)
（3）abline(v =, untf = FALSE, ...)
（4）abline(coef =, untf = FALSE, ...)
（5）abline(reg =, untf = FALSE, ...)

附加参数还可以给出线型、线条颜色，线条宽度等等。


2. 实例
#例1 带方格虚线的线图
# 画空图：参数type设置为"n",并设置坐标系的纵坐标与横坐标的比例为1
plot(c(-2,3), c(-1,5), type = "n", xlab = "x", ylab = "y", asp = 1)
# 绘制一条水平线和垂直线，并指定颜色
abline(h = 0, v = 0, col = "gray60")
#添加网格线或参考线
abline(h = -1:5, v = -2:3, col = "lightgray", lty = 3)
#如绘制y = 2x + 1，即绘制斜率为2，截距为1的直线
abline(a = 1, b = 2, col="red") #这里指定直线颜色为红色



#例2 过几个点，拟合曲线，画出该回归线
#在回归方程中可以添加趋势线,最简单的额情况，过2个点画直线
x <- c(2,5)
y <- c(50,57)
reg <- lm(y~x)
reg #会计算出截距和斜率
## Call:
## lm(formula = y ~ x)
## 
## Coefficients:
## (Intercept)            x  
##      45.333        2.333 
##
plot(x, y, xlab = "x XX", ylab = "y YY")
abline(reg,col="blue")





========================================
|-- R语言低级画图命令: legend() 画图例
----------------------------------------
吐槽吐到累，不如多掌握几个图例（Legend）的软肋，更好地利用R语言绘图。
legend(x, y = NULL, legend, fill = NULL,col =, bty = "o",xjust = 0, yjust = 1, x.intersp = 1, y.intersp =1, adj = c(0, 0.5), text.width = NULL,xpd=TRUE)



1. Legend 定位

整个绘图框的坐标轴范围，
> par("usr")
# [1] -0.24  6.24 -0.24  6.24
# 分别对应着 (xmin, xmax), (ymin, ymax); 可以辅助定位图例的位置。



(1). 如果图例绘在制图区外，必须提前保留绘制legend的空间。如par（mai=c（2,0.5,0.5,0.5）），图例绘制在下方，所以留2，其余3个方向为0.5。

(2). 图例绘在制图区外，必须设置参数xpd=TRUE，否则命令正确也不会出图，因为默认xpd=F。

(3). 图例位置由x，y决定。legend 默认坐标为左上角的坐标（因为设定xjust=0，yjust=1），因此可以通过xjust，yjust来调节。xjust=1，yjust=0，即为右下角坐标。

barplot中图例位置设置：args.legend = list(x="topleft"),


(4)R里面legend图例位置调整函数 inset
http://blog.sciencenet.cn/blog-267448-1021711.html
Legend函数里面有9个文本的位置字符串，但是有时对位置不太满意，比如离边际太远，可以在legend里面直接用inset=c(x,y)进行调整，第一个参数为横轴，第二参数为纵轴，一般可以使用负值来接近边际。





2.Legend布局
(1). 如果图例数量太多，则设置多列（ncol=），如ncol=4，分为4列。
(2). 如果图例不加边框，则设置bty=“n”，“o”为加边框。
(3). 图标和文字的位置，可以通过x.intersp, y.intersp, adj,text.width等来调控。
x（y）.intersp指图标和文字之间的绝对距离adj指图标和文字的相对距离text.
width指图标和文字整体的宽度。

命令1
设置绘图参数mai=c（下，左，上，右）的边界空间。

命令2
绘制柱状图。

命令3
选取绘图区域左下角和右上角的坐标。

命令4
正常绘图，设置xpd=T。xinch()、yinch()，分别表示沿x轴，y轴移动的距离，按绝对距离计算，或按坐标轴的数量级计算。fill=T，即显示图标（默认为矩形填充色）。fill=F的话可以设置pch，选择图标类型。

命令5
设置adj=0.6，adj越接近于0，图标与文字的相对距离越远。
此参数作用于文字，图标不动。


命令6
设置x.intersp=0.6，越接近于0，图标与文字的绝对距离越近。以一侧为标准，图标文字均移动。

命令7
设置text.width=1.4，表示图标和文字整体的宽度。当文字太长时可以调节此参数。

命令8
text.width与x.intersp结合使用，效果最好。

命令9
设置ncol=2，分为两列。





3. 在绘图函数(如barplot)中直接定义图例
实例: 把图例放到图外边
args.legend=list(x="right", border=NA, #不要图例小方块描边
				 box.col="white", inset=-0.25,bty = "n"),
#



4.图例参数详解
legend(x, y = NULL, legend, fill = NULL, col = par("col"),
border = "black", lty, lwd, pch,
angle = 45, density = NULL, bty = "o", bg = par("bg"),
box.lwd = par("lwd"), box.lty = par("lty"), box.col = par("fg"),
pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd,
xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1,
adj = c(0, 0.5), text.width = NULL, text.col = par("col"),
text.font = NULL, merge = do.lines && has.pch, trace = FALSE,
plot = TRUE, ncol = 1, horiz = FALSE, title = NULL,
inset = 0, xpd, title.col = text.col, title.adj = 0.5,
seg.len = 2)


画图调整legend（图例）位置：args.legend=list(x='topleft',bty='n')，
- x, y用于定位图例，也可用单键词"bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right" and "center"；
- bty 是指图例的盒子类型，只能选择o（带方框）或者n（不带方框）。

legend 字符或表达式向量；
fill 用特定的颜色进行填充；

col 图例中出现的点或线的颜色；
border 当fill = 参数存在的情况下，填充色的边框；设为NA表示不要边框。

lty, lwd 图例中线的类型与宽度；
pch 点的类型；
angle 阴影的角度；
density 阴影线的密度；
bty 图例框是否画出，o为画出，默认为n不画出；
bg bty != "n"时，图例的背景色；
box.lty, box.lwd, box.col bty = "o"时，图例框的类型，box.lty决定是否为虚线，box.lwd决定粗线，box.col决定颜色；
pt.bg 点的背景色；
cex 字符大小；
pt.cex 点的大小；
pt.lwd 点的边缘的线宽；
x.intersp 图例中文字离图片的水平距离；
y.intersp 图例中文字离图片的垂直距离；
adj 图例中字体的相对位置；
text.width 图例字体所占的宽度；
text.col 图例字体的颜色；
text.font 图例字体；
merge logical, if TRUE，合并点与线，但不填充图例框，默认为TRUE；
trace logical; if TRUE显示图例信息；
plot logical. If FALSE不画出图例；
ncol 图例中分类的列数；
horiz logical; if TRUE,水平放置图例；
title 给图例加标题；
inset 当图例用关键词设置位置后，inset = 分数，可以设置其相对位置；
xpd xpd=FALSE，即不允许在作图区域外作图，改为TRUE即可，与par()参数配合使用；
title.col 标题颜色；
title.adj 图例标题的相对位置，0.5为默认，在中间。0最左，1为最右；
seg.len lty 与lwd的线长，长度单位为字符宽度。



5. 实例 

(1) 使用 ifelse() 设置点的类别

plot(mpg ~ wt, data = mtcars, col = "grey",
     pch = ifelse(mtcars$am == 0, 1, 16), cex = 1.2)
legend( mean(par('usr')[1:2])/2, par('usr')[4]*1.2,  xpd=T,
        text.width = 1.2,
       legend = c("automatic", "manual"), pch = c(1,16), lty = c(2,1),
       col = "grey", pt.cex = 1.2, bty = "n", horiz = T)

# 红色圈出来那些点
dat=mtcars[which(mtcars$am==1),]
lines(mpg ~ wt, data = dat, col = "#FF0000", type="p",
      pch = 16, cex = 0.5)
#





ref:
https://blog.csdn.net/xiangyong58/article/details/54579293
http://www.360doc.com/content/17/0831/20/46931810_683661129.shtml









========================================
|-- 低水平绘图函数: arrow() 画箭头
----------------------------------------

1. 普通箭头

(1) 
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4)


(2) x0, y0,x1,y1 支持一次设置多个值，同时画多个箭头，示例代码如下：

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = c(1, 1),  y0 = c(1, 2),  x1 = c(4, 4), y1 = c(4, 5))



2. 更多参数

(1) length：控制箭头两边分叉的长度。该参数一次只能设置一个值，默认值为0.25。

op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 0.1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 0.5")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 1)
par(op)


(2)code : 调整箭头的类型，一共有1,2,3 共3种类型，该参数一次只能设置一个值.
code = 1 代表箭头由终止点指向起始点
code = 2 是默认值，箭头由起始点指向终止点
code = 3 代表在起始点和终止点两端都标上箭头

op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 2")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 2)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 3")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 3)
par(op)


(3) angle: 设置箭头分叉与主干的角度，默认值是45，该参数一次只能设置一个值
op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 15")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 15)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 45")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 45)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 60")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 60)
par(op)


(4) 除了上面的针对arrows 的特殊参数之外，也支持一些通用的参数，col , lty ,lwd 等
... graphical parameters such as xpd and the line characteristics lend, ljoin and lmitre: see par.

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, col = "red", lwd = 2, lty = 3)



ref: https://www.cnblogs.com/xudongliang/p/6756258.html




========================================
|-- 低水平绘图函数: rect() 画矩形
----------------------------------------

1. 基本使用

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5)

(2)xleft, ybottom, xright, ytop 支持一次设置多个值，同时创建多个矩形，用法如下：
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4))




2. 更多参数

(1) border : 设置矩形边框的颜色，默认为"black"， 支持为多个矩形设置不同的值

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4), border = c("red", "blue"))


(2)col : 设置矩形的填充色，默认为NULL, 表示无填充色，， 支持为多个矩形设置不同的值

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4), col = c("pink", "green"))


(3) density 和 angle : 搭配使用，设置用线条填充矩形，
angle 设置线条的角度，默认为45， 
density 设置填充线条的密度，数值越大越密集


par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 1")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 3")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 4")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 3) 


(4)lwd:  设置矩形所有线条的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2, lwd = 3)


(5)lty: 设置矩形所有线条的类型

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2, lwd = 2, lty = 3)




3. 实例 

(1) 画晃眼睛的方格图 
https://www.zhihu.com/question/458049025/answer/1871631313

plot(NULL, xlim=c(0,10), ylim=c(0,10), 
     xaxs ='i', yaxs ='i', 
     xaxt="n", yaxt="n",
     main="", xlab="", ylab=""); 

drawBox=function(x.adj, y){
  for(x0 in seq(0,11,2)){
    x=x0+x.adj
    rect(x,y, x-1,y-1, col="black")
  }
}
# test
#drawBox(0.4,1)
#drawBox(0.2,2)
#drawBox(-0.1,3)

# ajust for x
arr=c(0.4, 0.2, -0.1, 0.1,
      0.4, 0.2, -0.1, 0.1,
      0.4, 0.2, -0.1)

for(y in seq(1,11,1)){
  drawBox(arr[y], y-1)
}


abline(h=seq(1,10), col="#999999", lty=1, lwd=3)










========================================
|-- R语言低级绘图函数-grid() 画网格线 
----------------------------------------
1. grid 函数用来在一张图表上添加网格线，
(1)基本用法：默认在添加刻度线的地方添加网格线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid()
box()

(2) lwd  : 设置网格线的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(lwd = 3)
box()

(3) lty  : 网格线的类型，默认为虚线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(lty= 1)
box()

(4) col  : 网格线的颜色，默认为 lightgray
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(col = "lightblue")
box()

(5) 控制网格的数量，nx和ny
# nx : 设置x轴方向的网格数，默认是按照对应的坐标轴刻度绘制对应的网格线，当nx 设置具体的值时，
会根据数据的范围均匀分配网格，比如说5，代表画出5个单元格；当设置为NA时，不会画网格线

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(nx = 5)
box()

# ny : 设置y轴的网格数，默认ny的值等于nx 的值，当设置为NA时，不会画网格线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(nx = 5, ny = 4)
box()







========================================
|-- R语言低级绘图函数-points()画点，及点的25个类型 
----------------------------------------
1. points 用来在一张图表上添加点，指定好对应的x和y坐标，就可以添加不同形状，颜色的点了；

(1)基本用法：通过x和y设置点的坐标
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5))


(2)cex : 设置点的大小
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5), cex = c(2, 4))


(3) lwd : 设置点的边框的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5), cex = 4, lwd = c(2, 4))

(4) pch ： 设置点的形状，取值范围为1到25，
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5)
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}

(5) col:  设置点的边框的颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5, col="red") #设置颜色
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}

(6) bg ： 设置点的背景色，其实就是填充色，需要注意的是，只有形状为21到25的点是有填充色的
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5, bg="red") #设置背景色
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}










========================================
|-- R语言低级绘图函数: title() 函数用来在一张图表上添加标题
----------------------------------------
1. title函数的用法
　　main、sub、xlab和ylab分别表示主标题、副标题、x轴标题和y轴标题；
　　cex.lab表示坐标轴标题的字号大小；
　　font.lab表示坐标轴标题的字体；
　　col.lab表示坐标轴标题的颜色；
　　其余参数和axis中用法一致。

(1). main 表示主标题，通常位于图像的上方; 
sub 表示副标题，位于图像的下方;
xlab 表示x轴的标签; 
ylab 表示y轴的标签

par(oma = c(1, 1, 1, 1))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "figure", col = "red", lwd = 2)
box(which = "plot", col = "blue", lwd = 2)
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab")



(2). 参数设置
col : 设置标题的颜色
cex : 设置标题的文字大小
font : 设置标题的文字的格式

以上三个参数可以针对不同的标题分别进行设置，需要注意的是xlab和ylab 不能分开设置，只能是同时设置，对应的参数为 col.lab, col.cex, font.cex

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab", col.main = "red", cex.sub = 1.5, col.lab = "blue")


(3) outer : 逻辑值，如果为TRUE, 将标题放到plot area的外边

par(oma = c(5, 5, 3, 3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "figure", col = "red", lwd = 2)
box(which = "plot", col = "blue", lwd = 2)
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab", outer=TRUE)

(4) title 中也允许表达式

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
title(main = expression(sqrt(x)), sub = expression(x^2), xlab = "xlab", ylab = "ylab")

更多关于表达式的书写，可以参考plotmath 函数的帮助文档







2. 综合实例 

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#无标题
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4)
axis(2,seq(0, 16, 4), seq(0, 16, 4))
#使用title设置标题
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y')
#使用line调整位置
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y', line = 2)
#调整颜色字体字号
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y', col.lab = 2, font.lab = 4, cex.lab = 2)








========================================
|-- R语言低级绘图函数: polygon() 函数绘制多边形，为指定区域填充背景色
----------------------------------------
1. 简介 
以数据(x,y)为坐标，依次连接所有的点，绘出一个多边形

# polygon draws the polygons whose vertices are given in x and y.
polygon(x, y = NULL, density = NULL, angle = 45,
        border = NULL, col = NA, lty = par("lty"),
        ..., fillOddEven = FALSE)

x, y: vectors containing the coordinates of the vertices of the polygon.
其中density为填充的阴影线的密度，angle为阴影线的斜率(角度)。
值得注意的是，当你需要纯色填充时，density和angle可以忽略不写。
然后border为边框的颜色。同时border也可以是逻辑。即FALSE相当于NULL，TRUE相当于为前景色。




2. 实例
(1)给背景填充颜色
xx=c(1:100, 100:1)
yy=c(rep(0,100), rep(1,100) )
plot(xx, yy, type = "n", bty="n",
     #xaxs ='i', 
     yaxs ='i', 
     xlim=c(0,150),
     xlab = "mpg", ylab = "wt")

polygon(xx, yy, col = "#66C2A566", border = NA) #填充bg1

polygon( c(100:150, 150:100), c(rep(0, 51), rep(0.8,51)), #填充bg2
         col = "#F81082AA", border = NA)
# 
points(mtcars$mpg*4.4, mtcars$wt/6, col="black", pch=21, bg="red" )


(2). 填充更复杂的区域
set.seed(3)
# Distance Between Brownian Motions 布朗运动之间的距离
n <- 100
xx <- c(0:n, n:0)   #生成202个元素的向量，其中前面101与后面101数字对称
yy <- c(c(0, cumsum(rnorm(n))), rev(c(0, cumsum(stats::rnorm(n)))))
plot(xx, yy, type = "n", xlab = "Time", ylab = "Distance")
polygon(xx, yy, col = "gray", border = "red")



(3) 综合实例：上下抖动的点连起来，填充其和坐标轴围成的面积
set.seed(123)
x <- rnorm(30) # 产生 30 个正态随机数

plot(x, xlab = "", type = "l") # plot函数绘制线条

xy <- par()$usr # 获取当前图形区域坐标范围
rect(xy[1], xy[3], xy[2], 0, col = "gray") #将0以下区域覆盖为灰色

polygon(c(1, 1:30, 31), c(0, x, 0), col = "red") # 绘制多边形

#lines(x) # 重画一遍 x 的线条
abline(h = 0, col = "blue",lwd = 4) # 添加水平线











========================================
text(), mtext() 添加文字：R中的字体-font
----------------------------------------
1. text() 添加文字

text(x,y, labels=, adj=, pos=, ...)
参数解释:
pos=1, 数字 1,2,3,4 分别对应着(x,y)点的 bottom, left, top, right.
offset=1 从(x,y)点偏移距离

cex=2 字号倍数
col=c('red', 'blue') 颜色 
adj=0, 0左下对齐，1右上对齐，0.5居中对齐(用于 text, mtext, title)
xpd=T 可以显示到plot区外的figure区
srt=30 顺时针旋转30度，结合adj使用效果更佳


(1). 画个包含坐标的空白图形。
plot(0:4,type="n",xlab = NA,ylab=NA,axes=F)
# 0:4 表示x轴和y轴的坐标刻度; type="n",表示画的点不显示。
# xlab= ,ylab=  表示x轴和y轴的 标签，NA 表示不显示内容；
# axes=F 表示坐标轴的线不显示。因此，该输出结果可以认为是隐藏了所有内容的图性。

(2). 设置字体 
font（字体）参数的取值是一个整数，一般分别用1、2、3、4来表示正常体、粗体、斜体和粗斜体1。

text(2,4,label="font=1 正常体",font=1)
text(2,3,label="font=2 粗体",font=2)
text(2,2,label="font=3 斜体",font=3)
text(2,1,label="font=4 粗斜体",font=4)

# 如果说label 过长的话会横向铺开，由此可见虽然设置了（2,y）的坐标，但横坐标并不是label的起点。

(3). 大小
cex（缩放倍数）参数的取值是一个实数，默认为1，表示不缩放。取值小于1时，表示缩小。取值大于1时，表示放大。

plot(0:4,type="n",xlab = NA,ylab=NA,axes=F) #画空图形
text(2,4,label="cex=1 font=1 正常体",font=1,cex=1)
text(2,3,label="cex=0.5 粗体",font=2,cex=0.5)
text(2,2,label="cex=1.5 font=3 斜体",font=3,cex=1.5)
text(2,1,label="cex=2 font=4 粗斜体",font=4,cex=2)


(4).字体类型

1)windows下使用windowsFont()函数来创建映射，
windowsFonts(
  A=windowsFont("Arial Black"),
  B=windowsFont("Bookman Old Style"),
	C=windowsFont("Comic Sans MS")
)
之后，即可使用A、B、C作为family的取值。
比如使用 par(family="A") 将指定Arial Black作为绘图字体
par(family="A")
plot(1:10,main="plot") 坐标轴、标题的字体都是粗体了。

在Mac下，请改用 quartzFonts()函数。

输出pdf、PostScript格式，则修改字体相对简单。

pdf则直接用如下函数找出系统可用字体，
names(pdfFonts())
# [1] "serif"                "sans"                 "mono"                
# [4] "AvantGarde"           "Bookman"              "Courier"  
#...
然后使用pdf(file="myplot.pdf", family="fontName") 来生成图形。

PostScript格式输出，对应函数为 names(postscriptFonts())和postscript(file="myplot.ps", family="fontname")





2. mtext() 在margin 区添加 text 

mtext(text, side=3, line=0 )
参数解释:
side=1,2,3,4 分别对应着 bottom,left,top,right 4个边界区域。
line=1表示往外偏移的行数，越大越靠外。
outer=T 在外区 outer margin 画(figure区外)；需要设置oma=c()才能看到效果
at=0.2 在 figure 宽高算，相对坐标轴的位置。
其他参数和text()类似。



========================================
|-- plotmath() 函数: R中可视化希腊字母(delta)、上下标、数学公式(根号、分数)等特殊符号
----------------------------------------
1. 数学标注 help(plotmath)
使用类似于TeX中的写法为图形添加数学符号和公示。细节和示例参考help(plotmath); demo(plotmath)。expression()中可以使用的数学表达式，比Latex少，但是比matlab多。

也可以用 plotmath() 函数为图形主体或边界上的标题、坐标轴名称或文本标注添加数学符号。

具体使用是利用text()语句中放入expression表达的数学公式。

(1)#Mathematical Annotation in R
plot(1,2,type="b",ylim=c(1.2,2.1),
     pch=21,col="blue",bg="red",cex=2) # 在(1,2)处画一个点
text(1,2,expression(hat(x)), pos=4) # 在(1,2)右加入\hat{x}
#更复杂的公式
formula = expression(italic(Prob) == bgroup("(",atop(n, x),")")%*%p[1]^x%*%(1-p[1])^(n-x))
text(1,1.5,label=formula)


(2)#right: https://stats.idre.ucla.edu/r/codefragments/greek_letters/
set.seed(1)  # for reproducible, pseudo-random numbers
h = rnorm(mean = 5, sd = 1, n = 1000)
hist(h, xlab = expression(h),
     main = expression(paste("希腊字母, ", mu, "=5, ", sigma,"=1")))
#






2. 在使用R语言作图时，有时需要在图上标注诸如求和、积分、上下标等数学符号，该操作可以通过expression函数完成。
　　expression(...)
括号中输入数学表达式，配合plot、text、title、axis等函数使用，可以将数学公式绘制在图表上。

(1) 显示根号
x <- seq(0, 4, 0.01)
y <- sqrt(x)
tt <- expression(y == sqrt(x))
plot(x, y, type = 'l', main = tt, las = 1)

(2)expression函数支持的表达式语法与Latex类似，常用的表达式语句可以查看plotmath的帮助，即?plotmath。下面简单总结一下：
基础运算符
	sqrt(x) 根号x 
	sqrt(x,y) 根号x开y次方
	frac(x,y) x/y 
	
	x %+-% y	x plus or minus y
大型运算符
	sum(f(x), i=a,b) 对f(x)求和，从i=a到b
	prod(f(x), i=a,b) 对f(x)求乘积，从i=a到b
上下标
	a^b 表示b是上标
	a[b] b是下标
箭头符号
	x%->%y 表示左箭头
	x%<-%y 右箭头
	x%up%y 上箭头
	x%down%y 下箭头
集合运算
导数符号
特殊字体
	bold(x) 粗体x
	italic(x) 斜体x
	bolditalic(x) 粗斜体x
	underline(x) 下划线x
希腊字母:　希腊字母既可以使用其英文名表达，也可以使用symbol()表达。
	alpha or symbol(a)
	Omega
	Gamma 
	Theta
	

(3) 常用表示方法
plot(c(1,2), main=expression(sum(f(x), i=a,b))) 

plot(1:10, 1:10)
text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))






3. 实例：图里如何组合paste()和expression()函数完成特殊字符的文本
注: 不支持paste0(),支持paste(),可以用paste(...,sep="")代替前者。

(1) 换行符号：除了 "\n"之外，还可以使用函数 expression(atop(x,y))
plot(x=rnorm(10), y=rexp(10), main =
       expression(atop(paste('N(',mu,',  ',sigma,')'),
            paste('Exp(',lambda,')'))))
#


(2) 上标
labNames <- c('xLab','yLab')
xlab <- bquote(.(labNames[1]) ~ x^2)
ylab <- bquote(.(labNames[2]) ~ y^2)
plot(c(1:10), xlab = xlab, ylab = ylab)



注意：bquote()内部可以使用变量！！！使用方法: .(paras), .(paraArr[1])
也就是说p值可以由科学记数法，改为正常乘号x及上标的形式了

## 实例1: 使用非科学计数法 在图中标注p值
annotate_Pvalue=function(p0, ...){
  #p0=1.2e-52; p0
  p0=formatC(p0, format="e", digits=2);#p0 #"1.2e-52"
  # split by e
  p0=strsplit(p0, "e")[[1]]; #p0 #[1] "1.2" "-52"
  # plot
  label = bquote(italic(P)~"=" ~ .(p0[1]) ~ "\u00d7" ~ 10^.(p0[2]) )
  text(labels = label, ...)
}

plot(1:3)
annotate_Pvalue(1.5e-26, x=2, y=1.8)


>> 更新版本请看 NGS/最佳实践: p值怎么画？




## 实例2: 标注线性拟合曲线的R^2
# 散点图
plot(mpg ~ disp, data=mtcars)
# 拟合曲线
fit=lm(mpg ~ disp, data=mtcars)
abline(fit,col="red")
# 标注R^2
text(x=300,y=30, col='red',
     label=bquote(R^2==.( round(summary( fit )$r.squared, 3))) )







(3) 上下标 
## 方法1
labNames <- c('xLab','yLabl')
plot(c(1:10),xlab=expression(paste(labName[1], x^2)),ylab=expression(paste(labName[2], y^2)))

## 方法2
R语言画图中输出上或者下标的方法
plot(1,ylab=expression(italic("toto")["subscript"]),xlab=expression(italic("toto")^"superscript"))


#上标
labNames <- c('xLab','yLab')
plot(c(1:10),
     xlab=substitute(paste(nn, x^2), list(nn=labNames[1])),
     ylab=substitute(paste(nn, y^2), list(nn=labNames[2])))

par(mar=c(5, 4.3, 4, 2) + 0.1)
# 上标
plot(c(1:10), xlab = expression(xLab ~ x^2 ~ m^-2),
     ylab = expression(yLab ~ y^2 ~ m^-2),
     main="Plot 1")
# *更紧凑
plot(c(1:10), xlab = expression(xLab * x^2 * m^-2),
     ylab = expression(yLab * y^2 * m^-2),
     main="Plot 2")
# ~更宽松
plot(c(1:10), xlab = expression(xLab ~ x^2 * m^-2),
     ylab = expression(yLab ~ y^2 * m^-2),
     main="Plot 3")
# 下标字母[], 希腊字母
plot(c(1:10), xlab = expression('Your x label' ~ mu[3] * phi),
     ylab = expression("Temperature (" * degree * C *")"))
#




ref:
https://blog.csdn.net/qq_18055167/article/details/92755403
R语言进阶：表达式、数学公式与特殊符号 https://blog.csdn.net/u014801157/article/details/24372443









========================================
|-- 打印\u开头的16进制 Unicode 字符：\u2248 对应 ≈ 
----------------------------------------

1. 打印方法

(1) 基本版
# 16进制Unicode编码 与字符
par(mar=c(2,2,2,1))
plot(1:10, type="n", ann=F, axes=T)
text(1,1, "\u2265 2265", col='red', pos=4)
text(1,2, "\u2264 2264", col='red', pos=4)

text(1,3, "\u2248 2248", col='red', pos=4)
text(1,6, "\u00B1 00B1", col='red', pos=4) #PLUS-MINUS SIGN


(2) 循环版

# 16进制Unicode编码 与字符
par(mar=c(2,2,2,1))
plot(1:10, type="n", ann=F, axes=F, xlim=c(0,3)); box()
mtext(side=1, text='text(1,10, "\\u00B1 00B1", col="red", pos=4)', col='red')
text(1,11, "\u2265 2265", col='red', pos=4, xpd=T)
#
codes=c('2264','2265','2248','00F7','00B1', "0024", "0023", "0022")
for(i in 1:length(codes)){
  code=codes[i]
  #print(code)
  library(stringi)
  cStr=stri_unescape_unicode(paste0("\\u",code)) #"±"
  text(1,10-i, paste0(cStr," ", code ), pos=4)
}






2. 资源
(1) 符号转换

Unicode与中文互转 16进制Unicode编码转换、还原
http://www.msxindl.com/tools/unicode16.asp


(2) 更多符号
https://blog.csdn.net/jiuzaizuotian2014/article/details/107048538/
https://blog.csdn.net/u011094862/article/details/49797015

具体符号	Unicode
±		\u00b1
×		\u00d7
÷		\u00f7
≤		\u2264
≥		\u2265
≈		\u2248
≠		\u2260




←↑→↓↖↗↘↙≈≠≤≥①②③④⑤⑥⑦⑧⑨⑩
⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇
⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛
█■□▲△▼▽◆◇○◎●◢◣◤◥★☆☉♀♂、。
 〃々〈〉《》「」『』【】〒〓〖〗
㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩㈱㊣㎡︳︵︶︷︸︹︺︻︼︽︾︿﹀﹁﹂﹃﹄﹛﹜﹝﹞

﹩＄＇＊｀＇～￣￥ 　 ！ ＇ ， ． ／ ： ； ？
＾ ＿ ｀ ｜ ￣ 、 。 · ‥ … ¨ 〃­ ­- ­― ∥ ＼
∼ ´ ～ ˇ ˘ ˝ ˚ ˙ ¸ ˛ ¡ ¿ ː ＂ （ ） ［ ］ ｛ ｝
‘ ’ “ ” 〔 〕 〈 〉 《 》 「 」 『 』­ 【 】
＋ － ＜ ＝ ＞ ± × ÷ ≠ ≤ ≥ ∞ ∴ ♂ ♀ ∠ ⊥
 ⌒ ∂ ∇ ≡­ ­≒ ­≪ ≫ √ ∽ ∝ ∵ ∫ ∬ ∈ ∋ ⊆ ⊇ ⊂ ⊃
∪ ∩ ∧ ∨ ￢ ⇒ ⇔ ∀ ∃ ∮ ∑ ∏ ＄ ％ ￦ Ｆ ′ ″
℃ Å ￠ ￡ ￥ ¤ ℉ ‰ ㎕ ㎖ ㎗ ℓ ㎘ ㏄





(3) 更多转换

1)# unicode to string
library(stringi)
stri_unescape_unicode(paste0("\\u","00B1")) #"±"

# js版转换 unicode to utf8
> unescape(`\u00b1`) //"±"




2)# unicode in string
x1 <- 'pretty\\u003D\\u003Ebig'
x1
x2 <- parse(text = paste0("'", x1, "'"))
x2
as.character(x2) #"pretty=>big"
x2[[1]] #"pretty=>big"



3)string to unicode









https://blog.csdn.net/u011094862/article/details/49797015




========================================
** 3. 其他辅助设置: par(), 边距, 坐标轴, 
----------------------------------------
除了par()函数，高级绘图函数(plot,hist,boxplot等)也允许自行设定坐标轴和文本标注选项。
标题main, 副标题sub, 坐标轴标签xlab-ylab, 坐标轴范围xlim-ylim。


par(mfrow = c(2, 1)) #布局为2行1列


par()$usr # 获取当前图形区域坐标范围





========================================
|-- R语言绘图布局: oma 参数设置outer margin, mar 参数设置margin
----------------------------------------
1. 在R语言中，par 函数可以设置图形边距，
	其中oma 参数设置outer margin, 
	mar 参数设置margin。

这些边距有什么不同呢，通过box函数可以直观的看到
box 默认在当前图形绘制边框，第一个参数
	which = "plot", 所以在当前图形上绘制边框
	which 的值除了plot 之外，还可以选择 figure, inner, outer

接下来分别用不同的值测试一下，为了区分，为不同的边框设置不同的颜色和类型,代码如下：






1. 外边框边距 oma = c(1, 1, 1, 1) # b,l,t,r

par(oma = c(1, 1, 1, 1))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "outer", col = "purple", lwd = 3, lty=2) #能看到的边界，最外圈。
box(which = "plot", col = "blue", lwd = 2) #能画点的区域，中间坐标轴方框内(默认)
box(which = "figure", col = "red", lwd = 2) #整个绘图区，包括坐标轴

box(which = "inner", col = "green", lwd = 5, lty=3) #貌似和plot是重叠的

title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab")




2. 边界: 图形尺寸与边界尺寸mar
参数： 
pin 图形宽高(英寸) (width, height), in inches.; 
mai边界(英寸),c(bottom, left, top, right); 
mar边界(英分),c(bottom, left, top, right), 默认是c(5, 4, 4, 2) + 0.1.;


mar和mai的区别是什么？单位不同。







https://www.cnblogs.com/xudongliang/p/6741843.html





========================================
|-- par() 的设置项目: 高级绘图重合new=T, 隐藏坐标轴标签及标题 ann
----------------------------------------

1.调用高级绘图时，想重合，可以使用par(new = TRUE)。
为了重叠的更好，需要设置坐标轴范围。

plot(1:5, c(2,3,2,3,2), col = "red", type = "l",  
     xlim = c(1,5), ylim = c(1,5), ylab = "", xlab = "")
par(new = TRUE)
plot(1:5, c(3,4,3,4,3), col = "blue", type = "l", lwd=3, 
     xlim = c(1,5), ylim = c(1,5), ylab = "y", xlab = "x")
#



2.当设置为ann=FALSE时，图片的标题，x轴和y轴的标签、图标题main 就不会显示

par(ann = FALSE)
plot(1:5, 1:5, main = "title", xlab = "x", ylab = "y")

或者写到函数内
plot(1:5, 1:5, main = "title", xlab = "x", ylab = "y", ann=F)







========================================
|-- 低级绘图函数: axis()坐标轴设置
----------------------------------------
R语言作图：坐标轴设置
https://blog.csdn.net/weixin_40628687/article/details/79254791
https://www.cnblogs.com/xudongliang/p/6762618.html
在R语言底层作图中，对坐标轴的调整主要通过调整plot函数、axis函数和title函数的一系列参数完成。


一、plot函数的准备

　　在个性化设置坐标轴之前中，通常需调整plot函数中的ann、bty、xaxt、yaxt、xaxs和yaxs参数：
　　ann取FALSE时将不会画出标题（包括主、副标题及坐标轴标题）；
　　bty用来设置边框形式，默认值为"o"，表示四面边框都画出，其余可选值包括"l"（左下）、"7"（上右）、"c"（上下左）、"u"（左下右）、"]" （上下右）和"n"（无，即不画边框），在很多个性化绘图中，bty设为"n"，后期的边框线再使用其他函数（如axis）自行添加；

　　xaxs和yaxs 用来设置x轴和y轴的范围，默认值取“r”，表示坐标轴比给定作图范围（参数xlim和ylim给出的范围）稍微大一点儿，取”i”时表示坐标轴范围与给定作图范围完全相同，另外还可取”s”、”e”、”d”；

　　xaxt和yaxt 取”n”时，坐标轴、刻度线以及刻度值将不会画出。
#
x <- seq(-4, 4, 0.01)
y <- x^2
par(mfrow = c(2, 2), mar = c(4, 4, 1, 1))
plot(x, y)   # 未作处理
plot(x, y,  xaxs = "i", yaxs ="i")   # 绘图边框未留白
plot(x, y, bty = 'l')   # 只保留左和下两条边框
plot(x, y, ann = F, bty = "n", xaxt = "n", yaxt ="n")   # 边框、坐标轴都去掉






二、axis函数的用法

以x轴为例，一条轴线包含3个元素，
	水平的一条横线，叫做axis line; 
	刻度线，叫做tick line;
	对应的标签 labels


1、基本操作
　　side表示要操作的坐标轴，取值1、2、3、4分别代表下、左、上、右；
　　at表示刻度线及刻度值所在位置；
　　labels表示刻度值；
　　las表示坐标刻度值文字方向，las=0表示文字方向与坐标轴平行，1表示始终为水平方向，2表示与坐标轴垂直，3表示终为垂直方向。
	tick : 逻辑值，是否显示轴线，包括刻度线和对应的轴线， FALSE 表示不显示

(1) 综合实例
x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(1, 2), mar = c(4, 4, 1, 1))
#未设置文字方向
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4)
axis(2,seq(0, 16, 4), seq(0, 16, 4))
#文字方向水平
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)


(2) 使用at手工指定x刻度位置
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, at = c(0, 2, 4, 6))

(3) lables : 指定在刻度上需要标记的内容，默认就是刻度对应的值
# 指定x轴刻度为 0A, 2A 等
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, at = c(0, 2, 4, 6), labels = paste(c(0, 2, 4, 6), "A", sep = ""))


(4) tick=F不显示刻度线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
axis(side = 1, tick = F)






2、字体字号
　　cex.axis表示坐标轴刻度值的字号大小，
　　font.axis表示坐标轴刻度值的字体，font=1表示正体，2表示黑体，3表示斜体，4表示黑斜体。

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#未设置字体字号
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4)
#cex.axis = 2
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, cex.axis = 2)
#font.axis = 2
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, font.axis = 2)
#font.axis = 3
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, font.axis = 3)





3、颜色
　　col表示图的颜色，用在axis函数中表示坐标轴线和坐标刻度线的颜色；
　　col.axis 表示坐标轴刻度值的颜色；
　　col.ticks表示坐标轴刻度线的颜色。

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#未设置颜色
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4)
#col = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col = 2)
#col.axis = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col.axis = 2)
#col.ticks = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col.ticks = 2)


(1) col  : 设置axis line 和 tick.line 的线条颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue")


(2) col.ticks  : 设置tick line的颜色 
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue", col.ticks = "red")

(3) col.axis 设置刻度数值的颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue", col.axis="red")





4、位置
　　line表示坐标轴线位置与图像边框的距离，取负数时会画在图像边框以内；
　　mgp默认值为c(3, 1, 0)，三个数字分别代表坐标轴标题、刻度值和轴线与绘图边框的距离；
　　tcl默认值为-0.5，数值表示刻度线长度，负值表示刻度线朝外，正值朝里；
　　pos 表示轴线所在的位置；
　　line.outer取TRUE时，坐标轴将画在画布边缘处；
　　hadj指将刻度值沿平行坐标轴方向调整的距离；
　　padj指将刻度值沿垂直坐标轴方向调整的距离。

x <- seq(-4, 4, 0.01)
y <- x^2
par(mfrow= c(2, 2), mar = c(4, 4, 1, 1))
# 未设置刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4)
# 使用line调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, line = 2)
# 使用mgp调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, mgp = c(3, 2, 0)) 
# 使用padj调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, padj = 1)

(1) line : 轴线的位置
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 3)
axis(side = 1, line = 0, col='red')

(2) pos : 对轴线的位置进行调整，当pos 设置了对应的值之后会覆盖line 参数的值
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, pos = 1)





5、其他

tick取FALSE时，坐标轴线和刻度线不画出；
lty表示线型，用在axis函数中表示坐标轴线型；
lwd表示线的粗细，用在axis函数中表示坐标轴线粗细；
lwd.ticks表示刻度线粗细。


(1) lwd : 设置 axis  line 和 tick line  的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lwd = 2)

(2) lwd.tick : 设置tick line的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lwd = 1, lwd.tick = 5)

(3) lty : 设置axis line 和tick line的线条类型
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lty = 3)












========================================
|-- par函数mgp=c(2,0.8,0) 参数-控制坐标轴的位置
----------------------------------------
1. mgp 参数的值为长度为3的一个向量，默认值为 c(3, 1, 0); 3个数值控制的元素不同

(1) 第一个数值：3， 控制xlab 和  ylab的与坐标轴的距离

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(1, 1, 0))
box(which = "figure")

plot(1:10,main = "main", sub = "sub", mgp = c(2, 1, 0))
box(which = "figure")

plot(1:10, main = "main", sub = "sub",mgp = c(3, 1, 0))
box(which = "figure")

注意观察: xlab=index 与x轴的距离。
从左到右我分别设置了1到3; 从图中也可以看出来，影响的元素的包括xlab, ylab, sub



(2) 第二个数值 1， 影响的是坐标轴刻度值和的轴的距离。

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(3,1, 0))
box(which = "figure")
plot(1:10,main = "main", sub = "sub", mgp = c(3, 2, 0))
box(which = "figure")
plot(1:10, main = "main", sub = "sub",mgp = c(3, 3, 0))
box(which = "figure")

注意观察：x坐标刻度值2,4,6,8,10 与x轴的距离。



(3) 第三个数值 0：

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(3,1, 0))
box(which = "figure")
plot(1:10,main = "main", sub = "sub", mgp = c(3, 1, 1))
box(which = "figure")
plot(1:10, main = "main", sub = "sub",mgp = c(3, 1, 2))
box(which = "figure")

可以看到，影响的是坐标轴轴线位置。






2. 比较理想的设置

// todo






ref:
https://www.cnblogs.com/xudongliang/p/7993109.html








========================================
** 4. R中的色彩: colors, RColorBrewr, colortools
----------------------------------------
在R中，可以通过颜色下标、颜色名称、十六进制的颜色值、RGB值或HSV值来指定颜色。举例来说，col=1、col="white"、col="#FFFFFF"、col=rgb(1,1,1)和col=hsv(0,0,1)都是表示白色的等价方式。
函数rgb()可基于红—绿—蓝三色值生成颜色，而hsv()则基于色相—饱和度—亮度值来生成颜色。


1.R颜色列表
https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf

(1)R中有多少种颜色？怎么看？
> colors() #查看R内置的657个颜色名字
[1] "white"                "aliceblue"            "antiquewhite"        
[4] "antiquewhite1"        "antiquewhite2"        "antiquewhite3" 

但是初级用户很难从如此长的列表中找到适合场景的颜色。这时候就需要借鉴别人的配色方案，并通过取色工具获取颜色。



(2)R中表示颜色的3种方式
1）颜色名字，即上面所显示的那么多种颜色；

2) 颜色编码。
rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1)
每种颜色是RGB形式的，最终转变为6位16进制的字符串表示，前面加“#”号！
> plot(10:1,type='s',col=rgb(0,1,0,0.5)) #green颜色的，每个颜色默认0-1; 
可以在rgb()中指定maxColorValue=255参数;
> rgb(0,0,255,alpha=255, maxColorValue=255) #[1] "#0000FFFF" 后两位是alpha值，表示不透明度

如红色对应的RGB值为"255 0 0",用16进制表示就是"FF0000",在R中可以用"#FF0000"表示红色。

> plot(10:1,type='s',col='#0096ff')

rgb转为16进制
> myHex<-rgb(red=126,green=0,blue=211,max = 255);myHex
#[1] "#7EFFD3"
> text(2,4,labels="文字",col= myHex)



3) 调色板中的索引。R中用palette()表示调色板，默认的是颜色是下面的几种：
> palette()
[1] "black"   "red"     "green3"  "blue"    "cyan"    "magenta" "yellow" "gray" 

在默认情况下，col=2表示红色。这个颜色会重复利用，如指定col=10同样是红色。
> plot(10:1,type='s',col=2)

可以改变调色板中的颜色，从而改变索引所代表的颜色。
i) 调色板函数palette()是一个非常灵活的函数，可以根据自己的要求改变调色板，如想把调色板变为下面5种颜色:red,green,blue,yellow,cyan.可以这么做：
color <- c("red","green","blue","yellow","cyan")
palette(color)
则palette()会显示下面的颜色：
[1] "red"    "green"  "blue"   "yellow" "cyan" 
这种情况下col=2表示绿色。

可以采用函数来产生颜色模式，如上面提到的rainbow()函数，rgb()函数。rgb(）函数可以产生很多种颜色，如
rgb(1,0,1:100,max=255)会产生一个长度为100的颜色向量。


ii) 如改变为另外一种颜色模式：palette(rainbow(10)),则palette()为：
[1] "red"     "#FF9900" "#CCFF00" "#33FF00" "#00FF66" "cyan"    "#0066FF"
[8] "#3300FF" "#CC00FF" "#FF0099"
在这种情况下，col=1表示红色.








2. 自带配色方案：用rainbow()，heat.colors()，terrain.colors()，topo.colors()，cm.colors()等函数
直接选取颜色，新手很难做到美观。R本身也提供特定颜色主题的配色方案。这些配色方案用一系列渐变的颜色表现特定的主题。
https://book.2cto.com/201408/45551.html

(1)rainbow()即彩虹的颜色，是由“赤、橙、黄、绿、青、蓝、紫”一系列颜色组成的。
该函数的用法如下：
rainbow(n,s=1,v=1,start=0,end=max(1,n-1)/n,gamma=1)

n 设定产生颜色的数目
start和end 设定彩虹颜色的一个子集，生成的颜色将从这个子集中选取，这个子集选取的大致分界线为：
赤色（red）为start=0，end=1/6
黄色（yellow）为start=1/6，end=2/6
绿色（green）为start=2/6，end=3/6
青色（cyan）为start=3/6，end=4/6
蓝色（blue）为start=4/6，end=5/6
紫色（magenta）为start=5/6，end=1

例1: 彩色的圆圈
n=20; plot(1:n, pch=CIRCLE<-16, cex=1:n, col=rainbow(n))

例2: 该例中会产生由赤、橙、黄、绿、青、蓝、紫7色依次合成6组颜色，每组包含6个渐变色。
barplot(rep(1,41),
        col=c(rainbow(n=6,start=0,end=1/6),
              "white",
              rainbow(n=6,start=1/6,end=2/6),
              "white",
              rainbow(n=6,start=2/6,end=3/6),
              "white",
              rainbow(n=6,start=3/6,end=4/6),
              "white",
              rainbow(n=6,start=4/6,end=5/6),
              "white",
              rainbow(n=6,start=5/6,end=1)))
x.text<-c("赤色","黄色","绿色","青色","蓝色","紫色")
axis(side=1,at=seq(from=3,length.out=6,by=8.5),labels =x.text,cex=0.75)


(2)其他主题配色函数
#heat.colors()从红色渐变到黄色，再变到白色
barplot(rep(1,6), col= heat.colors(6) )  

#terrain.colors() 从绿色渐变到黄色，再到棕色，最后到白色  
barplot(rep(1,6),col=terrain.colors(6))

#topo.colors() 从蓝色渐变到青色，再到黄色，最后到棕色  
barplot(rep(1,6),col=topo.colors(6))

#cm.colors() 从青色渐变到白色，再到粉红色
barplot(rep(1,6),col=cm.colors(6))








3. RColorBrewr颜色扩展包 提供了3套配色方案。
#画出来这些颜色
library(RColorBrewer)
display.brewer.all()
（1）连续型 sequential， 颜色渐变。
（2）极端型 Diverging，生成深色强调两端、浅色表示中部的颜色，可用来标注数据中的离群点。
（3）离散型 Qualitative，生成彼此差异明显的颜色，通常用来标记分类数据。


（1）查看连续型的种类。
display.brewer.all(type="seq")# 有9种颜色
#Set1 中只有9个颜色， Set3中有12个颜色，Paired 中有12个颜色
用法：barplot(rep(1,6),col=brewer.pal(9,"Blues")) # 数字9，表示使用色条中颜色的个数，引号内表示色条对应的名称。
可以使用brewer.pal（9, "<某组渐变颜色的名称>"）来获取该组渐变色的全部9种颜色。


（2）极端型。
display.brewer.all(type="div")# 有11种颜色。
用法： barplot(rep(1,6),col=brewer.pal(11,"RdGy")[2:7])# 第二到第七个颜色。



（3）离散型。
display.brewer.all(type="qual")# 颜色种类不确定。
用法： barplot(rep(1,6),col=brewer.pal(8,"Dark2")[1:5]) #参数和上面的相类似。












4.自定义调色板：直接自定义颜色、渐变色
https://blog.csdn.net/u014801157/article/details/24372411

如果觉得R预设调色板不合用，可以用 colorRampPalette 函数自定义调色板。使用之前得熟悉几个R预定义的颜色名称，这些名称可以通过colors函数获得：
> cl <- colors()
> head(cl,10)
> length(cl) #当前版本有657个预置颜色名称

(1)可以用这些颜色名称通过colorRampPalette函数产生自己的颜色系列，也就是渐变色。colorRampPalette的参数如下：

colorRamp(colors, bias = 1, space = c("rgb", "Lab"), interpolate = c("linear", "spline"))
colorRampPalette(colors, ...)


我们用它产生几个颜色系列：

# 红到白渐变
n=10
ramp <- colorRamp(c("red", "white"))  
barplot(rep(1,n), col=rgb( ramp(seq(0, 1, length = n)), max = 255) )


rgb.palette <- colorRampPalette(c(rgb(35,179,225,max=255),rgb(35,24,21,max=255),rgb(247,236,0,max=255)),space = "rgb") #黄黑蓝
rgb.palette(10)
barplot(rep(1,10), col=rgb.palette(10))

rgb.palette <- colorRampPalette(c(rgb(230,247,255,max=255),rgb(35,179,225,max=255)),space = "rgb") #蓝色渐变
barplot(rep(1,10), col=rgb.palette(10))



par(mfrow=c(3,1));par(mar=c(0.1,0.1,0.5,0.1));par(xaxs="i", yaxs="i")
n <- 1000

mycolors <- colorRampPalette(c("blue", "orangeRed"))(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()

mycolors <- colorRampPalette(c("darkgreen", "yellow", "orangered"))(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()

mycolors <- colorRampPalette(c("blue", "white", "darkgreen", "yellow", "orangered"), bias=1.2)(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()




(2)grey() or gray()函数可以产生不同层次的灰度颜色
> args(grey) 
function (level) 
其中：level指定灰度，为0～1间的数，0为黑，1为白。例如： 

例1:
hist(x,breaks=seq(-250,250,5),col=grey(seq(0,1,0.01))) 

例2: 更多细节设置
n=10
mycolors <- gray(0:n/n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()




(3)hsv函数通过设置色调、饱和度和亮度获得颜色，三个值都是0-1的相对量：
> args(hsv)  
function (h = 1, s = 1, v = 1, gamma = 1, alpha)  
色调（H），饱和度（S），亮度（V）。 

例1: 条形图，给出不同颜色
x=runif(10000,-250,250)  
hist(x,breaks=seq(-250,250,5),col=hsv(seq(0,1,0.01))) 
#用seq序列，默认饱和度和亮度是1

例2: 所有颜色平铺
par(mfcol=c(11,121)); par(mar=c(0,0,0,0));par(xaxs="i", yaxs="i")
x <- seq(0,10)/10
ndx <- expand.grid(x, x, x)
mycolor <- hsv(ndx[,3],ndx[,2],ndx[,1])
for(i in 1:nrow(ndx)){
	barplot(1,col=mycolor[i],border=mycolor[i],axes=FALSE)
}



(4) hcl() 函数 

> args(hcl)  
function (h = 0, c = 35, l = 85, alpha, fixup = TRUE) 
其中h指定颜色，为0～360间的整数，0为红色，120为绿色，240为蓝色；c指定浓度；l指定亮度；alpha指定透明度。 
 
例子：
x=runif(10000,-250,250)  
hist(x,breaks=seq(-250,250,5),col=hcl(1:100)) 


(5) rgb()函数 
该函数按三元色，红，绿，蓝原理指定颜色，rgb(r=1,g=0,b=0)为红色，
rgb(r=0,g=1,b=0)为绿色，rgb(r=0,g=0,b=1)为蓝色。 

> args(rgb) 
function (red, green, blue, alpha, names = NULL, maxColorValue = 1) 
# maxColorValue(max)设置为255时，rgb可以从1~255变化。与配色表查询值一致。

hist(x,breaks=seq(-250,250,5),col=rgb(r=1,g=0,b=0)) 













5. 配色 R包
(1) scales 包
scales软件包提供了很多颜色设置的函数，其中的alpha对颜色的透明度设置很方便，可以考虑使用。
有人可能喜欢用 RColorBrewer 软件包里面的不连续调色板，萝卜白菜吧。

# 查看颜色，用九宫格
library(scales)
show_col( c("red",'darkred','navy','#FF9600',"#0096FF"), labels = FALSE)




(2) colortools包
install.packages("colortools")
library("colortools")

#
wheel("darkblue", num = 12)

#Analogous color scheme
adjacent("darkblue") 
#or 
analogous("darkblue")

#Complementary color scheme
complementary("steelblue")


#Split Complementary Color Scheme
splitComp("steelblue")


#Tetradic Color Scheme
tetradic("steelblue")

#Square color scheme
square("steelblue")


#Sequential colors
sequential("steelblue")







6. 颜色格式互换

(1) rgb to hsv
rgb2hsv(255,255,255)#rgb转hsv
  [,1]
h    0
s    0
v    1
 

(2) 








7.最后提供几个颜色组合，从多到少：

library(RColorBrewer)
#433种
color433 = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
pie(rep(1,50), col=sample(color433, 50, replace = F))

#74种
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
color74 = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
pie(rep(1,60), col=sample(color74, 60, replace = F))

#37种
color37 = c("#466791","#60bf37","#953ada","#4fbe6c","#ce49d3","#a7b43d","#5a51dc","#d49f36","#552095","#507f2d","#db37aa","#84b67c","#a06fda","#df462a","#5b83db","#c76c2d","#4f49a3","#82702d","#dd6bbb","#334c22","#d83979","#55baad","#dc4555","#62aad3","#8c3025","#417d61","#862977","#bba672","#403367","#da8a6d","#a79cd4","#71482c","#c689d0","#6b2940","#d593a7","#895c8b","#bd5975")
pie(rep(1,37), col=sample(color37, 37))

#20种
color20<-c('#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#ffffff', '#000000')
pie(rep(1,20), col=sample(color20, 20))

#彩虹20种
barplot(rep(0.2,20), col=rainbow(20)) #20种彩虹色，再多就区分不明显了

#这个抽样颜色还是值得考虑的，有经济学人柱状图的风格
library(RColorBrewer)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
#处理后有73种差异还比较明显的颜色，基本够用
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) 
#看下中间60种颜色的效果
n=30
pie(rep(1,n), col=sample(col_vector, n))
barplot(rep(0.2,n), col=sample(col_vector, n))







========================================
|-- colorRampPalette() 创建颜色梯度(渐变色)
----------------------------------------
1. 使用预制配色集合，生成多个连续的颜色

library(RColorBrewer)
display.brewer.all() #显示全部颜色集合

# 挑选某一个集合
#barplot(rep(1,8),col=brewer.pal(8,"Dark2")[1:8]) #基础语法
myColors=brewer.pal(8,"Dark2")[1:8] #Dark2主题有8种颜色

par(mfrow=c(4,1), mar=c(0,2,2,0) )
barplot(rep(1,8),col= myColors, main="Dark2"  )
#
n=15 #nrow(df);
barplot(rep(1, n ),col= colorRampPalette(colors = myColors)( n ),main="Default:linear") #则由8种生成15种颜色
barplot(rep(1, n ),col= colorRampPalette(colors = myColors, interpolate ="linear")( n ),main="linear" ) #插值方式
barplot(rep(1, n ),col= colorRampPalette(colors = myColors, interpolate ="spline")( n ),main="spline") #插值方式



> colSet2
[1] "#1B9E77" "#D95F02" "#7570B3" "#E7298A" "#66A61E" "#E6AB02" "#A6761D" "#666666"





2. 实例 

library(RColorBrewer)
#(1) 产生11种颜色
col1=brewer.pal(11,'Spectral'); col1
barplot(rep(1,11), col=col1, border = NA)


(2) 根据给定的颜色，产生100个连续的颜色
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100) #减去第六个颜色
colors
barplot(rep(1,100), col=colors, border = NA)



(3) 把某一个连续的数字列，对应到一个连续的颜色区间上
有了颜色梯度之后，我们就可以方便的把数值映射到颜色梯度上
基本的思想是，
1)将数值排序，然后得到每个数值在排序好的序列中的顺序，其实就是rank 函数的返回值，然后利用该顺序去获取颜色
2)另一种思想，颜色更变化平滑，就是把数值切分区间，每个区间的levels对应的颜色就是我们需要的颜色。

plotcol <- colors[ cut( iris$Sepal.Length, breaks=100) ]; plotcol #把数字分成100个区间的因子，每个level对应一个颜色。
barplot(rep(1,length(plotcol)), col=plotcol, border = NA)
#












========================================
|-- 如何控制不透明度？rgb函数的第四个参数，或者16进制第7-8位
----------------------------------------
1.rgb函数的第四个参数
(1) 实例1
> set.seed(1)
> x <- rnorm(200)
> y <- rnorm(200)
> plot(x, y, cex = 3, pch = 16, col = rgb(255, 0, 0, 80, maxColorValue=255))
> plot(x, y, cex = 3, pch = 16, col = rgb(255, 0, 0, 20, maxColorValue=255))


(2). 实例2: 两个峰，重合部分显示不同颜色
#Create data
set.seed(1)
Ixos=rnorm(4000 , 120 , 30)     
Primadur=rnorm(4000 , 200 , 30) 

# First distribution
hist(Ixos, breaks=30, xlim=c(0,300), col=rgb(1,0,0,0.5), xlab="height", 
     ylab="nbr of plants", main="distribution of height of 2 durum wheat varieties" )

# Second with add=T to plot on top
hist(Primadur, breaks=30, xlim=c(0,300), col=rgb(0,0,1,0.5), add=T)

# Add legend
legend("topright", legend=c("Ixos","Primadur"), 
       col=c(rgb(1,0,0,0.5),rgb(0,0,1,0.5)), pt.cex=2, pch=15 )




2. 使用16进制的7-8位控制透明度。最后一位表示【不透明度】。
不透明度从 00(完全透明) 到 FF(完全不透明，默认)。比如:
	#FF0000 表示红色，等价于 #FF0000FF，表示完全 不透明。
	#FF000000 表示完全透明的红色，就是默认的白色背景。

例:
set.seed(1)
d1=rnorm(4000 , 120 , 30)     
d2=rnorm(4000 , 200 , 30) 

hist(d1, breaks=30, xlim=c(0,300), col="#FF000066")
hist(d2, breaks=30, xlim=c(0,300), col="#0000FF66", add=T)







ref:
https://bbs.pinggu.org/thread-4627872-1-1.html
https://www.r-graph-gallery.com/2-two-histograms-with-melt-colors.html





========================================
** 5. 图形排版
----------------------------------------
http://www.360doc.com/content/14/0831/20/17553313_406108143.shtml
一、图形边距：mar/mai参数
> par(bg="cyan")                #把图形背景设为青色以便观察
> par(mar=c(4, 4, 0.5, 0.5))    #c(下、左、上、右)设定下边距和左边距为4行，另外两边距为0.5行。
> set.seed(1000)                #设此参数是为了下面的rnorm()函数都能获得相同数据
> plot(rnorm(10))


二、坐标轴（标题、刻度标签和刻度线）位置：mgp参数
mgp参数可设三个数值，依次为标题、刻度标签和刻度的位置。mar/mai设定参数后，图形区（用box函数绘制的边框）边缘位置即为0。所以，mgp=c(2, 0.5, 0)就表示标题在第二行，刻度标签在0.5行，刻度线在0行。
par(bg="cyan")
par(mar=c(4, 4, 0.5, 0.5))
set.seed(1000)
par(mgp=c(1.5,0.5,0)) #坐标轴各项的位置设定c(x标题,刻度标签,刻度线)
plot(rnorm(10))


三、获取位置坐标 //不懂没事，看完继续看四
如果要把图例、自定义文字等设置在图形区以外，par函数的usr参数非常有用，获取方法很简单：

usr <- par("usr")
usr
# [1]   0.64 10.36  0.64 10.36
#返回值是一个向量：c(x1, x2, y1, y2)
#如果要通过鼠标点击获得图形上的某些点的坐标，可以用locator()函数：

xy <- locator(n=1)   #参数n表示要获得n个点的坐标，需要点击n次鼠标
xy
#$x
#[1] 0.6516328
#
#$y
#[1] -1.761121




四、在图形区外添加图例和文字
有了以上获取坐标信息的方法，我们可以把图例放在图形区外。先绘制柱形图：
par(mar=c(3, 3, 0.5, 4))      #注意给图例留出空间，右侧4 inch
par(mgp=c(2,0.5,0))
NF <- c(17.44 , 2.56 , 2.70 , 18.71 , 5.61 , 32.98)
CA <- c(11.48 , 0.75 , 1.16 , 12.73 , 2.84 , 20.04)
labels <- paste("S", 1:length(NF),sep="")
the.data <- rbind(NF, CA)
barplot(the.data, ylim=c(0, max(NF,CA)*1.2), col=c("orange", "red"),
	xlab="Sample", ylab="Level", beside=TRUE,
	offset=0, axis.lty=1, names.arg=labels)
box() #外边框

#然后通过坐标设定将图例放到图形区外。
#注意：除坐标（指图例的左上角坐标）数值设定外，
#还要legend函数中的参数xpd值设为TRUE，意思为“允许在图形区外绘制”。

usr <- par("usr")
x <- usr[2]*1.02     #图例左上角的x坐标，向右移动
y <- usr[4]*0.6      #图例左上角的y坐标，向下移动
legend(x, y, legend=c("NF","CA"), fill=c("orange", "red"), box.col="white", xpd=TRUE)


#事实上，使用legend函数的inset参数就可以把图例放到图形区外，不需要设定坐标值。
#inset的值表示相对于图形区的比例，比如：如果位置坐标用 “left”和“right”，inset表示相对于x轴长度的比例。
#要将图例放到图形区外，inset设定为负值，具体数字自己估算。前面的图例可以用下面语句获得：
legend("right",legend=c("NF","CA"), box.col="white", fill=c("orange", "red"), 
       inset=-0.35, xpd=TRUE) #相对于right线，inset为正则向左移动，为负责向右移动。0.1的步长。
#建议还是先获取坐标好点，这个inset太难调了。

#灵活设定inset的值可以把图例放置在图形的其他地方，比如顶部：
par(mar=c(3, 3, 2, 0.5))
par(mgp=c(2,0.5,0))
barplot(the.data, ylim=c(0, max(NF,CA)*1.2), col=c("orange", "red"),
        xlab="Sample", ylab="Level", beside=TRUE,
        offset=0, axis.lty=1, names.arg=labels)
legend("top", legend=c("NF","CA"), box.col="white", fill=c("orange", "red"),
       ncol=2, inset=-0.15, xpd=TRUE)
box() #最后画box好，可以压下legend的白色背景。


顺便简单说说文字添加，更详细的内容留后面介绍。
图形区内添加文字用text()函数，在图形区外添加文字用mtext()函数。这种约束也不是死的，设定合适的参数，两者可以随意使用。
另外，mtext()不能添加旋转的文字，text用srt参数可以获得旋转文字。下面我们用旋转文字设定x轴标签：

NF <- c(17.44 , 2.56 , 2.70 , 18.71 , 5.61 , 32.98)
CA <- c(11.48 , 0.75 , 1.16 , 12.73 , 2.84 , 20.04)
the.data <- rbind(NF, CA)
labels <- paste("Sample", 1:length(NF))
par(mar=c(4, 3, 0.5, 0.5))
par(mgp=c(2,0.5,0))
position <- barplot(the.data, ylim=c(0, max(NF,CA)*1.2),
                    col=c("orange", "red"), legend.text=c("NF","CA"),
                    args.legend=list(x="topleft", box.col="white", inset=0.02),
                    ylab="Level", beside=TRUE, offset=0, axis.lty=1)
#以下为横坐标标签设定
x <- (position[1,] + position[2,])/2
y <- par("usr")[3]-1
text(x, y, labels=labels, adj=1, srt=45, xpd=TRUE) #adj标签与轴的距离，srt设置xlable角度
box()




五、一页多图

把一个页面平分成n份做n个图，用par函数的mfrow和mfcol参数。这两个参数都是两个值的向量，表示行数和列数，但在页面上作图顺序的顺序不一 样。如果用mfrow参数，一行一行从左到右作图；mfcol则是一列一列的做。下面图形的代码只有第一行不一样，注意看每个图内的点（数字）：

#画图函数
myDraw=function(){
  set.seed(1000);plot(rnorm(100),pch="1", cex=0.6)
  set.seed(1001);plot(rnorm(100),pch="2", cex=0.6)
  set.seed(1002);plot(rnorm(100),pch="3", cex=0.6)
  set.seed(1003);plot(rnorm(100),pch="4", cex=0.6)
}

#图片按横着输出
par(mfrow=c(2,2)) #两行两列，mfrow行
par(mar=c(3, 3, 0.5, 0.5))
myDraw()

#图片竖着输出
par(mfcol=c(2,2)) #两行两列，mfcol列
par(mar=c(3, 3, 0.5, 0.5))
myDraw()
#


如果页面不均等分隔绘制多图，用layout函数分隔页面。它有四个参数，mat，widths，heights和respect。后三个参数有默认值，这 里我们只设置第一个参数mat。它是一个矩阵，表示绘图区分隔的各部分，相同数字的部分合并成一个绘图区，数字也是它们作图时的顺序。下面的矩阵mat有 2行3列，我们看看它绘出的图形：

注意：mat参数的值必需从1-n顺序依次取值，不能有间隔。

#layout布局1
par(mar=c(2, 2, 0.5, 0.5))
mat <- matrix(c(1,1,2,3,4,4), nrow=2, byrow=TRUE)
mat
#     [,1] [,2] [,3]
#[1,]    1    1    2
#[2,]    3    4    4
layout(mat)
myDraw()


#layout布局2
par(mar=c(2, 2, 0.5, 0.5))
mat <- matrix(c(1,2,3,4,4,4), nrow=2, byrow=TRUE)
mat
#     [,1] [,2] [,3]
#[1,]    1    2    3
#[2,]    4    4    4
layout(mat)
myDraw()












========================================
|-- 图片的组合与拼接(任意位置、任意个图, 支持base和grid绘图系统)
----------------------------------------
https://mp.weixin.qq.com/s?__biz=MzA3MTM3NTA5Ng==&mid=2651059193&idx=1&sn=67c8db755cb9e2376b6a49f3af1f473f

customLayout R包可以自由拼图，可以使用矩阵自定义图形位置和顺序，用数字来定义每一个模块的长宽比，试用了一遍简直爱不释手。

这个包不仅支持数字拼图，还支持R内置的base绘图对象、grid绘图对象等（也就是支持ggplot2对象）。
customLayout用于拼图特别方便，尤其是仪表盘布局。
支持R内置的base绘图对象，ggplot2对象（与grid结合）。

这样的话，对于需要制作简单仪表盘的场景，完全不必要使用rmarkdown+flexdashboard或者shiny+shinydashboard也可以快速生成仪表盘原型。






1.安装
customLayout包有CRAN版本，也有github版本可供下载：

install.packages("customLayout")
devtools::install_github("zzawadz/customLayout")



2.简单的数字拼图：

lay_new() 创建拼图画布
lay_show() 显示拼图画布




(1)通过设置简单的数字矩阵以及对应的宽高比，可以非常方便的设置出来数字拼图：

library(customLayout)
#library(magrittr)

lay <- lay_new(
  mat = matrix(1:4, ncol = 2), # 矩阵分布，mat表示指定排版的数字矩阵 
  widths = c(3, 2), # 设定宽度比例
  heights = c(2, 1))   # 设置高度比例)
lay_show(lay) # 显示拼图画布

mat数字矩阵必须从1开始，且必须连续
其中mat指定要拼图的数字矩阵，将1:4数字按照纵向顺序拼成两行，其中宽对比为3:2,高度比为2:1。



(2)
lay2 <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 5),
  heights = c(2, 4))
lay_show(lay2)


(3)画布合并
其它拼图包没有的功能，非常好用
跟合并矩阵类似。分为行合并和列合并

lay_bind_col() 画布列合并
lay_bind_col(x, y, widths = c(1, 1), addmax = TRUE) 参数widths表示指定合并宽度比

lay_bind_row() 画布行合并
lay_bind_row(x, y, heights = c(1, 1), addmax = TRUE) 参数heights表示指定合并高度比


将前两个例子横向拼接，两个模块对象仍然支持设置款对比例（3:1）
cl = lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl)


(4)不同层级的对象仍然支持拼接在一起。
lay3 <- lay_new(matrix(1:2))
lay4 <- lay_bind_row(cl, lay3, heights = c(5, 2))
lay_show(lay4)


(5) 画布嵌套: 将一个模块嵌入到两一个模块特定位置。
这个功能也是其它包没有的，非常有用
关键函数：
lay_split_field(lay, newlay, field)

参数lay表示大画布，参数newlay表示要嵌套进去的小画布，field表示指定要嵌套的区域编号


lay <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 2),
  heights = c(2, 1))
lay_show(lay)

lay2 <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 5),
  heights = c(2, 4))
lay_show(lay2)

slay <- lay_split_field(lay, lay2, field = 4)
lay_show(slay)

这里就将lay2嵌入到lay模块的第四个区域，但may2内部的布局结构任然不变。








3.填充图片: 关于图像对象的布局与拼接
关键函数：
lay_set(layout) 将画布layout设置为绘图布局，用于base绘图对象
lay_grid(grobs, lay, ...) 将绘图对象grobs填充到画布lay中， 用于ggplot2等绘图对象


(1)基础绘图对象的拼接：
par(mar = c(3, 2, 2, 1))
lay  <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 2),
  heights = c(2, 1))
lay2 <- lay_new(matrix(1:3))
cl   <- lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl) #显示画布

##
lay_set(cl) # initialize drawing area

set.seed(123)
plot(1:100 + rnorm(100))
plot(rnorm(100), type = "l")
hist(rnorm(500))
acf(rnorm(100))
pie(c(3, 4, 6), col = 2:4)
pie(c(3, 2, 7), col = 2:4 + 3)
pie(c(5, 4, 2), col = 2:4 + 6)



(2) grid(ggplot2)图形对象的拼接:

library(ggplot2)
#library(gridExtra)

## 创建排版画布
lay  <- lay_new( matrix(1:2, ncol = 1))
lay2 <- lay_new(matrix(1:3))
cl   <- lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl)

# 创建数据
cuts <- sort(unique(diamonds[["cut"]]),decreasing = TRUE)

make_cut_plot <- function(cut) {
  dd <- diamonds[diamonds[["cut"]] == cut, ]
  ggplot(dd) +
    geom_point(aes(carat, price)) +
    facet_wrap("cut") # 封装分面
}

plots <- lapply(cuts, make_cut_plot) # 对不同切割水平的进行作图
lay_grid(plots, cl) # 将绘图对象依次填充到cl画布中


customLayout包的版式布局思想非常简单，就是基于数值矩阵的模块化分割，同时不同层级的模块也可相互拼接，这样就可以像拼七巧板一样拼出很多奇形怪状的版式出来，甚至你使用这种版式来设计一个富有美感的超照片拼图或者海报都有可能。





========================================
|-- R保存图片，强制覆盖前面的空白页
----------------------------------------
1. 先可视化图片，然后再保存到文件。

x=seq(-3,3,0.1)
plot(x,x**2,type='l')
abline(h=2,col='red', lty=2)
lines(x,4/(1+exp(-x**2)),col='blue')
#blablabla...
#dev.copy(postscript, file="myfile.eps", height=6, width=6, horizontal=F, onefile=F)
#dev.copy(png, filename="myfile.png", height=600, width=800, bg="white")
#dev.print(device=postscript, file="yourFileName.ps")
dev.copy2pdf(file="xx_plot.pdf",out.type="pdf")
dev.off()




2. 强制输出到一张: pdf 函数中，有一个参数onefile ,  默认值为TRUE, 表示每张图片占用pdf 中的一页

(1) 两页，第一页是空白
pdf("test.pdf")
plot(1:5, type = "n", xlab = "", ylab = "", bty = "n", xaxt = "n", yaxt = "n")
plot(1:5)
dev.off() 

(2) 只需要设置onefile = FALSE 就可以了，此时后面的图片会覆盖前面空白的图片
pdf("test.pdf", onefile = FALSE)
plot(1:5, type = "n", xlab = "", ylab = "", bty = "n", xaxt = "n", yaxt = "n")
plot(1:5)

# hist(iris$Sepal.Length)
dev.off()

前面不管是不是空白，都会被覆盖掉，只显示最后一个该显示的图。




ref: https://qinqianshan.com/r_code/r_draw/images-export-r/






========================================
高级效果
----------------------------------------


========================================
|-- 3d散点图: 一次观察4个属性(3个位置、1个颜色)
----------------------------------------
1. 3D散点图，无法拖动 scatterplot3d

library(scatterplot3d)
set.seed(2015)
x <- runif(100)
y <- runif(100)
z <- runif(100)
grp <- as.factor(sample(1:3, 100, replace = T))#这是设置三种颜色标签，一个数字对应一个颜色
dat <- data.frame(x, y, z, grp)#生成数据框
head(dat)
plot3d <- with(dat, scatterplot3d(x, y, z, color = as.numeric(grp), pch = 16))

legend(plot3d$xyz.convert(0.5,0.7,0.5),pch=16,yjust=0,legend=levels(dat$grp), col = seq_along(levels(dat$grp)))


控制点的大小: cex.symbols=0.5,



(1) 理解angle参数
library("scatterplot3d")
z <- seq(-10, 10, 0.01) 
x <- cos(z) 
y <- sin(z) 
for(i in seq(0,360,5) ){
  print(i)
  scatterplot3d(x, y, z, 
                highlight.3d=TRUE, 
                col.axis="blue", 
              col.grid="lightblue",
              angle=i, #x和y轴夹角，就是2d图中目测看到的
              main=paste("scatterplot3d - 1",i), pch=20)
  Sys.sleep(0.05)
}


(2) 根据某一列的值，设置渐变颜色。
## version 1: 不完善，颜色获取容易出bug。原因未知。
mycolors=colorRampPalette(colors = c("yellow",'red','purple'))( 200 )
i=3; #染色的列
scatterplot3d(mtcars[,c(1,2,5)], type = "h", lwd = 1, pch = 16, 
              #x.ticklabs = colnames(my.mat),
             color = mycolors[ round(mtcars[,i]/max(mtcars[,i])*200) ],
               #grey(25:1 / 100), 
             angle=60,
             main = "3D barplot")
#


(3) 更完善的颜色设置
## version 2: 完善颜色获取，使用极值做标准化
# get color list
getColorList=function(df, i){
  mycolors=colorRampPalette(colors = c("yellow",'red','purple'))( 201 )
  stdvalue=round( (df[,i]-min(df[,i]) )/( max(df[,i])- min(df[,i]) )*200 );
  list.color=c()
  for(j in 1:nrow(df) ){
    color=mycolors[stdvalue[j]+1]
    list.color=c(list.color,color)
  }
  return(list.color)
}
#getColorList(rsDF, i)

library("scatterplot3d")
i=3; #染色的列
rsDF=mtcars #测试数据
scatterplot3d(#rsDF[,c(3,4,6)], 
  x=rsDF[,3], y=log2(rsDF[,6]+1), z=rsDF[,4], #zlim=c(0,80),
  xlab=colnames(rsDF)[3],
  ylab='',#paste0('log2 ', colnames(rsDF)[6] ),
  zlab=paste0('', colnames(rsDF)[4]),
  type = "h", #p 点图
  lwd = 1, pch = 16, cex.symbols=0.5,
  color = getColorList(rsDF, i),
  angle=60,
  main = "3D barplot")
#添加y坐标 https://www.jb51.cc/css/217864.html
dims <- par("usr");#dims
x <- dims[1]+ 0.9*diff(dims[1:2])
y <- dims[3]+ 0.08*diff(dims[3:4])
text(x,y,expression(paste(log[2]*'XXX') ),srt=45)












2. rgl:这个可以实现用鼠标对图像进行旋转，从不同的视角看图像。
#install.packages("rgl")
library(rgl)
attach(mtcars)
plot3d(wt,disp,mpg,col="red",size=5) #更多色彩 col=rainbow(12)
detach(mtcars)

attach(dat)
plot3d(x,y,z)
detach(dat)
缺点是不好看，不好控制。







3.如何利用R语言画出三维动画图
http://blog.csdn.net/chen790646223/article/details/45483275




========================================
|-- plotly包：让ggplot2的静态图片变得可交互(基于svg)
----------------------------------------

1. 简介

Plotly 是个交互式可视化的第三方库，官网提供了Python，R，Matlab,JavaScript，Excel的接口，因此我们可以很方便地在这些软件中调用Plotly，从而实现交互式的可视化绘图。

plotly支持facet，不过当facet的图形超过9个以后，legend处会出现bug。


Plotly's R graphing library makes interactive, publication-quality graphs. Examples of how to make line plots, scatter plots, area charts, bar charts, error bars, box plots, histograms, heatmaps, subplots, multiple-axes, and 3D (WebGL based) charts.

官网: https://plotly.com/r/
文档: https://plotly.com/r/reference/

也可以用于python: https://plotly.com/python/




2. 例子
# 安装包
## install.packages("plotly")

# 运行时会自动载入ggplot2包
library(plotly)
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
p <- plot_ly(d, x = ~carat, y = ~price, color = ~carat,
        size = ~carat, text = ~paste("Clarity: ", clarity),
        type = "scatter", mode = "markers")
print(p) #鼠标悬浮可显示提示
#embed_notebook(p) #显示到jupyter notebook




ref:
https://zhuanlan.zhihu.com/p/24917856




========================================
|-- image 和 barplot 的组合
----------------------------------------

1. 实例：左边是热图，右侧是条形图。

par(mfrow = c(1, 2)) #1行2列

# c(bottom, left, top, right)
par(mar = c(1, 5, 3, 0), las = 1, ann = F)
set.seed(1)
image(x=1:100, y=1:20,  z= scale(  matrix(sample(1:2000), ncol = 20) ), 
      xaxt = "n", yaxt = "n", #不要坐标轴
      axes = FALSE)
axis(side = 2, at = 1:20, 
     labels = paste("gene", seq(1:20), sep = "") , 
     tick = F, 
     col.ticks ="red", #刻度线颜色
     col="blue", #轴线颜色
     mgp=c(1,0.3,0), #刻度标签和图的距离
     lwd=5)

par(mar = c(1, 0.5, 3, 3))
barplot(1:20,  horiz = T, 
        ylim = c(0.1, 20.1), 
        yaxs = "i", 
        width = 0.8, 
        space = 0.25, 
        xaxt = "n", border = NA)

需要注意barplot 中space 函数的应用，space 的值为柱子宽度的百分比；
通过ylim 展示y轴的一部分；





========================================
|-- dendrogram 和 barplot 的组合
----------------------------------------
1. 实例 
左边是树，右边是 barplot。中间是共同的文字

data <- mtcars[1:10, ]
hc  <- hclust(dist(data))
hcd <- as.dendrogram(hc)
plot(hc)
plot(hcd)


par(mfrow = c(1, 2))

par(mar = c(1,1 , 1, 0))
plot(hcd, horiz = T, yaxs = "i", axes = F, leaflab = "none") # 左边的树

sep <- 5 * max(strwidth(rownames(data), units = "inches")) + 1.2
par(mar = c(1, sep , 1, 1), adj = 0.5, mgp = c(3, sep / 2, 0), las = 1)
b <- barplot(1:10,  horiz = T,  
             ylim = c(0.1, 10.1), 
             yaxs = "i", 
             width = 0.8, space = 0.25,  # space 调节距离
             xaxt = "n", border = NA)

# 中间的文字
axis(side = 2, at = b, rownames(data), 
     line = NA, tcl = FALSE, lwd = 0, hadj = 0.5, padj = 0.5)





========================================
|-- 实现分面效果：使用sapply(data, fn)
----------------------------------------

1. 例: 3行1列, 每个图是 hist+density
par(mfrow = c(3,1), mar = c(2,1,2,1), oma = c(2,3,0,0))
sapply(levels(iris$Species), function(f) {
  hist(iris$Sepal.Length[iris$Species == f], main = f, xlab = "", n=25, xlim=c(4,8) )
  par(new=T)
  plot(density(iris$Sepal.Length[iris$Species == f], n=50), xlim=c(4,8), 
       lwd=5,col='#FF000066', ann=F, axes=F )
  #lines(density(iris$Sepal.Length[iris$Species==f], n=50), xlim=c(4,8), col='green')
})
mtext(side = 1, outer = T, line = 1, "Sepal.Length", cex = 0.8) #x标签
mtext(side = 2, outer = T, line = 2, "Freq", cex = 0.8) #y标签






========================================
lattice 绘图系统
----------------------------------------
lattice主要记录在 http://www.biomooc.com/R/R-draw-adv-lattice.html
[R In Action(2nd Edtion), Chapter23] https://livebook.manning.com/book/r-in-action-second-edition/bonus-chapter-23-advanced-graphics-with-the-lattice-package/


1. lattice 包
	函数：xyplot, bwplot, histogram, stripplot, dotplot, splom, levelplot, contourplot
	格式： xyplot(y~x| f*g, data) # f和g是分类变量
	panel函数，用于控制每个面板内的绘图

grid包：
	实现了独立于base的绘图系统
	lattice包是基于grid创建的；很少直接从grid包调用函数

lattice和base的重要区别：
	base绘图函数直接在图形设备上绘图
	lattice绘图函数返回trellis类对象
		打印函数真正执行了在设备上绘图
		命令执行时，trellis类对象会被自动打印，看起来像是lattice函数直接完成了绘图

#



refer:
https://www.imooc.com/video/11578






========================================
图论: 点、边、度
----------------------------------------

1. 最小生成树 minimum spanning tree (MST)
A special tree called a minimum spanning tree (MST) is very useful for testing the relations between a graph and other covariates. 

定点：nodes or vertices (often called V) 
边：a set of edges between these vertices (E). 



A spanning tree is a tree that goes through all points at least once,
The minimum spanning tree is the spanning tree of minimum length;






2.  adjacency matrix: 临近矩阵 表示边E, 
有几个定点就有几行。
第i行第j列不为0，就表示第i点和第j点有联系。

问题: 对于无方向的边，adjacency matrix有什么特别的？

代码：
library("igraph")
edges1 = matrix(c(1,3,2,3,3,4,4,5,4,6),byrow = TRUE, ncol = 2)
g1 = graph_from_edgelist(edges1, directed = FALSE)
plot(g1, vertex.size = 25, edge.width = 5, vertex.color = "coral")



3. 网络的定义
We call a weighted, directed graph a network. 
Networks have adjacency matrices, which are nxn matrices of positive numbers corresponding to the edge lengths.

对于大的网络，很多研究者喜欢 summarize overall graph structure such as vertex degrees (the number of edges connected to the vertex), centrality or betweenness. 
定点度，中心性，中间度。


(1)
如果边和定点个数类似，则称这个图是稀疏的。
如果是稀疏的，按照矩阵保存就是浪费空间，可以使用Matrix包中的方法保存。
如果边的个数是定点的二次函数，该矩阵就是idense的，内存将是个问题。


(2)
更丰富的图包含带箭头的边。还可以计算in-degree和out-degree。
边的宽度可以表示link的强度。
协变量也可以加到定点上。一个连续协变量可以与定点的大小相关，分类变量可以和定点颜色相关。


(3)
图的布局
同一个图可以有不同的布局。

边的长度可表示距离。
简单情况，边没有长度时，算法可以选择不同的标准，Fruchterman and Reingold 方法通常是默认标准。
这时基于相似点吸引或排斥的物理模型的，就像有一个物理力的影响一样。


作业：
(1)使用igraph包，创建一个dense随机图，12个定点和超过50个边。
(2) 尝试不同的布局：把点放到圆上; 或尽量对称的放置，放置边和定点的重叠。

# 
set.seed(1)
rs=matrix(rnorm(144), nrow=12);dim(rs)
rs=abs(rs)
rs[rs<0.6] <- 0; table(rs==0)
#FALSE  TRUE 
#68    76 
df2=NULL;
for(i in 1:12){
  for(j in 1:12){
    # if(i==j)next;
    if(rs[i,j]!=0)
    df2=rbind(df2, data.frame(
      i,j, rs[i,j]
    ))
  }
}
head(df2);dim(df2)
g1 = graph_from_edgelist(as.matrix(df2[, c(1,2)]), directed = FALSE)
g1
plot(g1, vertex.size = 25, edge.width = 3*as.numeric(df2[,3]),
     vertex.color = "coral")
plot(g1, layout=layout.fruchterman.reingold)
#g1$layout=layout.circle
plot(g1, layout=layout.circle) #圆形显示


##
E(g1)
E(g1)[c(5,10)]$label="xxlink" #为边标记标签
plot.igraph(g1)
# 设置link颜色
E(g1)$color='grey'
E(g1)[c(5,10)]$color='red' #这是E(g1)显示的顺序
plot.igraph(g1)
# 小球填充绿色
plot(g1, layout=layout.circle, vertex.color="green")
# 线条粗细
g1_2=g1; E(g1_2)[c(2,8,10)]$width=15  #error?? 不理解
plot.igraph(g1_2, layout=layout.circle)
#


##
## 更简单的是这个函数，且带方向
g2 <- graph.adjacency( rs >= 0.6)
g2
plot(g2, vertex.size = 25, edge.width = 3*as.numeric(df2[,3]),
     vertex.color = "coral")
# 换一种布局
plot(g2, layout=layout.fruchterman.reingold)








4. ggnetwork 包模拟数据
Make a dataframe from the graph g1 using the ggnetwork package, then plot it using ggplot and the provided geoms geom_edges, geom_nodes and geom_nodetext.

马尔科夫链
Markov chains are idealized models of dynamical systems and the states are represented by the nodes in the graph. The transition matrix gives us the weights on the directed edges (arrows) between the states.

library("markovchain")
statesNames = c("A", "C", "G","T")
T1MC = new("markovchain", states = statesNames, transitionMatrix =
  matrix(c(0.2,0.1,0.4,0.3,0,1,0,0,0.1,0.2,0.2,0.5,0.1,0.1,0.8,0.0),
    nrow = 4,byrow = TRUE, dimnames=list(statesNames,statesNames)))
plot(T1MC, edge.arrow.size = 0.4, vertex.color="purple",
      edge.arrow.width = 2.2, edge.width = 5, edge.color = "blue",
      edge.curved = TRUE, edge.label.cex = 2.5, vertex.size= 32,
      vertex.label.cex = 3.5, edge.loop.angle = 3,
      vertex.label.family="sans", vertex.label.color = "white")
#







refer:
http://web.stanford.edu/class/bios221/book/Chap-Graphs.html
https://blog.csdn.net/yepeng2007fei/article/details/78250088




========================================
R语言igraph 包-构建网络图 //todo
----------------------------------------

igaph 是一个项目，目标是建立一条简单，易用的网络分析工具，有 R, python, C/C++ 等语言的具体实现；
项目主页：http://igraph.org/

在R语言中，对应的就是 igraph 这个R包

安装：install.packages("igraph")

使用：
对于图 graph 这种数据结构而言，最基本的元素包括节点（node） 和 边（节点之间的连线，edge）;
igraph 这个R包提供了很多种创建graph的方式，我们先看一个最基本的例子，从数据框创建一个graph；

我们将要创建的graph 如下：


可以看到，这个graph 包括5个节点，首先创建一个数据框，这个数据框中的每一行是一个节点，每一列是节点的属性
> actors <- data.frame(name=c("Alice", "Bob", "Cecil", "David",
                            "Esmeralda"),
                     age=c(48,33,45,34,21),
                     gender=c("F","M","F","M","F"))

> actors
       name age gender
1     Alice  48      F
2       Bob  33      M
3     Cecil  45      F
4     David  34      M
5 Esmeralda  21      F

actors 这个数据框保存了图中所有节点的信息，共5个节点，有name, age, gender 3种属性；注意节点的属性是自定义的
接下来创建另外一个数据框，保存边的信息，


> relations <- data.frame(from=c("Bob", "Cecil", "Cecil", "David",
+                                "David", "Esmeralda"),
+                         to=c("Alice", "Bob", "Alice", "Alice", "Bob", "Alice"),
+                         same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),
+                         friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3))
> relations
       from    to same.dept friendship advice
1       Bob Alice     FALSE          4      4
2     Cecil   Bob     FALSE          5      5
3     Cecil Alice      TRUE          5      5
4     David Alice     FALSE          2      4
5     David   Bob     FALSE          1      2
6 Esmeralda Alice      TRUE          1      3


relations 数据框保存了节点之间的连线信息， from， to 两列描述了这条边是从哪个节点到哪个检点，最后的3列是每条边的一些自定义的属性

当两个数据框创建完成之后，就可以利用 graph_from_data_frame 函数创建一个graph, 代码如下：

g <- graph_from_data_frame(relations, directed=TRUE, vertices=actors)
第一个参数是保存edge 信息的数据框，directed 参数控制graph 有无方向，vertices 参数是保存节点信息的数据框
最后进行一个简单的可视化
plot(p)



(2) 上面只是最基本的可视化的例子，对于graph 而言，有directed graph 和 undirected graph 两种，在可视化的时候，最核心的东西是计算每个节点的位置，对于不同类型的graph， 有不同的自动化的布局算法

通过layout 参数可以方便的指定，使用不同的布局算法

代码示例：
plot(g, layout = layout.fruchterman.reingold)









ref:
https://rdatamining.wordpress.com/2012/05/17/an-example-of-social-network-analysis-with-r-using-package-igraph/
http://kateto.net/networks-r-igraph
https://www.cnblogs.com/xudongliang/p/6944413.html




========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


