如何写 R包？


《R包(第二版)》R packages by Hadley Wickham and Jenny Bryan.
https://r-pkgs.org/index.html





========================================
R 包概述
----------------------------------------
1. R包是R代码可重复研究的基石。R包包含函数、文档、示例数据。
Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data.


本书教你怎么把代码放到R包中，方便其他人下载和复用。
In this book you’ll learn how to turn your code into packages that others can easily download and use. 

写一个包咋看很难。所以从简单开始，一版一版的提升。
Writing a package can seem overwhelming at first. So start with the basics and improve it over time. It doesn’t matter if your first version isn’t perfect as long as the next version is better.


(2) 官方资料
Advanced R https://adv-r.hadley.nz/index.html
Writing R Extensions https://cran.r-project.org/doc/manuals/R-exts.html

https://www.jianshu.com/p/4d8e3ba787ad
https://www.yuque.com/xiayonghe/dev_r_pack/vfm47w



2. 相对第一版的更新
(2)准备工作
(3)设置
代码风格 https://style.tidyverse.org/
(4)代码结构和状态
(5)写R包的工作流和工具
(6) git/github



3. R 包相关话题
基础知识
    介绍
    游戏规则
    系统设置
    包的结构和状态
    基本开发流程
    包的内部

包的组成
    R代码
    元数据
    对象文档
		小品文-一种长文档
    测试
    命名空间
    外部数据
    编译代码
	
    证书
    安装文件
    其他组成部分

包的发布
    GitHub
    自动检查
    包的版本









========================================
|-- 查看一个R包
----------------------------------------
1. 包就是由函数构成的

(1) 查看某个包内的所有函数
ls("package:ggplot2")
ls(envir=as.environment( "package:ggplot2" ))


(2) 函数结果通常会自动从控制台打印出来，想要隐藏结果
myfunc <- function(x, y) {
	z <- x + y
	invisible(z)
}






========================================
|-- 如何写第一个R包: 有用的链接
----------------------------------------
1. 权威资料
https://r-pkgs.org/ 共20章
Writing R Extensions https://cran.r-project.org/doc/manuals/R-exts.html 



2. 好的博客

(1) english blog

2020 | How to write your own R package and publish it on CRAN https://www.mzes.uni-mannheim.de/socialsciencedatalab/article/r-package/
	* devtools, roxygen2

2019 | How to create your own R package with RStudio [Tutorial] https://hub.packtpub.com/how-to-create-your-own-r-package-with-rstudio-tutorial/ 
	* devtools, roxygen2


2015 | Making Your First R Package https://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html
	* devtools, roxygen2, 

2014 | Writing an R package from scratch https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/
	* devtools, roxygen2, 



(2) English ppt/pdf

Step by Step Tutorial to creating R Packages https://www.stt.msu.edu/~cui/Groupmeeting/R_package_tutorial.pdf
	* 原生R: dirs like R/ data/ man/ tests/ exec/ inst/ 


2018 | Instructions for Creating Your Own R Package http://web.mit.edu/insong/www/pdf/rpackage_instructions.pdf
	* devtools, 
	* Rcpp, For win users, 




========================================
R包实战第n版: 如何写一个R包
----------------------------------------
ref: 
https://www.bilibili.com/video/BV1M4411S72M
https://cosx.org/2011/05/write-r-packages-like-a-ninja

写R扩展: https://cran.r-project.org/doc/manuals/R-exts.html

生成R文档的网页版: https://pkgdown.r-lib.org/ pkgdown is designed to make it quick and easy to build a website for your package.


写包只是程序开发的一方面啦，很多人不写包但做的事情很牛。
要说中高级R程序员，窃以为还是得看John Chambers老爷子的原著（如Software for Data Analysis），S语言和R语言的设计之精巧，似乎并没有引起人们的注意。
比如这里介绍的命名空间（主要是Luke Tierney的工作），可能绝大部分用户永远都不会接触到，但的确是一个很好的管理对象的方式；
还有S3与S4以及最新的ReferenceClass（参见?setRefClass），这些概念都很有意思，很能体现设计者的智慧。
这些东西才能体现R作为一门“语言”的特征，对多数人来说，R只是一门“程序”，是用来完成数据处理任务的。
当然，这也无妨，R就像一盘大餐，爱吃哪部分就挑哪部分。


可以看看 http://adv-r.had.co.nz/C-interface.html 
不过个人觉得还是Rcpp更人性化一点 http://adv-r.had.co.nz/Rcpp.html




##############
# R包实战第一版
##############

1. 在文件fun.R中先写一个函数，读入到R的内存中。

add=function(x){
  return (x+7)
}



2. 下一步是生成R包目录结构

(1) 在R中执行如下2行:
> setwd('/home/wangjl/data/r-pkg/') #要生成的目录位置
> package.skeleton(name="wjl007", list="add") # name="包的名字", list="函数的名字"
## package.skeleton(name='RoxygenSkeleton', code_files = "Roxygen.R", force=TRUE)


则在目录下生成文件结构
$ cd /home/wangjl/data/r-pkg/
$ tree 
.
├── fun.R
└── wjl007
    ├── DESCRIPTION ##项目描述文件。
    ├── man ##帮助文档
    │   ├── add.Rd
    │   └── wjl007-package.Rd
    ├── NAMESPACE
    ├── R ##具体代码
    │   └── add.R
    └── Read-and-delete-me

3 directories, 7 files

其中重点关注新生成的 wjl007/ 文件夹，里面有几个基本的R包的文件。

(2) 其中的 Read-and-delete-me 告诉我们接下来干什么:
* Edit the help file skeletons in 'man', possibly combining help files for multiple functions.
* Edit the exports in 'NAMESPACE', and add necessary imports.
* Put any C/C++/Fortran code in 'src'.
* If you have compiled code, add a useDynLib() directive to 'NAMESPACE'.
* Run R CMD build to build the package tarball.
* Run R CMD check to check the package tarball.

Read "Writing R Extensions" for more information.

完善项目描述文件 DESCRIPTION: 我们象征性的把版本号修改为 0.1.2.3
完善帮助文件 man/。

删除掉 Read-and-delete-me 文件。



3. 建立包
可以在terminal中进行build了：
cd your_directory
R CMD INSTALL --build mypkg 


会报错的 man/add.Rd 文件添加一行
\title{
%%  ~~function to do ... ~~
  Add 7 for a given number.
}


$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL --build wjl007 
## packaged installation of ‘wjl007’ as ‘wjl007_0.1.2.3_R_x86_64-pc-linux-gnu.tar.gz’
## * DONE (wjl007)



4. 使用包 
然后，在R中library(yourpackage)一下就好了！

## 退出这个包，删除同名函数
> rm(add)
> detach("package:wjl007", unload=TRUE)
> add(10)
## Error in add(10) : could not find function "add"


## 载入包，并使用包中的函数
> library(wjl007)  ##> library("wjl007", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.6")
> add(10)
[1] 17


## 永久卸载这个包
> remove.packages("wjl007", lib="~/R/x86_64-pc-linux-gnu-library/3.6")

## 再次安装
$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL wjl007










========================================
|-- R 文档与 roxygen2：从代码注释生成.Rd files
----------------------------------------

1. 简介
如果有30个函数，每次函数更新完，还要更新man/下的文档，会抓狂的。
于是有人发明了在函数内直接写文档，然后用程序翻译成文档的方法。

流程：你在源代码中写 roxygen comments --> roxygen2::roxygenise() 抽取翻译出.Rd文件 --> R翻译出人看的文档。


roxygen2 是一个 R 包（它的前任是 roxygen，但已经停止更新了），它实现了把特定注释 “翻译” 为 R 文档的工作，例如：
##' @author Yihui Xie
##' @source \url{https://cos.name}

会被翻译为：
\author{Yihui Xie}
\source{\url{https://cos.name}}



R provides a standard way of documenting packages: you write .Rd files in the man/ directory. These files use a custom syntax, loosely based on latex. Roxygen2 provides a number of advantages over writing .Rd files by hand:

- 代码文档一起，方便更新。Code and documentation are adjacent so when you modify your code, it’s easy to remember that you need to update the documentation. 

- 动态检查，自动代替手动添加。Roxygen2 dynamically inspects the objects that it’s documenting, so it can automatically add data that you’d otherwise have to write by hand.

- 提取S3和S4方法的差异，学更少的细节。It abstracts over the differences in documenting S3 and S4 methods, generics and classes so you need to learn fewer details.

As well as generating .Rd files, roxygen will also create a NAMESPACE for you, and will manage the Collate field in DESCRIPTION.
自动生成Rd文件，创建 NAMESPACE，并管理 DESCRIPTION 中的 Collate字段。






2. 函数的注释要符合一定的规范

$ mkdir -p /home/wangjl/data/r-pkg/wjl008/R
$ vim /home/wangjl/data/r-pkg/wjl008/R/fun.R

##' title of stupid_f...
##'
##' description...
##'
##' details here
##' @param a ###<<-------- 这里不标准，会warning，后面有修改版
##' @param b
##' @return
##' @author Yihui Xie &lt;\url{http://yihui.name}&gt;
##' @examples
stupid_f = function(a, b){
    a + b
}


#' A wrap of linear regression
#' @description This function performs linear regression (a simplified version)
#' @param formula: a formula
#' @param data: dataset
#' @return a lm object
#' @examples
#' linear_reg(Sepal.Length~., iris)
#' @export
linear_reg <- function(formula, data){         
    result <- lm(formula, data)         
    return(result) 
} 

注释：
每行开头必须是 #' 
@param 中的冒号可选
@export 才能在外面被用户直接使用，否则只能内部函数使用。


roxygen2 的常规是，第一段是标题（将来翻译为\title{}），段落之间以空行分开，第二段是描述（\description{}），然后接着是这个函数的详细描述（\details{}），它可以是若干段落，你愿意写多长就写多长。剩下的@字段就不必多解释了，参数、返回值、作者、示例等。


roxygen2 还实现了一些自动功能，比较重要的就是对命名空间文件 NAMESPACE 和描述文件 DESCRIPTION 的自动更新，这些我们第五节再说。先说如何从 roxygen 注释翻译到 Rd 文档，很简单：如果一个包已经按第二节的结构写好（不需要有 man 文件夹），函数和相应的 roxygen 注释都已经存在，那么用函数roxygenize()就可以把这样一个初级包翻译为一个完整 R 包了：

setwd('/a/b/c/')  # 先把工作目录切换到pkg之上
library(roxygen2)
roxygenize('pkg')

默认情况下新生成的 R 文档以及更新的 NAMESPACE 和 DESCRIPTION 都生成在包的目录下，现在 pkg 就是一个完整的 R 包，包含自动生成的 man 文件夹，可以直接用R CMD INSTALL pkg安装。





##############
# R包实战第二版
##############
(1) 建立目录，在文件R/fun.R内写函数及要求格式的注释，见上文 stupid_f 和 linear_reg 函数。
$ tree wjl008/
wjl008/
├── DESCRIPTION2 #这个文件需要提前准备。
├── man
└── R
    └── fun.R

(2) 编译出帮助文档Rd：需要提前准备好 DESCRIPTION文件。
> setwd("/home/wangjl/data/r-pkg/")
> library(roxygen2)
> roxygenize('wjl008')
Error: `package.dir` must include a DESCRIPTION file:
  * "/data/wangjl/r-pkg/wjl008" does not.

$ cp wjl007/DESCRIPTION wjl008/ ##复制一个过来，修改一下
Package: wjl008
Type: Package
Title: Title of pkg wjl008
Version: 0.1.2.4
Date: 2021-01-02
Author: wjl <wjl@none.net>
Maintainer: wjl <wjl@none.net>
Description: test pkg of wjl008
License: MIT
Encoding: UTF-8


## 再试
> roxygenize('wjl008')

有三个warning，尝试解决掉吧：
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:6] @param requires name and description
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:7] @param requires name and description
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:10] @examples requires a value

$ vim R/fun.R  #修改第一个函数的注释部分
##' title of stupid_f...
##'
##' description...
##'
##' details here
##' @param a: a number
##' @param b: a number
##' @return a number
##' @author Yihui Xie &lt;\url{http://yihui.name}&gt;
##' @examples
##' stupid_f(2, 6)
stupid_f = function(a, b){
  a + b
}


## 三试
> roxygenize('wjl008')
Loading wjl008
Writing NAMESPACE
Writing NAMESPACE
Writing stupid_f.Rd
一切正常。

查看文件结构
$ tree wjl008
wjl008
├── DESCRIPTION
├── man
│   ├── linear_reg.Rd
│   └── stupid_f.Rd
├── NAMESPACE
└── R
    └── fun.R

##
(3) 安装 
$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL --build wjl008
packaged installation of ‘wjl008’ as ‘wjl008_0.1.2.4_R_x86_64-pc-linux-gnu.tar.gz’
* DONE (wjl008)

这时，刷新Rstudio的Packages面板，就能看到已经安装了 wjl008 Version 0.1.2.4

这时所有函数都可以访问，因为为了生成注释，所有函数都读入过了。
> stupid_f(1,2)
[1] 3
为了防止副作用，要重启R！！


(4) 使用R包
十分重要: 要先重启R! 
- 点击菜单 Session - restart R.
- 或者更好的策略： 菜单 Session - Quit Session.


> library(wjl008)
> stupid_f(2,3)
Error in stupid_f(2, 3) : could not find function "stupid_f"

> linear_reg(speed~dist, cars)
Call:
lm(formula = formula, data = data)

Coefficients:
(Intercept)         dist  
     8.2839       0.1656 
#


另一种调用包内 export出来的函数：
> library(wjl008)
> e1=as.environment("package:wjl008");
> e1$linear_reg(speed~dist, cars)

Call:
lm(formula = formula, data = data)

Coefficients:
(Intercept)         dist  
     8.2839       0.1656
#




(5) 注意点
* 自动生成函数的注释，包的注释怎么生成的呢？没看到包的Rd文件。
* 看函数的源代码或文档，在Console输入函数名，按F1，或者输入?linear_reg。
* @export 一个函数，就只有一个可以直接被用户调用。

* roxygen2 抽取注释前需要有主是好的R/xx.R 函数文件，以及 DESCRIPTION 文件。




ref:
roxygen2官方教程：https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html
Rd格式: https://cran.r-project.org/doc/manuals/R-exts.html#Rd-format





========================================
|-- R 的命名空间 NAMESPACE
----------------------------------------
两个包都有一个同名函数，怎么区别？使用命名空间前缀。
namespace1::funcName()
namespace2::funcName()

https://r-pkgs.org/namespace.html


1. 作用

命名空间（NAMESPACE）是 R 包管理包内对象的一个途径，它可以控制哪些 R 对象是对用户可见的，哪些对象是从别的包导入（import），哪些对象从本包导出（export）。

为什么要有这么个玩意儿存在？主要是为了更好管理你的一堆对象。写 R 包时，有时候可能会遇到某些函数只是为了另外的函数的代码更短而从中抽象、独立出来的，这些小函数仅仅供你自己使用，对用户没什么帮助，他们不需要看见这些函数，这样你就可以在包的根目录下创建一个 NAMESPACE 文件，里面写上export(函数名)来导出那些需要对用户可见的函数。自 R 2.14.0 开始，命名空间是 R 包的强制组成部分，所有的包必须有命名空间，如果没有的话，R 会自动创建。

前面我们也提到 DESCRIPTION 文件中有 Imports 一栏，这里设置的包通常是你只需要其部分功能的包，例如我只想在我的包中使用 foo 包中的bar()函数，那么 Imports 中就需要填 foo，而 NAMESPACE 中则需要写importFrom(foo, bar)，在自己的包的源代码中则可以直接调用bar()函数，R 会从 NAMESPACE 看出这个bar()对象是从哪里来的。

roxygen 注释对这一类命名空间有一系列标签，如一个函数的文档中若标记了##' @export，那么这个函数将来就会出现在命名空间文件中（被导出），若写了##' @importFrom foo bar，那么 foo 包的bar对象也会被写在命名空间中。这些内容参见 R-exts 的 1.6 节和 roxygen2 的?export帮助。



(2) 调用时
不是我们自己定义的函数通常来自一些包
● 核心包的函数可以直接调用
● 其他包，我们都需要载入对应的命名空间

(3) 载入包的方式
library(ggplot2)
require(magrittr) # 很少使用
# 使用::
dplyr::mutate()
enrichplot:::list2graph # 内部函数


当开发包时，用::就比较方便
• 因为需要精确的调用，有很多重名函数
• 通常使用importFrom 在 NAMESPACE 文件记录







2. R包的 命名空间 namespace

(1) 每个R包的根目录都有一个NAMESPACE文件：
The package namespace (as recorded in the NAMESPACE file) is one of the more confusing parts of building a package.

其中记录着哪些函数是提供（export）给用户使用，需要哪些依赖包（import），哪些包的哪些函数（importFrom）

As the name suggests, namespaces provide “spaces” for “names”. They provide a context for looking up the value of an object associated with a name.

有时候你明明看到某个函数内部调用了另一个函数，但就是无法使用它（没有export给用户）！



(2) 学习一下 ggplot 包的NAMESPACE 文件，摘录几行：
https://github.com/tidyverse/ggplot2/blob/master/NAMESPACE
https://github.com/duncantl/Rllvm/blob/master/NAMESPACE

S3method("[[",ggproto)
S3method(fortify,Polygon)
S3method(ggplot,"function")
S3method(print,rel)
S3method(print,theme)
export(scale_color_discrete)
export(xlim)
import(scales)
importFrom(stats,setNames)
importFrom(tibble,tibble)




(3) 从 Seurat 包的NAMESPACE 文件中摘录几行：
https://github.com/satijalab/seurat/blob/master/NAMESPACE

# Generated by roxygen2: do not edit by hand

S3method("SCTResults<-",SCTAssay)
S3method("SCTResults<-",SCTModel)
S3method(FindClusters,Seurat)
S3method(RunPCA,Assay)
export("Idents<-")
export(DoHeatmap)
export(DotPlot)
exportClasses(Assay)
exportClasses(DimReduc)
exportClasses(Graph)
exportClasses(Neighbor)
exportClasses(Seurat)
import(Matrix)
importClassesFrom(Matrix,dgCMatrix)
importClassesFrom(SeuratObject,Assay)
importFrom(Matrix,as.matrix)
importFrom(Matrix,colMeans)
importFrom(Matrix,colSums)
importFrom(SeuratObject,"Idents<-")
importFrom(ggplot2,geom_text)
importFrom(utils,read.table)







3. 文件的命名空间

R 一定程度上也可以用文件作为一个“命名空间”：sys.source() 可以指定环境，比如
bar = new.env()
sys.source('foo.R', bar)
然后就可以 bar$对象 调用 foo.R 里创建的对象了。











4. 有4个函数可以使用三方包的功能（函数、数据等）
基于它们是否加载（Load）或绑定（attach），找不到包时的反馈而有所不同。

        抛出error	         返回 FALSE
Load	loadNamespace("x")	 requireNamespace("x", quietly = TRUE)
Attach	library(x)	         require(x, quietly = TRUE)


(1)4个函数里面，你应该只使用两个：

* 在数据分析脚本中使用 library(x)，它会在包找不到时抛出错误并且停止脚本的运行。
你想要绑定包以节省代码键入。永远不要在开发包时使用library()函数。

* 在包中使用requireNamespace(x, quietly = TRUE)用来进行一个特定的行为，如当建议包找不到时抛出一个错误。


(2) 不要使用的情况

你永远也不需要使用 require() (requireNamespace()更好)或loadNamespace() (仅需要在R包内部代码中使用).。
永远不要在一个包中使用require()或library()，相反， 应该在DESCRIPTION的Depends或Imports 字段部分填入包名。


(3)那么，Imports与Depends部分到底有什么区别呢？什么时候该使用它们呢？

Imports和Depends包部分会确保你所需要的依赖包被安装，主要的区别是Imports中的包仅仅会被导入，而Depends中的包会被绑定，没有其他的区别了。

假设你开发的包需要dplyr，你把它列到了Depends，那么载入你开发的包的用户它会发现dplyr也被载入了，而且能够直接使用里面的函数。
而写在Imports的话，dplyr里面的函数用户是不可以直接使用的。








ref:
https://www.jianshu.com/p/caf44731f3c0





========================================
|-- 函数式编程
----------------------------------------
1. 高级操作
(1)管道符号
- 来自 magrittr 包: 将左手作为右手的第一个参数
library(magrittr)
mtcars %>% dim()

- R在4.1.0版本以后定义了一个管道运算符“|>”
mtcars |> dim()

可以使得这种复合调用按照正常的执行次序来写， 变成
x |>
  sqrt() |>
  sin()

普通复合方法写成 sin(sqrt(x))





(2) 高级函数
什么是高级函数？
采用一个或多个函数作为参数。
因此，在R世界，函数是一等公民。

函数作为输入参数
myfunc <- function(vec, f) {
	z <- f(vec)
	return(z)
}
myfunc(c(1, 2, 3), mean) # 2
myfunc(c(1, 2, 3), sum) # 6



2. 怎么写函数？
(1)如何写一个函数
-明确函数的目标: 函数用来进行什么操作
- 思考函数的交互: 输入是什么, 返回是什么
- 实现函数: 对于要实现的操作，采用什么算法


(2) 脚本中的函数
明确脚本中重复的部分
如果重复了三次或更多次，值得写一个函数
使用参数来调节各个部分的差异
一个函数要专注于做一件事（不能太长）


(3) 输入参数检验
R函数是动态参数，为了更好的用户体验，可以增加参数校验

包括个数校验，类型、范围检验。

myfunc <- function(x, y) {
	checkmate::assert_numeric(x, len = 1)
	checkmate::assert_numeric(y, len = 1)
	z <- x + y
	return(z)
}
myfunc(x = 5, y = "cookies")
# Assertion on 'y' failed: Must be of type 'numeric',
# not 'character'.


# 原生校验方式：预防性设计
在编写自定义函数时， 可以检查自变量输入以确保输入符合要求。 函数stopifnot可以指定自变量的若干个条件， 当自变量不符合条件时自动出错停止。
例如，函数f()需要输入两个数值型向量x, y, 需要长度相等， 可以用如下的程序
f <- function(x, y){
  stopifnot(is.numeric(x),
            is.numeric(y),
            length(x)==length(y))
  ## 函数体程序语句...
}





ref: 
https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-func.html






========================================
|-- 介绍文档（Vignette）
----------------------------------------
前面我们提到了 inst/doc / 目录，下面可以放一个 Sweave 文件，在R CMD INSTALL过程中这个 Sweave 文件会被执行并生成 PDF 文档，若 Sweave 文件中有一句注释：

%\VignetteIndexEntry{An Introduction to XXX}
那么这句话将来会出现在 HTML 帮助页面中（点开链接 “Overview of user guides and package vignettes”），例如 Rd2roxygen 包或者 formatR 包的帮助页面中就有介绍文档的链接。



========================================
|-- 其它语言
----------------------------------------
在 src 目录下我们可以放置一些其它语言的源代码，里面可能包含一些函数，这些函数在被编译之后，（以 C 语言为例）可以在 R 代码中以.C('routine_name', ..., package = 'pkg')的形式调用，但要注意，如果需要用这个功能，在 R 目录下需要有一个 zzz.R 文件（这个特殊文件是用来在加载包之前加载运行的代码），里面写上：

.onLoad <- function(lib, pkg) {
    library.dynam("pkg_name", pkg, lib)  # pkg_name是你的包的名字
}
这些东西我并不在行，只介绍到这里，详细内容还请深挖 R-exts。



========================================
R 包函数名的生命周期
----------------------------------------

https://lifecycle.r-lib.org/articles/stages.html#superseded

1.Experimental 最早的实验函数


2.Stable   到稳定版本

3.Deprecated [ˈdeprəkeɪtɪd] 不赞成使用，弃用。一般会有 warning，提醒不要再用了。

df <- tibble::data_frame(x = 1)
#> Warning message:
#> `data_frame()` is deprecated as of tibble 1.1.0.
#> Please use `tibble()` instead.
#> This warning is displayed once every 8 hours.
#> Call `lifecycle::last_warnings()` to see where this warning was generated. 



4.Superseded  作废的；【被取代的】

一般是有更好的替代函数了。



5.Superseded stages
这个阶段曾经用过，现在已经不用了。




========================================
我自己的R包，起名字叫 GEB (借鉴自人工智能界著名同名书籍)
----------------------------------------

1.
1979 年，有一部获普利策大奖的书轰动了美国，这就是当代人工智能专家道格拉斯·霍夫施塔特的《GEB－－一条永恒的金带》。而今这书已被译作许多种文字流传全世界。

书出自1979年, 就是当代人工智能专家道格拉斯·霍夫施塔特的《GEB－－一条永恒的金带》（四川人民出版社，1984年） [1]  。而今这书已被译作许多种文字流传全世界。还有版本翻译为《哥德尔、艾舍尔、巴赫——集异璧之大成》。



(1) 悖论和怪圈
1) 2句话
下面这个句子是假的。
上面那个句子是真的。

如果 1 真，那么2假，2的反面是 1假，和假设矛盾；
如果 1 假，那么其反面是2真，而2认为1真，和假设矛盾；


2) 一句话悖论: 我在说谎。
如果是在说谎，则是在说实话，矛盾；
如果不是在说谎，他说是在说谎，则是在说实话，矛盾；


(2) Gödel, Escher, Bach: A Mental Space Odyssey
https://ocw.mit.edu/high-school/humanities-and-social-sciences/godel-escher-bach/







ref:
https://www.zhihu.com/question/20511599/answer/87895142



========================================
|-- R 包开发流程：编写、构建、测试、发布、安装与使用
----------------------------------------
对于有blog的我来说，写R包是一个优先级不高的任务。
今天兴致又来了，花了一下午尝试写R包，不确定这是第几个写残的R包了。


权威书: Hadley Wickham大神写的《R包开发》，
	电子版 https://github.com/hadley/r-pkgs
	英文地址 https://r-pkgs.org/


本文环境: centos7.9 + R 4.1.1 + devtools 2.4.2
该过程适合纯R书写的函数，如果有C代码，可以参考下一篇。


1. 创建R包框架

(1) 使用菜单实现

Rsutdio：File——> New Project——> New Directory ——> R Package
填写:
	pkg name: GEB
	source files: empty
	subdir: ~/data/my_R_pkg
	点击 Create Project

自动进入该子目录，并创建包名目录
$ pwd
/home/wangjl/data/my_R_pkg/GEB

文件结构，其中最重要的是 代码目录R/和 文档目录man/。
$ tree 
.
├── GEB.Rproj #R工程文件
├── DESCRIPTION #R包描述信息
├── man 	#存放 *.Rd 文档
│   └── hello.Rd
├── NAMESPACE #命令空间
└── R  #存放R脚本
    └── hello.R
2 directories, 5 files



(2) 还可以使用纯代码构建脚手架

> library('devtools') # 开发 R 包黑魔法工具
> create('~/data/my_R_pkg/somePkg') # 建立 R 包的目录， somePkg 就是你想要的包的名称
> setwd('~/data/my_R_pkg/somePkg') # 把工作目录放到 R 包中的目录，开发 R 包过程中始终推荐这样做。
> dir() # 列出当前工作目录的文件和文件夹
# [1] "DESCRIPTION"   "NAMESPACE"     "R"             "somePkg.Rproj"


$ cd ~/data/my_R_pkg/somePkg
$ tree 
.
├── DESCRIPTION
├── NAMESPACE
├── R
└── somePkg.Rproj

貌似这个框架连hello()函数都没提供，是真的空白。




2. 自定义R包。

以上是自动生成的脚手架，接下来要自定义R包的代码和注释了。

最简单的R包，只需要 R/文件夹和 DESCRIPTION 即可。
但是没有注释的大函数确实没法用~~有位名人说过“代码不写注释是万恶之源”。



(1) 编写R代码
主要就是写R函数，默认带有一个 R/hello.R 中的 hello() 函数。
# Hello, world!
#
# This is an example function named 'hello' 
# which prints 'Hello, world!'.
#
# You can learn more about package authoring with RStudio at:
#
#   http://r-pkgs.had.co.nz/
#
# Some useful keyboard shortcuts for package authoring:
#
#   Install Package:           'Ctrl + Shift + B'
#   Check Package:             'Ctrl + Shift + E'
#   Test Package:              'Ctrl + Shift + T'

hello <- function() {
  print("Hello, world!")
}



我们接着写一个用户友好的画饼图的函数，保存在和函数同名的文件中 R/my_pie.R，也可以不同名，也可以保存到 hello.R 中。

my_pie <- function(data, ncol){
  plotdat <- as.data.frame(table(data[,ncol])) %>% dplyr::arrange(-Freq)
  plotdat$Label <- paste(plotdat$Var1, paste0("(",round(((plotdat$Freq/sum(plotdat$Freq))*100),2),"%)"))

  p <- ggplot(plotdat, aes (x="", y = Freq, fill = factor(Var1))) +
        geom_col(position = 'stack', width = 1) +
        geom_text_repel(aes(label = Label, x = 1.3),size=5,
                        position = position_stack(vjust = 0.5)) +
        theme_classic() +
        theme(plot.title = element_text(hjust=0.5),
              axis.line = element_blank(),
              axis.text = element_blank(),
              axis.ticks = element_blank()) +
        labs(fill = "Category",x = NULL,y = NULL) +
        coord_polar("y")
	return(p)
}



2) 测试
其实我们要边写边测试，把错误消灭在萌芽状态。
load_all() 函数很神奇地把包骨架文件夹中的 R 文件夹中的所有 .R 文件读进来了；
每一次你改进你的 *.R 文件，只要运行一次 load_all() 就会把最新的自创函数们拉进来，在 R 环境中就可以测试最新的代码是否正常。




(2) 写文档，就是在函数上按F1时看到的帮助页面

与一般的函数编写不同的是，我们需要对这个函数编写文档，这就是为什么我们在用R包中函数时可用?来查看函数帮助。

注释文件都在 man/ 下，一个函数一个注释文件。注释文件是由奇奇怪怪的东西（R+LaTeX）写成的。
我们只需要按照一定的规则(规则是 roxygen2 包定义的)把注释写到函数定义前面，然后由代码生成Rd文档。



1) 第一步，给函数添加注释
这里是对函数整体进行roxygen注释，方便文档生成，而非普通代码注释。

tips: 光标放在函数名上，使用 Ctrl+Shift+Alt+R 快捷键即可生成一个基本模板，我们根据需要进行相应修改即可。


#' Using a dataframe specific column to plot a pie figure
#'
#' @param data a dataframe or tibble
#' @param ncol specific column, factor
#'
#' @return a figure as ggplot2 object
#' @export
#'
#' @examples
#' my_pie(mtcars,ncol=2)
#' my_pie(diamonds,ncol=3)
#' my_pie(diamonds,ncol=3)+guides(fill="none")
#'
my_pie <- function(data,ncol){
	...
}

对用户使用的函数都要在函数注释中加上一个 #' @export 行。最后，#' @examples 接下来的行就是示例用法。


2) 第二步，运行 > devtools::document() ，会在man文件夹下生成该函数的Rd文件：


$ cat NAMESPACE
exportPattern("^[[:alpha:]]+")
推荐删掉 NAMESPACE，再次运行 > devtools::document() 会自动生成该文件
$ cat NAMESPACE
# Generated by roxygen2: do not edit by hand

export(my_pie)



然后可以接着写R函数及其注释，只需要重复以上2步。
再添加一个ID转换的函数：//不能保证运行

代码文件也可以和函数名不同 R/uniprot.R
#' Using r code to connect uniprot web api
#'
#' You can choose one id as well as another id as output id
#' Read uniprot documentation to know more information
#'
#' @param query vector of protein ids
#' @param inputid type of input id, character
#' @param outputid type of output id, character
#' @param fmt output format
#'
#' @return a dataframe
#' @export
#'
#' @examples
#' idMapping(query=proid, inputid="ACC", outputid="P_ENTREZGENEID", mft="fmt")
#'
idMapping <- function(query, inputid, outputid, fmt){
	query = paste(query, collapse=",")
	r=httr::POST('http://www.uniprot.org/uploadlists/',
		body=list(from=inputid, to=outputid, format=fmt,  query=query), encode="form")
	cont=httr::content(r, type="text")
	result=readr::read_tsv(cont)
}

执行 > devtools::document() 生成注释文件 man/idMapping.Rd





(3) 修改DESCRIPTION
点击 DESCRIPTION 对模块进行修改。
这是包的描述文件，根据情况修改即可。

原文
Package: GEB
Type: Package
Title: What the Package Does (Title Case)
Version: 0.1.0
Author: Who wrote it
Maintainer: The package maintainer <yourself@somewhere.net>
Description: More about what it does (maybe more than one line)
    Use four spaces when indenting paragraphs within the Description.
License: What license is it under?
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.1.2


修改后 
Package: GEB
Type: Package
Title: A R toolkit to process NGS data (BioInfo)
Version: 0.1.0
Author: George
Maintainer: The package maintainer <poster469@163.com>
Description: NSG data pre-processing.
    Draw figures, etc.
License: GPL
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.1.2
Depends:
	R(>= 3.6.0)
Suggest:
	roxygen2,
	knitr
Imports:
	httr,
	readr,
	dplyr,
	ggplot2,
	ggrepel

教训: Depends中>=后面要有一个空格。

解释 
Package: 包名
Description: 描述信息
Depends: 依赖R版本（要注意空格，否则后续会报错）
Suggest：建议包，非必需
Imports：依赖包（这里编写的函数依赖了图中5个R包）
License：协议



(4) 构建包
1) 使用菜单
Rstudio ——> Build，可构建源码包或者二进制包。

点击 Build Source Package ，Rstudio 右上角Build面板开始显示构建过程：编译并更新文档。
==> devtools::build()

✓  checking for file ‘/home/wangjl/data/my_R_pkg/GEB/DESCRIPTION’
─  preparing ‘GEB’:
✓  checking DESCRIPTION meta-information ...
─  checking for LF line-endings in source and make files and shell scripts
─  checking for empty or unneeded directories
   Omitted ‘LazyData’ from DESCRIPTION
─  building ‘GEB_0.1.0.tar.gz’
[1] "/home/wangjl/data/my_R_pkg/GEB_0.1.0.tar.gz"
Source package written to ~/data/my_R_pkg

2) 使用R命令
> library(devtools)
> build()
...
[1] "/home/wangjl/data/my_R_pkg/GEB_0.1.0.tar.gz"



3) 使用?my_pie等编写的函数，已经可以查看文档了，说明编译成功，已经可以使用R包了。

好了，你现在有了一个安装包(GEB_0.1.0.tar.gz)了，随便以任何方式，不管是email、qq、网盘、ftp，还是优盘、手机、移动硬盘，只要让用户能得到你这个压缩文件，他就能安装和使用这个包了。




(5) 安装R包，测试效果
安装该包，并测试。或直接使用::测试函数。这里采用前者。
tips: 为了减少副作用，建议先重启R进程(菜单 Session - Restart R).


1) Tool-Install pkg, 选择 from: tar.gz, archive: 选择该包 GEB_0.1.0.tar.gz

2) 相当于语句
> install.packages("~/data/my_R_pkg/GEB_0.1.0.tar.gz", repos = NULL, type = "source")

3) 使用shell安装
$ cd ~/data/my_R_pkg/
$ R CMD INSTALL GEB_0.1.0.tar.gz



如果缺少包，就先安装这些包 
> install.packages("ggrepel")

如果没报错，表示安装成功。
选择右下角的 Pkg 面板，输入 GEB，发现这个 v 0.1.0 已经安装了。



> library(GEB)
> hello() #因为注释部分没有主动暴露，该函数只能内部使用。
Error in hello() : could not find function "hello"

> library(dplyr)
> library(ggplot2)
> library(ggrepel)
> my_pie(mtcars, ncol = 2)
# 确实画了饼图。

> GEB::idMapping("PD1","ACC", "P_ENTREZGENEID", "fmt")
报错。

目前的问题：不会自动加载需要的包，第三个函数报错。



(6) 上传 Github

如果只是自己使用，可以放在本地。本着R语言开源精神，要想分享给其他人使用，需要有地方托管。
权威认可的地方如CRAN、Bioconductor等，但如果专业度不够高或者处于开发阶段，还是托管在Github上吧。


1) 想上 CRAN 需要很严格的质控，
比如运行 > check() # 1 error x | 0 warnings ✓ | 1 note x
# Running examples in ‘GEB-Ex.R’ failed

要尽量排除所有的 errors notes。
在 hello() 函数上面加上例子后
#' Title
#'
#' @return
#' @export
#'
#' @examples
#' hello()
#'
再次执行 > check() #还有报错

还可以在 terminal 环境，对前面 build() 生成的包用 R 自带的命令检查：
$ R CMD check --as-cran ~/somebm_0.1.tar.gz
尽量排除所有的 errors notes。

算了，放弃



2) 从本地仓库上传到Github远程仓库，与一般代码上传无异。

i)首先，进入本地R包目录，提交代码

查看隐藏目录
$ ls -ltha
新建不跟踪文件
$ vim .gitignore 
.Rproj.user

$ git init
$ git add .

设定用户名和邮箱，邮箱要和github一致。
$ git config --global user.email "jimmymall@xxv.com"
$ git config --global user.name "James"

$ git commit -m 'my first r package'


ii) 创建 github repo，使用 ssh 地址


iii) 设置秘钥

本地生成秘钥
$ ssh-keygen -t rsa -C "jimmyMall@xxx3.com" 
路径默认 /home/wangjl/.ssh/id_rsa
密码是 tencent 

把公钥
$ cat ~/.ssh/id_rsa.pub
放到 github: 头像，settings，ssh，new key。

测试连通性
$ ssh -T git@github.com
Enter passphrase for key '/home/wangjl/.ssh/id_rsa': 
Hi DawnEve! You've successfully authenticated, but GitHub does not provide shell access.


iv) 上传代码
$ git remote add origin git@github.com:DawnEve/GEB.git
$ git push -u origin master

显示如下，表示成功。
To git@github.com:DawnEve/GEB.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.

可以浏览器查看上传到 github 的代码: https://github.com/DawnEve/GEB





(7) 换个电脑使用该包

> devtools::install_github("DawnEve/GEB")
> library(GEB)

> library(dplyr)
> library(ggplot2)
> library(ggrepel)
> my_pie(diamonds,ncol=3)
# 饼图正常显示。




(8) 经验与教训
也可以把几个包都保存到一个目录下，然后把该目录推送到github的一个repo中，然后这样安装:
> devtools::install_github("userName/my_rpackage/rmytools")

问题:
- 安装时不能自动安装依赖包，使用时不能自动加载依赖包： 使用 Depends 而不是 Imports 可解决该问题。
- help(package='GEB') 时找不到包中所有函数的目录 URL '/help/library/GEB/html/00Index.html' not found。重启R即可解决。




3. 小结：包的好处
(1) 首先自己用的方便

用R包来管理组织自己平时经常用的代码是一种非常高效的方式，后续想添加任何功能或修改原有脚本，只需git push，重新装一下R包即可。是时候整理整理之前混乱的代码了（俗称屎山）。

之前放一堆R文件来保存函数，每次使用都是 source() 一下全部载入，导致RStudio右上窗Environment标签下特别冗长，而且经常忘记有哪些函数，以及每个函数的功能和用法。

现在使用自定义包，不仅Environment区清爽了，而且忘了可以tab补全，然后F1看帮助。


(2) 改善代码

毕竟暴露给大众，会强制写的规范一点，自觉查找标准操作流程。
同时别人可能帮忙改错，或许会用着原来越好用。



(3) 收集需求 

开源社区也会有许多需求，没准就是下一篇方法学文章。





ref:
https://www.cnblogs.com/jessepeng/p/12895520.html 推荐
https://www.bioinfo-scrounger.com/archives/546/
https://pzhao.org/zh/post/rmickey/#comment-3312847859
https://cosx.org/2011/05/write-r-packages-like-a-ninja #有点过时了
https://cosx.org/2013/11/building-r-packages-easily
https://kbroman.org/pkg_primer/
https://uoftcoders.github.io/studyGroup/lessons/r/packages/lesson/





========================================
|-- 包的函数列表不显示: 要重启 R session
----------------------------------------
> help(package='GEB') #URL '/help/library/GEB/html/00Index.html' not found
而 ggplot2 能显示，是该包所有函数的列表。

https://github.com/r-lib/devtools/issues/2390


1. 使用纯命令行构建包，重现该问题
=> R
> library('devtools')
> create('~/data/my_R_pkg/somePkg')
> setwd('~/data/my_R_pkg/somePkg')
> dir()
# [1] "DESCRIPTION" "NAMESPACE"   "R"


=> shell
$ cd ~/data/my_R_pkg/somePkg
$ vim R/add.R
#' Add 2 numbers
#'
#' @param num1 a number
#' @param num2 another number
#'
#' @return a number
#' @export
#'
#' @examples
#' my_add(2, 3)
#'
my_add <- function(num1, num2){
	num1+num2
}

# no change to DESCRIPTION.
$ cat DESCRIPTION 
Package: somePkg
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person("First", "Last", , "first.last@example.com", role = c("aut", "cre"),
           comment = c(ORCID = "YOUR-ORCID-ID"))
Description: What the package does (one paragraph).
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.1.2



=>R
> devtools::document()
> build()
# [1] "/home/wangjl/data/my_R_pkg/somePkg_0.0.0.9000.tar.gz"

> install.packages("~/data/my_R_pkg/somePkg_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# * DONE (somePkg)

> library("somePkg")
> my_add(2,3)
[1] 5

> help(package='somePkg')
Information on package ‘somePkg’
Nothing below, no function list, no description 



> help(package='ggplot2')
              Information on package ‘ggplot2’

Description:

Package:                ggplot2
Version:                3.3.5
Title:                  Create Elegant Data Visualisations Using the
                        Grammar of Graphics
...
Index:

+.gg                    Add components to a plot
CoordSf                 Visualise sf objects
aes                     Construct aesthetic mappings


## 重启R session 即可。 
> q()
n

$ R
> help(package='somePkg')

 Information on package ‘somePkg’

Description:

Package:            somePkg
Title:              What the Package Does (One Line, Title Case)
Version:            0.0.0.9000
Authors@R:          person("First", "Last", , "first.last@example.co
...
Index:

my_add                  Add 2 numbers








(2) 使用原生R代码
=> R
> my_add2 = function(x, y){
  return (x + y)
}
> setwd('~/data/my_R_pkg/')
> package.skeleton(name="somePkg2", list="my_add2")
# Further steps are described in './somePkg2/Read-and-delete-me'.


$ cd ~/data/my_R_pkg/somePkg2
$ tree
.
|-- DESCRIPTION
|-- man
|   |-- my_add2.Rd
|   `-- somePkg2-package.Rd
|-- NAMESPACE
|-- R
|   `-- my_add2.R
`-- Read-and-delete-me
2 directories, 6 files


$ cat Read-and-delete-me 
* Edit the help file skeletons in 'man', possibly combining help files
  for multiple functions.
* Edit the exports in 'NAMESPACE', and add necessary imports.
* Put any C/C++/Fortran code in 'src'.
* If you have compiled code, add a useDynLib() directive to
  'NAMESPACE'.
* Run R CMD build to build the package tarball.
* Run R CMD check to check the package tarball.
Read "Writing R Extensions" for more information.

$ cd ..
$ R CMD INSTALL --build somePkg2
报错 
Error in Rd_info(db[[i]]) : 
  missing/empty \title field in '/home/wangjl/data/my_R_pkg/somePkg2/man/my_add2.Rd'
Rd files must have a non-empty \title.
See chapter 'Writing R documentation' in manual 'Writing R Extensions'.
* removing ‘/home/wangjl/R/x86_64-pc-linux-gnu-library/4.1/somePkg2’

$ vim somePkg2/man/my_add2.Rd
\title{
%%  ~~function to do ... ~~
 add 2 numbers
}

$ R CMD INSTALL --build somePkg2
# packaged installation of ‘somePkg2’ as ‘somePkg2_1.0_R_x86_64-pc-linux-gnu.tar.gz’

$ R CMD INSTALL somePkg2_1.0_R_x86_64-pc-linux-gnu.tar.gz 
# * DONE (somePkg2)


=> R
> library("somePkg2")
> my_add2(1,5)
[1] 6

> help(package='somePkg2')
                Information on package ‘somePkg2’
Description:

Package:       somePkg2
Type:          Package
Title:         What the package does (short line)
Version:       1.0
Date:          2021-11-27
Author:        Who wrote it
Maintainer:    Who to complain to <yourfault@somewhere.net>
Description:   More about what it does (maybe more than one line)
License:       What license is it under?
Built:         R 4.1.1; ; 2021-11-27 06:11:48 UTC; unix

Index:

my_add2                 add 2 numbers
somePkg2-package        What the package does (short line)



##############
$ R
> install.packages("~/data/my_R_pkg/somePkg_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# * DONE (somePkg)
> my_add()
Error in my_add() : could not find function "my_add"
> library("somePkg")
> my_add(1,9)
[1] 10








========================================
<bytecode: #>在R的内置函数定义中的含义
----------------------------------------
1. 看到有的函数末尾有 <bytecode: 0x55bd24e2d988>，什么意思？
> nchar
function (x, type = "chars", allowNA = FALSE, keepNA = NA) 
.Internal(nchar(x, type, allowNA, keepNA))
<bytecode: 0x55bd24e2d988>
<environment: namespace:base>

解释:
bytecode声明表明函数已由compiler包进行字节编译。所有的基本R函数都是字节编译的。字节编译函数几乎总是比非编译版本更快。

如果包的描述文件中包含ByteCompile: true，则包中的所有函数都将进行字节编译。


您可以编译自己的函数，如果你想：

f = function(x) x 
f_cmp = compiler::cmpfun(f) 
f 
# function(x) x 
f_cmp 
# function(x) x 
# <bytecode: 0x55cf9aa61860> 


或者，假定您正在从源安装软件包，可以在.Renviron 设置安装包时字节编译 R_COMPILE_PKGS=3。



ref:
http://cn.voidcc.com/question/p-bxdazadx-gx.html










========================================
R adv 高级理论
----------------------------------------

主要是还不能独立出去的琐碎知识点。

极客RrR<<-数据分析之道 https://www.jianshu.com/nb/22007361
	r<-高级|理论】
	R的符号和环境 https://www.jianshu.com/p/d9b4ce873dc8 
	R中的属性与类 https://www.jianshu.com/p/1a27afbd04b8
	R的函数 https://www.jianshu.com/p/7a3d027258bb




========================================
|-- 观察R是如何工作的
----------------------------------------
1. R中的一切皆对象，R表达式也是R对象。这意味着我们可以从语法上解析R表达式，或者部分地执行R表达式，来观察R是如何解释它们的。这对于了解R的工作机制或者调试R代码十分有用。

R解释器在执行语句时要经过几个步骤。
	- 第一步是从语法上解析语句，将其转化为合适的函数形式。
	- 第二步，按顺序执行这些函数。


(1) 我们可以查看R解释器是如何执行一个给定的表达式的。以下面代码片段为例：
> x = 1
> if (x > 1) "orange" else "apple"
[1] "apple"


(2) 我们可以用quote()函数演示上述表达式的解析过程。
该函数会从语法上解析它的参数，但并不执行。通过使用quote，R表达式会返回一个语言对象。

> quote(if (x > 1) "orange" else "apple")
if (x > 1) "orange" else "apple"

> typeof(quote(if (x > 1) "orange" else "apple"))
[1] "language"

    
(3) 表达式的语法树（parse tree）
针对语言对象的print函数返回的信息量非常有限，我们可以先将语言对象转化为列表。
通过观察列表形式展示的语言对象，我们就可以看出来R是如何执行一个表达式的了。

> quote(if (x > 1) "orange" else "apple")
if (x > 1) "orange" else "apple"
> as.list( quote(if (x > 1) "orange" else "apple") )
> as(quote(if (x > 1) "orange" else "apple"),"list")
[[1]]
`if`

[[2]]
x > 1

[[3]]
[1] "orange"

[[4]]
[1] "apple"


(4) 我们可以将typeof函数应用到列表中的所有元素上，以查看每个对象在语法树中的类型。
> lapply(as(quote(if (x > 1) "orange" else "apple"),"list"),typeof)
[[1]]
[1] "symbol"

[[2]]
[1] "language"

[[3]]
[1] "character"

[[4]]
[1] "character"

# 语句可以写为 lapply(quote(if (x > 1) "orange" else "apple"),typeof)，即忽略as函数，因为R会自动将语言对象强制转换为列表


可以看到if-then语句的一些片段没有包含在解析后的表达式中（尤其是else关键字）。
要注意，列表中的第一个项目是一个符号。在本例中，该符号指向的是if函数。
因此，虽然if-then语句的语法与函数命令不同，但R语句分析器会将表达式翻译为函数命令，再执行表达式。


(5) 函数名是第一个项目，剩下的项目是函数的参数。

> mean(iris$Sepal.Length)
[1] 5.843333
> quote(mean(iris$Sepal.Length))
mean(iris$Sepal.Length)
> as.list( quote(mean(iris$Sepal.Length)) )
[[1]]
mean

[[2]]
iris$Sepal.Length

> lapply(quote(mean(iris$Sepal.Length)), typeof)
[[1]]
[1] "symbol"

[[2]]
[1] "language"


(6) 对于常数而言，返回的列表中只有一个项目
> 1
[1] 1
> quote(1)
[1] 1
> as.list( quote(1) )
[[1]]
[1] 1

> lapply(quote(1), typeof)
[[1]]
[1] "double"


(7) 通过使用quote函数，我们发现，R语言中的很多结构只是函数命令的语法糖。

例如，假设我们要找向量x的第二个元素。标准的做法是使用表达式x[2]；还有另一种做法是把表达式替换成函数`[`(x,2)。这两种方式是等效的。

> x=1:5
> x
[1] 1 2 3 4 5

> x[2]
[1] 2
> `[`(x, 2)
[1] 2

> as.list(quote(x[2]))
[[1]]
`[`

[[2]]
x

[[3]]
[1] 2

> as.list(quote(`[`(x, 2)))
[[1]]
`[`

[[2]]
x

[[3]]
[1] 2


(8) deparse函数可以将语法树转化回合适格式的R代码。

> deparse(quote(`[`(x,2)))
[1] "x[2]"
> deparse(quote(x[2]))
[1] "x[2]"

这时是字符串，无法执行
> class(deparse(quote(x[2])) )
[1] "character"
> eval( deparse(quote(x[2])) )
[1] "x[2]"


(9) 可以使用 str2lang 把字符串变为 call 类型，然后使用 eval 执行 
> str2lang( deparse(quote(x[2])) )
x[2]
> class(str2lang( deparse(quote(x[2])) ))
[1] "call"
> eval(str2lang( deparse(quote(x[2])) ))
[1] 2

或者使用 str2expression 转为 expression 类型，然后使用 eval 执行
> str2expression( deparse(quote(x[2])) )
expression(x[2])
> class(str2expression( deparse(quote(x[2])) ))
[1] "expression"
> eval(str2expression( deparse(quote(x[2])) ))
[1] 2




ref:
https://www.jianshu.com/p/eb11a2a87d01
学习自《R核心技术手册》







========================================
R 内存泄漏
----------------------------------------
http://adv-r.had.co.nz/memory.html


A memory leak occurs when you keep pointing to an object without realising it. In R, the two main causes of memory leaks are formulas and closures because they both capture the enclosing environment. 


就是在使用 闭包 的时候，如果里面有复制的对象，请记着清除。
rm(obj)
gc()

否则会造成内存泄漏。


(2) 我总感觉我的立即执行函数也在泄漏内存。

(function(){
	obj2=obj;
	# do with obj2 
	
	rm(obj2)
	gc()
	return(xx)
})()



2) 测试 闭包
setClass("Person", slots=list(name="character",age="numeric", data="data.frame"), 
         prototype = list(name="NoName", age = 20))

p1=new("Person",name="XiaoMing")

big_num=1:1e7
p1@data=data.frame(
  id=big_num,
  value=paste0("v",big_num)
)

dim(p1@data)
#is68M, use 320M

(function(){
  p2=p1
  p2@name="Laowang"
  head(p2@data)
})()






3) 测试 R占用内存不能清空？

# after restart: total=144M
# 1. define class
setClass("Person", slots=list(name="character",age="numeric", data="data.frame"),
         prototype = list(name="NoName", age = 20))
#T=156M

# 2. get an Obj of the class
big_num=1:1e7
#T=158M
p1=new("Person",
       name="XiaoMing",
       data=data.frame(
         id=big_num,
         value=paste0("v",big_num)
       )
) #10s
#T=1.54G, is 752M
str(p1)
dim(p1@data)

rm(p1)
gc() #1.31G
gc(full=T) #1.31G
gc(verbose=T, reset=T)
#

rm(list = ls())
rm(list = ls(all.names = TRUE))
gc()

rm(list = ls(envir = globalenv()),envir = globalenv())
gc()

#









========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

