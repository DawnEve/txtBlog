R语言进阶-数据框

主要包括 data.frame 操作，及其进阶操作
1. 数据框基本操作
2. apply 家族函数。
3. dplyr 包 --> 详见专题 数据框清理


更多高级话题：
https://segmentfault.com/a/1190000004621068



========================================
公众号文章总结过的话题 及数据框相关资源
----------------------------------------
1. R语言 | 数据框data.frame操作一网打尽
https://mp.weixin.qq.com/s?__biz=MzU4MDAwODIyNw==&mid=2247483700&idx=1&sn=666b928c3af73456d369dcfaa352c0bd


2. R语言 | 详解高效批量处理apply族函数(apply lapply sapply vapply mapply tapply rapply eapply)
https://mp.weixin.qq.com/s?__biz=MzU4MDAwODIyNw==&mid=2247483727&idx=1&sn=7458d90846765ceae214726cdef540d6


2014年刚到, RStudio Blog 介绍dplyr 包已发布 (Introducing dplyr), 此包将原本 plyr 包中的 ddply() 等函数进一步分离强化, 专注接受dataframe对象, 大幅提高了速度, 
并且提供了更稳健的与其它数据库对象间的接口，还是Hadley Wickham 的新作, 并自称 a grammar of data manipulation。


R语言plyr包和dplyr包学习 (一句话概述)
https://blog.csdn.net/hill_night/article/details/45750641

数据处理包plyr和dplyr包的整理
https://blog.csdn.net/G090909/article/details/50769701

RNote__dplyr and plyr
https://blog.csdn.net/whjwindow/article/details/46654341

数据处理包plyr和dplyr包的整理
https://www.cnblogs.com/awishfullyway/p/6485250.html


R语言plyr包——超越apply族的数据分块处理包
https://blog.csdn.net/emy_zj/article/details/46508653



【R语言】必学包之dplyr包
https://blog.csdn.net/wltom1985/article/details/54973811


长宽转换仍然支持plyr中的melt/dcast函数以及tidyr中的gather/spread函数。



3. 精彩视频

R语言基础 https://www.imooc.com/learn/546







========================================
特殊数字的处理: 科学计数法
----------------------------------------

2. format()系列函数，科学计数法，返回的是字符串
> x=2640000000000; z<-format(x,scientific=TRUE,digit=3);z
[1] "2.64e+12"


# 任务: 保留3位小数

> round(3.1415926,3)
[1] 3.142


(1) 对于小数字
# round函数不能正确处理特别大或特别小的数字
> a=0.0123456789;
> round(a,3)
[1] 0.001

## formatC() formats numbers individually and flexibly using C style format specifications.
# 保留n位小数
> formatC(a, format = "e", digits = 3) #小写e
[1] "1.235e-02"

> formatC(a, format = "E", digits = 3) #使用大写E
[1] "1.235E-02"

> format(a,scientific=TRUE,digit=3) # 保留3位有效数字
[1] "1.23e-02"



(2) 对于大数字
> round(1415926,3)
[1] 1415926

> formatC(1415926, format = "E", digits = 3) 
[1] "1.416E+06"










========================================
数据框data.frame的增删改查(使用which过滤出需要的行，支持布尔运算&, |, !)
----------------------------------------
# http://www.cnblogs.com/studyzy/p/4316118.html

数据框(data.frame)在R中使用的十分广泛。只要你用read.table输入数据，基本都是data.frame类别的数据。

Data Frame一般被翻译为数据框，就像是R中的Excel表，由行和列组成。矩阵Matrix要求每个元素都必须存储同样类型的对象，而数据框data frame可以存储不同类型的对象，但每一列里面数据类型相同。

Data Frame每一列有列名，每一行也可以指定行名。如果不指定行名，那么就是从1开始自增的Sequence来标识每一行。

data frame常用的操作包括创建、筛选、取子集、获取值、修改、新增、删除、转置、遍历、连接合并、计算等。


##############
最佳实践/注意事项：
* 取矩阵子集必须使用 which()，不要偷懒！否则容易出各种问题！







##############
refer:
https://cos.name/cn/topic/12365/
http://www.cnblogs.com/W-Seven/p/5920331.html
http://www.cnblogs.com/studyzy/p/4316118.html

plyr包:http://www.bagualu.net/wordpress/archives/5519
dplyr包:https://www.cnblogs.com/shangfr/p/6110614.html

apply:http://www.cnblogs.com/studyzy/p/4355082.html




========================================
|-- 1.创建数据框
----------------------------------------
(1)使用已有向量建立数据框
patientID <- c(1:4)
age <- c(25,31,42,57)
diabetes <- c("Type1","Type2","Type3","Type4")
status <- c("Poor","Improved","Excellent","Poor")
patientdata <- data.frame(patientID,age,'diabetesType'=diabetes,status) #可以修改列名
patientdata
结果
patientID age diabetesType status
1 1 25 Type1 Poor
2 2 31 Type2 Improved
3 3 42 Type3 Excellent
4 4 57 Type4 Poor

(2)使用向量直接建立数据框
student<-data.frame(ID=c(11,12,13),Name=c("Devin","Edward","Wenli"),
  Gender=c("M","M","F"),Birthdate=c("1984-12-29","1983-5-6","1986-8-8"))
student
输出
ID   Name Gender  Birthdate
1 11  Devin      M 1984-12-29
2 12 Edward      M   1983-5-6
3 13  Wenli      F   1986-8-8


例: 用row.names参数直接为行命名
my_df1 <- data.frame(
  num = 1:3, 
  letter = LETTERS[1:3], 
  logic = c(T,F,T), 
  row.names = paste('row',1:3)  #paste参数sep设置连接符
)

my_df1
#       num letter logic
# row 1   1      A  TRUE
# row 2   2      B FALSE
# row 3   3      C  TRUE



(3)另外也可以使用read.table() read.csv()读取一个文本文件，返回的也是一个Data Frame对象。
读取数据库也是返回Data Frame对象。

比如：
text1=read.table('001.txt') #其中文本文件001.txt最后一行是空行，否则会报错
text2=read.table('001.txt',header=F)  #如果没有标题，用header设置
text3=read.table('001.txt',header=F,sep=",") #如果是逗号分隔的，则用sep设置（默认是tab分隔的）


APA=read.table("D:/UniqAPA.txt", 
     sep = '\t', #指定分隔符是tab
     row.names = 1,  #用第一列命名行名
     header=TRUE) #文件带有标题


(4)如果是从excel、txt中复制到内存的，可以直接读取内存。
text4=read.table('clipboard',header=T) #设置有标题




========================================
|-- 2.行名列名等属性
----------------------------------------

0. 最佳实践
(1) 更快的拿到子集的行名

peaks.to.plot <- rownames(subset(res.table.top, gene_name == "Cxcl12"))






1. 基本使用
(1)使用names、colnames函数可以查看列名、修改列名
> names(student)
[1] "ID"        "Name"      "Gender"    "Birthdate"
或者 colnames(student)

colnames(student)[2]="Mingzi" #修改列名
student
colnames(student)[2]="Name" #再改回来
student

Student
Error: object 'Student' not found
#注意：R区分大小写，仅仅差一个单词的大小写都会判断为不一样



(2)如果要查看行名，需要用到 row.names/rownames 函数。
> row.names(student)
[1] "1" "2" "3"

> rownames(student)
[1] "1" "2" "3"

这里我们希望将ID作为行名，那么可以这样写：
row.names(student)<-student$ID
更简单的办法是在初始化date.frame的时候，有参数row.names可以设置行名的向量。


也可以用dimnames()查看行名和列名。


(3)获取行列维度的函数
nrow(student)
#[1] 3
dim(student)
#[1] 3 4
ncol(student)
#[1] 4

(4)获取数据框的结构信息
str(student)
# 'data.frame':	3 obs. of  4 variables:
#  $ ID       : num  11 12 13
#  $ Name     : Factor w/ 3 levels "Devin","Edward",..: 1 2 3
#  $ Gender   : Factor w/ 2 levels "F","M": 2 2 1
#  $ Birthdate: Factor w/ 3 levels "1983-5-6","1984-12-29",..: 2 1 3


(5)显示数据框前几行信息
这对掌握大型数据框的结构很重要。
head(student,n=2)
tail(student)







========================================
|-- 3. 获取元素、取子集: subset()/sql语句/which()/遍历/apply()
----------------------------------------
与Matrix一样，使用[行Index,列Index]的格式可以访问具体的元素。

(1)访问某行，从1计数。
student[1,] #返回第一行

(2)访问某列，从1计数。可以使用[[或者$来访问，返回的是Vector类型的。
c2=student[,2] #返回第二列
class(c2) #"factor"

student[[2]] #等价写法：双中括号
student$Name #等价写法：使用列名
student[["Name"]] #等价写法：使用列名

第一行用户的名字
> student[1,]$Name
[1] Devin
Levels: Devin Edward Wenli



(3)返回【子列】数据框
student[c('Name','Birthdate')] #如果取不连续的列，可以用列名
student[,c(1,3)] #也可以用向量，取列时可省略逗号(不建议省略，防止误解)

v1=student[2]
## class(v1) # "data.frame"
student[1:3] #取前3列


(4)返回【子行】数据框
student[1:3,] #1到3行
student[c(1,3),] #1和3行


(5)使用attach和detach函数可以使得访问列时不需要总是跟着变量名在前面。
比如要打印所有Name，那么可以写成：
rownames(student)=student$Name
student #用名字命名每行。
输出
#  ID   Name Gender  Birthdate
#  Devin  11  Devin      M 1984-12-29
#  Edward 12 Edward      M   1983-5-6
#  Wenli  13  Wenli      F   1986-8-8

student['Devin',] #输出Devin行 Devin 11 Devin      M 1984-12-29

attach(student)
print(Name) #也就是只能识别列名
print(Devin) #报错
detach(student)



(6)用with函数写法上更简洁：
with(student,{print(Gender)})

#使用局部变量
with(student,{
  n<-Birthdate
  print(n)
})

n #Error: object 'n' not found

这里的n作用域只在大括号内，
如果想在with函数中对全局的变量进行赋值，那么需要使用<<-这样一个运算符。

先添加一个新列Age，就是现在的年减去生日的年。
下文会讲解该语法。
student<-within(student,{
  #as.integer(format(Sys.Date(),"%Y")) #固定时间
  Age=2005-as.integer(format.Date(Birthdate,"%Y"))
})





(7)查询与子集-使用which对行过滤filter
查询一个Date Frame，返回一个满足条件的子集，这相当于数据库中的表查询，是非常常见的操作。

1)使用行和列的Index来获取子集是最简单的方法，前面已经提到过。
2)如果我们使用布尔向量，配合which函数，可以实现对行的过滤。

比如我们要查询所有Gender为F的数据，那么我们首先对student$Gender==“F”，得到一个布尔向量:FALSE FALSE  TRUE,

然后使用which函数可以将布尔向量中TRUE的Index返回，所以我们的完整查询语句就是：

boys=student[which(student$Gender=="M"),]
boys

注意这里列Index并没有输入，如果我们只想知道所有女生的年龄，那么可以改为：
student[which(student$Gender=="M"),"Age"]
student[which(student$Gender=="M"),c("Age","Name")]


3)which可以进行逻辑运算
#性别为男，且年龄大于21
student[which(student$Gender=="M" & student$Age>21),c("Age",'Name')]

#性别为男，或年龄小于21
student[which(student$Gender=="M" | student$Age<21),c("Age",'Name')]

#年龄是21或22岁的
student[which(student$Age==21 | student$Age==22),]


4)subset函数过滤
这样的查询写法还是复杂了点，可以直接使用subset函数，那么查询会简单些，比如我们把查询条件改为年龄<30的女性，查姓名和年龄，那么查询语句为：
subset(student,Gender=="F" & Age>20 ,select=c("Name","Age"))

subset(student,Name!='Devin' | Age>21) #名字不是Devin或者年龄大于21岁。




(8)使用SQL查询Data Frame
对于使用了多年SQL的人来说，如果能够直接写SQL语句对Data Frame进行查询操作，那真是太酸爽了，
结果还真有这么一个包：sqldf。

同样是前面的需求，对应的语句就是：
library(sqldf)
result<-sqldf("select Name,Age from student where Gender='F' and Age>20")
result

result<-sqldf("select Name,Age from student where Gender='M' and Age>20")
result
result[1,][1]



(9)遍历数据框
常规解决不了的就用遍历吧。
虽然效率可能不理想，但至少先work。

#获取data frame的维度：
x=dim(student)[1]
y=dim(student)[2]

#遍历每个元素
for(i in 1:x){
  for(j in 1:y){
    print(student[i,j])
  }
}

#对每行进行遍历，找出4-9月出生的学生
student
tmp=c()
for(i in 1:x){
  birthday=student[i,4]
  
  birthday=as.character(birthday)
  month=strsplit(birthday,'-')[[1]][2]#字符分割函数
  #month=as.integer(substr(birthday,6,7))#原来能把"2a"转成数字2，现在版本的R直接报警告。
  
  if(month>=4 && month<=9){
    tmp=c(tmp,i)
  }
}
tmp
print(student[tmp,])


#还有更好的方法吗？使用apply家族函数，能避免循环。


(10)apply家族函数，比循环速度快。
#http://www.cnblogs.com/cloudtj/articles/5523811.html
#apply(X, MARGIN, FUN, ...) MARGIN: 按行计算或按按列计算，1表示按行，2表示按列

rs=apply(student,1,function(x){
  #print("结果")
  birthday=x["Birthdate"]
  month=as.integer(substr(birthday,6,7))
  if(month>=4 && month<=9){
    return(x[["Name"]])
  }
})
rs2=unlist(rs)
rs3=as.character(rs2)
rs3
student[rs3,]

关于apply家族函数的用法见相关专题。


(11)使用table函数获得列联表
#生成变量Gender和Age的列联表
table(student$Gender,student$Age)
#    19 21 22
#  F  1  0  0
#  M  0  1  1





========================================
|-- 4.修改：增删改、转置、melt宽变长
----------------------------------------
(1)查看和修改数据类型
str(student)
输出
#  'data.frame':	3 obs. of  4 variables:
#    $ ID       : num  11 12 13
#  $ Name     : Factor w/ 3 levels "Devin","Edward",..: 1 2 3
#  $ Gender   : Factor w/ 2 levels "F","M": 2 2 1
#  $ Birthdate: Factor w/ 3 levels "1983-5-6","1984-12-29",..: 2 1 3

默认情况下，字符串向量都会被自动识别成Factor，也就是说，ID是数字类型，其他的3个列都被定义为Factor类型了。

显然这里Name应该是字符串类型，Birthdate应该是Date类型，我们需要对列的数据类型进行更改：

student$Name<-as.character(student$Name)
student$Birthdate<-as.character(student$Birthdate)
str(student) #Birthdate已经是字符型了 $ Birthdate: chr  "1984-12-29" "1983-5-6" "1986-8-8"


一般修改factor到日期或数字，需要先转换为字符串
student$Birthdate<-as.Date(student$Birthdate)

更改数据框所有数据的格式
df<- lapply(df,as.numeric)



(2) 添加新列
对于以及存在的student对象，我们希望增加Age列，该列是根据Birthdate算出来的。

首先需要知道怎么算年龄。我们可以使用日期函数Sys.Date()获得当前的日期，
然后使用format函数获得年份，然后用两个年份相减就是年龄。

好像R并没有提供几个能用的日期函数，我们只能使用format函数取出年份部分，然后转换为int类型相减。

#写法1【不好】
#时间日期总结
#http://blog.csdn.net/xiangyong58/article/details/50458532
student$Age=as.Date(Sys.Date())-student$Birthdate
str(student)
student$Age=as.integer(student$Age/365) #这处理的不好，应该获取年，减去当前年
str(student)

#写法2
student$Age2<-as.integer(format(Sys.Date(),"%Y")) - as.integer(format(student$Birthdate,"%Y"))
str(student)

这样写似乎太长了，我们可以用within函数，这个函数和之前提到过的with函数类似，可以省略变量名，
不同的地方是within函数可以在其中修改变量，也就是我们这里增加Age列：

#写法3
student<-within(student,{
  Age3=as.integer(format(Sys.Date(),"%Y"))-as.integer(format(Birthdate,"%Y")) #因为做过日期格式转换，所以没有报错
})
str(student)


#写法4,也可以使用cbind函数添加新列
rs=cbind(student, Age4=c(1,2,3) )
rs



(3)删除行
student2=student[-1,] #减去第1行
student2


(4)增加列
student$class=c("art","math","law")
str(student)


(5)删除列
student2 <- subset(student, select = -Age )
student2 #已经删除了不靠谱的age列

student3=student2[,-7] #减去第7列

colNum=dim(student2)[2]
student4=student2[,-colNum] #减去最后一列
student4


(6)行列转置
因为数据框每一列要是同一种数据类型，所以转置只适用于单一数据类型的data frame。
先使用矩阵转置，然后再改变数据类型为数据框。

data1=data.frame(id=c(1,2,3,4),weight=c(10,20,30,40))
rownames(data1)=c("a",'b','c','d') #设置标题
data1
#   id weight
# a  1     10
# b  2     20
# c  3     30
# d  4     40

data2=t(data1) #转置
data3=as.data.frame(data2) #转化为数据框格式
class(data2)#[1] "matrix"
class(data3)#[1] "data.frame"
data3
#         a  b  c  d
# id      1  2  3  4
# weight 10 20 30 40

rm(data1,data2,data3)






(7)保持信息量不变，多列的合并与拆分
https://blog.csdn.net/u013421629/article/details/72954490


1)reshape2包 的melt函数合并多列(宽变长):
detach("package:reshape") #必须移除已加载的reshape包。它和reshape2语法不一致。
(.packages()) #查看当前加载的包

library(reshape2)

sales<-data.frame(
  Name = c("苹果","谷歌","脸书","亚马逊","腾讯"),
  Company = c("Apple","Google","Facebook","Amozon","Tencent"),
   Sale2013 = c(5000,3500,2300,2100,3100),
   Sale2014 = c(5050,3800,2900,2500,3300),
   Sale2015 = c(5050,4000,3200,2800,3700),
   Sale2016 = c(6000,4800,4500,3500,4300)
)

sales
#  Name  Company Sale2013 Sale2014 Sale2015 Sale2016
#1   苹果    Apple     5000     5050     5050     6000
#2   谷歌   Google     3500     3800     4000     4800
#3   脸书 Facebook     2300     2900     3200     4500
#4 亚马逊   Amozon     2100     2500     2800     3500
#5   腾讯  Tencent     3100     3300     3700     4300


sales2<-melt(sales,
  id.vars=c("Name","Company"),#保留变量，如果为空，则使用所有非数字变量。
  #measure.vars=  使用到的变量列，如果为空，则使用id外的所有列。
  variable.name="Year", #新变量的列名
  value.name="Sale" #值的列名
)

dim(sales2)
str(sales2)
head(sales2)
##     Name  Company     Year Sale
## 1   苹果    Apple Sale2013 5000
## 2   谷歌   Google Sale2013 3500
## 3   脸书 Facebook Sale2013 2300
## 4 亚马逊   Amozon Sale2013 2100
## 5   腾讯  Tencent Sale2013 3100
## 6   苹果    Apple Sale2014 5050




2)三列 => 数据透视表: reshape包cast函数
library("reshape") 
sales3=cast(sales2, Company~Year, value="Sale")
str(sales3)
sales3

sales4=as.data.frame(sales3)
str(sales4)
sales4
##    Company Sale2013 Sale2014 Sale2015 Sale2016
## 1   Amozon     2100     2500     2800     3500
## 2    Apple     5000     5050     5050     6000
## 3 Facebook     2300     2900     3200     4500
## 4   Google     3500     3800     4000     4800
## 5  Tencent     3100     3300     3700     4300













========================================
|-- 5.连接数据框(merge/cbind/rbind)、拆分数据框
----------------------------------------
(1)使用merge函数横向连接
https://www.cnblogs.com/emanlee/p/4435900.html

按照rowname融合
de <- merge(d, e, by=0, all=TRUE) # merge by row names (by=0 or by="row.names")


对于数据库来说，对多表进行join查询是一个很正常的事情，那么在R中也可以对多个Data Frame进行连接，这就需要使用merge函数。

比如除了前面创建的student对象外，我们再创建一个score变量，记录了每个学生的科目和成绩：

score<-data.frame(
	SID=c(11,11,12,12,13),
	Course=c("Math","English","Math","Chinese","Math"),
	Score=c(90,80,80,95,96)
)
score
输出
##  SID  Course Score
##  1  11    Math    90
##  2  11 English    80
##  3  12    Math    80
##  4  12 Chinese    95
##  5  13    Math    96


这里的SID就是Student里面的ID，相当于一个外键，现在要用这个ID进行inner join操作，那么对应的R语句就是：
result<-merge(student,score,by.x="ID",by.y="SID")
result
##   ID   Name Gender  Birthdate  Course Score
## 1 11  Devin      M 1984-12-29    Math    90
## 2 11  Devin      M 1984-12-29 English    80
## 3 12 Edward      M   1983-5-6    Math    80
## 4 12 Edward      M   1983-5-6 Chinese    95
## 5 13  Wenli      F   1986-8-8    Math    96
## 6 13  Wenli      F   1986-8-8 Chinese    85

正如我们期望的一样join在了一起。类似于数据库中的inner join.









(2)使用cbind横向连接 （column bind，就是列更多了）
student
score
rs=cbind(student,score[1:3,])   ##按照行连接，行数必须相同
rs #没有外键关联，直接连接。

就本例来说，这不是我们想要的结果。


可用于向一个数据框中插入一列。





(3)使用rbind纵向连接（row bind，就是行更多了）
除了join，另外一个操作就是union，这也是数据库常用操作，那么在R中如何将两个列一样的Data Frame Union联接在一起呢？

虽然R语言中有union函数，但是不是SQL的Union的意思，我们要实现Union功能，需要用到rbind函数。

rbind的两个Data Frame必须有相同的列，比如我们再创建一个student2，将两个变量rbind起来：
student2<-data.frame(ID=c(21,22),Name=c("Yan","Peng"),Gender=c("F","M"),Birthdate=c("1982-2-9","1983-1-16"),Age=c(32,31))
student3<-data.frame(ID=c(11,12,13),Name=c("Devin","Edward","Wenli"),Gender=c("M","M","F"),Birthdate=c("1984-12-29","1983-5-6","1986-8-8"),Age=c(32,31,30))
student2
student3

##按照列把行连接起来。列数必须相同，列名要一致，顺序不要求一致。
studentAll=rbind(student2,student3)
studentAll

(4)按照性别把student拆成两个数据框
#方法1
df=student
df
df_M=df[df$Gender=="M",]
df_F=df[df$Gender=="F",]

#方法2
df_sub=split(df, df$Gender)
df_sub

可以按照Gender的种类把数据分成几个不同的data.frame






========================================
|-- 6.数据框的计算，按某列求平均值(数据透视表)
----------------------------------------
student<-data.frame(ID=c(11,12,13),Name=c("Devin","Edward","Wenli"),Gender=c("M","M","F"),Birthdate=c("1984-12-29","1983-5-6","1986-8-8"))

score<-data.frame(SID=c(11,11,12,12,13,13),Course=c("Math","English","Math","Chinese","Math","Chinese"),Score=c(90,80,80,95,96,85))

student
score
result<-merge(student,score,by.x="ID",by.y="SID")
result

(1)求各科目平均分
courseMean=data.frame(course=c(),avg=c(),sum=c(),count=c())
for(i in unique(score$Course)){
  subgrp=score[which(score$Course==i),][['Score']] #分组
  #求行的平均数
  count=length(subgrp);#计数
  sum=sum(subgrp) #总分
  avg=mean(subgrp) #平均分
  #合并到科目平均数df
  courseMean=rbind(courseMean,data.frame(course=c(i),avg=c(avg),sum=c(sum),count=c(count)))
}
courseMean
##    course      avg sum count
## 1    Math 88.66667 266     3
## 2 English 80.00000  80     1
## 3 Chinese 90.00000 180     2



(2)求每个人的平均分。修改分组，其他不变化
stuMean=data.frame(course=c(),avg=c(),sum=c(),count=c())
for(i in unique(result$Name)){ #循环(modify)
  subgrp=score[which(result$Name==i),][['Score']] #分组(modify)
  #求行的平均数
  count=length(subgrp);#计数
  sum=sum(subgrp) #总分
  avg=mean(subgrp) #平均分
  #合并到科目平均数df
  stuMean=rbind(stuMean,data.frame(course=c(i),avg=c(avg),sum=c(sum),count=c(count)))
}
结果
stuMean
##   course  avg sum count
## 1  Devin 85.0 170     2
## 2 Edward 87.5 175     2
## 3  Wenli 90.5 181     2



(3)使用tapply函数
# http://bbs.pinggu.org/thread-3934132-1-1.html
# tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE)

result
tapply(result[,6],result[,5],mean)
输出
#  Chinese  English     Math 
#  90.00000 80.00000 88.66667


tapply(result[,6],result[,5],sum) #总数
tapply(result[,6],result[,c(3,5)],mean) #数据透视表:性别
tapply(result[,6],result[,c(2,5)],sum) #两个维度的数据透视表
输出
#         Course
#  Name     Chinese English Math
#  Devin       NA      80   90
#  Edward      95      NA   80
#  Wenli       85      NA   96




(4)数据透视表
# http://bbs.pinggu.org/thread-3797604-1-1.html
1)
dat1=data.frame(host=c("A","A","A","E","E","G"),
                guest=c("C","B","D","Q","F","W"),
                num=c(2,1,2,3,0,2))

tapply(dat1[,3],dat1[,c(1,2)],mean)


2)
#或者使用reshape包<见 4(7)>
library(reshape)
dat2=cast(dat1,host~guest,value="num")
dat2


3)
能用colMeans函数吗？
不能达到本题所需目标。
#colMeans只能求2列及以上的数据列的平均数。
colMeans(result[,c(1,6)])
结果
#      ID    Score 
#12.00000 87.66667 


4)
使用sql生成数据透视表  https://www.douban.com/note/609129045/
head(sales2,n=10)
#      Name  Company     Year Sale
# 1    苹果    Apple Sale2013 5000
# 2    谷歌   Google Sale2013 3500
# 3    脸书 Facebook Sale2013 2300
# 4  亚马逊   Amozon Sale2013 2100
# 5    腾讯  Tencent Sale2013 3100
# 6    苹果    Apple Sale2014 5050
# 7    谷歌   Google Sale2014 3800
# 8    脸书 Facebook Sale2014 2900
# 9  亚马逊   Amozon Sale2014 2500
# 10   腾讯  Tencent Sale2014 3300


library(sqldf)
#求均值，R中是mean函数，SQL是avg。
sqldf("select Name, avg(Sale) as avg_Sales from sales2 group by Name")
##     Name avg_Sales
## 1 亚马逊      2725
## 2   脸书      3225
## 3   腾讯      3600
## 4   苹果      5275
## 5   谷歌      4025


#求总销售额，并按销售总额倒序排列
sqldf("select Name, sum(Sale) as sum_Sales from sales2 group by Name order by sum_Sales DESC")
#其中，order by 是排序，desc是排倒序，结果为
##    Name sum_Sales
## 1   苹果     21100
## 2   谷歌     16100
## 3   腾讯     14400
## 4   脸书     12900
## 5 亚马逊     10900



(5) 专门数据预处理的dplyr包

http://plyr.had.co.nz
plyr包的作者是Hadly Wickham。这个包的名字来自apply + r。由此可知，该包的主要作用是提供一些apply函数。它提供一些方便的函数用来对向量，列表，数组的各个成员进行函数调用，并以给定的格式返回数据。熟悉这个包以后，将会让你的R代码更加简洁。The split-apply-combine strategy for R.


https://dplyr.tidyverse.org
https://github.com/tidyverse/dplyr
2014年刚到, RStudio Blog 介绍dplyr 包已发布 (Introducing dplyr), 此包将原本 plyr 包中的 ddply() 等函数进一步分离强化, 专注接受dataframe对象, 大幅提高了速度, 并且提供了更稳健的与其它数据库对象间的接口，还是Hadley Wickham 的新作, 并自称 


dplyr is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges:
- mutate() adds new variables that are functions of existing variables
- select() picks variables based on their names.
- filter() picks cases based on their values.
- summarise() reduces multiple values down to a single summary.
- arrange() changes the ordering of the rows.



本文略。

本文提到的data frame处理有关的R包: sqldf包、reshape包、reshape2包、plyr包、dplyr包。




========================================
|-- 实现数据透视表--基于sqldf包、dplyr包、reshape2包
----------------------------------------
不同的人群可以使用不同的实现方式，比较熟悉SQL的可以使用sqldf包，喜欢呈现方式与Excel中一致的可以使用reshape2包中的函数，人生苦短，开心就好。

1. 数据准备
##交易失败月份
TransFailTime <- rep(c("2018-01", "2018-02", "2018-03"), each = 16)
##分店
Branch <- rep(c("branch_1", "branch_2"), times = 24)
##交易失败原因
TransFailCode <- rep(c("Failed_code01","Failed_code02","Failed_code04",
                        "Failed_code05","Failed_code06",
                        "Failed_code07","Failed_code08",
                        "Failed_code09"), each = 2, times = 3)
##交易失败客户
set.seed(123)
TransFailCust <- sample(500:1000, 48, replace = T)
 
data <- data.frame(TransFailTime, Branch, TransFailCode, TransFailCust)
data 

#   TransFailTime   Branch TransFailCode TransFailCust
#1        2018-01 branch_1 Failed_code01           914
#2        2018-01 branch_2 Failed_code01           962





2. 案例分析
这里使用R语言中的sqldf、reshape2、以及dplyr尝试着一些案例分析，直接上代码

(1)统计每月交易失败的人数
##dplyr包
library(dplyr)
data %>% 
  group_by(TransFailTime) %>%
  dplyr::summarise(cnt_cust = sum(TransFailCust))
 
##sqldf包
library(sqldf)
sqldf::sqldf("select TransFailTime, sum(TransFailCust) cnt_cust from 
    data group by TransFailTime")
 
##reshape2包
reshape2::acast(data, TransFailTime ~ ., sum) ##没有行标签
reshape2::dcast(data, TransFailTime ~ ., sum) ##有行标签

注意：不同的分析可以选择不同的聚合函数，只需替换上述3个包中的函数：例如：需要每个月分店的平均交易失败人数，dplyr和reshape2包中将sum换成mean函数，sqldf中将sum换成avg。



(2)每月每个分店交易失败的人数
##dplyr包
data %>% 
  dplyr::group_by(TransFailTime, Branch) %>%
  dplyr::summarise(cnt_cust = sum(TransFailCust))
 
##sqldf包
sqldf("select TransFailTime, branch, sum(TransFailCust) cnt_cust from 
    data  group by TransFailTime, branch")
 
##reshape2包
acast(data, TransFailTime ~ Branch, sum) ##不带行标签
dcast(data, TransFailTime ~ Branch, sum) #带行标签
注意：
使用reshape2包中可以实现行汇总和列汇总，只需在函数中加入margins = "TransFailTime"或者margins = "Branch"或者margins = TRUE。



(3)筛选：每月交易失败码是Failed_code01、Failed_code02、Failed_code03人数
公司比较关注由于个别交易失败码导致的交易失败的人数，例如Failed_code01、Failed_code02、Failed_code03：

##dplyr包
data %>% 
  dplyr::filter(TransFailCode == "Failed_code01" | TransFailCode == "Failed_code02" | 
                  TransFailCode == "Failed_code03") %>%
  dplyr::group_by(TransFailTime, TransFailCode) %>%
  dplyr::summarise(cnt_cust = sum(TransFailCust))
 
##sqldf包
sqldf::sqldf("select TransFailTime, TransFailCode, sum(TransFailCust) cnt_cust from 
    data where TransFailCode in ('Failed_code01','Failed_code02','Failed_code03') 
             group by TransFailTime,TransFailCode")
 
##reshape2包
reshape2::acast(data, TransFailTime ~ TransFailCode, sum, 
                subset = .(TransFailCode == "Failed_code01" | TransFailCode == "Failed_code02" | TransFailCode == "Failed_code03"))
 
reshape2::dcast(data, TransFailTime ~ TransFailCode, sum, 
                subset = .(TransFailCode == "Failed_code01" | TransFailCode == "Failed_code02" | TransFailCode == "Failed_code03"))






ref:
https://blog.csdn.net/weixin_39751959/article/details/85342389






========================================
|-- 7.数据框按照某一列排序: order函数
----------------------------------------
造一个数据框。
>a=data.frame(a1=c(20,10,30,40,20,50,40),a2=c(7,4,5,6,5,6,4),a3=c(1,2,3,4,5,6,7))
a
##  a1 a2 a3
## 1  20  7  1
## 2  10  4  2
## 3  30  5  3
## 4  40  6  4
## 5  20  5  5
## 6  50  6  6
## 7  40  4  7


(1) 使用order函数
>order(a$a1)
[1] 2 1 5 3 4 7 6
order()返回的是什么？向量排序前的位置索引，和sort.list功能一样。

然后使用该索引对数据框重排：
a[order(a$a1),]
##   a1 a2 a3
## 2 10  4  2
## 1 20  7  1
## 5 20  5  5
## 3 30  5  3
## 4 40  6  4
## 7 40  4  7
## 6 50  6  6

按照a2升序、a1降序排序:
>a[order(a$a2,-a$a1),] #a2 desc, a2 asc
##   a1 a2 a3
## 7 40  4  7
## 2 10  4  2
## 3 30  5  3
## 5 20  5  5
## 6 50  6  6
## 4 40  6  4
## 1 20  7  1

按a1升序，a2降序（a1相同的基础上）排列
http://cos.name/cn/topic/104496



(2)使用decreasing参数定升降
> order(a$a1)
[1] 2 1 5 3 4 7 6
> order(a$a1,decreasing = T)
[1] 6 4 7 3 1 5 2

比如data.frame的rt（name,sex,age,score）按照score进行排序，行也跟着变动
>-rt[order(rt[,4],decreasing=T),]



(3)使用sql语句
library(sqldf)
sqldf("select * from a order by a1, a2 desc")






========================================
|-- 8.使用cbind在数据框指定位置插入一列、transform()函数在末尾新建列
----------------------------------------
1.问题：把y这个向量，插入到数据框的第2-3列之间，其他列不受影响。
思路：把数据框分成前两列，和从第三列开始到最后一列。然后加入新列，cbind横向连接成一个新数据框。

y<-1:4
dataE1 <-data.frame(x1=c(1,3,5,7), x2=c(2,4,6,8),x3=c(11,12,13,14),x4=c(15,16,17,18))
dataE1
dataE2<-cbind(dataE1[,1:2],y,dataE1[,3:ncol(dataE1)]) #合并之前、新列、之后。
dataE2






2. 用 transform() 函数创建新列, 且可一次性定义多个变量
> library(ggplot2)
> df=diamonds
> df=transform(df, total=price*carat, volum=x*y*z); head(df)
  carat       cut color clarity depth table price    x    y    z  total    volum
1  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43  74.98 38.20203
2  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31  68.46 34.50586










========================================
|-- 9.数据框的去重: unique 和 duplicated
----------------------------------------

1.unique主要是返回一个把重复元素或行给删除的向量、数据框或数组

> x <- c(3:5, 11:8, 8 + 0:5)
> x
 [1]  3  4  5 11 10  9  8  8  9 10 11 12 13
> unique(x)
[1]  3  4  5 11 10  9  8 12 13
> unique(x, fromLast = TRUE)
[1]  3  4  5  8  9 10 11 12 13    #排序后的

> a
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    4
[3,]    1    3    5
[4,]    1    2    3

> unique(a)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    4
[3,]    1    3    5   #去除重复的最后一行





2.duplicated主要是判定向量或数据框中的元素是否重复，它返回一个元素（行）是不是重复的逻辑向量
> duplicated(a)
[1] FALSE FALSE FALSE  TRUE    # 返回一个是否重复的逻辑判断

> a[!duplicated(a),]
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    4
[3,]    1    3    5                         #去除重复的最后一行



(2)如果把第二列有重复的去除，则需要加一个索引

> index <- duplicated(a[,2])
> index
[1] FALSE  TRUE FALSE  TRUE
> a[!index,]
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    3    5       














3. 实例
(1) 基于无先后顺序的两列去重复
url: https://www.zhihu.com/question/468715913

distinct=function(arr, x1,x2){
  print(dim(arr))
  # rm dup 1
  tmp1=arr[!duplicated(arr),]
  print(dim(tmp1)) #8 2
  tmp1
  
  # rm dup 2
  refArr=c()
  newDf=NULL;
  for(i in 1:nrow(tmp1)){
    str1=paste(tmp1[i,x1],tmp1[i,x2], sep="|")
    str2=paste(tmp1[i,x2],tmp1[i,x1], sep="|")
    if(!(str1 %in% refArr)){
      refArr=c(refArr, str1, str2)
      newDf=rbind(newDf, tmp1[i,])
    }else{
      next;
    }
  }
  print(dim(newDf)) #6 2
  newDf
}

#################
# test
arr=letters[5:7]
set.seed(2021)
tmp100=data.frame(
  X=sample(arr, 30, replace = T),
  Y=sample(arr, 30, replace = T)
)

distinct(tmp100, 1,2)
#[1] 30  2
#[1] 9 2
#[1] 6 2
#   X Y
#1  g e
#2  f g
#3  f f
#5  g g
#14 e e
#22 f e


不知道有没有向量形式的。



## 构建一个更复杂的案例，发现用dplyr包要快的多
set.seed(2021)
arr=paste0(sample(letters, 2e4, replace = T),sample(letters, 2e4, replace = T),
       sample(letters, 2e4, replace = T),sample(letters, 2e4, replace = T))
set.seed(2021)
tmp100=data.frame(
  c1=sample(arr, 1e5, replace = T),
  c2=sample(arr, 1e5, replace = T)
)
dim(tmp100)
head(tmp100)
system.time({
  rs1=distinct(tmp100, 1,2)
}) # 1000多秒
#    user   system  elapsed 
# 1133.706    0.159 1133.626
dim(rs1)


library(dplyr)
df=tmp100
dim(df)
system.time({
	rs2=df %>% rowwise() %>% 
	  mutate(class = paste0(sort(c(c1, c2)), collapse = '')) %>% 
	  group_by(class) %>% 
	  slice_sample() %>% select(-class)
})
# user  system elapsed 
# 4.659   0.004   4.663 
dim(rs2)
head(rs2)












refer:
https://blog.csdn.net/qq_35242986/article/details/68927909







========================================
|-- 10.数据筛选、排序 match(x, table)函数, x %in% table 更直观
----------------------------------------
1. 用法:
(1) match(x, table, nomatch = NA_integer_, incomparables = NULL)
match returns a vector of the positions of (first) matches of its first argument in its second.
返回一个列表，就是第一个参数在第二个参数中的位置。

Match () Function in R, returns the position of match i.e. first occurrence of elements of Vector 1 in Vector 2. 
If an element of vector 1 doesn’t match any element of vector 2 then it returns “NA”. Output of Match Function in R will be a vector.


(2) x %in% table
%in% is a more intuitive interface as a binary operator, which returns a logical vector indicating if there is a match or not for its left operand.
返回一个逻辑值数组，表示第一个数组的元素是否在第二个列表中。







2. 用法 
(1)
match(c(1, "TRUE"), c(T, 0, "1"))
# [1] 3 1

a1=c(1,2,3,4,5,6)
a2=c(2,3,4,5,6,8,10)
rs=match(a1, a2);rs #[1] NA  1  2  3  4  5 # 返回的是a1在a2中的位置，没找到就返回NA
a2[rs]  #[1] NA  2  3  4  5  6 #返回的是位置的变量 


(2) wgcna 包的代码
femaleSamples = rownames(datExpr); #获取行名
traitRows = match(femaleSamples, allTraits$Mice); #返回行名在第二个矩阵中的位置
datTraits = allTraits[traitRows, -1]; #从第二个矩阵获取子矩阵，保持第一个矩阵的行名； 去掉第一列。
rownames(datTraits) = allTraits[traitRows, 1]; #把第一列当新矩阵的行标题



(3) seurat中，给定基因list，返回原矩阵中存在的基因。
1)
HB.genes <- c("HBA1","HBA2","HBB","HBD","HBE1","HBG1","HBG2","HBM","HBQ1","HBZ")
HB_m <- match(HB.genes, rownames(pbmc@assays$RNA)) 
HB.genes <- rownames(pbmc@assays$RNA)[HB_m]
HB.genes <- HB.genes[!is.na(HB.genes)]

HB.genes  ## 'HBA1''HBA2''HBB''HBD''HBG1''HBG2''HBQ1'



2) 使用 %in% 达到同样目的，更简练。
HB.genes <- c("HBA1","HBA2","HBB","HBD","HBE1","HBG1","HBG2","HBM","HBQ1","HBZ")

HB_m <- HB.genes %in% rownames(pbmc@assays$RNA)
HB.genes <- HB.genes[HB_m]

HB.genes  ## 'HBA1''HBA2''HBB''HBD''HBG1''HBG2''HBQ1'




(4) 练习题：根据矩阵2对矩阵1进行注释
1) 单细胞数据，一个矩阵是表达值矩阵data，一个矩阵是分类信息meta。
给定一个表达矩阵子集，注释上分类信息。








ref:
https://blog.csdn.net/woodcorpse/article/details/84927296




========================================
|-- 11.数据汇总/透视/提炼
----------------------------------------
汇总、透视、提炼、凝炼，对数据处理来说这些词的意思都差不多。
R语言提供了很多函数处理这些事情，还有一些软件包也提供了非常方便的数据汇总功能，方法不胜枚举。
summary是获取数据概要最常用的函数。
这里只简单介绍rowSums, colSums, rowMeans, colMeans, table、apply、lapply、sapply、vapply、tapply、mapply、by 和 aggregate 等函数的用法。


1. 行列求和、平均值和频度
rowSums, colSums, rowMeans, colMeans 可以简单理解为按行或列求和或求均值，table把数字或字符当成因子统计频度，都相当简单：
> a <- array(rep(1:3, each=3), dim=c(3,3))
> rowSums(a)



2.apply系列函数：

如果我们关心的不仅仅是求和、平均值和频度这些指标的计算，可以用apply系列函数来处理，这些函数包括apply、lapply、sapply、vapply、tapply和mapply。这些函数的使用可以从目标数据类型和返回值类型两个方面进行了解。

详见专题 apply家族函数。




3.aggregate函数
详见下文。






ref:
https://blog.csdn.net/u014801157/article/details/24372429


========================================
|-- 12.R中的无穷大、无定义和缺失值，缺失值的处理，异常值处理
----------------------------------------
1. 需要处理的类型
(1).无穷大
R中的无穷大用Inf表示（即Infinity，无穷大），负无穷表示为-Inf。要检查一个数是否为无穷，可以使用is.finite()或者is.infinite()函数，当一个数是有限大时，第一个函数将返回TRUE，第二个函数将返回FALSE。

(2).无定义
R中的无定义数用NaN表示，即“Not a Number（非数）”。不过在R中，R实际上是把NaN视作一个数的，当其参与运算时，返回结果总是NaN。我们可以使用is.nan()函数来检测计算结果有无定义，但是需要注意的是，对于NaN而言，is.finite()和is.infinite()都会返回FALSE。

(3).缺失值
R中使用保留字NA来表示缺失的数据，即“Not Available（不可用）”。对于NA，is.na()函数会返回TRUE；但是is.finite、is.infinite()和is.nan()则会返回FALSE。







2. 处理方法
(1). 使用0填充缺失值
d[is.na(d)] <- 0



(2). 统计非缺失值的个数

# 每一行非NA的个数
df=iris[,1:4]
apply(df, 1, function(x){ sum(!is.na(x)) })

# 每一列缺失值的个数
apply(df, 2, function(x){ sum(!is.na(x)) })
# Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
#          150          150          150          150  


推荐一个函数：complete.case()可用来识别矩阵或数据框中没有缺失值的行！



(3)缺失值检测
关于缺失值的检测应该包括：缺失值数量、缺失值比例、缺失值与完整值数据筛选

sum(is.na(data))                #查看data里缺失值个数
sum(is.na(data$DINNER_PRICE)    #查看data里维度DINNER_PRICE缺失值个数
data=data[!is.na(data$DINNER_PRICE),]     #删除DINNER_PRICE缺失样本
data=na.omit(data)              #去除有NA的行(方法1)
data[complete.cases(data),]     #去除有NA的行(方法2)
data[complete.cases(data[,5:6]),]    #只过滤第5列，第6列中含有NA的行




(4)缺失值检测-整体

sum(complete.cases(data))   #不含缺失值记录 
sum(!complete.cases(data))    #含缺失值记录
mean(!complete.cases(data))       #有缺失值记录比例  
head(data[!complete.cases(data),])  #筛选出有缺失值的记录 
sum(is.na(data))     #数据集中缺失值总计数量



(5) 缺失值检测-维度检测
sum(complete.cases(data$CHANNEL_GRADE))   #不含缺失值 
sum(!complete.cases(data$CHANNEL_GRADE))    #含缺失值
mean(!complete.cases(data$CHANNEL_GRADE))       #有缺失值占比
head(data[!complete.cases(data$CHANNEL_GRADE),])    #筛选出CHANNEL_GRADE有缺失值的记录



(6)把缺失值数据集、非缺失值数据集分开

sub <- which(is.na(data$CHANNEL_GRADE))  #识别CHANNEL_GRADE中缺失值所在行数  
inputfile1 <- inputfile[-sub,]   #将数据集分成完整数据和缺失数据两部分  
inputfile2 <- inputfile[sub,] 



(7) 只保留没有 IFN的行
getFiniteRows=function(df){
    keep=apply(df, 1, function(x){
        sum(is.finite(x))==ncol(df)
    })
    rs=df[keep,]
    print(dim(rs))
    rs
}
# 4103 165
gRatio.BC=getFiniteRows(gRatio.BC)
# 397 165







3.异常值（outlier）
指样本中的个别值，其数值明显偏离它（或他们）所属样本的其余观测值,也称异常数据，离群值。

i)目前人们对异常值的判别与剔除主要采用物理判别法和统计判别法两种方法。

ii)物理判别法就是根据人们对客观事物已有的认识，判别由于外界干扰、人为误差等原因造成实测数据值偏离正常结果，在实验过程中随时判断，随时剔除；
统计判别法是给定一个置信概率，并确定一个置信限，凡超过此限的误差，就认为它不属于随机误差范围，将其视为异常值剔除。当物理识别不易判断时，一般采用统计识别法。


(1)异常值检验
方法1：箱线图检验离群值

sp=boxplot(hon_01$CHARGE_T,boxwex=0.7)  
title("异常值检测箱线图")  
xi=1.1  
sd.s=sd(hon_01[complete.cases(hon_01),]$CHARGE_T)  
mn.s=mean(hon_01[complete.cases(hon_01),]$CHARGE_T)  
points(xi,mn.s,col="red",pch=18)  
arrows(xi, mn.s - sd.s, xi, mn.s + sd.s, code = 3, col = "pink", angle = 75, length = .1)  
text(rep(c(1.05,1.05,0.95,0.95),length=length(sp$out)),labels=sp$out[order(sp$out)],  
     sp$out[order(sp$out)]+rep(c(150,-150,150,-150),length=length(sp$out)),col="red")


方法2：当前值在平均值的±3个标准差之外
a<-matrix(1:12,nrow=3) 
list_mean<- apply(a,2,mean)        #按列求均值
list_sd<-apply(a,2,std)            #按列求标准差
max<-list_mean+3*(list_sd)         #按列求最大值
min<-list_mean-3*list_sd           #按列求最小值
apply(a,2,mean,na.rm=TRUE)         #如果有空值，可以加入na.rm=TRUE,忽略掉空值


方法3：
3.1、计算下四分位数、上四分位数和四分位距

QL <- quantile(value, probs = 0.25)
QU <- quantile(value, probs = 0.75)
QU_QL <- QU-QL

3.2、找出异常点

which(value > QU + 1.5*QU_QL)
value[which(value > QU + 1.5*QU_QL)]


(2)异常值处理
盖帽法：整行替换数据框里99%以上和1%以下的点，将99%以上的点值=99%的点值；小于1%的点值=1%的点值

q1 <- quantile(hon_01$USER_AGE, 0.01)        #取得时1%时的变量值  
q99 <- quantile(hon_01$USER_AGE, 0.99)       #取得时99%时的变量值
hon_01[hon_01$USER_AGE < q1,]$USER_AGE <- q1  
hon_01[hon_01$USER_AGE > q99,]$USER_AGE < -q99  
summary(hon_01$USER_AGE)      #盖帽法之后，查看数据情况  



ref:
R 缺失值处理 https://blog.csdn.net/jinruoyanxu/article/details/51969556
R中的无穷大、无定义和缺失值总结: https://blog.csdn.net/jisuanjiguoba/article/details/75220275
R语言缺失值高级处理方法 https://blog.csdn.net/weixin_30502965/article/details/95722358
基于R语言的缺失值及异常值处理 https://blog.csdn.net/yawei_liu1688/article/details/79175433



========================================
|-- 13. 对符合条件的位置重新赋值 (报错: replacement has 1 row, data has 0)
----------------------------------------

1. 直接上例子
Example <- data.frame(Col1 = c(1, 2, 3, 4, 5),
                      COl2 = c("A", "B", "C", "D", "E"))
> Example
  Col1 COl2
1    1    A
2    2    B
3    3    C
4    4    D
5    5    E

# 第1列大于3的改为3;
Example[Example$Col1 > 3,]$Col1 <- 3 #works fine, 2 rows were selected

# 第1列小于-5的改为0;(被改动位置是0个则报错)
> Example[Example$Col1 < -5,]$Col1 <- 0 #gets an error, 0 rows were selected
Error in `$<-.data.frame`(`*tmp*`, Col1, value = 0) : 
  replacement has 1 row, data has 0

#
(1)解决方法1:
if(sum(Example$Col1 < -5) > 0){
    Example[Example$Col1 < -5,]$Col1 <- 0
}
缺点: 太繁琐了。


(2) 推荐写法1
Example$Col1[Example$Col1 < -5] <- 0

(3) 推荐写法2
Example[Example$Col1 < -5, "Col1"] <- 0






2. 对角线元素赋值为0
iris.cor = cor(iris[,1:4])
> iris.cor
             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length    1.0000000  -0.1175698    0.8717538   0.8179411
Sepal.Width    -0.1175698   1.0000000   -0.4284401  -0.3661259
Petal.Length    0.8717538  -0.4284401    1.0000000   0.9628654
Petal.Width     0.8179411  -0.3661259    0.9628654   1.0000000



library(pheatmap)
pheatmap(iris.cor)

diag(iris.cor)=0  #对角线元素赋值为0
pheatmap(iris.cor)

> iris.cor
             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length    0.0000000  -0.1175698    0.8717538   0.8179411
Sepal.Width    -0.1175698   0.0000000   -0.4284401  -0.3661259
Petal.Length    0.8717538  -0.4284401    0.0000000   0.9628654
Petal.Width     0.8179411  -0.3661259    0.9628654   0.0000000






ref:
https://stackoverflow.com/questions/47001491/r-dataframe-error-replacement-has-1-row-data-has-0







========================================
|-- 14. 从数据框/矩阵中找到大于或小于某个值得位置，指定阈值，给出符合的坐标
----------------------------------------

问题：矩阵中的最值在什么位置？
> max(dat.matrix)
[1] 7.9

> which.max(dat.matrix)
Error in which.max(dat.matrix) : 
  'list' object cannot be coerced to type 'double'





1. 根据数据的长短选择按行或者按列

dat.matrix = iris[, 1:4]
head(dat.matrix)

# 按列输出
sapply(1:ncol(dat.matrix), function(y){
  # get 1 column
  tmp = dat.matrix[, y]
  
  # which greater than ?
  x=which(tmp > 5)  ########### edit here

  # output
  if( length(x) != 0 ){
    cat("(x=", x, " | y=", y, ") | value=", dat.matrix[x, y], "\n")
  }
})


# 按行输出
tmp = sapply(1:nrow(dat.matrix), function(x){
  # get 1 row
  tmp = dat.matrix[x, ]
  
  # which greater than ?
  y=which(tmp > 5)  ########### edit here
  
  # output
  if( length(y) != 0 ){
      cat("(x=", x, ", y=", y, ") | value=", paste(dat.matrix[x, y]), "\n")
      # print(dat.matrix[x, y])
  }
})

输出：
(x= 1 , y= 1 ) | value= 5.1 
(x= 6 , y= 1 ) | value= 5.4 
(x= 11 , y= 1 ) | value= 5.4 
(x= 15 , y= 1 ) | value= 5.8 
(x= 16 , y= 1 ) | value= 5.7 
(x= 17 , y= 1 ) | value= 5.4 
(x= 18 , y= 1 ) | value= 5.1 
(x= 19 , y= 1 ) | value= 5.7 
(x= 20 , y= 1 ) | value= 5.1 
(x= 21 , y= 1 ) | value= 5.4 
(x= 22 , y= 1 ) | value= 5.1 
(x= 24 , y= 1 ) | value= 5.1 
...
(x= 147 , y= 1 ) | value= 6.3 
(x= 148 , y= 1 3 ) | value= 6.5 5.2 
(x= 149 , y= 1 3 ) | value= 6.2 5.4 
(x= 150 , y= 1 3 ) | value= 5.9 5.1








========================================
|-- df操作常见bugs: R语言首行一定要执行 options(stringsAsFactors=F)
----------------------------------------

1. 取子列时，一定要使用字符，而不能是因子
不确定时使用 as.character

br.data2=br.data[, as.character(df[df$reads<=th2,]$cell) ] 
#debug: 有factor时一定要注意转换，和检验是否去掉了

(2) 复现bug: 

# step1.根据某个指标筛选细胞
dat=iris[,1:4]
dat$cell=paste0('cell',1:150)
dat$cell=factor(dat$cell) #起因：不经意间 str 变 factor
# check
head(dat)
str(dat)
# 根据条件，筛选细胞
sel=dat[which(dat$Sepal.Width>4),]$cell
sel #factor
# [1] cell16 cell33 cell34
# 150 Levels: cell1 cell10 cell100 cell101 cell102 cell103 cell104 cell105 cell106 cell107 ... cell99
# 转为字符串 
sel2=as.character(sel)
sel2 #character
# [1] "cell16" "cell33" "cell34"
# 
# step2.造 表达矩阵 3行150列
dat2=as.data.frame( matrix(1:(3*150), 3, 150, byrow = T) )
colnames(dat2)=paste0("cell", 1:150)
# check
head(dat2[, 1:6])
# 
# step3.对 表达矩阵 取子集
dat2[,  sel] #用因子时，不符合预期
#   cell59 cell78 cell79
# 1     59     78     79
# 2    209    228    229
# 3    359    378    379
# 
dat2[, as.character( sel ) ] #用字符串时，符合预期
#   cell16 cell33 cell34
# 1     16     33     34
# 2    166    183    184
# 3    316    333    334
# 
# check 第n行第2列是否>4
dat[59,2] # [1] 2.9 #not >4
dat[16,2] # [1] 4.4 # >4

可见，用不用 as.character(f) 取出的子集完全不同。
本例子中，用 factor 类型取子集的结果完全错误！而且系统不报错。





(3) 解决方法: 
防止 字符串 自动转为 因子。

#less 1.txt
#a	1
#b	2
# stringAsFactors=FALSE
rs=read.table("D:/Temp/1.txt")
str(rs) #factor
#(1)
rs2=read.table("D:/Temp/1.txt", stringsAsFactors=F)
str(rs2) #chr
#

(2) 在代码第一行加上 
options(stringsAsFactors=F)







========================================
R语言的数据转换: split – apply – combine 模式
----------------------------------------
下面要讨论的是数据转换的一个常用模式：split – apply – combine。

（1） for 显式循环,但是这种方式的缺点也很明显，代码长，易出错，也难以并行化；
（2） 拜R语言的向量计算特点所赐，在R当中，大多数问题不需要用显示循环方式，而代之以base包中的apply函数族及其它的一些函数，直接对向量，数组，列表和数据框实现循环的操作。
（3） Hadley Wickham大神觉得apply族还是不够简洁，所以开发了pylr包，以更少的代码来解决split – apply – combine问题。


1 split – apply – combine模式

大型数据集通常是高度结构化的，结构使得我们可以按不同的方式分组，有时候我们需要关注单个组的数据片断，有时需要聚合不同组内的信息，并相互比较。
因此对数据的转换，可以采用split – apply – combine模式来进行处理：
split：把要处理的数据分割成小片断；
apply：对每个小片断独立进行操作；
combine：把片断重新组合。

利用这种模式解决问题在很多数据分析或编程问题中都会出现:
Python当中，是map( ),filter( )，reduce( );
Google 有MapReduce；
R 当中是split( ),*apply( ),aggregate( )…,以及plyr包。

在本篇（上）中，介绍R的base包中给出的解决split – apply – combine模式的一些函数，在本篇（下）中，介绍plyr包






ref:
https://site.douban.com/182577/widget/notes/10567181/note/245088040/




========================================
|-- split() 函数： Divide into Groups and Reassemble
----------------------------------------
Divide into Groups and Reassemble | 重新组合

函数split()可以按照分组因子，把向量，矩阵和数据框进行适当的分组。它的返回值是一个列表，代表分组变量每个水平的观测。这个列表可以使用sapply(),lappy()进行处理（apply – combine步骤），得到问题的最终结果。

只是分组，既可以对向量分组，也可以对数据框分组

Usage
split(x, f, drop = FALSE, ...)
## Default S3 method:
split(x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...)

split(x, f, drop = FALSE, ...) <- value
unsplit(value, f, drop = FALSE)

参数
x: 一个待分组的向量或者data frame
f: 函数，一个factor或者list（如果list中元素交互作用于分组中），以此为规则将x分组
drop: 逻辑值，如果f中的某一个level没有用上则被弃用
value: 一个储存向量的list，其形式类似于分组完成之后返回的那个list



例1：
> d <- data.frame(gender=c("M","M","F","M","F","F"),age=c(47,59,21,32,33,24),income=c(55000,88000,32450,76500,123000,45650), over25=rep(c(1,1,0), times=2))
> d
  gender age income over25
1      M  47  55000      1
2      M  59  88000      1
3      F  21  32450      0
4      M  32  76500      1
5      F  33 123000      1
6      F  24  45650      0

> split(d$income, list(d$gender,d$over25)) #将income按照gender、over25分组
$`F.0`
[1] 32450 45650
$M.0
numeric(0)
$F.1
[1] 123000
$M.1
[1] 55000 88000 76500


然后配合 apply 家族函数求每组的mean
> lapply(split(d$income, list(d$gender,d$over25)),mean)
$F.0
[1] 39050

$M.0
[1] NaN

$F.1
[1] 123000

$M.1
[1] 73166.67





例2：
> split(1:10, 2)
$`2`
 [1]  1  2  3  4  5  6  7  8  9 10

> split(1:10, 1:2) #分成2组
$`1`
[1] 1 3 5 7 9

$`2`
[1]  2  4  6  8 10

> split(1:10, 1:5) #分成5组
$`1`
[1] 1 6

$`2`
[1] 2 7

$`3`
[1] 3 8

$`4`
[1] 4 9

$`5`
[1]  5 10




========================================
 |-- 高阶函数: apply家族函数
----------------------------------------
高阶函数就是操作函数的函数。可能参数是函数，也可能返回函数。具有一定的抽象性。

#apply, lapply, sapply, tapply, sweep: 替代循环的函数

1.apply函数
作用：Apply Functions Over Array Margins对阵列行或者列使用函数
用法：apply(X, MARGIN, FUN, ...)

(1)按行求和:apply第二个参数为1
a=array(c(1,2,3,4,5,6),c(2,3))
a
#[,1] [,2] [,3]
#[1,]    1    3    5
#[2,]    2    4    6

#一行代码搞定
apply(a,1,sum) #[1]  9 12

#fn内用循环实现的话
rs=apply(a,1,function(data){ #1是按行传入。
  sum=0
  for (i in data) {
    sum =sum+i
  }
  print(sum)
  return(sum)
})

print(rs) #[1]  9 12 结果是个数组



(2)按列求和:apply第二个参数为2
a=array(c(1,2,3,4,5,6),c(2,3))
a
#[,1] [,2] [,3]
#[1,]    1    3    5
#[2,]    2    4    6

#一行代码搞定
apply(a,2,sum) #[1]  3  7 11

#fn内用循环实现的话
rs=apply(a,2,function(data){ #2是按列传入。
  sum=0
  for (i in data) {
    sum =sum+i
  }
  print(sum)
  return(sum)
})

print(rs) #[1]  3  7 11 结果是个数组
str(rs)  #num [1:3] 3 7 11






2.lapply函数
作用：Apply a Function over a List or Vector 对列表或者向量使用函数
用法：lapply(X, FUN, ...) X表示一个向量或者表达式对象，其余对象将被通过as.list强制转换为list

b=list(x=1:10,y=exp(-3:3),z=c(TRUE,FALSE));b
#$x
#[1]  1  2  3  4  5  6  7  8  9 10

#$y
#[1]  0.04978707  0.13533528  0.36787944  1.00000000  2.71828183  7.38905610 20.08553692

#$z
#[1]  TRUE FALSE

rs=lapply(b,mean)

print(rs)
str(rs)
#List of 3
# $ x: num 5.5
# $ y: num 4.54
# $ z: num 0.5






3.sapply函数
描述：Apply a Function over a List or Vector 对列表或者向量使用函数
用法：sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

这是一个用户友好版本，是lapply函数的包装版。该函数返回值为向量、矩阵，如果simplify="array"，且合适的情况下，将会通过simplify2array()函数转换为阵列。sapply(x, f, simplify=FALSE, USE.NAMES=FALSE)返回的值与lapply(x,f)是一致的。

USE.NAMES逻辑值，如果为TRUE，且x没有被命名，则对x进行命名。

a=array(c(1,2,3,4,5,6),c(2,3))
a

b=list(x=1:10,y=exp(-3:3),z=c(TRUE,FALSE));b

rs=sapply(b,function(data){
  print(data)
})

print(rs)
str(rs)



4.sweep主要用于array的一些分类计算，而apply更多的是矩阵计算，data.frame也行。array是高于2维的数据


http://blog.csdn.net/yitianguxingjian/article/details/51820758





========================================
|-- R语言数据整合- aggregate() 将数据进行分组（按行）然后每组做统计，有点类似sql语言中的group by
----------------------------------------

这个函数的功能比较强大，它首先将数据进行分组（按行），然后对每一组数据进行函数统计，最后把结果组合成一个比较nice的表格返回。根据数据对象不同它有三种用法，分别应用于数据框（data.frame）、公式（formula）和时间序列（ts）：

aggregate(x, by, FUN, ..., simplify = TRUE)
aggregate(formula, data, FUN, ..., subset, na.action = na.omit)
aggregate(x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption("ts.eps"), ...)

我们通过 mtcars 数据集的操作对这个函数进行简单了解。mtcars 是不同类型汽车道路测试的数据框类型数据：



1. 形式1: by= 分组

# aggregate这个函数比较有意思，常用的带入方式是：
# aggregate(aDataFrame, by = list(vector1,vector2), FUN = aFunction)
# 作用就是基于by指定的变量做分组，计算FUN分别统计每个组的结果。


## S3 method for class 'data.frame'
aggregate(x, by, FUN, ..., simplify = TRUE, drop = TRUE)
## x：待折叠的数据 by:统计标量   FUN 折叠计算  

例1:
> aggregate(diamonds,by=list(cutType=diamonds$cut), FUN=mean) #by 必须是list
##     cutType     carat cut color clarity    depth    table    price        x        y        z
## 1      Fair 1.0461366  NA    NA      NA 64.04168 59.05379 4358.758 6.246894 6.182652 3.982770
## 2      Good 0.8491847  NA    NA      NA 62.36588 58.69464 3928.864 5.838785 5.850744 3.639507
## 3 Very Good 0.8063814  NA    NA      NA 61.81828 57.95615 3981.760 5.740696 5.770026 3.559801
## 4   Premium 0.8919549  NA    NA      NA 61.26467 58.74610 4584.258 5.973887 5.944879 3.647124
## 5     Ideal 0.7028370  NA    NA      NA 61.70940 55.95167 3457.542 5.507451 5.520080 3.401448


# 例2: 
> fby1 <- factor(mtcars$cyl)
> fby2 <- factor(mtcars$gear)
> aggregate(x = mtcars, by = list(cyl_G=fby1, gear_G=fby2), FUN = "mean")
  cyl_G gear_G    mpg cyl     disp       hp     drat       wt    qsec  vs   am gear     carb
1     4      3 21.500   4 120.1000  97.0000 3.700000 2.465000 20.0100 1.0 0.00    3 1.000000
2     6      3 19.750   6 241.5000 107.5000 2.920000 3.337500 19.8300 1.0 0.00    3 1.000000
3     8      3 15.050   8 357.6167 194.1667 3.120833 4.104083 17.1425 0.0 0.00    3 3.083333
4     4      4 26.925   4 102.6250  76.0000 4.110000 2.378125 19.6125 1.0 0.75    4 1.500000
5     6      4 19.750   6 163.8000 116.5000 3.910000 3.093750 17.6700 0.5 0.50    4 4.000000
6     4      5 28.200   4 107.7000 102.0000 4.100000 1.826500 16.8000 0.5 1.00    5 2.000000
7     6      5 19.700   6 145.0000 175.0000 3.620000 2.770000 15.5000 0.0 1.00    5 6.000000
8     8      5 15.400   8 326.0000 299.5000 3.880000 3.370000 14.5500 0.0 1.00    5 6.000000






2. 还可以使用表达式
## S3 method for class 'formula'
aggregate(formula, data, FUN, ...,
          subset, na.action = na.omit)
## 第一个参数也可以输入表达式

(1)例
> aggregate(price~cut,diamonds, FUN=mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542




(2)
> aggregate(cbind(mpg,hp) ~ cyl+gear, mtcars, FUN=mean)
  cyl gear    mpg       hp
1   4    3 21.500  97.0000
2   6    3 19.750 107.5000
3   8    3 15.050 194.1667
4   4    4 26.925  76.0000
5   6    4 19.750 116.5000
6   4    5 28.200 102.0000
7   6    5 19.700 175.0000
8   8    5 15.400 299.5000


公式 cbind(mpg,hp) ~ cyl+gear 表示使用 cyl 和 gear 的因子组合对 cbind(mpg,hp) 数据进行操作。


(3) 例3
> aggregate(. ~ Species, data = iris, mean)
     Species Sepal.Length Sepal.Width Petal.Length Petal.Width
1     setosa        5.006       3.428        1.462       0.246
2 versicolor        5.936       2.770        4.260       1.326
3  virginica        6.588       2.974        5.552       2.026






========================================
reshape2包的melt(wideData)和dcast(longData)实现数据长宽转变
----------------------------------------
和上面重复，但是太常用了，保留冗余。


介绍4个函数，其中melt()、dcast()来自reshape2包，
gather()、spread()来自tidyr包
https://blog.csdn.net/cyydjt/article/details/82889984



1.reshape2 简介
reshape2是由Hadley Wickham编写的R包，可以轻松地在宽格式（wide-format）和长格式（long-format）之间转换数据。
reshape2R包主要有两个主要的功能：melt和cast
	melt：将wide-format数据“熔化”成long-format数据；
	cast：获取long-format数据“重铸”成wide-format数据。
这两个命名十分形象，方便记忆，你可以想象成你在处理金属。当你熔化金属成液体滴下时，金属会被拉长（long-format）。如果你把金属它铸成一个模子，它就会变宽（wide-format）。


一般我们实验记录的数据格式（大多习惯用宽表格记录数据）和我们后期用R绘图所用到的数据格式往往不一样，例如ggplot2、plyr，还有大多数建模函数lm()、glm()、gam()等经常会使用长表格数据来作图，这时用reshape2包来转换实验记录的宽表格数据会十分方便。





2.以R自带的空气质量数据集airquality为例。

head(airquality)
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4



2.1 melt()宽变长 Wide- to long-format data: the melt function

(1)默认情况使用全部数据列
library(reshape2)     #  首先加载一下reshape2包
aql <- melt(airquality) # 命名取首字母：[a]ir [q]uality [l]ong format
## No id variables; using all as measure variables

head(aql)  # 查看数据前6列
#  variable value
#1    Ozone    41
#2    Ozone    36

tail(aql)   # 查看数据后6列
#    variable value
#917      Day    29
#918      Day    30


(2)如果只想使用某些列，则使用id.vars=c("")来去除指定的列，只将其他数据做变形。
aql <- melt(airquality, id.vars = c("Month", "Day"))
head(aql)
#  Month Day variable value
#1     5   1    Ozone    41
#2     5   2    Ozone    36


(3)如果想控制数据列的列名，则使用variable.name和value.name指定
aql <- melt(airquality, id.vars = c("Month", "Day"),
            variable.name = "climate_variable", 
            value.name = "climate_value")
head(aql)
#  Month Day climate_variable climate_value
#1     5   1            Ozone            41
#2     5   2            Ozone            36
#3     5   3            Ozone            12




******
melt实例: 基因表达矩阵宽变长
https://stackoverflow.com/questions/26277198/ggplot2-histogram-binwidth

aa=data.frame(
  A=c( 6305, 37610, 15507 ),
  B=c(159214,  36565,  49019),
  C=c(44724, 19901, 27441),
  geneSymbol=c("gene1", "gene2", "gene3")
)
aa
#      A      B     C geneSymbol
#1  6305 159214 44724      gene1
#2 37610  36565 19901      gene2
#3 15507  49019 27441      gene3

d2=melt(aa, id.vars = "geneSymbol",#id列是保留的
        measure.vars=c("C","A","B"),#数据列，会合并为一列
        variable.name = "sample", #分类列名
        value.name = "expression")#数据列名
d2
#  geneSymbol sample expression
#1      gene1      C      44724
#2      gene2      C      19901
#3      gene3      C      27441
#4      gene1      A       6305
#5      gene2      A      37610
#6      gene3      A      15507
#7      gene1      B     159214
#8      gene2      B      36565
#9      gene3      B      49019


省略形式例子：
plotData <- melt(df, id.vars = "group", measure.vars = c("p1","p2")  )













2.2 Long- to wide-format data: the cast functions
首先使用dcast函数将上面转换后的宽数据转换成长数据。用month + day ~ variable告诉dcast月份和日期是变量，转换成的长数据与原始数据除了变量列的序号不一样，其他都一致。

aql <- melt(airquality, id.vars = c("Month", "Day"))

> head(aql) #可见，variable一列有很多变量名，value是其值;
  Month Day variable value
1     5   1    Ozone    41
2     5   2    Ozone    36
...
611     9  29     Temp    76
612     9  30     Temp    68


aqw <- dcast(aql, Month + Day ~ variable)
> head(aqw)  #和原来的数据完全一样，只是列的顺序不同。
  Month Day Ozone Solar.R Wind Temp
1     5   1    41     190  7.4   67
2     5   2    36     118  8.0   72

> head(airquality) # original data
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2



(2) 长变宽 例2：
> dat
    X A B
1  45 1 1
2  75 1 2
3  30 1 3
4  40 1 4
5  50 2 1
6  50 2 2
7  40 2 3
8  48 2 4
9  35 3 1
10 65 3 2
11 50 3 3
12 53 3 4


> library(tidyr)
> dataW=spread(dat, key=B, value=X);dataW #把B列拆开成行，X列是数据
  A  1  2  3  4
1 1 45 75 30 40
2 2 50 50 40 48
3 3 35 65 50 53

使用dcast不能得到这个结果，还是我没用对？



refer:
https://blog.csdn.net/qazplm12_3/article/details/83618497
https://blog.csdn.net/cyydjt/article/details/82889984





========================================
|-- wide - loang 长宽转变函数:tidyr::pivot_longer / tidyr::pivot_wider
----------------------------------------
1. wide to long 

> library(reshape2)
> head(airquality)
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6

指出想要变长的列:
> d1=tidyr::pivot_longer(airquality, cols=c( "Ozone", "Solar.R", "Wind", "Temp" )); head(d1)
# A tibble: 6 × 4
  Month   Day name    value
  <int> <int> <chr>   <dbl>
1     5     1 Ozone    41  
2     5     1 Solar.R 190  
3     5     1 Wind      7.4
4     5     1 Temp     67  
5     5     2 Ozone    36  
6     5     2 Solar.R 118  
> dim(d1)
[1] 612   4





对比: 指出想要保留的列，其他列(融化)变长
> aql <- melt(airquality, id.vars = c("Month", "Day"))
> aql
    Month Day variable value
1       5   1    Ozone    41
2       5   2    Ozone    36
3       5   3    Ozone    12
4       5   4    Ozone    18
> dim(aql)
[1] 612   4




2. long to wide
> head(d1)
# A tibble: 6 × 4
  Month   Day name    value
  <int> <int> <chr>   <dbl>
1     5     1 Ozone    41  
2     5     1 Solar.R 190  
3     5     1 Wind      7.4
4     5     1 Temp     67  
5     5     2 Ozone    36  
6     5     2 Solar.R 118  


指出要保留的列名:
> d2=tidyr::pivot_wider(d1, id_cols=c("Month", "Day")); head(d2)
# A tibble: 6 × 6
  Month   Day Ozone Solar.R  Wind  Temp
  <int> <int> <dbl>   <dbl> <dbl> <dbl>
1     5     1    41     190   7.4    67
2     5     2    36     118   8      72
3     5     3    12     149  12.6    74
4     5     4    18     313  11.5    62
5     5     5    NA      NA  14.3    56
6     5     6    28      NA  14.9    66


> head(airquality)
  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6





========================================
apply家族函数操作数据框(矩阵)的方法和示例
----------------------------------------
主要是 do.call 和apply以及各种分类方式的配合使用。
怎么节省代码，怎么提高效率？




========================================
|-- 对数据进行测序深度标准化，和log2标准化
----------------------------------------
log2之前要加1，防止底数为0报错。


# Tested. Passed.
getNormalizedCts <- function ( ctsPath ) {
    cts <- read.table ( ctsPath , header = T , as.is = T )
    apply ( cts , 2 , function ( x ) { log2 ( ( 10^6 ) * x / sum ( x ) + 1 ) })
}


解释说明:
传入记基因表达计数矩阵cts，行为基因，列为细胞。
然后是apply函数按照列(第2个参数是2)处理，处理方式在匿名函数中定义。

匿名函数
function ( x ) {
	log2 ( ( 10^6 ) * x / sum ( x ) + 1 ) 
}
输入的x是cts的一列数据，用x表示每个值，用sum(x)表示每个值的和 <==不好理解，好好看，记死了！
R函数默认返回最后一行，返回的还是原始数据结构，只是每列做了处理: 除以整个细胞内的总reads，乘以10^6，加上1，再取2取对数。




========================================
|-- 香农信息熵(Shannon Entropy)
----------------------------------------

孤立系统的熵只增不减，熵增定律。
系统内温度平衡后，不会再有热力学交换，这时候熵达到最大。

#Entropy H = sum( -pi*log(pi) ) 
- 有人用 ln(), 也有人用 log2()
- pi为此物种个体数占总个体数比例，pi>0, sum(pi)=1


#混乱态
a=c(1/100, 4/100,95/100)
sum(-a*log10(a)) #[1] 0.09708018

#平衡后，熵增了， n=3
a=c(1/3,1/3,1/3)
sum(-a*log10(a)) #0.4771213

# 更细分后的平衡 n=4
a=rep(1/4, 4)
sum(-a*log10(a)) #0.60206

# n=10000
a=rep(1/10000, 10000)
sum(-a*log10(a)) #4


生命以负熵为食。
可以理解为吃了之后，能保持温度高于外界，熵变低了。
等去世了，和环境温度一致了，熵在最高点。
为了抗拒熵增，生命就需要捕食。






1.
##  calculate entropy 
entropy <- apply(knn[[group]], 1, function(x){
	freq_batch = table(x)/length(x)
	freq_batch_positive = freq_batch[freq_batch > 0]
	shannon <- -sum(freq_batch_positive * log(freq_batch_positive))/
		log(length(levels(as.factor(x))))
})




2. 输入表达counts矩阵(列为细胞，行为基因)，输出每个细胞的熵;

cts=data.frame(
  cell1=c(0,0,0,10),
  cell2=c(0,0,5,5),
  cell3=c(0,3,3,4),
  cell4=c(1,1,1,7),
  cell5=c(2.5,2.5,2.5,2.5),
  cell6=c(1,1,1,1)
)

getEntropy <- function ( cts ) {
  #print(cts)
  prop=apply(cts, 2, function(x){ x/sum(x)})
  #print(prop)
  entropy = apply( -prop*log10(prop+1e-100), 2, sum )
  #
  df=data.frame(
    cid=names(entropy),
    entropy=as.numeric(entropy)
  )
  row.names(df)=df$cid
  #
  return(df)
}
entropy=getEntropy(cts)
dim(entropy)
head(entropy)

#         cid   entropy
# cell1 cell1 0.0000000
# cell2 cell2 0.3010300
# cell3 cell3 0.4729033
# cell4 cell4 0.4084314
# cell5 cell5 0.6020600
# cell6 cell6 0.6020600






========================================
|-- 把namedxx写成df形式
----------------------------------------
1.
#v0.2
getDFfromNamed=function(Namedxx){
  data.frame(
    id=attr(Namedxx,'names'),
    val=unname(Namedxx),
    row.names = 1
  )
}





2. 更好的版本：实现了添加列名、按值排序、输出行列、前几行;
getDF_fromNamesXX=function(namedXX){
  rs=data.frame(
    name=names(namedXX),
    value=as.numeric(namedXX)
  )
  row.names(rs)=rs$name
  rs=rs[order(-rs$value),]
  print(dim(rs))
  print(head(rs))
  return(rs)
}



========================================
|-- 输入有重复的字符串，返回频率倒序数据框
----------------------------------------
1.
# 输入一系列有重复的字符串列表，输出该字符串的频率倒序排列的数据框。
getFreqFromStrings=function(Strs, orderStr="desc"){
  #默认倒序，如果指定asc，则正序；
  orderN=-1;
  if(orderStr=='asc' || orderStr=="ASC"){ orderN=1; }
  # 取频率
  tb=table(Strs);
  # 数据框形式
  df=data.frame(
    id=names(tb),
    freq=as.numeric(tb)
  )
  # 按照频率排序
  df=df[order(orderN*df$freq),]
  row.names(df)=df$id;
  return(df)
}
#
head(apaSite$gene) #[1] "DIP2C"  "LARP4B" "IDI1"   "IDI1"
sitePerGene=getFreqFromStrings(apaSite$gene)
#
dim(sitePerGene) #9455 2
head(sitePerGene)
#             id freq
#.             . 1560
#MALAT1   MALAT1   46
#EGFR       EGFR   40
#NCL         NCL   32




========================================
|-- 在apply中使用if条件
----------------------------------------
使用if(){}else{}是不起作用的，不知道是不是方法不正确。
要设置条件，要使用 ifelse(x>y, a, b) 语句。

例:把数据框中>3的改为1，<3则为-1, 等于3则0

tmp=iris[,1:4];
head(tmp)
tmp2=as.data.frame(t(apply(tmp, 1, function(x){
  ifelse(x<3, -1, ifelse(x>3,1, 0) )
})))
head(tmp2)
#  Sepal.Length Sepal.Width Petal.Length Petal.Width
#1            1           1           -1          -1
#2            1           0           -1          -1




========================================
|-- 分别统计三种鸢尾花的每个指标的平均值
----------------------------------------

思路: 
1. 按照分类列分组；
2. 求每个分组内的平均值



# 按照第5列分组(得到sub df)，统计每组各列的平均值
sapply(  split( iris[,1:4], iris[,5]), function(x){
  apply(x, 2, mean)
})


结果:
             setosa versicolor virginica
Sepal.Length  5.006      5.936     6.588
Sepal.Width   3.428      2.770     2.974
Petal.Length  1.462      4.260     5.552
Petal.Width   0.246      1.326     2.026


验证：
> colMeans(iris[which(iris$Species=="setosa"),1:4])
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
       5.006        3.428        1.462        0.246
# 其余两类略。






========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


