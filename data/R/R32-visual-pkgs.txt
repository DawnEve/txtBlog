R32-visual-pkgs

常见的可视化 R 包

热图 

绘图最佳实践




========================================
使用Cairo画图——R语言的高质量图形渲染库Cairo
----------------------------------------
Cairo的 坑: win10下用 Cairo 生成的图片中文字用 illustrator 打开乱码！换 linux画可以，在win10下用pdf()正常。


常用语句

library(Cairo)
CairoPDF(file="xx.pdf",width=10,height=10)
plot(c(1,2,3,8))
dev.off()


注意！如果是函数内用到ggplot2作图，则要定义ggplot2返回值，再用print()输出，否则会出现空pdf文件！
library(ggplot2)
fn2=function(){
	CairoPDF(file="xx2.pdf",width=10,height=10)
	g=ggplot(diamonds[1:1000,], aes(carat, price,color=color))+geom_point();
	print(g) #直接ggplot()作图，有可能不能输出到pdf中
	dev.off()
}
fn2();




https://www.cnblogs.com/payton/p/5391680.html
#R语言不仅在统计分析，数据挖掘领域，计算能力强大。在数据可视化上，也不逊于昂贵的商业。当然，背后离不开各种开源软件包的支持，Cairo就是这样一个用于矢量图形处理的类库。
# Cairo可以创建高质量的矢量图形(PDF, PostScript, SVG) 和 位图(PNG, JPEG, TIFF)，同时支持在后台程序中高质量渲染！
# 本文将介绍，Cairo在R语言中的使用。
#特别是原生画图命令失效的时候。
#莫名其妙不能使用X11生成图片, 只好使用图形渲染库Cairo。


1.安装
Cairo基本库安装
~ sudo apt-get install libcairo2-dev
~ sudo apt-get install libxt-dev
~ R 
> install.packages("Cairo")

2.Cairo使用
Cairo使用起来非常简单，和基础包grDevices中的函数对应。

CairoPNG: 对应grDevices:png()
CairoJPEG: 对应grDevices:jpeg()
CairoTIFF: 对应grDevices:tiff()
CairoSVG: 对应grDevices:svg()
CairoPDF: 对应grDevices:pdf()
我常用的图形输出，就是png和svg。

检查Cairo的兼容性：
~ R
> library(Cairo)
> Cairo.capabilities()
   png   jpeg   tiff    pdf    svg     ps    x11    win raster
  TRUE   TRUE  FALSE   TRUE   TRUE   TRUE   TRUE  FALSE   TRUE
下面比较一下 CairoPNG() 和 png() 输出效果。

1). 散点图


x<-rnorm(6000)
y<-rnorm(6000)

# PDF格式
CairoPDF(file="Cairo4.pdf",width=10,height=10) #开始画图
plot(x,y,col="#ff000018",pch=19,cex=2,main = "Cairo") #画图语句
dev.off() #结束画图




# PNG图
png(file="plot4.png",width=640,height=480)
plot(x,y,col="#ff000018",pch=19,cex=2,main = "plot")
dev.off()

CairoPNG(file="Cairo4.png",width=640,height=480)
plot(x,y,col="#ff000018",pch=19,cex=2,main = "Cairo")
dev.off()

# SVG图
svg(file="plot-svg4.svg",width=6,height=6)
plot(x,y,col="#ff000018",pch=19,cex=2,main = "plot-svg")
dev.off()

CairoSVG(file="Cairo-svg4.svg",width=6,height=6)
plot(x,y,col="#ff000018",pch=19,cex=2,main = "Cairo-svg")
dev.off()







========================================
|-- 最佳实践： R语言输出的pdf，怎么在 illustrator 中不乱码/形状位移/字体找不到？pdf(useDingbats=FALSE)
----------------------------------------

1. 如果是ggplot2，则可以使用ggsave的'useDingbats'=F参数：
https://stackoverflow.com/questions/9992275/ggplot2-pdf-import-in-adobe-illustrator-missing-font-adobepistd

(1)Although changing the fonts used by AI works well, an alternative is to restrict ggplot2 from using Dingbats in the first place by adding the argument 'useDingbats' to your ggsave command eg:

(2)useDingbats=FALSE also works if AI displays your geom_point dots as squares.

ggsave(plot=p,height=6,width=6,dpi=200, filename="~/example.pdf", useDingbats=FALSE)

神评论: 
 - This is brilliant! Thank you so much, I've been looking for this for years.
 - my life is significantly improved because of this!



(3) 使用自带的pdf输出，带上useDingbats=F参数

pdf("test.pdf", useDingbats=FALSE,width=10, height=10)
heatmap( as.matrix(mtcars) )
dev.off()


https://stackoverflow.com/questions/9992275/ggplot2-pdf-import-in-adobe-illustrator-missing-font-adobepistd





2. CairoPDF 的输出，win下画用AI打开是乱码。
不要win下用 CairoPDF 画图，或者推荐使用 pdf() 函数输出。

https://stackoverflow.com/questions/20502772/r-cairo-pdf-fonts-unreadable-in-adobe-illustrator







4.使用 embedFonts {grDevices} 函数： Embed Fonts in PostScript and PDF
//todo
embedFonts(file, format, outfile = file,
           fontpaths = character(), options = character())











========================================
R包画各种热图 - 高分文章必备漂亮的大热图
----------------------------------------
比较好的配色方案： https://www.plob.org/article/10156.html





========================================
|-- R基本函数image画热图
----------------------------------------
1.使用R基本函数image画热图
https://www.jianshu.com/p/c17a7c92b7fe

# 产生样本数据
m <- data.frame(
  rep1 = sample(1:20),
  rep2 = sample(1:20)
)

# 写一个绘图函数
draw_image <- function(data, label = FALSE) {
	# 设定绘图参数
	breaks.frequency <- seq(from=min(data), to=max(data), length.out=10)
	myColors <- colorRampPalette(c("white", "#2874A6"))

	# 产生图片
	image(1:nrow(data), 1:ncol(data), as.matrix(data),  breaks=breaks.frequency,      col=myColors(length(breaks.frequency)-1), axes = F, cex = 1.5, xlab = "", ylab = "")

	# 自定义axis
	axis(2, 1:ncol(data), colnames(data), cex.axis=2.5)
	axis(1, 1:nrow(data), rownames(mxdata), cex.axis=2.5)

	# 自定义文本
	if (label) {
		for (x in 1:nrow(data)) {
			for (y in 1:ncol(data))  {
				text(x, y, data[x, y], cex = 2)
			}
		}
	}
}
# 绘制图形
draw_image(data, FALSE)



################
#如果想添加图例：
################

# 绘制图形
CairoPDF(file="heatmap2.pdf",width=7,height=3.5)
#1.图下面留空
par(mai=c(1,1,0.5,0.5))
#画图
draw_image(m, T,mycolor) #改造成自定义颜色，
#2.图例
legend(x=1,y=-0,border = "black",lty=0,
       legend=c("<=0.001", "0.001~0.01", "0.01~0.05", ">0.05"),
       fill=MyCOLOR,
       xpd=T, #要设置xpd=T才能在图外画图例
       ncol=4,#ncol几列
       bty="n"
       ) 
dev.off()




========================================
|-- pheatmap包画各种热图 (附录: 全部参数列表)
----------------------------------------
https://www.jianshu.com/p/1c55ea64ff3f

顶部分类条
添加分类间隔gap




难题1: 颜色条精细控制
(1)使用pheatmap包画热图： 画列注释、图例自定义颜色和0的位置
Q: 在数据不scale时，颜色设为蓝，白，红，图例会显示最小值最大值的范围，有没有办法实现0点为白色，>0为红色，<0为蓝色？
A: 可以通过breaks和color参数进行设置的


#使用raw
#tmp=br5@raw.data[c(s.genes.2,g2m.genes.2),]
#使用标准化后的
tmp=br5@scale.data[c(s.genes.2,g2m.genes.2),]
tmp=tmp[,sort(colnames(tmp))]
#data.frame(Type=tmp.type)
tmp.type=data.frame( Type=substr(colnames(tmp),1,4) );
rownames(tmp.type) = colnames(tmp)
head(tmp.type)

###
#查看cell cycle基因对细胞分类的效果
#breaks
bk <- c(seq(-6,-0.1,by=0.01),seq(0,6,by=0.01)) #[-2, 6]
CairoPDF(file="06-3-heatmap-nonS-sync.pdf",width=8,height=10)
pheatmap(tmp, border=FALSE, 
         cluster_cols = F,
         #scale="row",
         annotation_col=tmp.type,
         #color
         color = c(colorRampPalette(colors = c("blue","white"))(length(bk)/2),colorRampPalette(colors = c("white","red"))(length(bk)/2)),
         legend_breaks=seq(-6,6,2),
         breaks=bk
         )
dev.off()





难题2: 保存总是不流畅，或者被覆盖
library(pheatmap)
library(Cairo)
drawHM01=function(output='',keyword=''){
  pHM=pheatmap( as.matrix(iris[,1:4]), 
                clustering_method = 'ward.D2', na_col = 'grey',
                show_rownames=F,show_colnames=F,
                border=FALSE)
  CairoPDF( paste0(output, keyword, '04_heatmap_cycleGene.pdf'), width=4.5, height=4.5)
  #fig1
  clust_ward <- hclust( dist(iris[,1:4]) , method = 'ward.D2')
  plot(clust_ward)
  rect.hclust(clust_ward, k = 3, border =c("#E41E25", "#FBD800", "#208A41") )
  #fig2
  grid.newpage()
  print(pHM)
  dev.off()
  print('draw end: ')
  return(pHM)
}
p1=drawHM01()

library(ggplot2)
# 还可以这样保存
ggsave(p1,filename = "04_pheatmap.pdf",width=4.5,height=4.5)

print(p1) #这样显示图片

class(p1) #"pheatmap"
str(p1) #特别长











1.构建测试数据集
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
head(test[,1:6])
##          Test1      Test2    Test3      Test4    Test5       Test6
## Gene1 4.064973  0.7535271 3.024070 -2.1294440 4.407945 -0.35677097
## Gene2 2.360043  1.6974946 3.273425 -2.3341406 3.839523  0.16982944
## Gene3 3.253465 -0.9011582 1.716257 -0.2294471 4.636610 -0.24520382
## Gene4 4.070226 -0.6191941 3.734437  1.9348314 4.426825 -0.17730957
## Gene5 3.821414  0.5584876 1.871479 -0.2784607 2.633761  0.01332901
## Gene6 3.012469  0.1738285 3.652423 -2.0083435 4.124951 -0.67899611

# 默认绘图
pheatmap(test)

(2) 归一化
# scale = "row"参数对行进行归一化
pheatmap(test, scale = "row")


(3) 聚类方式
# clustering_method参数设定不同聚类方法，默认为"complete",可以设定为'ward', 'ward.D', 'ward.D2', 'single', 'complete', 'average', 'mcquitty', 'median' or 'centroid'
pheatmap(test,scale = "row", clustering_method = "average")

# clustering_distance_rows = "correlation"参数设定行聚类距离方法为Pearson corralation，默认为欧氏距离"euclidean"
pheatmap(test, scale = "row", clustering_distance_rows = "correlation")

# cluster_row = FALSE参数设定不对行进行聚类
pheatmap(test, cluster_row = FALSE)


(4) 色彩
# color参数自定义颜色
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))



(5) 图例控制
# legend_breaks参数设定图例显示范围，legend_labels参数添加图例标签
pheatmap(test, legend_breaks = c(1:5), legend_labels = c("1.0","2.0","3.0","4.0","5.0"))


# legend = FALSE参数去掉图例
pheatmap(test, legend = FALSE)



(6) 每个最小方格的边框
# border_color参数设定每个热图格子的边框色
pheatmap(test, border_color = "red")

# border=FALSE参数去掉边框线
pheatmap(test, border=FALSE)










2. 顶部添加分类条

# 构建列注释信息
annotation_col = data.frame(
  CellType = factor(rep(c("CT1", "CT2"), 5)), 
  Time = 1:5
)
rownames(annotation_col) = paste("Test", 1:10, sep = "")
head(annotation_col)
##       CellType Time
## Test1      CT1    1
## Test2      CT2    2
## Test3      CT1    3
## Test4      CT2    4
## Test5      CT1    5
## Test6      CT2    1



# 构建行注释信息
annotation_row = data.frame(
  GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
)
rownames(annotation_row) = paste("Gene", 1:20, sep = "")
head(annotation_row)
##       GeneClass
## Gene1     Path1
## Gene2     Path1
## Gene3     Path1
## Gene4     Path1
## Gene5     Path1
## Gene6     Path1



# annotation_col参数添加列注释信息
pheatmap(test, annotation_col = annotation_col)


# annotation_legend = FALSE参数去掉注释图例
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)

(2)
# annotation_col和annotation_row参数同时添加行和列的注释信息
pheatmap(test, annotation_row = annotation_row, annotation_col = annotation_col)



(3)
# 自定注释信息的颜色列表
ann_colors = list(
  Time = c("white", "firebrick"),
  CellType = c(CT1 = "#1B9E77", CT2 = "#D95F02"),
  GeneClass = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E")
)
head(ann_colors)
## $Time
## [1] "white"     "firebrick"
## 
## $CellType
##       CT1       CT2 
## "#1B9E77" "#D95F02" 
## 
## $GeneClass
##     Path1     Path2     Path3 
## "#7570B3" "#E7298A" "#66A61E"

# annotation_colors设定注释信息的颜色
pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors, main = "Title")

pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors)

pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors[2]) 










3. 添加分类间隔gap

(1)
# gaps_row = c(10, 14)参数在第10和14行处添加gap, 要求对行不进行聚类
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14))

(2)
# cutree_col = 2参数将列按聚类树的结果分成两部分, 要求对列进行聚类
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14),
         cutree_col = 2)

(3)
# 对行和列都不聚类，自定义划分行和列的gap
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, cluster_cols = FALSE, 
         gaps_row = c(6, 10, 14), gaps_col = c(2, 5, 8))
#






4. 外观控制：行名显示、自定义行名、格子里的数字、格子宽度高度、标题
(1)
# show_rownames和show_colnames参数设定是否显示行名和列名
pheatmap(test,show_rownames=F,show_colnames=F)


# 自定义行的标签名
labels_row = c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
               "", "", "Il10", "Il15", "Il1b")
# labels_row参数添加行标签
pheatmap(test, annotation_col = annotation_col, labels_row = labels_row)



(2) 格子里显示数字
# display_numbers = TRUE参数设定在每个热图格子中显示相应的数值，number_color参数设置数值字体的颜色
pheatmap(test, display_numbers = TRUE,number_color = "blue")


(3)
# number_format = "%.1e"参数设定数值的显示格式
pheatmap(test, display_numbers = TRUE, number_format = "%.1e")



(4)
# 自定义数值的显示方式
pheatmap(test, display_numbers = matrix(ifelse(test < 0.05, "*", ""), nrow(test)))


(5)
# cellwidth和cellheight参数设定每个热图格子的宽度和高度，main参数添加主标题
pheatmap(test, cellwidth = 15, cellheight = 12, main = "Example heatmap")







5. 设定聚类方式
(1)
# 自定义聚类的距离方法
drows = dist(test, method = "minkowski")
dcols = dist(t(test), method = "minkowski")
# clustering_distance_rows和clustering_distance_cols参数设定行和列的聚类距离方法
pheatmap(test, clustering_distance_rows = drows, clustering_distance_cols = dcols)



(2)
# treeheight_row和treeheight_col参数设定行和列聚类树的高度，默认为50
pheatmap(test, treeheight_row = 30, treeheight_col = 50)







6. 输出
(1)
# fontsize参数设定标签字体大小，filename参数设定图片保存名称
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "test.pdf")


(2)将热图结果按聚类后的顺序输出
aa=pheatmap(test,scale="row")  #热图，归一化，并聚类

# 简要查看热图对象的信息
summary(aa)
##          Length Class  Mode   
## tree_row 7      hclust list   
## tree_col 7      hclust list   
## kmeans   1      -none- logical
## gtable   6      gtable list


order_row = aa$tree_row$order  #记录热图的行排序
order_col = aa$tree_col$order    #记录热图的列排序
datat = data.frame(test[order_row,order_col])   # 按照热图的顺序，重新排原始数据
datat = data.frame(rownames(datat),datat,check.names =F)  # 将行名加到表格数据中
colnames(datat)[1] = "geneid" 
write.table(datat,file="reorder.txt",row.names=FALSE,quote = FALSE,sep='\t')  #输出结果，按照热图中的顺序








### 附录 
mat
数组矩阵（要绘制热图的数据源，保证数据是numeric类型）
color
热图的颜色选择
默认：colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)

break
用来定义数值和颜色的对应关系。可以将特定颜色和特定数值关联，如果NA则自动进行计算。如果颜色超过值的范围，超过阈值的会使用和阈值一样的颜色。
默认：NA

border_color
热图的单位元素的描边颜色，NA表示不描边
默认：“gray60”

cellwidth
热图单位元素（cell）的宽度，NA表示依据窗口自动调整
默认：NA
cellheight同

scale
数值标准（scale）化，可以是“row“,”column“,”none“
默认：“none”

cluster_rows
用布尔值来判定行元素是不是应该被clustered or clust object。
默认：TRUE
同理，cluster_cols决定是否应该把列clust

clustering_distance_rows
计算类间距的方式，
默认：“euclidean”（欧式距离）
clustering_distance_cols同理

clustering_method
cluster的途径方法（method）
默认：“complete”

clustering_callback
默认：identity2

cutree_rows
如果使用了对行的集群，则可以指定集群个数（基于hclust），如果未使用对行集群则忽略
默认：NA
cutree_col同理

treeheight_row
行集群树的高度
默认：(50point)

legend
图例是否显示
默认：TRUE

legend_breaks
图例是否断点标注
默认：NA

legend_labels
图例的标题
默认：NA

annotation_row
是否对行进行分类注释
默认：NA
annotation_col同理

annotation(废弃)
deprecated parameter that currently sets the annotation_col if it is missing
默认：NA

annotation_colors
指定注释条的颜色。
默认：NA

annotation_legend
布尔值表示是否显示注释条的图例
默认：TRUE

annotation_names_row
布尔值表示是否在图例上显示注释名称
默认：TRUE
annotation_names_col同理

drop_levels
是否在图例显示unused levels
默认：TRUE

shown_rownames
是否显示行名
默认：T
shown_colnames
是否显示列名
默认：T

main
图表主标题
默认：NA

fondsize
图表字体大小
默认：10

fontsize_row
行标题的字号
默认：fondsize
fontsize_col同上

angle_col
列标签的角度，可以选择0，45，270，315

display_numbers
是否在单位元素（cell）内显示数字
默认：F

number_format
显示在cell内的数字格式，例如%.2代表两位小数%.1e表示指数形式...参见C语言printf函数格式
默认：%.2f

fontsize_number
限制在Cell内的数字大小
默认：0.8*fontsize

gaps_row
当行未进行集群分析时，指示再哪里查处gap空隙
默认：NULL
gaps_col同理

labels_row
使用行标签代替行名
默认：NULL
labels_col同理

filename
保存的路径和文件名。支持png、pdf、tiff、bmp、jpeg
NA

height
输出的图片都高度，单位：inches
默认：NA
width同理

silent
不要画出图像（在gtable导出适用）
FALSE

na_col
对NA值对应的cell填充特定颜色
默认："#DDDDDD",...



ref:
https://mp.weixin.qq.com/s?__biz=MzIyNDI1MzgzOQ==&mid=2650394128&idx=1&sn=5cb8b1a16077abc451a20fde62e6d347







========================================
|-- (推荐) ComplexHeatmap 包画热图: 基于 grid
----------------------------------------
1.官方文档： https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html

github: https://github.com/jokergoo/ComplexHeatmap
文档: https://github.com/jokergoo/ComplexHeatmap-reference
	https://jokergoo.github.io/ComplexHeatmap-reference/book/
文档(old, read only) https://github.com/dvdhover/ComplexHeatmap


ComplexHeatmap is implemented under grid system, so users need to know basic grid functionality to get full use of the package.

整个图的排布: 热图 - row annotations / row names / dendrogram / title


(2) 安装
BiocManager::install("ComplexHeatmap")




2. 入门级的是 和 pheatmap 包同名的热图。

具体的看官方文档。
可视化笔记在 《R 语言最佳实践》: https://dawneve.github.io/R_best_practice/













1.要求画热图：
(1).有三个数据文件，每个都是这样的7行9列：
2-HG	Citrate	Fumarate	lsocitrate	Lactate	maltate	Succinate	Age	Gender
Any cancer	0.001	0.001	0.25	0.001	0.25	0.001	0.25	0.001	0.25
Breast cancer	0.1	0.1	0.002525	0.1	0.002525	0.1	0.002525	0.1	0.002525
Thyroid cancer	0.023	0.023	0.001452	0.023	0.001452	0.023	0.001452	0.023	0.001452
Second malignant neoplasms(SMNS)	0.00255	0.00255	0.0236	0.00255	0.0236	0.00255	0.0236	0.00255	0.0236
Neurodevelopmental disorders	0.001548	0.001548	0.03564	0.001548	0.03564	0.001548	0.03564	0.001548	0.03564
Marcrocephaly	0.05426	0.05426	0.0254	0.05426	0.0254	0.05426	0.0254	0.05426	0.0254
Lhermitte-Duclos disease	0.0263	0.0263	0.09878	0.0263	0.09878	0.0263	0.09878	0.0263	0.09878

三个文件rbind拼接，同时在最左侧显示数据来源。
文件之间显示分割线。

(2)行列名字标注到热图的left和top;
(3)共用一个图例，显示到右侧。






2. 代码：
library(ComplexHeatmap)
library(circlize)
setwd("/home/wangjl/web/docs/docs")


see=function(df){
  print(dim(df))
  print(df[1:3,])
}

#read data
mat1=read.table("self_made_data.txt",sep="\t",header=T,row.names=1)
mat2=read.table("self_made_data2.txt",sep="\t",header=T,row.names=1)
mat3=read.table("self_made_data3.txt",sep="\t",header=T,row.names=1)
see(mat1) #7 9
#
mat=rbind(mat1,mat2,mat3)
see(mat) #21 9
#
rt = as.matrix(mat)
is.matrix(rt)
#colors = structure(circlize::rand_color(7), names = c("1", "2", "3", "4","5","6","7"))
colors = colorRamp2(c(-0.4,-0.01,0,0.01,0.5),
                    c("blue", "light blue","white","orange", "brown"))
p1 <- Heatmap(rt, 
              col = colors,
              show_heatmap_legend = T, name = "p-value", #显示图例，图例标题
              cluster_rows = FALSE, cluster_columns = FALSE,#不聚类行和列
              #
              rect_gp = gpar(col="white",lwd=1), #每个最小方框的描边
              #width = unit(10, "cm"), height = unit(10, "cm"), #尺寸自动好了
              #
              row_names_side = "left",column_names_side = "top",#xy坐标显示位置
              #
              #row_title = expression(PTEN^MUT/SDH^WT), #添加左侧标题，只有一个
              row_split = c( rep("A",7),rep("B",7),rep("C",7) ), #添加左侧标题3个，表明来源
              #row_split = c( rep(expression(PTEN^MUT/SDH^WT),7), #显示表达式会报错
              #               rep(expression(PTEN^WT/SDH^MUT),7),
              #               rep(expression(PTEN^WT/SDH^WT),7) )
              #为row标注(y轴刻度)设置不同的颜色和字号
              row_title_gp = gpar(col = c("green", "orange", "purple"), font =c(20,20) ),
              row_names_gp = gpar(col = c("green", "orange", "purple"), fontsize = c(10, 10, 10)),
			  
			  row_gap = unit(5, "mm") #三个文件之间的距离
);p1
library(Cairo)
CairoPDF(file='test3.pdf',width=8,height=5)
p1
dev.off()

## end


refer:
https://www.jianshu.com/p/d8b8f7acf47c





========================================
韦恩图绘制 venn图: VennDiagram 包
----------------------------------------
# 经典的2类交集韦恩图，顶上标标签，圆圈标数字个数，面积成比例
library (VennDiagram)
#grid.newpage()
venn.plot <- draw.pairwise.venn(393, 269, 94, c("BC", "HeLa"), 
                                fill = c('#F81082', '#619CFF'),  col = "transparent",
                                cex = 2.5,cat.cex=2.5,alpha = 0.50,
                                main="Cycle related genes", #不显示
                                
                                cat.pos = c(-30, 10), #angle of text, dgree=0 means top of cycle
                                cat.dist = 0.05,   #distance of text to border, can be negative
                                
                                cat.col = c('#F81082', '#619CFF'), margin=0.3, scaled = T);
#


1.VennDiagram包
#安装VennDiagram包
#install.packages("VennDiagram")
> library (VennDiagram)


(1)情况1: 知道集合大小、重叠区域大小
#install.packages("VennDiagram")
library (VennDiagram)

#1) 两个部分
#重叠区域大小按比例
venn.plot <- draw.pairwise.venn(100, 70, 30, c("First", "Second"));
grid.draw(venn.plot);
#不按比例
grid.newpage()
venn.plot <- draw.pairwise.venn(100, 70, 30, c("First", "Second"), scaled = FALSE);
grid.draw(venn.plot);


#3) 更多参数
grid.newpage()
venn.plot <- draw.pairwise.venn(
  area1 = 100,  #区域1的数
  area2 = 70,   #区域2的数
  cross.area = 60,  #交叉数
  category = c("First", "Second"),#分类名称
  fill = c("blue", "red"),#区域填充颜色
  lty = "blank",  #区域边框线类型
  cex = 2,        #区域内部数字的字体大小
  cat.cex = 2,    #分类名称字体大小
  cat.pos = c(285, 105), #分类名称在圆的位置，默认正上方，通过角度进行调整
  cat.dist = 0.09,   #分类名称距离边的距离（可以为负数）
  cat.just = list(c(-1, -1), c(1, 1)),  #分类名称的位置
  ext.pos = 30,  #线的角度 默认是正上方12点位置
  ext.dist = -0.05,   #外部线的距离
  ext.length = 0.85,  #外部线长度
  ext.line.lwd = 2,  #外部线的宽度
  ext.line.lty = "dashed"   #外部线为虚线
);
grid.draw(venn.plot); #再画一次，颜色更深


#3)三个数据集
# A more complicated diagram
grid.newpage()
venn.plot <- draw.triple.venn(
  area1 = 65,
  area2 = 75,
  area3 = 85,
  n12 = 35,
  n23 = 15,
  n13 = 25,
  n123 = 5,
  category = c("First", "Second", "Third"),
  fill = c("blue", "red", "green"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  scaled=F,
  cat.col = c("blue", "red", "green")
);

# Writing to file
tiff(filename = "Triple_Venn_diagram.tiff", compression = "lzw");  #保存图片
#pdf(file = "Triple_Venn_diagram.pdf", width=5,height=5)
grid.draw(venn.plot);#画图展示
dev.off(); 



#4)四个数据集：花瓣形
# Reference four-set diagram
grid.newpage()
venn.plot <- draw.quad.venn(
  area1 = 72,
  area2 = 86,
  area3 = 50,
  area4 = 52,
  n12 = 44,
  n13 = 27,
  n14 = 32,
  n23 = 38,
  n24 = 32,
  n34 = 20,
  n123 = 18,
  n124 = 17,
  n134 = 11,
  n234 = 13,
  n1234 = 6,
  category = c("First", "Second", "Third", "Fourth"),
  fill = c("orange", "red", "green", "blue"),
  lty = "dashed",
  cex = 2,
  cat.cex = 2,
  cat.col = c("orange", "red", "green", "blue")
);
grid.draw(venn.plot);#画图展示



#5)五个数据集：
# Reference five-set diagram
grid.newpage()
venn.plot1 <- draw.quintuple.venn(
  area1 = 301,
  area2 = 321,
  area3 = 311,
  area4 = 321,
  area5 = 301,
  n12 = 188,
  n13 = 191,
  n14 = 184,
  n15 = 177,
  n23 = 194,
  n24 = 197,
  n25 = 190,
  n34 = 190,
  n35 = 173,
  n45 = 186,
  n123 = 112,
  n124 = 108,
  n125 = 108,
  n134 = 111,
  n135 = 104,
  n145 = 104,
  n234 = 111,
  n235 = 107,
  n245 = 110,
  n345 = 100,
  n1234 = 61,
  n1235 = 60,
  n1245 = 59,
  n1345 = 58,
  n2345 = 57,
  n12345 = 31,
  category = c("A", "B", "C", "D", "E"),
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 2,
  margin = 0.05,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  ind = TRUE
);
grid.draw(venn.plot1);#画图展示







##############
# (2)情况2: 知道集合内容，还没统计集合大小、重叠区域
##############

#1) 两数据集
venn.plot <- venn.diagram(
  x = list(
    "A" = 1:100,
    "B" = 96:140
  ),
  filename = "Venn_22set_complex.png",imagetype='png',
  col = "transparent",
  fill = c("red", "green"),
  cex = 2.5,
  cat.cex = 2.5,
  rotation.degree = 0,
  main = "Complex Venn Diagram",
  main.cex = 2,
  sub.cex = 1,
  alpha = 0.50
);


##2) 三个数据集
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
venn.plot <- venn.diagram(
  #数据列表
  x = list(
    A = A,
    B = B,
    C = C
  ),
  filename ="1.tiff",    #保存路径
  height = 450, 
  width = 450,
  resolution =300, 
  #imagetype="png", 
  col = "transparent",      #指定图形的圆周边缘颜色  transparent 透明           
  fill = c("cornflowerblue", "green",  "darkorchid1"),  #填充颜色
  alpha = 0.50,                                      #透明度
  label.col = c("orange", "white", "darkorchid4", "white",
                "white", "darkgreen", "white"),
  cex = 0.45,    #每个区域label名称的大小
  fontfamily = "serif",  #字体
  fontface = "bold",     #字体格式
  cat.col = c("darkblue", "darkgreen", "darkorchid4"),  #分类颜色 
  cat.cex = 0.45,      #每个分类名称大小
  cat.pos = c(100, 260, 0),        #
  cat.dist = c(0.07, 0.07, 0.05),    #
  cat.fontfamily = "serif",     #分类字体
  rotation.degree =180,        #旋转角度
  margin = 0.2               #在网格单元中给出图周围空白量的编号
);


## 三个数据集的例2
A <- c("C", "D", "B", "E")
B <- c("C", "E", "B", "A")
C <- c("C", "E", "X", "Y")

##使用venn.diagram功能绘图
venn.plot=venn.diagram(x=list(Tumor=A, Organoids=B, Primary=C), 
                       filename="My1.png", 
                       height = 450, width = 450, resolution =300, 
                       #imagetype="png", 
                       col="white", 
                       fill=c(colors()[616], colors()[38], colors()[468]), 
                       alpha=c(0.6, 0.6, 0.6), lwd=c(1, 1, 1), 
                       cex=0.55, #数字文字大小
                       cat.dist=c(0.07, 0.07, 0.05), #注释文字大小
                       cat.pos=c(300, 60, 180), 
                       cat.cex=0.45,                      
                       margin=0.1)
#可以不保存查看图片，但是效果不佳（命令如下，但是需要首先把filename设置为（filename=NULL））
grid.newpage()
grid.draw(venn.plot);
dev.off();
#




例2:两个基因列表的交集
只能使用
library("VennDiagram")
venn.diagram(x=list(nonS=nonS$gene, sync=sync$gene),filename="a1.png",
             imagetype = "png",height = 800, width = 800, 
             resolution = 150, units = "px",
             fill=c("blue", "red") )

#
# 给出集合内容，R自动求交集、差集
library(VennDiagram)
venn.diagram(list(A=1:10,B=3:18), 
             fill=c("red","blue"), 
             alpha=c(0.5,0.5),  #设置透明度
             resolution =500, imagetype = "png", units = "px",
             main="1S_gt5_",
             cex=2, cat.fontface=4, fontfamily=3, filename="VennDiagram.png")
#


例3: 维恩图直观看DESeq2结果
library(VennDiagram)
library(grid)

data <- list(
  deg_1=as.character(deg_1$Description),
  deg_2=as.character(deg_2$Description)
)

data1 <- list(
  deg_ens_1=as.character(nrDEG_ens),
  deg_ens_2=as.character(nrDEG2_ens)
)

ven <- venn.diagram(data,filename = NULL,fill=c('red','yellow'))
ven1 <- venn.diagram(data1,filename = NULL,fill=c('red','yellow'))

grid.newpage()
grid.draw(ven)

grid.newpage()
grid.draw(ven1)





### 四个数据集：
#sample为抽样函数，首先指定抽样范围，然后制定抽样个数，最后指定是否允许同样的抽样值
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
D <- sample(1:1000, 550, replace = FALSE);
E <- sample(1:1000, 375, replace = FALSE);
venn.plot <- venn.diagram(
  #数据列表
  x = list(
    A = A,
    D = D,
    B = B,
    C = C
  ),
  filename = "Venn_4set_pretty.tiff",    #保存路径
  col = "transparent",      #指定图形的圆周边缘颜色  transparent 透明           
  fill = c("cornflowerblue", "green", "yellow", "darkorchid1"),  #填充颜色
  alpha = 0.50,                                      #透明度
  label.col = c("orange", "white", "darkorchid4", "white",
                "white", "white", "white", "white", "darkblue", "white",
                "white", "white", "white", "darkgreen", "white"),
  cex = 1.5,    #每个区域label名称的大小
  fontfamily = "serif",  #字体
  fontface = "bold",     #字体格式
  cat.col = c("darkblue", "darkgreen", "orange", "darkorchid4"),  #分类颜色 
  cat.cex = 1.5,      #每个分类名称大小
  cat.pos = 0,        #
  cat.dist = 0.07,    #
  cat.fontfamily = "serif",     #分类字体
  rotation.degree = 270,        #旋转角度
  margin = 0.2               #在网格单元中给出图周围空白量的编号
);



### 五个数据集：
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
D <- sample(1:1000, 550, replace = FALSE);
E <- sample(1:1000, 375, replace = FALSE);
venn.plot <- venn.diagram(
  x = list(
    A = A,
    B = B,
    C = C,
    D = D,
    E = E
  ),
  filename = "Venn_5set_pretty.tiff",
  col = "black",
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  alpha = 0.50,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 1.5,
  cat.fontface = "bold",
  margin = 0.05
);








2.在线 http://bioinfogp.cnb.csic.es/tools/venny/index.html
这个程序是在线运行的，无需安装任何插件.输出一张图真的是分分钟的事儿！其实即使不是画韦恩图，也可以利用这个网站，找出两种不同处理（状态）的共有基因，或者特有基因等等.



ref:
http://blog.sciencenet.cn/blog-2985160-957210.html
http://www.360doc.com/content/19/1231/13/46931810_883308977.shtml






========================================
|-- venn.diagram保存pdf格式文件？
----------------------------------------
vennDiagram包中的主函数绘图时，好像不直接支持PDF格式文件，只能指定filename = NULL, 然后通过pdf()函数输出。
如果不行，先安装加载library(grDevices)包。


1. 示例文件
#(1) data
dat = list(a = c('a','b','c','e'),b = c('a', 'x', 'c', 'd','y'))
names(dat) <- c('SetA', 'SetB')

#(2) plot
venn.plot <- venn.diagram(
  dat,
  filename = NULL, #设为空
  lwd = 3,
  col = "transparent",
  fill = c("cornflowerblue", "darkorchid1"),
  alpha = 0.6,
  label.col = "black",
  cex = 1.5,
  fontfamily = "serif",
  fontface = "bold",
  cat.col = c("cornflowerblue", "darkorchid1"),
  cat.cex = 2,
  cat.fontfamily = "serif",
  cat.fontface = "bold",
  margin = 0.05,
  cat.dist = c(0.03, 0.03),
  cat.pos = c(-20, 20)
)

# (3) save
pdf(file="proteinGroup_venn.pdf")
grid.draw(venn.plot)
dev.off()




========================================
|-- 画多个(n>5)集合的交集: UpSetR包
----------------------------------------
1. UpsetR这个包确实对多个交集的可视化做了提供了更好的展示方式

(1) 示例1：简单数据示例
install.packages("UpSetR")
library("UpSetR")

1) UpsetR 接受三种类型的数据输入：
- 表格形式，在 R 语言里就是数据框了。行表示元素，列表示数据集分配和额外信息。
- 元素名的集合( fromList )。
- venneuler 包引入的用于描述集合交集的向量 ( fromExpression）。


# fromList
listinput <- list(one = c(1, 2, 3, 5, 7, 8, 11, 12, 13), 
	two = c(1, 2, 4, 5, 10), 
	three = c(1, 5, 6, 7, 8, 9, 10, 12, 13))
> str(listinput)
List of 3
 $ one  : num [1:9] 1 2 3 5 7 8 11 12 13
 $ two  : num [1:5] 1 2 4 5 10
 $ three: num [1:9] 1 5 6 7 8 9 10 12 13

# fromExpression
expressionInput <- c(one = 2, two = 1, three = 2, 
	`one&two` = 1, `one&three` = 4, `two&three` = 1, 
	`one&two&three` = 2)
> str(expressionInput)
 Named num [1:7] 2 1 2 1 4 1 2
 - attr(*, "names")= chr [1:7] "one" "two" "three" "one&two" ...
#



2) 画图 
> upset(fromList(listinput), order.by = "freq")

# 下面绘制的图形等同于上图
> upset(fromExpression(expressionInput), order.by = "freq")

下面是3个集合，左下角是集合的size，黑色原点是哪几个集合的交集，上面 柱状图是该交集的元素数目，可以想象如果集合更多这种方式会更直观，但是--

当我输入为基因名列表（abcde），并在R中存为一个list时，会有一个fromList函数将我的list整合为upsetR自己的输入格式，等一下！！朕的基因名字呢！！

> z=fromList(listinput)
> z
   one two three
1    1   1     1
2    1   1     0
3    1   0     0
4    1   1     1
5    1   0     1
6    1   0     1
7    1   0     0
8    1   0     1
9    1   0     1
10   0   1     0
11   0   1     1
12   0   0     1
13   0   0     1





3) 调整与美化后的集合图

library(ggplot2)
library(RColorBrewer)
upset(fromList(listinput),      
      #nsets=length(listinput), #显示数据集的所有数据,nsets = 数值调整可视化数据集数量
      #nintersects=3, #显示前多少个bar
      #sets=c("set1","set2","set3","set4","set5","set6", "set7"), # 指定集合或用keep.order = TRUE保持集合按输入的顺序排序
      
      #number.angles = 60, #bar上 交互集合柱状图的 数字柱标倾角
      point.size=3, #图中点的大小
      line.size=1, #图中连接线粗细
      
      
      main.bar.color = 'black', #y轴柱状图颜色
      matrix.color="black", #x轴点的颜色
      
      mainbar.y.label="Number of overlap\ngenes(X 10^4)",  #default "Intersection Size", #y轴的标签
      sets.x.label="Total number of\n enriched genes(X 10^3)", #default "Set size",   #x轴的标签
      
      # RColorBrewer包: Set1中只有6个颜色，Set3中有12个颜色，Paired中有12个颜色
      sets.bar.color=brewer.pal(3,"Set3"),#x轴下 左水平bar 颜色; 
      #matrix.color = "yellow", #?
      # att.color="yellow", #?
      #color.pal="Dark2", #?
      
      mb.ratio = c(0.5, 0.4), #bar plot和matrix plot图形高度的占比
      order.by = "freq", #y轴矩阵排序,如"freq"频率，"degree"程度
      
      text.scale=c(1.5,1.5,1.5,1.5,1.5, 1), 
      #6个参数intersection size title（y标题大小）, intersection size tick labels（y刻度标签大小）, set size title（set标题大小）, set size tick labels（set刻度标签大小）, set names（set 分类标签大小）, numbers above bars（柱数字大小）的设置
      # https://www.jianshu.com/p/8323604f3d69
      
      #shade.color="#ff000022" #图中阴影部分的颜色
      
      queries = list(list(query = intersects,params = list("one","two","three"), color="Red",active = T)), #高亮显示某一列
)










(2) 示例2：使用 UpSetR 内置的数据集 movies 来绘制。
#导入数据
> movies <- read.csv(system.file("extdata", "movies.csv", package = "UpSetR"), header = TRUE, sep = ";")
> dim(movies)
[1] 3883   21

#先大致浏览一下该数据集,数据集太长，就只看前几列
knitr::kable(head(movies[,1:10]))

> head(movies) #1行一部电影，3-19列是类型，1是该类型，0不是
> colnames(movies)[3:19]
 [1] "Action"      "Adventure"   "Children"    "Comedy"      "Crime"       "Documentary" "Drama"       "Fantasy"     "Noir"       
[10] "Horror"      "Musical"     "Mystery"     "Romance"     "SciFi"       "Thriller"    "War"         "Western" 


> upset(movies, nsets = 6, number.angles = 30, point.size = 2, line.size = 1, mainbar.y.label = "Genre Intersections", sets.x.label = "Movies Per Genre", text.scale = c(1.3, 1.3, 1, 1, 1.5, 1))



df=movies[,3:19]
dim(df) #3883   17

head(df)
hist( apply(df, 1, sum) ) #type per film
hist( apply(df, 2, sum), n=10 ) #film per type

# 2 film has no type
table(apply(df, 1, sum)>0)
movies[apply(df, 1, sum)==0,]
colnames(df)


upset(df, nsets=10, #底下显示几个类，默认5
      nintersects = 20,#顶部显示几个交集bar, 默认40
      number.angles = 90, #顶部文字倾斜角度
      order.by = 'freq', #对顶部排序，按频数
      point.size = 2, # 底部圆点大小
      line.size = 1, #底部连线粗细
      
      
      #text.scale = c(1.3, 1.3, 1, 1, 1.5, 1), #6个字体大小
      # c(intersection size title, intersection size tick labels, 
      #   set size title, set size tick labels, set names, numbers above bars)
      sets.x.label = "Movies Per Genre", #xlab
      mainbar.y.label = "Genre Intersections" #ylab
    )

# 限定几个特定集合
upset(df, sets = c("Action", "Adventure", "Comedy", "Drama", "Mystery", 
                       "Thriller", "Romance", "War", "Western"), 
      mb.ratio = c(0.55, 0.45), #mb.ratio：控制上方条形图以及下方点图的比例。
      order.by = "freq")
#order.by：如何排序，这里 freq 表示从大到小排序展示，
#其他选项有 degree 以及先按 freq 再按 degree 排序。







2. 是否能给出交集元素？
https://github.com/hms-dbmi/UpSetR/issues/85

只能使用原始方式，各种intersect(a,b)嵌套。


例: intersect(listinput[['one']], listinput[['two']]) #1 2 5




ref:
官方: https://www.rdocumentation.org/packages/UpSetR/versions/1.4.0
https://cran.r-project.org/web/packages/UpSetR/UpSetR.pdf
https://cran.r-project.org/web/packages/UpSetR/readme/README.html

Interactive set visualization for more than three sets: https://jku-vds-lab.at/tools/upset/

webapp: https://hiplot.com.cn/basic/upset-plot

https://www.zhihu.com/question/59118999/answer/741196973
更多实例: https://my.oschina.net/shenweiyan/blog/4538670

http://research.libd.org/rstatsclub/post/hacking-our-way-through-upsetr/
https://stackoverflow.com/questions/67094573/upsetr-sets-bar-interacting-different-color-and-its-sets-intersections









========================================
GenVisR包: 瀑布图/突变图谱 Waterfall Plot
----------------------------------------
1. 官网
https://bioconductor.org/packages/release/bioc/html/GenVisR.html
https://github.com/griffithlab/GenVisR

实验室: https://griffithlab.org/


中文: 
https://www.jianshu.com/p/8723aa6c9845
https://www.jianshu.com/p/726310b02a56
https://www.jianshu.com/p/d3d3a34e95c2







ref:




========================================
Gviz 包 - Visualize genomic data (能一定程度上代替IGV的R包: 画bam文件的 read coverage 图)
----------------------------------------
这个R包是可以完全替代IGV的， 前提是你对它的了解足够深。

使用refGenome加上dplyr玩转gtf文件
原创： 生信技能树  生信技能树  2018-12-05




1. 入门
Sushi这个R包可以绘制基因组区域reads覆盖情况，这次我们介绍另外一个功能更强大的R包 Gviz：
全称：Plotting data and annotation information along genomic coordinates
正式发表于期刊：Source Code Biol Med. 2016
doi: 10.1186/s13029-016-0052-z


官方说明文档是多达200多页的PDF，依赖于很多bioconductor的基础R包，所以这个时候学习这个R包的速度其实取决于我们自己对其它R包或者R基础知识的掌握程度。


官方教程: 很厚
http://52.71.54.154/packages/devel/bioc/vignettes/Gviz/inst/doc/Gviz.html
https://ivanek.github.io/Gviz/articles/Gviz.html
https://ivanek.github.io/Gviz/reference/settings.html

入门教程: http://www.sthda.com/english/wiki/gviz-visualize-genomic-data



[推荐] learn Gviz
# https://mp.weixin.qq.com/s?__biz=Mzg5MzYzNTcwNQ==&mid=2247490523&idx=1&sn=4d54c2e0f561c8d6eff88db8e9769928


R包的示例数据，都可以 载入慢慢玩：
list.files(system.file('data' ,package = 'Gviz'))

cummeRbund 包 也依赖 Gviz包。



(1) 安装 
# BiocManager::install("Gviz")
library(Gviz)


# 1. 画基因在染色体的位置
idTrack <- IdeogramTrack(chromosome="X", genome='hg19') 
plotTracks(idTrack, from=153285264, to=153365188) 
# chrX:153285264-153365188


# 2. 画一个track，就是竖线/矩形，只有最后一句起作用了
library(GenomicRanges)
data(cpgIslands)
#print( class(cpgIslands) ) #"GRanges"
print( head(cpgIslands) )
#    seqnames            ranges strand
#<Rle>         <IRanges>  <Rle>
#  [1]     chr7 26549019-26550183      *
#  [2]     chr7 26564119-26564500      *

print('***********')
chr <- as.character(unique(seqnames(cpgIslands))) #"chr7"
gen <- genome(cpgIslands)
print(chr)
print('***')
print(gen)
#  chr7 
#"hg19"

atrack <- AnnotationTrack(cpgIslands, name='CpG') 
plotTracks(atrack)


# 3. 画带箭头的外显子，最后一行起作用
# BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene) 
txdb=TxDb.Hsapiens.UCSC.hg19.knownGene
#print(str(txdb))
#print(length(exonsBy(txdb))) #82960
#print(TxDb.Hsapiens.UCSC.hg19.knownGene)

g1 = exonsBy(txdb)[[1]] 
print(class(g1))
print(g1)
#print(str(g1))

atrack <- AnnotationTrack(g1, name='g1') 
plotTracks(atrack)



# 4. 画覆盖度
#需要读取bw格式的reads覆盖情况文件，这个时候可以使用R包自带的bw文件，使用 函数 DataTrack 来读取bw文件：

bgFile=system.file('extdata' ,package = 'Gviz','test.wig')
print(head(bgFile)) #filename

bw<-DataTrack(range = bgFile,genome='hg19',
			type='histogram', name='test')
print(bw)
plotTracks(bw)



# 5. 组合：把染色体信息，基因结构信息，覆盖度情况结合起来
假设，我们上面3个例子绘制的都是同一个区域的图，就可以结合：

tracklist=list()
tracklist[['bw']]=bw
tracklist[['atrack']]=atrack
tracklist[['idTrack']]=idTrack
plotTracks(tracklist)
# 其中 bw, atrack, idTrack 都是 AnnotationTrack 对象，它们组合为一个list，就可以一起绘制了。















2. 组合结果

将利用小鼠 mm9 基因组上的 UCSC 基因组和 7 号染色体 (chr7)

# BiocManager::install("Gviz")
library(Gviz)
library(GenomicRanges)

#加载数据 : class = GRanges
data(cpgIslands)

str(cpgIslands)
head(cpgIslands)
tail(cpgIslands)
# 3列，chr/start-end/ Rle不知道最后一列是啥

# (1) Annotation track, 标题命名为"CpG"
atrack <- AnnotationTrack(cpgIslands, name = "CpG2") #左侧的track名字
atrack
p<-plotTracks(atrack)
p



## (2) 基因组坐标
gtrack <- GenomeAxisTrack() #顶部加上基因组track
plotTracks(list(gtrack, atrack))


##(3) 添加染色体表意文字
#要添加染色体表意文字 (ideogram)，我们必须指明有效的 UCSC 基因组（例如："hg19"）以及染色体名称（例如："chr7"）
#由于该功能从 UCSC 获取数据，因此需要 Internet 连接，这可能需要很长时间。

# genome : "hg19"
gen<-genome(cpgIslands)
gen
#chr7
#"hg19"

# Chromosme name : "chr7"
chr <- as.character(unique(seqnames(cpgIslands))) #"chr7"

# Ideogram track
itrack <- IdeogramTrack(genome = gen, chromosome = chr) #联网，超慢！

plotTracks(list(itrack, gtrack, atrack)) #一共3行，最顶新增染色体长短臂

# 表意文字轨迹( ideogram track ) 是所有Gviz轨迹对象中的一个例外，因为它们不像所有其他轨迹那样真正显示在同一坐标系上。
#取而代之的是，当前的基因组位置在染色体上用一个红色方框表示（或者，在本例中，如果宽度太小而无法容纳方框，则用红线表示）。


# (4)添加基因模型

# 加载数据
data(geneModels)
dim(geneModels) #97 10
head(geneModels)
#  chromosome    start      end width strand feature            gene            exon      transcript     symbol
#1       chr7 26591441 26591829   389      + lincRNA ENSG00000233760 ENSE00001693369 ENST00000420912 AC004947.2

# 画图
grtrack <- GeneRegionTrack(geneModels, genome = gen,
                           chromosome = chr, name = "Gene Model4")
plotTracks(list(itrack, gtrack, atrack, grtrack), col.main="red")


# 放大绘图
# 1)使用 from 和 to 参数进行缩放
plotTracks(list(itrack, gtrack, atrack, grtrack),
           from = 26700000, to = 26750000)

# 2) 使用 extend.left 和 extend.right 进行缩放
# 这些参数是相对于当前显示的范围，
# 并且可用于在绘图的一端或两端快速扩展视图。
plotTracks(list(itrack, gtrack, atrack, grtrack),
           extend.left = 0.1, extend.right = 500000) #

# 删除外显子的边界,更好的展示图片
plotTracks(list(itrack, gtrack, atrack, grtrack),
           extend.left = 0.5, extend.right = 500000, col = NULL) #值为 0.5 时将放大到当前显示范围的一半


# 添加序列track并放大查看序列
# 序列信息来自 BSgenome 包
# BiocManager::install("BSgenome.Hsapiens.UCSC.hg19")

library(BSgenome.Hsapiens.UCSC.hg19)
strack <- SequenceTrack(Hsapiens, chromosome = chr)
plotTracks(list(itrack, gtrack, atrack, grtrack,
                strack), #要放大到30bp，才能看到碱基
           from = 26591822, to = 26591852, cex = 0.8)


# (5) 设置参数
#Annotation of transcript
# 更改面板和标题背景颜色
grtrack <- GeneRegionTrack(geneModels, genome = gen,
                           chromosome = chr, name = "Gene Model5",
                           transcriptAnnotation = "symbol",
                           background.panel = "#dbeeff",
                           background.title = "darkblue")
plotTracks(list(itrack, gtrack, atrack, grtrack))


# (6) 默认情况下，所有轨迹都将以 5' -> 3' 方向绘制。有时实际显示相对于相反链的数据会很有用。
plotTracks(list(itrack, gtrack, atrack, grtrack),
           reverseStrand = TRUE)
# 数据已绘制在反向链上这也反映在 GenomeAxis track 中。










3. 直接由bam文件画 AlignmentsTrack 峰图
(1) add AlignmentsTrack

afrom=2966000
ato=afrom + 1e4 #3160000
#bam file
alTrack <- AlignmentsTrack(system.file(package = "Gviz", "extdata", "gapped.bam"),
                           isPaired = TRUE, name="AlignmentsTrack Ctrl")
bmt <- BiomartGeneRegionTrack(genome = "hg19", chromosome = "chr12",
                              start = afrom, end = ato,
                              filter = list(with_ox_refseq_mrna = TRUE),
                              stacking = "pack")
plotTracks(c(bmt, alTrack),
           coverageHeight = 0.48, #控制高度
           from = afrom, to = ato, chromosome = "chr12")

# type = "coverage", #堆积 (pile-ups) 并不是特别有用，关掉
plotTracks(c(alTrack, bmt), from = afrom, to = ato, chromosome = "chr12", type = "coverage")

# 再放大
plotTracks(c(bmt, alTrack), from = afrom + 700,
           to = afrom + 3000, chromosome = "chr12")


#(opt) 单端模式下查看同一文件中的数据: isPaired = FALSE
if(0){
  alTrack.s <- AlignmentsTrack(system.file(package = "Gviz",
                                         "extdata", "gapped.bam"), isPaired = FALSE)
  plotTracks(c(bmt, alTrack.s), from = afrom + 700,
             to = afrom + 3000, chromosome = "chr12")
}

# 只看3'端
plotTracks(c(bmt, alTrack), from = afrom + 700,
           type = "coverage",
           to = afrom + 3000, chromosome = "chr12")







4. 如何自定义竖线呢？
toBed=function(pid){
  df1=NULL;
  for(i in pid){
    rs=strsplit(i, ":")[[1]]
    pos=as.numeric(rs[2])
    df1=rbind(df1, data.frame(
      chromosome =rs[1],
      start=pos,
      end=pos,
      strand=rs[3]
    ) )
  }
  return(df1)
}

pasPos=toBed(getAPAsitesByGene("CCND1"))

pasPos #如果输入 df，则必须要有 start和end列，而 chromosome 和 strand 则可选。
#  chromosome    start      end strand
#1      chr11 69466227 69466227      +
#2      chr11 69466256 69466256      +
#3      chr11 69468715 69468715      +
#4      chr11 69469241 69469241      +

atrack <- AnnotationTrack(pasPos, name = "polyA site")

plotTracks(c( getPolyA_track("CCND1") ), type="coverage",
           #sizes = c( rep(3,i-1),1),
           from = 69454807+7000, to = 69470105 + 1000, chromosome = "chr11",
           main="add new track")



ref:
http://www.bioconductor.org/packages/release/bioc/html/Gviz.html
http://www.bioconductor.org/packages/release/bioc/vignettes/Gviz/inst/doc/Gviz.html
http://www.sthda.com/english/wiki/gviz-visualize-genomic-data
https://www.jianshu.com/p/73cbebaefee4

(2)微信公众号 聊生信 2021-11-03 09:01 346个基因组可视化工具一网打尽！
GitHub来源：https://github.com/cmdcolin/awesome-genome-visualization
配套网页：https://cmdcolin.github.io/awesome-genome-visualization/?latest=true



========================================
|-- for 10x and c1 reads 峰图
----------------------------------------
图片见 https://blog.csdn.net/wangjunliang/article/details/122616156


1. for 10x bam file

# 能整合 UCSC或ENSEMBL等来源的公开基因组注释数据
# bam中染色体必须以 chr 字符串开头，可以决定通过调用 options(ucscChromosomeNames=FALSE) 来关此功能

library(Gviz)

## for 10x
options(ucscChromosomeNames=FALSE) #10x没有这一行，就没有峰图

rnaTrack1 <- AlignmentsTrack( "/home/wangjl/data/bams/N5_NH_CB_list_filtered_c1.bam",
                              col.title="black", #左侧标题颜色
                              #showAxis=F,
                             isPaired = TRUE, name="cluster1")
rnaTrack1
rnaTrack5 <- AlignmentsTrack( "/home/wangjl/data/bams/N5_NH_CB_list_filtered_c5.bam",
                              col.title="black", #左侧标题颜色
                           isPaired = TRUE, name="cluster5")
bmt <- BiomartGeneRegionTrack(genome = "hg38", chromosome = "12",
                              start = 6534514, end = 6534514 + 10000,
                              # filter = list(with_ox_refseq_mrna = TRUE),
                              name="CTLA4",
                              col.title="red", #左侧标题颜色
                              stacking = "pack") #pack/dense

#plotTracks(list(rnaTrack1, bmt), #type="coverage", coverageHeight = 0.8)

plotTracks(c(rnaTrack1, rnaTrack5, bmt), type="coverage",
           main="10x dataset",
           from = 203873844-3000, to = 203873844 + 500, chromosome = "2",
           sizes = c(3,3,1))
#


######### for other genes
# CCR7
bmt <- BiomartGeneRegionTrack(genome = "hg38", chromosome = "17",
                              start = 40558899, end = 40558899 + 10000,
                              # filter = list(with_ox_refseq_mrna = TRUE),
                              name="CCR7",
                              col.title="red", #左侧标题颜色
                              stacking = "pack") #pack/dense
plotTracks(c(rnaTrack1, rnaTrack5, bmt), type="coverage",
           main="10x dataset",
           from = 40558899-10000, to = 40558899 + 8500, chromosome = "17",
           sizes = c(3,3,1))
# GZMA
bmt <- BiomartGeneRegionTrack(genome = "hg38", chromosome = "5",
                              start = 55110133, end = 55110133 + 10000,
                              # filter = list(with_ox_refseq_mrna = TRUE),
                              name="GZMA",
                              col.title="red", #左侧标题颜色
                              stacking = "pack") #pack/dense
plotTracks(c(rnaTrack1, rnaTrack5, bmt), type="coverage",
           main="10x dataset",
           from = 55110133-8000, to = 55110133 + 500, chromosome = "5",
           sizes = c(3,3,1))








2. for C1 data
(1) 基本代码
library(Gviz)

rnaTrack1 <- AlignmentsTrack( "/home/wangjl/igv/GRB10/c01ROW31_GRB10.bam",
                              col.title="black", #左侧标题颜色
                              #showAxis=F,
                              isPaired = TRUE, name="c01ROW31")
rnaTrack1
rnaTrack5 <- AlignmentsTrack( "/home/wangjl/igv/GRB10/c15ROW22_GRB10.bam",
                              col.title="black", #左侧标题颜色
                              isPaired = TRUE, name="c15ROW22")
bmt <- BiomartGeneRegionTrack(genome = "hg19", chromosome = "chr7",
                              start = 50657767, end = 50657767 + 10000,
                              # filter = list(with_ox_refseq_mrna = TRUE),
                              name="GRB10",
                              col.title="red", #左侧标题颜色
                              stacking = "pack") #pack/dense

plotTracks(c(rnaTrack1, rnaTrack5, bmt), type="coverage",
           main="C1 dataset",
           from = 50657767-500, to = 50657767 + 3000, chromosome = "chr7",
           sizes = c(3,3,1))





(2) 升级版：批量化，并设置自定义颜色

library(Gviz)

# for c1
#fn1: 获取指定文件夹下的所有bam文件的文件名
getBamFileNames=function(filepath, suffix=".bam$"){
  fnames=dir(filepath)[grep(suffix, dir(filepath))]
  return( paste0(filepath, fnames) )
}

bam.files=getBamFileNames("/home/wangjl/igv/GRB10/")
bam.files

# fn2: 从文件名全路径中提取关键词，作为样本名字
getKeyword=function(fullpath, delete=""){
  rs1=strsplit(fullpath, "/")[[1]]
  rs1=rs1[length(rs1)]
  return(sub(delete, "", rs1))
}
getKeyword("/home/wangjl/igv/GRB10/c01ROW31_GRB10.bam", "_GRB10.bam") #"c01ROW31"

{
  rnaTracks=list()
  i=0
  for(fname in bam.files){
    i=i+1
    if(i>8) break;
    fig.keyword=getKeyword(fname, "_GRB10.bam")
    message(i, "\t", "Adding: ", fig.keyword, "(",fname, ")")
    rnaTrack1 <- AlignmentsTrack( fname, #"/home/wangjl/igv/GRB10/c01ROW31_GRB10.bam",
                                  background.legend="blue",
                                  #background.panel="blue", #整个背景色
                                  background.title="transparent", #标题背景色
                                  col.title="red", #左侧标题颜色
                                  #col.grid="black",

                                  col.border.title="transparent", #左侧坐标轴标签框颜色

                                  fill="lightblue", #峰图填充色
                                  col.coverage="transparent", #峰图边框颜色
                                  #coverageHeight=10,

                                  showAxis=T, #不显示坐标轴
                                  col.axis="black", #左侧坐标轴颜色

                                  #isPaired = TRUE, #pile-up图是否配对，本次不显示该部分，所以不用设置
                                  name=fig.keyword) #左侧关键词
    rnaTracks=c(rnaTracks, rnaTrack1)
  }

  bmt <- BiomartGeneRegionTrack(genome = "hg19", chromosome = "chr7",
                                start = 50657774, end = 50657774+2e4,
                                # filter = list(with_ox_refseq_mrna = TRUE),
                                background.title="transparent", #标题背景色
                                col.title="black", #左侧标题颜色
                                col="transparent", #基因结构的边框颜色
                                stacking = "pack", name="GRB10") #pack/dense
  plotTracks(trackList=c(rnaTracks, bmt),
             type="coverage", #不要堆叠图
             sizes=c(rep(2,i-1), 1), #每个track的高度，要和第一个参数配对
             from = 50657774-300, to = 50657774 + 3e3, chromosome = "chr7")
}









========================================
|-- ArchR 单细胞 ATAC-seq 峰图
----------------------------------------
1. 
ArchR https://www.archrproject.com/articles/Articles/tutorial.html
Publication: (doi link) (2021) (# citations 85) https://www.nature.com/articles/s41588-021-00790-6
Language: R
Tags: Single cell
Github: https://github.com/GreenleafLab/ArchR
Github Stargazers: 192 (2022.1.27)

https://github.com/GreenleafLab/ArchR
https://www.archrproject.com/
https://www.archrproject.com/articles/Articles/tutorial.html


(1) 示例图
https://cmdcolin.github.io/awesome-genome-visualization/archr.png



(2) 官方代码: Visualizing Genome Browser Tracks
https://www.archrproject.com/bookdown/index.html

In addition to plotting gene scores per cell as a UMAP overlay, we can browse the local chromatin accessibility at these marker genes on a per cluster basis with genome browser tracks. 


# To do this, we use the plotBrowserTrack() function which will create a list of plots, one for each of the genes specified by markerGenes.
p <- plotBrowserTrack(
    ArchRProj = proj, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)
# 函数定义 https://github.com/GreenleafLab/ArchR/blob/master/R/ArchRBrowser.R
到底基于哪个包绘制峰图的呢？



# To plot a track of a specific gene, we can simply select one from the list.
grid::grid.newpage()
grid::grid.draw(p$CD14)


# We can save a multi-page PDF with a single page for each gene locus in our plot list using the plotPDF() function.
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)



(3) 追踪代码
1) https://github.com/GreenleafLab/ArchR/blob/master/R/ArchRBrowser.R

p <- .bulkTracks(
                ArchRProj = ArchRProj, 
                region = region, 
                tileSize = tileSize, 
                useGroups = useGroups,
                groupBy = groupBy,
                threads = threads, 
                minCells = minCells,
                ylim = ylim,
                baseSize = baseSize,
                borderWidth = borderWidth,
                tickWidth = tickWidth,
                facetbaseSize = facetbaseSize,
                normMethod = normMethod,
                geneAnnotation = geneAnnotation,
                title = "",
                pal = pal, 
                tstart = NULL,
                logFile = logFile
              ) + theme(plot.margin = unit(c(0.35, 0.75, 0.35, 0.75), "cm"))

克隆到本地再查找，好吧，还是在本文件定义的：
	- 一般 点号 开头的变量或函数都是内部使用的，对外不暴露。
$ find . | xargs grep "bulkTracks" 2>/dev/null 
./R/ArchRBrowser.R:            p <- .bulkTracks(
./R/ArchRBrowser.R:            p <- .bulkTracks(
./R/ArchRBrowser.R:      plotList$bulktrack <- .bulkTracks(
./R/ArchRBrowser.R:.bulkTracks <- function(
./R/ArchRBrowser.R:  .logThis(split(df, df[,3]), ".bulkTracks df", logFile = logFile)


.bulkTracks <- function(){}中真正画图的函数竟然是 ggplot2

p <- ggplot(df, aes_string("x","y", color = "group", fill = "group")) + 
    geom_area(stat = "identity") + 
    facet_wrap(facets = ~group, strip.position = 'right', ncol = 1) +
    ylab(sprintf("Coverage\n(Norm. ATAC Signal Range (%s-%s) by %s)", round(min(ylim),2), round(max(ylim),2), normMethod)) +
    scale_color_manual(values = pal) +
    scale_fill_manual(values = pal) +
    scale_x_continuous(limits = c(start(region), end(region)), expand = c(0,0)) +
    scale_y_continuous(limits = ylim, expand = c(0,0)) +

往上看这个df怎么定义的

df <- .groupRegionSumArrows( #line 980
    ArchRProj = ArchRProj, 
    groupBy = groupBy, 
    normMethod = normMethod,
    useGroups = useGroups,
    minCells = minCells,
    region = region, 
    tileSize = tileSize, 
    threads = threads,
    verbose = verbose,
    logFile = logFile
  )

继续查这个函数，也在同一个文件内
	- 作者定义了一个新的文件格式 arrow: 
# Create Average Tracks from Arrows
.groupRegionSumArrows <- function(
  ArchRProj = NULL,
  useGroups = NULL,
  groupBy = NULL,
  region = NULL,
  tileSize = NULL,
  normMethod = NULL,
  verbose = FALSE,
  minCells = 25,
  maxCells = 500,
  threads = NULL,
  logFile = NULL
  )

看不懂了，暂停。




(4) 辅助函数是干啥的？
看名字是记录日志的，看看怎么写的，怎么用的。


.logError(e, fn = ".groupRegionSumArrows", info = .sampleName(ArrowFiles[i]), errorList = errorList, logFile = logFile)


$ find . | xargs grep "logError <- function" 2>/dev/null 
./R/LoggerUtils.R:.logError <- function(

https://github.com/GreenleafLab/ArchR/blob/master/R/LoggerUtils.R





========================================
ggvis: 浏览器中显示可交互式图
----------------------------------------
1.Vega: A Visualization Grammar 
https://github.com/vega/vega

With Vega you can describe data visualizations in a JSON format, and generate interactive views using either HTML5 Canvas or SVG.

2.ggvis is a data visualization package for R
http://ggvis.rstudio.com/

The goal is to combine the best of R (e.g. every modelling function you can imagine) and the best of the web (everyone has a web browser). Data manipulation and transformation are done in R, and the graphics are rendered in a web browser, using Vega.









========================================
曼哈顿图: 展示突变基因在染色体上的位置和p值
----------------------------------------
1. 什么是曼哈顿图 Manhattan Plot
曼哈顿图是一种散点图，通常用于显示具有大量数据点，许多非零振幅和更高振幅值分布的数据。该图通常用于全基因组关联研究（GWAS）以显示重要的SNP（来源wiki）。

在图中每个点代表一个SNP，纵轴为每个SNP计算出来的Pvalue取-log10，横轴为SNP所在的染色体。基因位点的Pvalue越小即-log10(Pvalue)越大，其与表型性状或疾病等关联程度越强。而且通常来说受到连锁不平衡的影响，强关联位点周围的SNP也会显示出相对较高的信号强度，并依次向两边递减，所以会出现上图中红色部分的现象。一般，在GWAS的研究中，Pvalue的阈值在10^-6 或者10^-8以下。


2.怎么做曼哈顿图 Manhattan Plot
使用R包 qqman——an R package for creating Q-Q and manhattan plots

(1) 安装包
install.packages("qqman")

(2) 所需数据的格式
library(qqman)
data("gwasResults")
head(gwasResults)
#   SNP CHR BP         P
# 1 rs1   1  1 0.9148060
# 2 rs2   1  2 0.9370754
# 3 rs3   1  3 0.2861395
# 4 rs4   1  4 0.8304476
# 5 rs5   1  5 0.6417455
# 6 rs6   1  6 0.5190959

第一列为SNP的名字，第二列CHR为所在染色体，第三列BP为染色体上所在位置。要注意如果你的CHR中存在X，Y这样的，需要给他们转化为数字如赋予23，24等。
其中第一列SNP的名字是可选择的，后三列是必须提供的。

(3) 画图
1)基础版: 按照chr黑灰交替
manhattan(gwasResults, chr="CHR", bp="BP", snp="SNP", p="P" )


2)标记其中一系列你感兴趣的SNP：给出你感兴趣的snpsOfInterest列表即可。
snpsOfInterest #这些点会高亮显示
# [1] "rs3001" "rs3002" "rs3003" "rs3004" "rs3005" "rs3006" "rs3007" "rs3008" "rs3009" "rs3010" "rs3011"
# [12] "rs3012" "rs3013" "rs3014" "rs3015" "rs3016" "rs3017" "rs3018" "rs3019" "rs3020" "rs3021" "rs3022"
manhattan(gwasResults, highlight = snpsOfInterest)


3)想知道每条染色体上pvalue最小的SNP
manhattan(gwasResults, annotatePval = 0.01)
manhattan(gwasResults, annotatePval = 0.0001)#不符合该筛选条件的即使-log10(pvalue)最高也不显示


4)不喜欢黑色和灰色的搭配，也可以自行改变颜色。
manhattan(gwasResults, annotatePval = 0.01,annotateTop = T, col = c("grey", "skyblue")) #灰蓝交替







3. 还可以使用ggplot2来绘制 

(1) 使用dplyr 包的%>% 管道符整理数据

library(dplyr)
don <- gwasResults %>% 
  
  # Compute chromosome size
  group_by(CHR) %>% 
  summarise(chr_len=max(BP)) %>% 
  
  # Calculate cumulative position of each chromosome
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%
  
  # Add this info to the initial dataset
  left_join(gwasResults, ., by=c("CHR"="CHR")) %>%
  
  # Add a cumulative position of each SNP
  arrange(CHR, BP) %>%
  mutate( BPcum=BP+tot)

head(don)
#   SNP CHR BP         P tot BPcum
# 1 rs1   1  1 0.9148060   0     1
# 2 rs2   1  2 0.9370754   0     2
# 3 rs3   1  3 0.2861395   0     3
# 4 rs4   1  4 0.8304476   0     4
# 5 rs5   1  5 0.6417455   0     5
# 6 rs6   1  6 0.5190959   0     6

axisdf = don %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )
head(axisdf)
# # A tibble: 6 x 2
#     CHR center
#   <int>  <dbl>
# 1     1   750.
# 2     2  2096 
# 3     3  3212.
# 4     4  4204 
# 5     5  5115 
# 6     6  5966 


don是用于作图的主要数据表，而axisdf是用于处理x轴，因为我们想要他们按照染色体的位置排布。



(2) 绘图
ggplot(don, aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    scale_y_continuous(expand = c(0, 0) ) +     # remove space between plot area and x axis
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    )

其中 scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center )控制着x轴的刻度位置和标签文本。



(3)如果想要把某些SNP标记出来呢？那么我们在前期处理数据的时候需要将这些数据标记出来，这个过程和之前火山图标记显著的基因很类似:
don <- gwasResults %>% 
  
  # Compute chromosome size
  group_by(CHR) %>% 
  summarise(chr_len=max(BP)) %>% 
  
  # Calculate cumulative position of each chromosome
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%
  
  # Add this info to the initial dataset
  left_join(gwasResults, ., by=c("CHR"="CHR")) %>%
  
  # Add a cumulative position of each SNP
  arrange(CHR, BP) %>%
  mutate( BPcum=BP+tot) %>%

  # ！！！！！！Add highlight and annotation information
 mutate( is_highlight=ifelse(SNP %in% snpsOfInterest, "yes", "no")) %>%
  mutate( is_annotate=ifelse(-log10(P)>4, "yes", "no")) 

# Prepare X axis
axisdf <- don %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )


## 然后画图的时候geom_point在颜色上进行区分，并使用geom_label_repel标注出来即可：
ggplot(don, aes(x=BPcum, y=-log10(P))) +
    
    # Show all points
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    
    # custom X axis:
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    scale_y_continuous(expand = c(0, 0) ) +     # remove space between plot area and x axis

    # Add highlighted points
    geom_point(data=subset(don, is_highlight=="yes"), color="orange", size=2) +
  
    # Add label using ggrepel to avoid overlapping
    geom_label_repel( data=subset(don, is_annotate=="yes"), aes(label=SNP), size=2) +

    # Custom the theme:
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    )








ref:
https://www.jianshu.com/p/1edc44fe922f









========================================
聚类树/进化树 Phylogenetic tree: ape 包
----------------------------------------

常用代码

# 通过距离聚类
out.dist= dist(mtcars); #out.dist
out.hclust=hclust( out.dist, method="ward.D2" ); out.hclust
rev(rownames(mtcars)[out.hclust$order]) #聚类后的顺序

# 画图，朝向左侧的树
library(ape)
plot(as.phylo(out.hclust), direction = "leftward")

?ape::plot.phylo() #F1 查看更多参数




1. R做聚类树分别用到了cor.dist、hclust、plot三个函数分别算相关性，聚类并作图。

(1)有关聚类的R包可以参考cluster包和ape包。
三角形、环形进化树，实线、虚线，旋转90度，染色、不同背景色，
R语言最全谱系图
- 原文：http://rstudio-pubs-static.s3.amazonaws.com/1876_df0bf890dd54461f98719b461d987c3d.html
- 翻译：http://blog.csdn.net/u010157382/article/details/45562435


可视化 mega，上色是mega画好后ai添加的
http://muchong.com/html/201602/9981406.html




(2) 核心问题
把相近的放一起，再把次相近的放一起。
	怎么定义相近？ How do we define close?
	怎么分组？ How do we group things?
	怎么可视化分组？ How do we visualize the grouping?
	怎么解释分组？ How do we interpret the grouping?
#

todo: https://bookdown.org/rdpeng/exdata/hierarchical-clustering.html




(3) 使用 R 基础绘图

使用 mtcars 数据集。
# 1. 算距离，默认是欧拉距离
out.dist= dist(mtcars); out.dist #一个下三角矩阵
# 2. 聚类，可以指定聚类方法
out.hclust=hclust( out.dist, method="ward.D2" ); out.hclust
# 3. 画图 
plot(out.hclust)


# 4. 更精细画图
plot( out.hclust, hang=0.1, #最外围长度
      axes=F, #去掉坐标轴
      ann=F, #不要坐标轴标题 xlab, ylab
      #labels=T, #不加标签，就是行名
      main="")
# 剪枝
#rect.hclust(out.hclust, k=2) #分成2类
#rect.hclust(out.hclust, k=2, border="blue")
rect.hclust(out.hclust, k=3, border=c("green", "cyan", "navy")) #指定不同颜色圈住每亚类
rect.hclust(out.hclust, k=5, which=c(1,3), border="purple") #圈住感兴趣的亚类



1) # 利用K值进行剪枝，并获取每类的名字
# https://blog.csdn.net/woodcorpse/article/details/84899008
out.cut=cutree(out.hclust, k=3)
out.cut
table(out.cut) #每一类有几个

2) # 利用Height值进行剪枝，并获取每类的名字
out.cut=cutree(out.hclust, h=200)
out.cut
table(out.cut) #每一类有几个

3) 其他输出
# 合并过程，-值是原来的类，正值是合并后产生的类
out.hclust$merge

# 每个分支的高度？
barplot(out.hclust$height)

# 聚类输出的顺序
out.hclust$order
可以对原始数据框进行排序
df1=df1[ rev(out.hclust$order),]
df1






(4) 距离
https://blog.csdn.net/weixin_39538687/article/details/111839410
https://blog.csdn.net/weixin_34351588/article/details/112868469

在聚类中求两点的距离有：
1，绝对距离：manhattan
2，欧氏距离：euclidean 默认
3，闵科夫斯基距离：minkowski
4，切比雪夫距离：chebyshev
5，马氏距离：mahalanobis
6，蓝氏距离：canberra

用默认的算法求出距离如下
out.hclust=hclust(out.dist,method="complete") #根据距离聚类




(5) 聚类方法 hclust(d, method = "complete", members=NULL)
d为距离矩阵。

method表示类的合并方法，有：
single            最短距离法
complete        最长距离法 （默认）
median        中间距离法
mcquitty        相似法
average        类平均法
centroid        重心法
ward            离差平方和法
density     密度估计法
有人推荐 ward.D2，说是最优的，不太确定 //todo


#'举例
d <- dist(x)
hc <- hclust(d,"single")
plot(hc)


#'然后可以用rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,border = 2, cluster = NULL)来确定类的个数。 #'tree就是求出来的对象。k为分类的个数，h为类间距离的阈值。border是画出来的颜色，用来分类的。
rect.hclust(hc,k=2)
rect.hclust(hc,h=0.5)

#'提取每个样本所属的类别
label <- cutree(hc,k=2)






2. 使用 ape 包画进化树

# 使用 mtcars 数据集
out.hclust=hclust(dist(mtcars))


# 水平向右的聚类图
# install.packages('ape')
library(ape)

?ape::plot.phylo() #F1 查看更多参数
plot(x, type = "phylogram", use.edge.length = TRUE,
    node.pos = NULL, show.tip.label = TRUE, show.node.label = FALSE,
    edge.color = "black", edge.width = 1, edge.lty = 1, font = 3,
    cex = par("cex"), adj = NULL, srt = 0, no.margin = FALSE,
    root.edge = FALSE, label.offset = 0, underscore = FALSE,
    x.lim = NULL, y.lim = NULL, direction = "rightwards",
    lab4ut = NULL, tip.color = "black", plot = TRUE,
    rotate.tree = 0, open.angle = 0, node.depth = 1,
    align.tip.label = FALSE, ...)


(1) type 参数: plot.phylo函数支持4种不同类型的聚类树形图
type	
a character string specifying the type of phylogeny to be drawn; it must be one of "phylogram" (the default), "cladogram", "fan", "unrooted", "radial" or any unambiguous abbreviation of these.

plot(as.phylo(out.hclust), type = "phylogram") #默认
plot(as.phylo(out.hclust), type = "cladogram", cex = 0.9, label.offset = 1) # 进化分枝图
plot(as.phylo(out.hclust), type = "fan") # fan 扇形，这个最漂亮

plot(as.phylo(out.hclust), type = "unrooted") #无根树，标签重叠很厉害
plot(as.phylo(out.hclust), type = "radial") # radial



(2) direction 参数：整个树的朝向 上/下/左/右（默认）
direction	
a character string specifying the direction of the tree. Four values are possible: "rightwards" (the default), "leftwards", "upwards", and "downwards".

# 画向左的树
plot(as.phylo(out.hclust), 
     directio="leftwards", #向左，共四个朝向
     cex = 0.9, #文字大小
     srt=-30, #文字标签旋转
     label.offset = 0.01) #标签和树的距离


(3) 颜色控制
1) 扇形图 add colors randomly 
plot(as.phylo(out.hclust), 
     type = "fan",  #风扇型
     tip.color = hsv(runif(15, 0.65,  0.95), 1, 1, 0.7), 
     edge.color = hsv(runif(10, 0.65, 0.75), 1, 1, 0.7), 
     edge.width = runif(20, 0.5, 3), 
     use.edge.length = TRUE, col = "gray80")


2) 控制不同类的颜色
# vector of colors
mypal = c("#556270", "#4ECDC4", "#1B676B", "#FF6B6B", "#C44D58")
# cutting dendrogram in 5 clusters
clus5 = cutree(out.hclust, 5)
# plot
op = par(bg = "#E8DDCB", mar=c(4,2,3,2))
# Size reflects miles per gallon
plot(as.phylo(out.hclust), 
     type = "fan", 
     tip.color = mypal[clus5], 
     rotate.tree = 70, #旋转
     label.offset = 10, 
     #xpd=T,
     cex = 0.7,#log(mtcars$mpg, 10), 
     col = "red")


原生 R: 
plot(out.hclust,
	hang=0.1, #最外围长度
     ann=F, axes=F,
     cex = 0.7,
     col = "darkred")
rect.hclust( out.hclust, k=3, border = c("#FF6B6B", "#4ECDC4", "#556270") )

















10. 推荐博客，很详细，且文艺到艺术：

算法不清楚，看文献：
(1).如果是dna或者蛋白序列信息，可以使用mega构建进化树。
how: http://blog.sina.com.cn/s/blog_5eb2fefb0101gny0.html
(2).如果是vntr数据，或者多位点可变数量串联重复序列分析(multiple-locus variable-numbertandem-repeat analysis,MLVA)数据，则只能用BioNumerics 了。
http://www.applied-maths.com/bionumerics
http://www.bionumerics.cn/download.html
申请免费： https://www.researchgate.net/post/Is_there_any_trial_version_of_Bionumerics_software_available_online_or_any_other_free_software


Data analysis services
Unravelling the puzzleApplied Maths offers a service of having your data analyzed at an hourly rate. Data sources include any type of 1D gels, 2D gels, chromatography, HPLC or MALDI, MLST, VNTR and other typing techniques, phenotype data, microarrays, sequences up to full chromosomes, including comparison, gene mapping and annotation.

If you would like to obtain more information or a quotation about this Applied Maths' service please do not hesitate to contact us.




ref:
https://bookdown.org/rdpeng/exdata/hierarchical-clustering.html

https://www.cnblogs.com/ywliao/articles/7411835.html






========================================
|-- 兰德系数(Rand Index)、调整兰德系数 （聚类评价标准）
----------------------------------------

兰德系数（Rand index）
调整兰德系数(Adjusted Rand index)

调整兰德系数（Adjusted Rand index）用于聚类模型的性能评估，但是其需要true_label,在正式介绍兰德系数之前，先介绍调整兰德系数的前身，兰德系数。



1. 一个小案例说明兰德系数是如何怎么计算的
http://www.otlet-institute.org/wikics/Clustering_Problems.html#toc-Subsection-4.1

(1)聚类问题
The clustering problems are a class of optimization problems where the goal is to group a set of objects in different groups, each object being assigned in one group only.

矫正的兰德系数衡量整个方案的整体质量。当聚类不好时，要看 precision and recall。
The adjusted Rand Index is used to measure the global quality of a solution. When a clustering is not correct, the measures of precision and recall are necessary to determine the reasons. In fact, there is a relation between recall and precision:

- A high value of the recall and a low value of the precision indicate that the resulting clustering has too few clusters: most objects that belongs to the same ideal cluster are grouped together, but are also grouped with objects of other ideal clusters.
- A low value of the recall and a high value of the precision indicate that the resulting clustering has too many clusters: most objects that are grouped together belongs to the same ideal cluster, but all the objects of the same ideal cluster are not grouped together.



(2)例子: 给定个对象集合S，假设A和B表示S的两个不同划分
假设A是外部评价标准即true_label，而B是聚类结果。

理想分类A
Ideal Clustering
	t1:1,2,3
	t2:4,5,6
	t3:7,8,9

计算方法B：
Computed Clustering
	c1:1,2
	c2:3,4,5,6
	c3:7,8
	c4:9

注意：计算方法给出了4类，而理想分类是3类。
Notice that, while there are 3 ideal cluster, the computed solution provides 4 clusters in this example.



Adjusted Rand index
The aim of the adjusted Rand index is to establish an overall comparison between the computed and the ideal clustering. It is based on the Rand index [3], where a comparison is made between the assignments of each pair of objects in the ideal and the computed clustering. Roughly speaking, the Rand index computes the percentage of pairs of objects for which both classification methods, the computed and the ideal one, agree.
本质：待分类对象的两两随机配对中，两种方法意见(理想、计算)统一的占比。
兰德系数的值在[0,1]之间，当聚类结果完美匹配时，兰德系数为1。

Let a be the number of pairs of objects in the same topic and the same computed cluster, 
let b be the number of pairs of objects in the same ideal cluster but not in the same computed cluster, 
let c be the number of pairs of objects in the same computed cluster but not in the same ideal cluster, and 
let d be the number of pairs of objects in different computed clusters and in different ideal clusters. 

对于上例
a=5 {(1,2), (4,5), (4,6), (5,6), (7,8)} #都在一类
b=4 {(1,3), (2,3), (7,9), (8,9)}
c=3 {(3,4), (3,5), (3,6)}
d=24 {(1,4), ...} #都不在一类

混淆矩阵
+----------------#---------------+------------------#-------------------+
| TP:                            | FN:                                  |
| Same class + same cluster      | Same class + different clusters      |
+----------------#---------------+------------------#-------------------+
| FP:                            | TN:                                  |
| different class + same cluster | different class + different clusters |
+----------------#---------------+------------------#-------------------+

行方向表示same class by A，可求得TP+FN的值；
列方向表示same cluster by B，可求得TP+FP的值。
总个数组合“选2个”，可求得总值TP+FN+FP+TN。矩阵的的每个元素组合“选2个”，即可求得TP的值。剩下的，相减即可。

兰德系数(Rand Index) = （TP+TN）/（TP+FP+FN+TN）= (a+d)/(a+b+c+d) = (5+24)/(5+4+3+24)=0.81

准确度（Precision） = （TP）/（TP+FP）；
召回率（Recall）=（TP）/（TP+FN）；



d1=data.frame(
  A=mtcars$gear,
  B=mtcars$carb
)
> table(d1$A)
 3  4  5 
15 12  5 
> table(d1$A, d1$B)
    1 2 3 4 6 8
  3 3 4 3 5 0 0
  4 4 4 0 4 0 0
  5 0 2 0 1 1 1
#





2. 调整兰德系数(Adjusted Rand index)

(1) 兰德系数的问题在于对于两个随机的划分,其兰德系数值不是一个接近于0的常数。Hubert和Arabie在1985年提出了调整兰德系数，调整兰德系数假设模型的超分布为随机模型，即和的划分为随机的，那么各类别和各簇的数据点数目是固定的。

# https://scikit-learn.org/stable/modules/clustering.html#adjusted-rand-index

The Rand index does not ensure to obtain a value close to 0.0 for a random labelling. The adjusted Rand index corrects for chance and will give such a baseline.

Poorly agreeing labels (e.g. independent labelings) have lower scores, and for the adjusted Rand index the score will be negative or close to zero. However, for the unadjusted Rand index the score, while lower, will not necessarily be close to zero.


RI=(a+d)/C(2,n) #其中 C(2,n)是n个样本挑选2个的组合数，a+d 是两种分类意见一致的样品对数。
	RI不能保证在类别标签随机分配的情况下，其值接近0(极端情况是类别数和样本数相等)
	C(2,x)=x(x-1)/2
	
为了解决这个问题，ARI被提出，它具有更高的区分度：
	ARI=( RI-E[RI] ) / (max(RI) -E[RI])

ARI（Adjusted Rand index）其实是去均值归一化的形式。

已经证明，以上形式可以写成

ARI=( Sigma(C(2, nij)) -  ( sigma(C(2, ni.))*sigma(C(2, n.j)) ))/
	((Sigma(C(2,ni.)) + Sigma(C(2,n.j)))/2  - sigma(C(2,ni.))*sigma(C(2,n.j))/C(2,n) )

where nij represents the number of objects of an ideal cluster, ti, 
to be grouped into a computed cluster, cj.

其中: C(2, x)=x*(x-1)/2

ARI 需要用到contingency table
对上例
ideal\Computed 
      c1 c2 c3 c4 sums
t1    2  1  0  0  3
t2    0  3  0  0  3
t3    0  0  2  1  3
sums  2  4  2  1  9


少于2的忽略，因为挑选2个配对的方法为0次。
分子 
	C(2,2)+C(2,3)+C(2,2)=5
	(C(2,3)+C(2,3)+C(2,3)) * (C(2,2)+C(2,4)+C(2,2)) / C(2,9) = (3+3+3)*(1+6+1)/ (9*8/2)=2
分母
	((C(2,3)+C(2,3)+C(2,3)) + (C(2,2)+C(2,4)+C(2,2)))/2=8.5
ARI=(5-2)/(8.5-2)=0.46



(2) ARI的优点:
- 随机均匀的标签分布的ARI值接近0，这点与raw Rand Index和 V-measure指标不同;
- ARI值的范围是[-1,1]，负的结果都是较差的，说明标签是独立分布的，相似分布的ARI结果是正的，1是最佳结果，说明两种标签的分布完全一致;
- 不用对聚类结果做任何假设，可以用来比较任意聚类算法的聚类结果间的相似性。

ARI的缺点：
- ARI指标需要事先知道样本的真实标签，这和有监督学习的先决条件是一样的。然而ARI也可以作为一个通用的指标，用来评估不同的聚类模型的性能。




3. R 语言
(1) 使用R语言实现
d0=data.frame(
	A=rep( c(1,2,3), each=3),
	B=c(1,1,2,2,2,2,3,3,4 )
)

adjusted.Rand.index=function(a, b){
  tb=table(a, b);
  
  tb.num=as.data.frame( t(tb) )$Freq
  C=function(x){x*(x-1)/2}
  SigmaC=function(num){
    rs=0;
    for(i in num){
      if(i>=2){
        rs=rs+C(i)
      }
    }
    return(rs)
  }
  
  eRI = (SigmaC(as.numeric(rowSums(tb))) * SigmaC(as.numeric(colSums(tb)))) / SigmaC(sum(tb))
  return( (SigmaC(tb.num) - eRI) / ((SigmaC(as.numeric(rowSums(tb))) + SigmaC(as.numeric(colSums(tb))))/2 - eRI) )
}
adjusted.Rand.index(d0$A, d0$B) #0.461


# 极端情况
labels_true = c(0, 0, 0, 0, 0, 0, 1, 1)
labels_pred = c(0, 1, 2, 3, 4, 5, 5, 6)
adjusted.Rand.index(labels_true, labels_pred) #-0.0720




(2) R 包 
https://www.rdocumentation.org/packages/fossil/versions/0.4.0/topics/rand.index

fossil (version 0.4.0)
rand.index: Rand Index and Adjusted Rand Index
Description: Measures to compare the similarity of two clustering outcomes






ref:
https://www.cnblogs.com/devilmaycry812839668/p/10880006.html
https://blog.csdn.net/myy3075/article/details/86542102
http://faculty.washington.edu/kayee/pca/supp.pdf
http://scikit-learn.org/stable/modules/clustering.html#adjusted-rand-index
https://stats.stackexchange.com/questions/89030/rand-index-calculation

问答: https://stackoverflow.com/questions/tagged/ape-phylo









========================================
ggpubr 包: 一条命令轻松绘制CNS顶级配图
----------------------------------------
ggpubr 实际上是基于ggplot2 开发出来的包，目的是为了简化ggplot2的操作，便于画出满足论文出版要求的图。

Reference: http://rpkgs.datanovia.com/ggpubr/reference/index.html#section-make-programming-easy-with-ggplot-

install.packages("ggplot2")
install.packages("ggpubr")

#加载包
library(ggplot2)
library(ggpubr)


1.Plot One Variable - X, Continuous

ggdensity() 密度图
stat_overlay_normal_density() 密度图，同时叠加正态分布的图，有助于检查偏离值
gghistogram() 直方图。
ggecdf() 经验累积密度分布图
ggqqplot() 分位数-分位数图，简称QQ图。



2. Plot Two Vriables - X and Y, Discrete X and Continuous Y

ggboxplot() 箱图
ggviolin() 小提琴图

ggdotplot() 点图
ggstripchart() strip chart, 也可以称为一维散点图。

ggbarplot() 柱状图
ggline() 线图
ggerrorplot() Visualizing Error 绘制误差棒图

ggpie() 饼图
ggdonutchart() 甜甜圈饼图
ggdotchart()theme_cleveland() 克利夫兰点图



3. 更多

ggscatter() 散点图
stat_cor() 将有P值的相关系数添加到散点图中
stat_stars()) Add Stars to a Scatter Plot

ggscatterhist() 绘制具有边际直方图的散点图

ggpaired() Plot Paired Data

ggballoonplot()



ggmaplot()
Make MA-plot which is a scatter plot of log2 fold changes (on the y-axis) versus the mean expression signal (on the x-axis).

MA plot充分展示了基因丰度和表达变化之间的关系。我们可以看到，越靠左下或者右上的点，就是丰度越高而且变化幅度越大的基因。当然了，MA plot就丢了FDR这类统计量。二维图嘛，死活两个参数，顶多用颜色做个假三维。

不过对于终端小白用户来说，如果在volcano plot和MA plot中发现了重叠的靶点（实际上会有不少重叠），那就愉快地拿去做实验吧。





4. 例子 

内有箱线图的小提琴图+星标记

data("ToothGrowth")
df1 <- ToothGrowth
head(df1)

ggviolin(df1, x="dose", y="len", fill = "dose", 
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),  
         add = "boxplot", add.params = list(fill="white"))+ 
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+#label这里表示选择显著性标记（星号） 
  stat_compare_means(label.y = 50)
#




(2) 配色
# palette = "npg", #杂志nature的配色 





ref:
https://zhuanlan.zhihu.com/p/102653888
http://blog.sciencenet.cn/blog-3334560-1091714.html




========================================
用R语言对JPG/JPEG图片进行白背景透明处理
----------------------------------------

library(jpeg)
library(png)

setwd("C:\\Users\\admin\\Desktop\\blog_pics\\201904\\")

FILTER <- matrix(c("JPG file", "*.jpg", "JPEG file", "*.jpeg"), ncol = 2, byrow = T)
img <- choose.files(caption = "Select JPG files", filters = FILTER, index = 1, multi=T)
for(i in 1:length(img)){
  x <- readJPEG(img[i])
  dimx <- dim(x) #三维，前两维是x和y，第三维是rgb通道名。
  #分出来rgb三个通道
  n <- dimx[1]*dimx[2]
  r <- x[1:n]
  g <- x[(n+1):(2*n)]
  b <- x[(2*n+1):(3*n)]
  #
  ps <- 5; ps <- dimx[1]*(ps-1) + ps # 背景取值，ps为左上到右下角的像素，5。按情况修改
  tv <- 0.1 # tv为容差范围，0-1取值，越小越精确
  sel <- abs(r-r[ps])<tv & abs(g-g[ps])<tv & abs(b-b[ps])<tv
  alpha <- rep(1, n)
  alpha[sel] <- 0
  x <- array(c(x, alpha), dim=c(dimx[1:2], 4))
  writePNG(x, gsub("(.+\\.)(jpg|jpeg)$","\\1png", img[i], ignore.case = TRUE))
}


https://blog.csdn.net/u014801157/article/details/24372421




========================================
生存期 cox 回归 //todo 不是太懂
----------------------------------------

https://www.rdocumentation.org/packages/survival/versions/3.3-1/topics/coxph

1. 官方示例
if(!require('survival')) {
  install.packages('survival')
  library('survival')
}



# Create the simplest test data set
test1 <- list(time=c(4,3,1,1,2,2,3),
              status=c(1,1,1,0,1,1,0),
              x=c(0,2,1,1,1,0,0),
              sex=c(0,0,0,0,1,1,1))

# Fit a stratified model
coxph(Surv(time, status) ~ x + strata(sex), test1)
# Create a simple data set for a time-dependent model
test2 <- list(start=c(1,2,5,2,1,7,3,4,8,8),
              stop=c(2,3,6,7,8,9,9,9,14,17),
              event=c(1,1,1,1,1,1,1,0,0,0),
              x=c(1,0,0,1,0,1,1,1,0,0))
summary(coxph(Surv(start, stop, event) ~ x, test2))

#
# Create a simple data set for a time-dependent model
#
test2 <- list(start=c(1, 2, 5, 2, 1, 7, 3, 4, 8, 8),
              stop =c(2, 3, 6, 7, 8, 9, 9, 9,14,17),
              event=c(1, 1, 1, 1, 1, 1, 1, 0, 0, 0),
              x    =c(1, 0, 0, 1, 0, 1, 1, 1, 0, 0) )


summary( coxph( Surv(start, stop, event) ~ x, test2))

# Fit a stratified model, clustered on patients

bladder1 <- bladder[bladder$enum < 5, ]
coxph(Surv(stop, event) ~ (rx + size + number) * strata(enum),
      cluster = id, bladder1)

# Fit a time transform model using current age
coxph(Surv(time, status) ~ ph.ecog + tt(age), data=lung,
      tt=function(x,t,...) pspline(x + t/365.25))













2. coxph 本身应该不需要特别多资源的

> coxh(Surv(tstart, tstop, death) ~ age*trt + surgery + year,
		data=sdata, ties="breslow")

是不是code有问题
比如把连续变量当factor放进去了（我之前不小心写过这种code
就用的是time varying cov


trt是时变变量吗
如果是这样，那你代码写错了
反过来一样，trt是时间，age是时变，也不对


trt*age就构成了一个随年龄变化的时间依赖变量


哈哈 很少看到有有做这种的依时的。我看到有的文章，好多是直接cox多因素，等比例风险假设都不一定有做。











========================================
R语言画生存期 kmplot
----------------------------------------
1.生存率：
    RFS: Relapse Free Survival; 无复发生存期
    OS: Overall Survival; 总生存期
    DMFS: Distant Metastasis Free Survival; 无远处转移生存期
    PPS: Post Progression Survival 进展后生存期

2.芯片数据该怎么做标准化：系统原理：两次标准化
第一次使用affy包MAS5算法标准化；第二次[文献14]把平均值调整为1000，消除批次效应。

1).After an initial quality control, redundant samples (n = 384) were excluded [12]. The raw CEL files were MAS5 normalized in the R statistical environment (www.r-project.org) using the affy Bioconductor library [13]. MAS5 can be applied to individual chips, making future extensions of the database uncomplicated.
2).At this stage, we performed a second scaling normalization to set the average expression on each chip to 1,000 to avoid batch effects [14].

13). Gautier L, Cope L, Bolstad BM et al (2004) affy—analysis of Affymetrix GeneChip data at the probe level. Bioinformatics 20:307–315
14). Sims AH, Smethurst GJ, Hey Y et al (2008) The removal of multiplicative, systematic bias allows integration of breast cancer gene expression datasets—improving meta-analysis and prediction of prognosis. BMC Med Genomics 1:42

探针序列：http://kmplot.com/analysis/index.php?p=download




3.使用网站画mRNA、miRNA画十年生存期的KM plot
http://kmplot.com/analysis/


使用 RNA 表达量做生存分析
http://gepia2.cancer-pku.cn/#survival






4.R语言画km plot:
共三列数据有效：
# tx是分组
# status是是否删失（0：右删失，1：死亡）
# time表示存活时间

## 生存期曲线的画法
#原始数据 
# case	inst	tx	grade	cond	site	t.stage	n.stage	entry.dt	status	time
# 1	a1	1	1	1	1	1	1	1	1	1
# 2	a1	1	1	1	1	1	1	1	1	100
# 3	a1	1	1	1	1	1	1	1	1	12
# 4	a1	1	1	1	1	1	1	1	1	12
# 5	a1	1	1	1	1	1	1	1	1	13
# 6	a1	1	1	1	1	1	1	1	1	13
# 7	a1	1	1	1	1	1	1	1	1	13
# 8	a1	1	1	1	1	1	1	1	1	20
# 9	a1	1	1	1	1	1	1	1	1	30
# 10	a1	2	1	1	1	1	1	1	1	31
# 11	a1	2	1	1	1	1	1	1	1	32
# 12	a1	2	1	1	1	1	1	1	1	33
# 13	a1	2	1	1	1	1	1	1	1	34
# 14	a1	2	1	1	1	1	1	1	1	35
# 15	a1	2	1	1	1	1	1	1	1	35
# 16	a1	2	1	1	1	1	1	1	1	35
# 17	a1	2	1	1	1	1	1	1	1	40
# 18	a1	2	1	1	1	1	1	1	1	40
# 19	a1	2	1	1	1	1	1	1	1	60
# 20	a1	2	1	1	1	1	1	1	1	80
# 其中
# caese表示编号
# tx是分组
# status是是否删失（0：右删失，1：死亡）
# time表示存活时间

# 载入包
library('survival')

# 读取数据
setwd('D:/R_code')
my=read.csv('death.csv',header=T);my

# 按照tx分组对time和statuss拟合生存曲线，
sd=survfit(Surv(time,as.numeric(status))~tx,data=my,se.fit=FALSE, conf.int=.95)

# 画出生存曲线
plot(sd,lty=1,col=c("red","purple"),
      xlab="time(year)",ylab="Overall Survival",main="survival", #生存曲线
    ) 
#加上图例
legend(60, 1, c("Group1", "Group2"), col = c("red","purple"),
       text.col = c("red","purple"), lty = c(1, 1), pch = c(1, 2),
       merge = TRUE, bg ="#efeeef" );
#rgb(0.99,0.99,0.99) grey


# 这个没懂
with(lung, Surv(time, status))
Surv(heart$start, heart$stop, heart$event)

作图结果如下：





4.2.怎么计算P值（log rank p-value）呢？[解决]
[1]http://bcb.dfci.harvard.edu/~aedin/courses/Bioconductor/survival.pdf
[2]https://cran.r-project.org/web/packages/HSAUR/vignettes/Ch_survival_analysis.pdf   Survival Analysis:
在pdf中搜索log-rank 等关键词。
[3]http://stats.stackexchange.com/questions/114304/log-rank-test-in-r


#p值怎么算？

# http://bbs.pinggu.org/thread-2178930-1-1.html


#请使用survdiff函数做log rank检验或建立Cox模型(coxph)来比较两条生存曲线,

#KM曲线只是一种可视化手段，不是正经的统计推断分析工具。

# 应该用 suvdiff 函数做 log-rank test

#
# 读取数据
setwd('D:/R_code/')
my=read.csv('suvive.csv',header=T);my

#############################
#计算p值：
#http://stats.stackexchange.com/questions/114304/log-rank-test-in-r
# install.packages("survival")
library("survival")
sdf=survdiff(Surv(time, as.numeric(status))~tx, data=my)
sdf
pvalue=1-pchisq(sdf$chisq, df=1)
#pvalue=round(pvalue,2)
# There is also an option for ‘rho’. Rho = 0 (default)
# gives the log-rank test, rho=1 gives the Wilcoxon test.

#install.packages("coin")
#library("coin")
#st=logrank_test(Surv(time, as.numeric(status)) ~ tx, data=my, distribution = "exact")
#st
#########################


# 按照tx分组对time和statuss拟合生存曲线，
km=survfit(Surv(time,as.numeric(status))~tx,data=my,se.fit=FALSE, conf.int=.95)
km

# 画出生存曲线
plot(km,lty=1,col=c("red","purple"), 
     xlab="OS MONTHS",ylab="Percent Survival",main="survival", #生存曲线
) 
#加上图例
legend(130, 1,  legend=c(paste("WT(n=",km$n[1],")"), paste("R132H(n=",km$n[2],")")), col = c("red","purple"),
       text.col = c("red","purple"), lty = c(1, 1), title = paste("logrank p = ",pvalue) )
#       merge = FALSE, bg ="#ffffff"





4.3.怎么标出来截尾数据？

http://www.biostatistic.net/thread-87214-1-1.html
mark.time=T  生存分析显示截尾数据点.

## S3 method for class 'survfit'
plot(x, conf.int=, mark.time=TRUE, 
mark=3, col=1, lty=1, lwd=1, cex=1, log=FALSE, xscale=1, yscale=1,  
firstx=0, firsty=1, xmax, ymin=0, fun, 
xlab="", ylab="", xaxs="S", ...)






4.4.从TCGA下载数据，怎么匹配样品名和生存时间？[半解决]
http://www.cbioportal.org/
（1）用excel的vookup函数[勉强可用，但是还是不自动化]：
VLOOKUP函数是Excel中的一个纵向查找函数，它与LOOKUP函数和HLOOKUP函数属于一类函数，在工作中都有广泛应用。VLOOKUP是按列查找，最终返回该列所需查询列序所对应的值；与之对应的HLOOKUP是按行查找的。
VLOOKUP(lookup_value,table_array,col_index_num,range_lookup)
当前页面样品name，寻找的表格范围，返回的列编号，不精确查找吗？
大概是这样： =VLOOKUP(A2,Sheet2!A:F,5,FALSE)

（2）使用R语言的sql模块【推荐】
...




4.5.怎么从marker选择最合适的cutoff值？
看文献是使用x-tile软件选择最优的cutoff值。
软件：http://medicine.yale.edu/lab/rimm/research/software.aspx
教程：http://wenku.baidu.com/link?url=GmVqIKZ41r1av7wzYDxZYquKk8Am6MuLyq5AD0NGicIa9t5bUvgokQqpgTGCHpIS-Oh-Vd24j1-wJpjY1b25UKXrpPLmZ2W9tlzUrJPqqV7

也有人说用ROC曲线的。





4.6 问题

How to calculate the HR and 95%CI using the log-rank test in R?
怎么用R的log-rank检验分析HR和95%置信区间

The R survival package is very useful to do survival analysis. And I know the survdiff function can be used to compare the difference of survival time in two or more groups. And the p-value number can also be calculated as below. However, how can I calculate the HR and 95% CI using the log-rank test.
R的生存期包对生存分析很有用。我知道survdiff函数可以被用于比较2组或多组生存时间差异。p值可以如下方法计算。然而，我不知道怎么使用log-rank检验计算HR和95%置信区间(CI)。

And I also know I can use the coxph() function to calculate the HR and 95% CI using the Cox regression. However, as the assumption of both the Cox model and log-rank test are that the hazard ratio stay constant over time, so I think I can also calculate the HR and 95% CI using the log-rank test.
我知道怎么使用Cox回归的coxph()函数计算HR和95%CI。然而，Cox模型和log-rank检验的假设都是风险比随着时间稳定，所以我认为我可以使用log-rank检验计算 HR and 95% CI。

According to the book Survival Analysis: A Practical Approach, I got two formulas on Page 62 and 66 to do this (as shown below). So I wrote the R code as below, is there anybody know whether I'm right?
按照《生存分析：实用方法》一书，我在P62和P66看到2个做这个的函数（如下）。所以，我写了如下R代码，有人知道我这么写对吗？

library(survival)
data.survdiff <- survdiff(Surv(time, status) ~ group)
p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
HR = (data.survdiff$obs[2]/data.survdiff$exp[2])/(data.survdiff$obs[1]/data.survdiff$exp[1])
up95 = exp(log(HR) + qnorm(0.975)*sqrt(1/data.survdiff$exp[2]+1/data.survdiff$exp[1]))
low95 = exp(log(HR) - qnorm(0.975)*sqrt(1/data.survdiff$exp[2]+1/data.survdiff$exp[1]))


输出：
> data.survdiff
Call:
survdiff(formula = Surv(data[, "os_whw"], data[, "status_whw"] == 
    1) ~ data[, "pcascore"] >= median(data[, "pcascore"]))

                                                       N Observed Expected (O-E)^2/E (O-E)^2/V
data[, "pcascore"] >= median(data[, "pcascore"])=FALSE 4        3     4.33     0.411     0.974
data[, "pcascore"] >= median(data[, "pcascore"])=TRUE  5        5     3.67     0.486     0.974

 Chisq= 1  on 1 degrees of freedom, p= 0.324 
> p.val
[1] 0.3235935
> HR
[1] 1.970484
> up95
[1] 7.917248
> low95
[1] 0.4904239





4.6.1 回答1
#############
如果你的问题是两组生存是否有差异，不管其他特性，你应该使用KM估计并获得P值。这是用log-rank检验获得的。仅仅考虑组间生存期差异。如果你（1）分组时随机的（2）仅仅想知道组间生存时间差异（3）想看生存曲线，则这个方法很合适。

然而，如果分组不是随机的而是基本特性差异很大（比如年龄、性别差异），简单的生存分析用处就不大了（比如可能生存差异是年龄因素造成的）；这就是需要引入Cox回归。你使用Cox回归比较生存同时调整混杂因素。如果Cox回归没有包含“分组”之外的预测因素，得到的p值和KM 估计中的log rank检验结果是一样的。但是Cox回归能让你获得每个预测因素的HR和CI，以及p值。

使用Sruvival包中的coxph函数，或者rms包中的cph函数。

通常不用为此纠结。使用Rms包中的函数就很好，还有一本很棒的与包同名的书(Springer; FE Harrell)。包中有可视化和表格化的函数。

可能你有些理论我不理解，但是这时有一个专家会指导我们。其他场景中，你会感觉这个途径很好。

The package: http://cran.r-project.org/web/packages/rms/rms.pdf

The book: http://www.springer.com/mathematics/probability/book/978-0-387-95232-1

(Btw: you can obtain Cox adjusted survival curves; 
google it or check out RMS package documentation).





4.6.2 回答2

你的实现看样子是对的，你认为log-rank可以用于计算HR和95%CI，但我有点问题：
1.你重新计算p值有特殊的理由吗？（因为survdiff()函数已经提供了，重算就像是额外工作）
2.你函数中的HR和95%，和使用coxph()函数计算出来的一致吗？使用coxph()函数验证你的实现。

注意：coxph()函数已经计算过，你为什么用log-rank检验又算了一次HR和95%CI？

I agree with your idea that log-rank test is used to compare the survival of two groups.









5. R语言超详细绘制生存曲线并说明各参数选择 //需要新版本的R，还没有测试。//todo
https://www.jianshu.com/p/34cc76221883

#生存曲线绘制

library(survminer) # 加载包
library(survival) # 加载包

data(lung) # 加载lung(lung) # 查看数据集
str(lung)

#'data.frame':  228 obs. of  10 variables:
#$ inst     : num  3 3 3 5 1 12 7 11 1 7 ...
#$ time     : num  306 455 1010 210 883 ...生存时间
#$ status   : num  2 2 1 2 2 1 2 2 2 2 ...生存状态，2为死亡，1位生存
#$ age      : num  74 68 56 57 60 74 68 71 53 61 ...
#$ sex      : num  1 1 1 1 1 1 2 2 1 1 ...
#$ ph.ecog  : num  1 0 0 1 0 1 2 2 1 2 ...
#$ ph.karno : num  90 90 90 90 100 50 70 60 70 70 ...
#$ pat.karno: num  100 90 90 60 90 80 60 80 80 70 ...
#$ meal.cal : num  1175 1225 NA 1150 NA ...进食时消耗的卡路里
#$ wt.loss  : num  NA 15 15 11 0 0 10 1 16 34 ...最近6个月内的体重下降

attach(lung)
Surv(time,status) # 创建生存对象

fit <- survfit(Surv(time,status) ~ sex,  # 创建生存对象 
               data = lung) # 数据集来源
fit # 查看拟合曲线信息

summary(fit)

ggsurvplot(fit, data = lung)

ggsurvplot(fit, # 创建的拟合对象
           data = lung,  # 指定变量数据来源
           conf.int = TRUE, # 显示置信区间
           pval = TRUE, # 添加P值
           surv.median.line = "hv",  # 添加中位生存时间线
           risk.table = TRUE, # 添加风险表
           xlab = "Follow up time(d)", # 指定x轴标签
           legend = c(0.8,0.75), # 指定图例位置
           legend.title = "", # 设置图例标题
           legend.labs = c("Male", "Female"), # 指定图例分组标签
           break.x.by = 100)  # 设置x轴刻度间距
## end








refer
1.[推荐]R的生存期包
https://cran.r-project.org/web/packages/survival/survival.pdf
2. http://stats.stackexchange.com/questions/124489/how-to-calculate-the-hr-and-95ci-using-the-log-rank-test-in-r

3.Use Software R to do Survival Analysis and Simulation. A tutorial
http://www.ms.uky.edu/~mai/Rsurv.pdf

10.英文图书 https://www.amazon.com/dp/0470870400/?tag=stackoverfl08-20

R语言的with和by http://statmethods.net/stats/withby.html

生存分析完整论述：https://cran.r-project.org/web/views/Survival.html  太复杂了



http://wenku.baidu.com/link?url=Ld9FAX6pFUfLet5YtTToTtyzhQ2GA2mD9IkmhBqHjjDEb3e3S2BAI8C3hxZ3UxhGKUhWD4aT_uh8rWIJmEvY0fFJtdmU1VWwQzlF9LolNU7
如何用graphpad制作生存曲线？ http://www.dxy.cn/bbs/topic/25619320
http://blog.csdn.net/shmilyringpull/article/details/17529637






========================================
networkD3 包画桑基图 sankeyNetwork()
----------------------------------------
networkD3 :D3 JavaScript Network Graphs from R

https://github.com/christophergandrud/networkD3
http://christophergandrud.github.io/networkD3/


桑基图(Sankey Diagram)是一种显示流量数据的可视化图形，在桑基图中，实体(nodes)由矩形或文本表示，实体之间的连接用箭头或弧线表示，箭头或弧线的宽度与流动的重要性或某种数值成比例。

桑基图是一种特定类型的流型图，其中箭头的宽度与流量成比例显示，桑基图将视觉重点放在数据的流动，有助于确定哪个部分对整体流量有主要贡献。



1. 桑基图基本示例: 表示一个种类有多少变成了另一个种类

(1) 两列图的情况。
注: 如果from和to有重叠元素，则可能有多列图。

连接数据框包含三列，分别表示连接的起点和终点以及连接的权重。

library(networkD3)
# the 1st df should contain: source,target and value; 
# and Source and Target is the index value
sankeydf=data.frame(
  source=c(0,1,1,2,2,3),
  target=c(4,4,5,6,4,6),
  value=c(1,2,3,4,5,6)
)
# add color to flow
sankeydf$group="flow"

nodes=data.frame( nodeName= paste0( "node_", seq(1,7)) )

Sankey.p=sankeyNetwork(Links = sankeydf, Nodes = nodes, 
              Source = "source", Target = "target", Value = "value",
              NodeID = "nodeName",
              LinkGroup = "group", #color of flow
              colourScale = JS("d3.scaleOrdinal(d3.schemeCategory20);"),
              #sinksRight=FALSE, # 最后一个节点移动到文字的右侧吗？默认是(2个元素时文字在中心)
              #width=900,
              #nodePadding=10,
              fontSize = 12, nodeWidth = 30)
Sankey.p
#画出来的图形，还可以直接在R窗口中调整方块上下位置，不过还是建议保存为pdf后用AI调整
#nodeWidth 每个节点方块的宽度
#nodePadding 每一列节点方块之间在纵向上的间隔
#width 是图形横向的宽度


(2) 保存为pdf
library(htmlwidgets)
saveWidget(Sankey.p, file="/tmp/Sankey.html")
library(webshot)
# webshot::install_phantomjs() #建议新开R安装，防止卡死当前进程。
webshot("/tmp/Sankey.html", "Sankey.pdf")


(3) 配置颜色部分，形式相对固定，不必纠结具体的语法规则
#16进制编码对应的颜色可以用RColorBrewer包结合scales包查看
my_color <- 'd3.scaleOrdinal() 
            .domain(["A", "B", "C", "D", "E", "F", "G", "H", "I", "J","flow"]) 
            .range(["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5",  "#BC80BD", "#CCEBC5","#BDBDBD"])'


(4) 设置flow的颜色和source一致
# the 1st df should contain: source,target and value; 
# and Source and Target is the index value
sankeydf=data.frame(
  source=c(0,1,1,2,2,3),
  target=c(4,4,5,6,4,6),
  value=c(1,2,3,4,5,6)
)

# 节点
nodes=data.frame( nodeName= paste0( "node_", seq(0,6)) )

# add color to flow
#sankeydf$group="flow"
# use color as node in source
sankeydf$group= nodes$nodeName[(1+sankeydf$source)]

library(RColorBrewer)
mypalette_1=brewer.pal(8,"Set1")[1:7]

# 自定义颜色
library(jsonlite)
my_color <- paste0('d3.scaleOrdinal().domain(', 
                   jsonlite::toJSON(nodes$nodeName), 
                   ').range(', 
                   jsonlite::toJSON( mypalette_1 ),
                   ')')
library(networkD3)
Sankey.p=sankeyNetwork(Links = sankeydf, Nodes = nodes, 
              Source = "source", Target = "target", Value = "value",
              NodeID = "nodeName",
              LinkGroup = "group", #color of flow
              
              colourScale =my_color, #自定义颜色
              fontSize = 20, nodeWidth = 30)
Sankey.p









2. 桑基图包装函数

#' Title: Make Sankey plot data from a table(paraLeft, paraRight)
#'
#' @param tbl1 a table produced by table()
#' @param omit omit which rows/paraLeft
#' @omitR omit rownames
#' @omitC omit column names
#'
#' @return
#' @export
#' ref: https://observablehq.com/@d3/sankey
#'
#' @examples
#' getSankeyData( table(mtcars$gear, mtcars$carb))
getSankeyData=function(tbl1, prefix_left="old_", prefix_right="new_", omitR=NULL, omitC=NULL, rm.na=T){
  preL=prefix_left
  preR=prefix_right
  #
  if(!is.null(omitR)){
    tbl1=tbl1[setdiff( rownames(tbl1), omitR), ]
  }
  if(!is.null(omitC)){
    tbl1=tbl1[ , setdiff( colnames(tbl1), omitC)]
  }
  # default, remove all 0 rows and columns
  tbl1=tbl1[rowSums(tbl1)>0, ]
  tbl1=tbl1[ , colSums(tbl1)>0]
  # table to data.frame
  df2=as.data.frame(tbl1)
  df2=df2[which(df2$Freq!=0),]
  #
  df2$Var1=paste0(preL, df2$Var1)
  df2$Var2=paste0(preR, df2$Var2)
  #
  nodes=data.frame(node=unique( c( paste0(preL, rownames(tbl1)),
                                   paste0(preR, colnames(tbl1))) ))
  nodes$index=0:(nrow(nodes)-1) #0-based index, as in JS
  df3=data.frame(
    source=nodes$index[match(df2$Var1, nodes$node)],
    target=nodes$index[match(df2$Var2, nodes$node)],
    value=df2$Freq
  )
  # use color as node in source
  df3$group= nodes$node[(1+df3$source)]
  
  return(list(link=df3, node=nodes))
}


#' Sankey plot from sankeyDt, produced by getSankeyData()
#'
#' @param sankeyDt 
#' @param colors a color list for sankeyDt$node$node
#' depend getSankeyData()
#' version: 2.0 define flow color as source//todo
#'
#' @return
#' @export
#'
#' @examples
#' getSankeyData( table(mtcars$gear, mtcars$carb))
#' sankeyDt2=getSankeyData(table(mtcars$gear, mtcars$carb),"Gear_", "Carb_")
#' sankeyPlot(sankeyDt2 )
#' library(RColorBrewer)
#' mypalette_1=brewer.pal(8,"Set1")
#' sankeyPlot(sankeyDt2, colors=mypalette_1 )
sankeyPlot=function(sankeyDt, colors=NULL){
  library(RColorBrewer)
  if(is.null(colors)){
    #define the color of each nodes(from/source, to/target)
    colors = brewer.pal(8,"Set2")
    #c("#FF0000", "#00FF00", "#0000FF", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#FF00004D", "#0000FF4D")
  }
  #R array to json
  colorsJson=  paste0('d3.scaleOrdinal().domain(', jsonlite::toJSON(sankeyDt$node$node), ').range(',  jsonlite::toJSON(colors) , ')');
  #colorsJson <- 'd3.scaleOrdinal().domain(["pH", "C", "N", "P", "K", "1", "-1"]).range(["#377EB8", "#4DAF4A", "#984EA3"])'
  sankeyNetwork(Links = sankeyDt$link, Nodes = sankeyDt$node,
                Source = "source", Target = "target", Value = "value",
                NodeID = "node",
                LinkGroup = "group", #color of flow
                colourScale = colorsJson, #JS("d3.scaleOrdinal(d3.schemeCategory20);"),
                fontSize = 12, nodeWidth = 30)
}
# test
#temp=table(scObj_known2@meta.data$oCluster, scObj_known2@meta.data$seurat_clusters)
# rownames(temp)[rowSums(temp)<10] #check to remove rows with very small numbers
#sankeyPlot( getSankeyData(temp) )
#sankeyPlot( getSankeyData(temp, omitR=c("10", "22", "24", "25", "28", "29") ) )
#sankeyPlot( getSankeyData(temp, omitR=c("10", "22", "24", "25", "28", "29") ), colors= brewer.pal(8,"Set2") )








========================================
|-- networkD3 包画 力导向图forceNetwork()
----------------------------------------
看样子能画基因互作网络图，还想不明白怎么用。


1. 最基础示例

edges_d3=data.frame(
  from=c(0,1,2,0,1,2),
  to=c(3,3,3,4,4,5),
  value=c(30,3,10,4,2,3)
)

nodes_d3=data.frame(
	id=c(0,1,2,3,4,5),
	label= c("S1", "s2", "s3", "T1", "t2", 't3')
)

forceNetwork(
  Links = edges_d3, Nodes = nodes_d3,
  Source = "from", Target = "to",      # so the network is directed.
  Value = "value",
  
  NodeID = "label", Group = "id", 
  legend = TRUE,
  arrows = TRUE,
  opacity = 0.8, fontSize = 16, zoom = TRUE
)



(2) 设置每个节点的大小

forceNetwork( 
	Links = MisLinks, Nodes = MisNodes, Source = "source", 
	Target = "target", Value = "value", 
	NodeID = "name", Nodesize = 'size', radiusCalculation = "d.nodesize",
	Group = "group", opacity = 1, legend = T, bounded = F
)









========================================
|-- 弦图(chordDiagram） 
----------------------------------------
hairColourData = matrix(
	c(11975,  1951,  8010, 1013,
	5871, 10048, 16145,  990,
	8916,  2060,  8090,  940, 
	2868,  6171,  8045, 6907), 
nrow = 4)                              

chordNetwork(hairColourData, 
	width = 500, height = 500,
	colourScale = c("#000000", "#FFDD89", "#957244", "#F26223"))





========================================
|-- 树状图 dendroNetwork
----------------------------------------
hc <- hclust(dist(USArrests), "ave")
plot(hc)

使用该包后:
dendroNetwork(hc, height = 600)
dendroNetwork(hc, treeOrientation = "vertical")

dendroNetwork(hc, height = 600, linkType = "diagonal")
dendroNetwork(hc, treeOrientation = "vertical", linkType = "diagonal")


# 分成三类染色
dendroNetwork(hc, textColour = c("red", "green", "orange")[cutree(hc, 3)],height = 600)
dendroNetwork(hc, textColour = c("red", "green", "orange")[cutree(hc, 3)], treeOrientation = "vertical")





========================================
图论: 点、边、度
----------------------------------------

1. 最小生成树 minimum spanning tree (MST)
A special tree called a minimum spanning tree (MST) is very useful for testing the relations between a graph and other covariates. 

定点：nodes or vertices (often called V) 
边：a set of edges between these vertices (E). 



A spanning tree is a tree that goes through all points at least once,
The minimum spanning tree is the spanning tree of minimum length;






2.  adjacency matrix: 临近矩阵 表示边E, 
有几个定点就有几行。
第i行第j列不为0，就表示第i点和第j点有联系。

问题: 对于无方向的边，adjacency matrix有什么特别的？

代码：
library("igraph")
edges1 = matrix(c(1,3,2,3,3,4,4,5,4,6),byrow = TRUE, ncol = 2)
g1 = graph_from_edgelist(edges1, directed = FALSE)
plot(g1, vertex.size = 25, edge.width = 5, vertex.color = "coral")



3. 网络的定义
We call a weighted, directed graph a network. 
Networks have adjacency matrices, which are nxn matrices of positive numbers corresponding to the edge lengths.

对于大的网络，很多研究者喜欢 summarize overall graph structure such as vertex degrees (the number of edges connected to the vertex), centrality or betweenness. 
定点度，中心性，中间度。


(1)
如果边和定点个数类似，则称这个图是稀疏的。
如果是稀疏的，按照矩阵保存就是浪费空间，可以使用Matrix包中的方法保存。
如果边的个数是定点的二次函数，该矩阵就是idense的，内存将是个问题。


(2)
更丰富的图包含带箭头的边。还可以计算in-degree和out-degree。
边的宽度可以表示link的强度。
协变量也可以加到定点上。一个连续协变量可以与定点的大小相关，分类变量可以和定点颜色相关。


(3)
图的布局
同一个图可以有不同的布局。

边的长度可表示距离。
简单情况，边没有长度时，算法可以选择不同的标准，Fruchterman and Reingold 方法通常是默认标准。
这时基于相似点吸引或排斥的物理模型的，就像有一个物理力的影响一样。


作业：
(1)使用igraph包，创建一个dense随机图，12个定点和超过50个边。
(2) 尝试不同的布局：把点放到圆上; 或尽量对称的放置，放置边和定点的重叠。

# 
set.seed(1)
rs=matrix(rnorm(144), nrow=12);dim(rs)
rs=abs(rs)
rs[rs<0.6] <- 0; table(rs==0)
#FALSE  TRUE 
#68    76 
df2=NULL;
for(i in 1:12){
  for(j in 1:12){
    # if(i==j)next;
    if(rs[i,j]!=0)
    df2=rbind(df2, data.frame(
      i,j, rs[i,j]
    ))
  }
}
head(df2);dim(df2)
g1 = graph_from_edgelist(as.matrix(df2[, c(1,2)]), directed = FALSE)
g1
plot(g1, vertex.size = 25, edge.width = 3*as.numeric(df2[,3]),
     vertex.color = "coral")
plot(g1, layout=layout.fruchterman.reingold)
#g1$layout=layout.circle
plot(g1, layout=layout.circle) #圆形显示


##
E(g1)
E(g1)[c(5,10)]$label="xxlink" #为边标记标签
plot.igraph(g1)
# 设置link颜色
E(g1)$color='grey'
E(g1)[c(5,10)]$color='red' #这是E(g1)显示的顺序
plot.igraph(g1)
# 小球填充绿色
plot(g1, layout=layout.circle, vertex.color="green")
# 线条粗细
g1_2=g1; E(g1_2)[c(2,8,10)]$width=15  #error?? 不理解
plot.igraph(g1_2, layout=layout.circle)
#


##
## 更简单的是这个函数，且带方向
g2 <- graph.adjacency( rs >= 0.6)
g2
plot(g2, vertex.size = 25, edge.width = 3*as.numeric(df2[,3]),
     vertex.color = "coral")
# 换一种布局
plot(g2, layout=layout.fruchterman.reingold)








4. ggnetwork 包模拟数据
Make a dataframe from the graph g1 using the ggnetwork package, then plot it using ggplot and the provided geoms geom_edges, geom_nodes and geom_nodetext.

马尔科夫链
Markov chains are idealized models of dynamical systems and the states are represented by the nodes in the graph. The transition matrix gives us the weights on the directed edges (arrows) between the states.

library("markovchain")
statesNames = c("A", "C", "G","T")
T1MC = new("markovchain", states = statesNames, transitionMatrix =
  matrix(c(0.2,0.1,0.4,0.3,0,1,0,0,0.1,0.2,0.2,0.5,0.1,0.1,0.8,0.0),
    nrow = 4,byrow = TRUE, dimnames=list(statesNames,statesNames)))
plot(T1MC, edge.arrow.size = 0.4, vertex.color="purple",
      edge.arrow.width = 2.2, edge.width = 5, edge.color = "blue",
      edge.curved = TRUE, edge.label.cex = 2.5, vertex.size= 32,
      vertex.label.cex = 3.5, edge.loop.angle = 3,
      vertex.label.family="sans", vertex.label.color = "white")
#







refer:
http://web.stanford.edu/class/bios221/book/Chap-Graphs.html
https://blog.csdn.net/yepeng2007fei/article/details/78250088




========================================
R语言 igraph 包-构建网络图 //todo
----------------------------------------

igaph 是一个项目，目标是建立一条简单，易用的网络分析工具，有 R, python, C/C++ 等语言的具体实现；
项目主页：http://igraph.org/

在R语言中，对应的就是 igraph 这个R包

安装：install.packages("igraph")

使用：
对于图 graph 这种数据结构而言，最基本的元素包括节点（node） 和 边（节点之间的连线，edge）;
igraph 这个R包提供了很多种创建graph的方式，我们先看一个最基本的例子，从数据框创建一个graph；

我们将要创建的graph 如下：


可以看到，这个graph 包括5个节点，首先创建一个数据框，这个数据框中的每一行是一个节点，每一列是节点的属性
> actors <- data.frame(name=c("Alice", "Bob", "Cecil", "David",
                            "Esmeralda"),
                     age=c(48,33,45,34,21),
                     gender=c("F","M","F","M","F"))

> actors
       name age gender
1     Alice  48      F
2       Bob  33      M
3     Cecil  45      F
4     David  34      M
5 Esmeralda  21      F

actors 这个数据框保存了图中所有节点的信息，共5个节点，有name, age, gender 3种属性；注意节点的属性是自定义的
接下来创建另外一个数据框，保存边的信息，


> relations <- data.frame(from=c("Bob", "Cecil", "Cecil", "David",
+                                "David", "Esmeralda"),
+                         to=c("Alice", "Bob", "Alice", "Alice", "Bob", "Alice"),
+                         same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),
+                         friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3))
> relations
       from    to same.dept friendship advice
1       Bob Alice     FALSE          4      4
2     Cecil   Bob     FALSE          5      5
3     Cecil Alice      TRUE          5      5
4     David Alice     FALSE          2      4
5     David   Bob     FALSE          1      2
6 Esmeralda Alice      TRUE          1      3


relations 数据框保存了节点之间的连线信息， from， to 两列描述了这条边是从哪个节点到哪个检点，最后的3列是每条边的一些自定义的属性

当两个数据框创建完成之后，就可以利用 graph_from_data_frame 函数创建一个graph, 代码如下：

g <- graph_from_data_frame(relations, directed=TRUE, vertices=actors)
第一个参数是保存edge 信息的数据框，directed 参数控制graph 有无方向，vertices 参数是保存节点信息的数据框
最后进行一个简单的可视化
plot(p)



(2) 上面只是最基本的可视化的例子，对于graph 而言，有directed graph 和 undirected graph 两种，在可视化的时候，最核心的东西是计算每个节点的位置，对于不同类型的graph， 有不同的自动化的布局算法

通过layout 参数可以方便的指定，使用不同的布局算法

代码示例：
plot(g, layout = layout.fruchterman.reingold)









ref:
https://rdatamining.wordpress.com/2012/05/17/an-example-of-social-network-analysis-with-r-using-package-igraph/
http://kateto.net/networks-r-igraph
https://www.cnblogs.com/xudongliang/p/6944413.html




========================================
ggalluvial 包: 冲积图 //todo
----------------------------------------
alluvial [əˈluːviəl] adj. 冲积的
http://corybrunson.github.io/ggalluvial/


1. 官方示例 
BiocManager::install("ggalluvial") #version 0.12.3

(1) 示例1
library(ggalluvial)

# ex1
# 转换内部数据为数据框，宽表格模式
titanic_wide <- data.frame(Titanic)

# 显示数据格式
head(titanic_wide)
#>   Class    Sex   Age Survived Freq
#> 1   1st   Male Child       No    0
#> 2   2nd   Male Child       No    0
#> 3   3rd   Male Child       No   35
#> 4  Crew   Male Child       No    0
#> 5   1st Female Child       No    0
#> 6   2nd Female Child       No    0

# 绘制性别与舱位和年龄的关系
ggplot(data = titanic_wide,
       aes(axis1 = Class, #第1个轴是Y方向第1个刻度
           axis2 = Sex,   #第2个轴是Y方向第2个刻度
           axis3 = Age,   #第3个轴是Y方向第3个刻度
           y = Freq)) +  #权重，条带的宽窄
  scale_x_discrete(limits = c("Class", "Sex", "Age"), expand = c(.2, .05)) + #x轴的显示
  xlab("Demographic") +
  geom_alluvium(aes(fill = Survived)) + #填充颜色：生存与否
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal() +
  ggtitle("passengers on the maiden voyage of the Titanic",
          "stratified by demographics and survival")



(2) 示例2
# ex2:
dat=data.frame( UCBAdmissions )
dat
#> dat
#      Admit Gender Dept Freq
#1  Admitted   Male    A  512
#2  Rejected   Male    A  313
#3  Admitted Female    A   89

ggplot(dat,
       aes(weight = Freq, axis1 = Gender, axis2 = Dept)) +
  geom_alluvium(aes(fill = Admit), width = 1/12) +
  geom_stratum(width = 1/12, fill = "black", 
               color = "grey") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  
  scale_x_continuous(breaks = 1:2, labels = c("Gender", "Dept")) +
  scale_fill_brewer(type = "qual", palette = "Set1") +
  ggtitle("UC Berkeley admissions and rejections, by sex and department")




x, 主要的分类，即X轴上每个柱
stratum, 主要分类中的分组
alluvium, 连接图的索引



2. 使用 
https://www.cxyzjd.com/article/weixin_42118056/112103937




#读取门水平丰度数据
dat  
#该丰度表中，已经提前按总丰度水平的高低作了降序排序
#现在将分类列转化为因子类型，即指定了预先定义的类群展示顺序
dat$Taxonomy  
#整理成 ggplot2 作图格式
dat  
#添加分组，根据样本分组绘制分面
group names(group)[1] dat  
#绘制带分面的柱状图
library(ggplot2)
color     '#80B1D3', '#FB8072', '#BEBADA', '#FFFFB3', '#8DD3C7')
p geom_col(position = 'stack', width = 0.6) +  #堆叠柱形图
facet_wrap(~group, scales = 'free_x', ncol = 2) +  #分面图
scale_fill_manual(values = color) +  #填充颜色赋值
labs(x = '', y = 'Relative Abundance(%)')
p




#修改为带分面的冲击图
library(ggalluvial)
p     stratum = Taxonomy, alluvium = Taxonomy)) +
geom_stratum() +  #代替 geom_col() 绘制堆叠柱形图
geom_flow(alpha = 0.5) +  #绘制同类别之间的连接线
facet_wrap(~group, scales = 'free_x', ncol = 2) +  #分面图
scale_fill_manual(values = color) +
labs(x = '', y = 'Relative Abundance(%)')
p





#继续修改主题，如背景色、网格线、图例、字体等
#和 ggplot2 的使用一样的
p     panel.background = element_rect(color = 'black', fill = 'transparent')) +
theme(axis.text = element_text(size = 12), axis.title = element_text(size = 13),
    legend.title = element_blank(), legend.text = element_text(size = 11))
p
#输出图片至本地
ggsave('test.pdf', p, width = 10, height = 5)
#ggsave('test.png', p, width = 10, height = 5)






========================================
viridis 包: 色盲友好的渐变色
----------------------------------------
library(viridis)
# https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html
# https://blog.csdn.net/wangjunliang/article/details/125549024


# 1.生成颜色实例: 参数类似
#c1=viridis(n=10, alpha = 1, begin = 0, end = 1, direction = 1); c1
c1=viridis(10, alpha = 1, begin = 0, end = 1, direction = 1, option = "A"); c1
# n 色彩个数
# alpha 不透明度，1表示完全不透明，0表示完全透明。
# begin 和 end 表示 hue 开始和结束的位置[0,1]
# direction 颜色方向，1从深到浅，-1反之。
# option 表示8种颜色方案，可以换前面的函数名，也可以换 option 种的字母A-H

barplot( rep(1, length(c1)), col=c1, 
         border=NA, yaxt='n', space=0, main="")


# 2.官方教程
library(ggplot2)
ggplot(data.frame(x = rnorm(10000), y = rnorm(10000)), aes(x = x, y = y)) +
  geom_hex() + coord_fixed() +
  scale_fill_viridis() + theme_bw()



# 3.查看8种颜色方案
draw=function(colorname, title="", n=100){
  if(title==""){
    title=paste0(colorname, ", n=", n)
  }
  #print(title)
  cols=do.call(colorname, list(n, alpha = 1, begin = 0, end = 1, direction = -1) )
  barplot( rep(1, length(cols)), col=cols, 
           border=NA, yaxt='n', space=0, main=title)
}
par(mfrow=c(8,2), mar=c(0,0,1.5,0) )
for(i in c("viridis", "magma", "inferno", "plasma", 
           "cividis", "rocket", "mako", "turbo")){
  print(i)
  draw(i, n=10)
  draw(i, n=100)
}




# 4.热图
set.seed(2022)
test =  matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
#
dim(test)

# Draw heatmaps
library(pheatmap)
pheatmap(test)

# viridis
pheatmap(test, color = viridis(8), main="viridis")

# mako
pheatmap(test, color = viridis(8, option = "G"), main="mako")






========================================
----------------------------------------





========================================
----------------------------------------





========================================
----------------------------------------




========================================
----------------------------------------






========================================
----------------------------------------





========================================
----------------------------------------





========================================
----------------------------------------

