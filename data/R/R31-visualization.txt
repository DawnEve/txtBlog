R的可视化：图片、pdf和网页等展示(略)



R绘图主要包括三部分：基础绘图命令、Lattice图形系统、ggplot包。

主要记录在 http://www.biomooc.com/R/R-draw-sketch.html


tips:
- 横坐标文字的方向改变，在画图之前加上par(las=2)，2表示垂直于坐标轴。
- 图形坐标离边缘的距离（调整图像位置）：par(mar=c(3,3,3,3))四个值分别表示下、左、上、右




========================================
R语言可视化概述与资源
----------------------------------------
1. 经典教材

R语言原生的绘图系统已经非常强大了，可以绘制非常炫目的图片，需要的仅仅是耐心。
其他绘图包ggplot2，plotly都很好用。

再近几年，R语言推出了Shiny框架，可以用R语言快速写成一个网页，这简直不能更方便。


数据可视化软件 Tableau http://www.tableau.com/zh-cn
数据可视化： d3库 https://github.com/d3/d3/wiki/Gallery

“高大尚图片包括（GNUplot，http://www.gnuplot.info/）和matlab，但是R包ggplot2作图秒杀以上二者。”


(1)《R语言实战》中的绘图章节
第3章 图形初步P40-64
	本章介绍了创建、修改图形的方法，以及如何将图形保存为各种格式的文件。
第6章 基本图形P108-129
	第6章演示了创建常见单变量图形的方法，例如柱状图、饼图、直方图、密度图、箱线图和点图。这些图形对于理解单变量的分布都很有用。
第11章 中级绘图P236-261
	第11章扩展了第5章的内容，介绍了创建表现两个或多个变量间关系的图形。这包括各种2D和3D的散点图、散点图矩阵、折线图、相关图和马赛克图。
第16章 高级图形P333-256
	第16章介绍了R中最先进、最有用的数据可视化方法，包括用lattice图形表现非常复杂的数据，简要介绍新的ggplot2包，并对各种跟图形实时交互的方法做了综述。


该书配套网站包含的图形
https://www.statmethods.net/graphs/index.html
Creating a Graph
Histograms and Density Plots
Dot Plots
Bar Plots
Line Charts
Pie Charts
Boxplots
Scatterplots

- 高水平画图命令；
- 低水平画图命令；
- 图形的交互与参数；
- 图形设备；
- 动态图形；


记录到： http://biomooc.dawneve.cc/R/R-draw-basic.html
参考： 
https://www.yiibai.com/r/r_pie_charts.html
https://blog.csdn.net/disappearedgod/article/details/8681312

https://www.flutterbys.com.au/stats/tut/tut5.1.html






2.图形示例
某种程度上，本博客txtBlog是一个文字为主的博客系统，不适合记录R可视化相关的教程。
请跳转查看-->
可视化部分： www.biomooc.com 找到R模块中的可视化部分即可。
( local url: http://biomooc.dawneve.cc )


(1).如何将枯燥的大数据呈现为可视化的图和动画？
https://www.zhihu.com/question/23416938


(2).R语言绘制日本老龄化：
https://github.com/walkerke/idbr


(3) 女儿的睡觉时间可视化(SVG)
https://www.zhihu.com/question/23416938
http://bl.ocks.org/abruzzi/d01a221df9cf79b918a00033695092c9


(4) 原生R绘图命令和参数
R语言的graphics功能（画图） https://blog.csdn.net/weixin_34204722/article/details/94712532
	https://www.cnblogs.com/JackieZhu/p/4190450.html





3. 视频教程
R语言之数据可视化 https://www.imooc.com/learn/640

录屏软件 oCam 









4.网络资源

R Graphics Essentials: 3个表格很好
http://www.sthda.com/english/articles/32-r-graphics-essentials/134-r-basics-for-data-visualization/



R Base Graphs
http://www.sthda.com/english/wiki/r-base-graphs

https://bookdown.org/rdpeng/exdata/the-base-plotting-system-1.html




Lattice Graphs
http://www.sthda.com/english/wiki/lattice-graphs


R语言绘图、高清保存、以及颜色系统
https://blog.csdn.net/jianjewl/article/details/69257841


R语言绘图样式设置（符号、线条、颜色、文本属性）
https://blog.csdn.net/glodon_mr_chen/article/details/79293615


R语言作图：坐标轴设置
https://blog.csdn.net/weixin_40628687/article/details/79254791


R语言高级绘图命令（标题-颜色等）
https://blog.csdn.net/hhtnan/article/details/54571975


https://www.cnblogs.com/xudongliang/tag/R%E8%AF%AD%E8%A8%80/default.html?page=2









========================================
R原生绘图 概述
----------------------------------------
R原生绘图也很强大。用一个高级绘图函数画出主体，然后用一系列低级绘图函数添加辅助元素。


低层作图包:

> ls("package:grDevices")
  [1] "adjustcolor"              "as.graphicsAnnot"         "as.raster"
  [4] "axisTicks"                "bitmap"                   "blues9"
  [40] "dev.off"                  "dev.prev"                 "dev.print"
  [73] "palette.pals"             "pdf"                      "pdf.options"
  ...

> ls("package:graphics") #所有画图函数名
  [1] "abline"          "arrows"          "assocplot"       "axis"            "Axis"
  [51] "panel.smooth"    "par"             "persp"           "pie"             "plot"
  ...

> ls("package:grid")
  [1] "absolute.size"        "addGrob"              "applyEdit"            "applyEdits"
  [105] "grid.raster"          "grid.record"          "grid.rect"            "grid.refresh"
  ...

高层作图包

> ls("package:ggplot2")
  [1] "%+%"                       "%+replace%"                "aes"
  [4] "aes_"                      "aes_all"                   "aes_auto"
 [31] "coord_equal"               "coord_fixed"               "coord_flip"
 [103] "geom_abline"               "geom_area"                 "geom_bar"
 ...



1.简单图形绘制

attach(mtcars)
plot(wt,mpg) #散点图x,y
abline(lm(mpg~wt)) #拟合曲线y~x
title("Regression of MPG on Weight") #加标题
detach(mtcars)



2. 通过代码保存图片
setwd("F://Temp//") #设定工作目录

pdf("pic1.pdf") # 设定文件名
attach(mtcars)
plot(wt,mpg)
abline(lm(mpg~wt))
detach(mtcars)
dev.off() #关闭绘图设备

除了pdf()，还可以使用函数win.metafile()、png()、jpeg()、bmp()、tiff()、xfig()和postscript()将图形保存为其他格式。（注意，Windows图元文件格式仅在Windows系统中可用。）



3. 执行如plot()、hist()（绘制直方图）或boxplot()这样的高级绘图命令来创建一幅新图形时，通常会覆盖掉先前的图形。
如何才能创建多个图形并随时查看每一个呢？
方法1： dev.new()
方法2： 使用ggplot2绘图窗口的后退-前进箭头；
方法3: 数dev.new()、dev.next()、dev.prev()、dev.set()和dev.off()同时打开多个图形窗口，并选择将哪个输出发送到哪个窗口中。参考help(dev.cur)。


4.散点图 
语法： plot(x, y, type="p")
x and y: the coordinates of points to plot
type : the type of graph to create; Possible values are :

type="p": for points (by default)
type="l": for lines
type="b": for both; points are connected by a line
type="o": for both ‘overplotted’;
type="h": for ‘histogram’ like vertical lines
type="s": for stair steps
type="n": for no plotting
使用help(plot)可以查看其他选项.


x<-1:10; y=x*x
plot(x,y) #空心点图
plot(x, y, type="b") #空心点，用实线连接
plot(x, y, type="h") #竖直线
plot(x,y, type="s") #台阶图



5.图形参数：字体、颜色、线条、坐标轴、标题
(1)通过par()指定，除非被再次修改，该设定在进程结束前一直有效。该语句可一次性定义好，或使用多次。
添加par(no.readonly=T)可以生成一个不可以修改的当前图形参数列表，用于恢复设定。

oldPar=par(no.readonly = T) #记录当前设定
par(lty=2,pch=17) #修改设定：line type将默认实线改为虚线，pch将默认的点符号改为实心三角
plot(x,y,type="b")
par(oldPar) #恢复设定
plot(x,y,type="b")

##lty
 - The line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings "blank", "solid", "dashed", "dotted", "dotdash", "longdash", or "twodash", where "blank" uses ‘invisible lines’ (i.e., does not draw them).
 - Alternatively, a string of up to 8 characters (from c(1:9, "A":"F")) may be given, giving the length of line segments which are alternatively drawn and skipped. See section ‘Line Type Specification’.
 - Functions such as lines and segments accept a vector of values which are recycled.

##pch
 - plotting ‘character’, i.e., symbol to use. This can either be a single character or an integer code for one of a set of graphics symbols. The full set of S symbols is available with pch = 0:18, see the examples below. (NB: R uses circles instead of the octagons used in S.)
 - Value pch = "." (equivalently pch = 46) is handled specially. It is a rectangle of side 0.01 inch (scaled by cex). In addition, if cex = 1 (the default), each side is at least one pixel (1/72 inch on the pdf, postscript and xfig devices).
 - For other text symbols, cex = 1 corresponds to the default fontsize of the device, often specified by an argument pointsize. For pch in 0:25 the default size is about 75% of the character height (see par("cin")).



(2)通过高级绘图函数直接定义，仅对当前图形有效。
plot(x,y,type="b",lty=2,pch=17)



(3)指定符号和线条的参数
pch: 指定绘制时使用的符号
cex: 缩放倍数，默认是1；
lty: 指定线条类型；
lwd: 线条宽度。







1.画布分割

#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))

# par(mfrow=c(2,2),mar=c(1,1,2,1), mgp=c(2,.7,0), tck=-.01)#下、左、上、右的边距

par(mfrow=c(3,2)) #分割画布为3行2列
# http://blog.csdn.net/reallocing1/article/details/41726577

for(i in c(mean0,quantile2,quantile3,quantile4)){
  plot(x,y)
}








3.画图并保存到文件
(1) 建议优先使用R原生函数
pdf('xx.pdf', width=3,height=2.2)
g2+ggtitle("Positively Sig correlation(n=222)")
dev.off()



(2) 不建议的方式
Cairo的bug: win10下用 Cairo 生成的图片中文字用 illustrator 打开乱码！换 linux画可以，在win10下用pdf()正常。

library(Cairo)
CairoPNG(file=fname,width=1000)
plot(c(1,4,9,16))
dev.off()


4.调整坐标轴与刻度之间的距离：mgp=c(2.5,1,0)
http://blog.sina.com.cn/s/blog_4c7fada80102x3gd.html

mgp:坐标轴各部件的位置。第一个元素为坐标轴位置到坐标轴标签的距离，以文本行高为单位。第二个元素为坐标轴位置到坐标刻度标签的距离。第三个元素为坐标轴位置到实际画的坐标轴的距离，通常是0。





========================================
** 1. 高水平画图命令: plot, hist, barplot, boxplot, 
----------------------------------------
条形图、箱线图和点图
饼图和扇形图
直方图与核密度图

主要记录在
http://www.biomooc.com/R/R-draw-basic2.html
http://www.biomooc.com/R/R-draw-intermediate.html


========================================
|-- R语言中plot()函数
----------------------------------------
1. 基本作图

(1)




(2) 某数列的累积曲线
set.seed(1)
x=rnorm(1000) 
y=cumsum(x)
plot(y,type="l", col="red",xlab="x series")







2. 细节
(1). 6种边框
R语言中，设置plot(x,y,..., bty="o",..)里参数bty，就可以不同的6种边框了。

bty可以取6种字符，分别为“o”、“l”、“7”、“c”、“u”、“]”。这些字符代 表6种边框。

https://blog.csdn.net/sanqima/article/details/43022277







========================================
|-- 可视化查看数据分布: hist图和density图 (add=T 参数叠加图形)
----------------------------------------
1. hist() 查看数据的分布，重要参数是 n，就是分的区间个数。
hist(mtcars$mpg, 
     freq=FALSE, 
     breaks=12, 
     col="red", #柱子填充色
     border = NA, #去掉柱子的边框
     xlab="Miles Per Gallon", 
     main="Histogram, rug plot, density curve")  
rug(jitter(mtcars$mpg)) 
lines(density(mtcars$mpg), col="blue", lwd=2)





2. 对每个列染不同颜色
cl=colors()
set.seed(2)
x=runif(1000,-250,250) 
hist(x,breaks=seq(-250,250,5),col=cl[1:100]) 





3. hist图叠加一个hist图，再叠加一个 curve 曲线

# 模拟数据
set.seed(202010)
a1=rnorm(1000,180,10)
a2=rnorm(1000,165,7)

# freq = F 频率, freq=T 频数(默认)
hist(a1, n=20) #y [0, 200]
hist(a1, n=20, freq=T) #y [0,200]
hist(a1, n=20, freq=F) #y [0, 0.04]

# 频率才表示曲线下面积为1
hist(a1, n=20, freq=F, 
     col="#FF000088", xlim=c(130, 220), ylim=c(0, 0.07),
     mgp=c(2,1,0),
     xlab="Height", main="Histogram")
#add=T 叠加到上一个hist图上
hist(a2, n=20, freq=F, 
     col="#0000FF88", add=T)
#图例
legend("topleft", legend = c("boy", "girl"), fill=c("#FF000088", "#0000FF88"), bty="n")

# 叠加曲线
curve( dnorm(x, 180, 10), col = "red", lty = 2, lwd = 2, add = TRUE)
curve( dnorm(x, 165, 7), col = "blue", lty = 2, lwd = 2, add = TRUE)







========================================
|-- barplot(): 柱状图、堆叠图
----------------------------------------

1. R语言在柱状图上添加文字
画三组ABC，每组又两个柱子(空心、实心)


data <- data.frame(A = 1:2, B = 1:2, C = 1:2)
data <- data.matrix(data)

par(font = 2, lwd = 2)
pos=barplot(data, col = c("black", "white"), beside = T, ylim = c(0, 2.5), font = 2)
pos #返回坐标

# 使用pos 在柱子顶部添加文字
text( x = pos[,1], y = 0.05 + data[,1], adj = c(0.5, 0)) #A

text( x = pos[,2], y = 0.05 + data[,2], adj = c(0.5, 0), col="red") #B
text( x = pos[,3], y = 0.05 + data[,3], adj = c(0.5, 0), col=c("blue",'purple')) #C

axis(side = 2, lwd = 2, font = 2) #side=2左侧， lwd=2 加粗









2. R语言画barplot堆叠条形图

用于表现一个样本中有多少种亚型及其比例。
比如种群中的亚群比例，组织中的突变比例等信息。

数据实例：
province	cl1	cl2	cl3	cl4
10	0.927	0.012	0.023	0.038
10	0.894	0.057	0.009	0.04
15	0.03	0.277	0.262	0.431
15	0.032	0.768	0.042	0.159
16	0.021	0.731	0.058	0.19
16	0.017	0.914	0.042	0.027
17	0.011	0.945	0.011	0.033
17	0.013	0.96	0.014	0.013
18	0.207	0.148	0.223	0.422
18	0.677	0.084	0.119	0.12
19	0.064	0.124	0.223	0.589
19	0.539	0.194	0.027	0.24
20	0.021	0.041	0.058	0.879
20	0.027	0.046	0.106	0.821
21	0.018	0.102	0.051	0.829
21	0.026	0.122	0.167	0.685
22	0.015	0.012	0.956	0.017
22	0.063	0.018	0.905	0.014
23	0.015	0.018	0.93	0.038
23	0.018	0.025	0.938	0.018
23	0.023	0.046	0.864	0.067


代码：

#从剪切板读取数据
tbl2=read.table('clipboard',header=T)
#画条状图
barplot(t(as.matrix(tbl2))[-1,],col=rainbow(4), 
  #names.arg=(paste(substr(FirstName,1,1),".",LastName)),   #设定横坐标名称
  names.arg=tbl2$province,
  space=0, #条形间距
  xlab="Individual #", ylab="Ancestry",border=NA)
#axis(las=3,labels=tbl2$province)

#refer
#http://blog.sina.com.cn/s/blog_670445240102uwo3.html
#axis(1, lab=(t(as.matrix(tbl2))[1,]), cex.axis = 1.2)


问题：怎么在barplot图的上下标上文字注释？顶部标上分类，底部标上来源地。

这一步是structure软件的可视化部分。










========================================
|-- boxplot(): 箱线图 //todo
----------------------------------------






========================================
|-- curve(fn, x1, x2): 画函数曲线
----------------------------------------
1. Draws a curve corresponding to a function over the interval [from, to]. curve can plot also an expression in the variable xname, default x.

curve(expr, from = NULL, to = NULL, n = 101, add = FALSE,
      type = "l", xname = "x", xlab = xname, ylab = NULL,
      log = NULL, xlim = NULL, ...)
#




2. 实例
(1) 正弦曲线
curve(sin(x), -pi, pi)
abline(h=0, lty=2, col='grey')


(2) 二次曲线
pdf('123456wjl.pdf', width=4, height=4)
curve( (x-7)**2+2.25, 1,11, xlab="X", ylab="Y")

# arrow in a curve 用多边形画一个箭头
polygon(c(3,5,5,3), c(2,2,2.5,2.5), xpd=T, col='#FF000066', border = NA)
polygon(c(5,6,5), c(1.5,2.25,3), xpd=T, col='#FF000066', border = NA)
dev.off()







========================================
|-- R语言高/低级绘图函数-symbols: 圆形， 正方形，矩形，箱线图, 温度计图案 等
----------------------------------------
1. 严格意义上将symbols 并不能算是一个低级的绘图函数，因为它不仅可以在一幅已经存在的图标上添加元素，还可以创建一张新的图表
鉴于它绘图时的灵活性，我把它归入到低级绘图函数中

symbols 可以创建包括圆形， 正方形，矩形，箱线图，类似温度计的图形在内的多种图形

基本用法：
通过x和y坐标指定要创建的图形的中心，对于不同的形状，设置对应的参数
需要注意的是，图形的大小默认使用的单位是inches, 为了和坐标系中的坐标保持一致，可以通过inches = FALSE 将对应的参数和坐标系保持一致
add = TRUE 运行symbols 函数作为一个低级绘图函数来使用，在一张图表上添加对应的图形


(1)圆形：对于圆形来说，通过控制半径来控制其大小
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 1:5, y = 1:5, circles = rep(1, 5), inches = FALSE, add = TRUE)

(2)正方形：对于正方形来说，设置的参数是正方形边长的1/2
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 1:5, y = 1:5, squares = rep(2, 5), inches = FALSE, add = TRUE)

(3)矩形： 通过一个两列的矩阵来控制大小，第一列为宽度，第二列为长度
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), rectangles = matrix(c(2, 3, 3, 2), byrow = T, nrow = 2), inches = FALSE, add = TRUE)

(4)stars : 多边形，指定多边形的中心到各条边的距离，对于不同边数的多边形来说，对应的矩阵列数不同
par(oma = c(1, 1, 1, 1), mfrow = c(1, 3))
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 6), ncol = 3), inches = FALSE, add = TRUE)

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 8), ncol = 4), inches = FALSE, add = TRUE)

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = c(1, 4), y = c(3, 4), stars = matrix(rep(1, 10), ncol = 5), inches = FALSE, add = TRUE)

(5)温度计图案：通过一个列数为3或者4的矩阵来控制其大小，前两列对应图形的宽度和长度，如果矩阵只有3列，第3列是一个百分比，在该百分比对应的高度，会有填充色；如果矩阵有第4列，则在第3列和第4列对应的百分比之间会有一个填充色

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 2, y = 3, thermometers = matrix(c(1, 3, 0.5), ncol = 3), inches = FALSE, add = TRUE)
symbols(x = 4, y = 4, thermometers = matrix(c(1, 3, 0.2, 0.8), ncol = 4), inches = FALSE, add = TRUE) 


(6)箱线图：通过一个列数为5的矩阵进行控制，前两列分别对应宽度和高度， 第三列和第四列对应箱线图的下限和上限，第五列为一个0到1之间的数，控制代表中位数的直线所处的位置

plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE)

# fg : 设置图形边框的颜色
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE, fg = "red")


# bg: 设置图形的填充色
plot(1:5, 1:5, type = "n", xlim = c(0, 6), ylim = c(0, 6))
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, add = TRUE, bg = "red")


(7) 以上的用法都是通过add = TRUE , 将symbols 函数的输出添加到一个图形上，当add = FALSE 时，symbol 函数可以创建一张新的图表
除了前面的通用参数外，在创建新图表时，还有一些额外的参数
# xlim, ylim  : 设置新图表x轴和y轴的范围

symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, xlim = c(0, 6), ylim = c(0, 6))

(8)xlab, ylab , main : 分别设置新图表的x轴标签，y轴标签，标题
symbols(x = 3, y = 3, boxplots = matrix(c(1, 3, 0.5, 0.5, 0.4), ncol = 5), inches = FALSE, xlim = c(0, 6), ylim = c(0, 6),xlab = "x lab", ylab = "y lab", main = "title")







========================================
** 2. 低水平画图命令: legend, abline, text, axis, title
----------------------------------------
标题title
坐标轴axis
参考线abline
图例legend
文本标注text（绘图区域内部添加文字），mtext（图形四个边界添加文字）




1.散点图实例：自定义坐标轴及刻度，背景虚线，散点图，拟合的实线和虚线
来源：Fig 2C(Philip Brennecke, 2013: A ccounting for technical noise in single-cell RNARNARNA-seq experiments)

数据：#x=meansHeLa,y=cv2HeLa
> head(meansHeLa)
5_8S_rRNA       7SK      A1BG  A1BG-AS1       A2M   A2M-AS1 
2.8057377 0.3591766 0.6739348 0.3230381 1.1488078 0.3647032 
> head(cv2HeLa)
5_8S_rRNA       7SK      A1BG  A1BG-AS1       A2M   A2M-AS1 
19.335707  8.082797  6.597475  6.299504 28.000000 28.000000


画图命令
#2.4.1 Plot of the fit
CairoPDF(file="03-plotOfTheFit.pdf",width=5,height=5)
# Prepare the plot (scales, grid, labels, etc.)
plot( NULL, xaxt="n", yaxt="n",
      log="xy", xlim = c( 1e-1, 3e5 ), ylim = c( .005, 80 ),
      xlab = "average normalized read count", ylab = "squared coefficient of variation (CV^2)" )
axis( 1, 10^(-1:5), c( "0.1", "1", "10", "100", "1000",
                       expression(10^4), expression(10^5) ) )
axis( 2, 10^(-2:2), c( "0.01", "0.1", "1", "10","100" ), las=2 )
abline( h=10^(-2:2), v=10^(-1:6), col="#D0D0D0", lwd=2 )
title(main="nonSHela")
# Add the data points
points( meansHeLa, cv2HeLa, pch=20, cex=.2, col=colHeLa )
# Plot the fitted curve
xg <- 10^seq( -2, 6, length.out=1000 )
lines( xg, (xi+a1)/xg + a0, col="#FF000080", lwd=3 )
# Plot quantile lines around the fit
df <- ncol(countsERCC) - 1
lines( xg, ( (xi+a1)/xg + a0 ) * qchisq( .975, df ) / df,
       col="#FF000080", lwd=2, lty="dashed" )
lines( xg, ( (xi+a1)/xg + a0 ) * qchisq( .025, df ) / df,
       col="#FF000080", lwd=2, lty="dashed" )
dev.off()





========================================
|-- abline(截距, 斜率)函数为当前绘图添加直线，加背景虚线网格
----------------------------------------
1.abline(a = NULL, b = NULL, h = NULL, v = NULL, reg = NULL, coef = NULL, untf = FALSE, ...)

各参数的含义为：
（1）a 要绘制的直线截距
（2）b 直线的斜率
（3）h 绘制水平线时的纵轴值
（4）v 绘制垂直线时的横轴值
（5）reg 是一个具有coef方法的回归对象名称。若该对象返回的向量长度为1，则该值会作为该该函数的斜率，否则前两个值将会分别作为所绘直线的截距和斜率。
（6）coef 一个二维向量，给出截距和斜率
（7）untf 逻辑值，如果UNTF为真，且坐标轴中的一个或两个进行了对数变换，则会绘制对应于原始坐标系中的直线的曲线，否则在变换坐标系中绘制线。

abline()函数典型的用法
（1）abline(a, b, untf = FALSE, ...)
（2）abline(h =, untf = FALSE, ...)
（3）abline(v =, untf = FALSE, ...)
（4）abline(coef =, untf = FALSE, ...)
（5）abline(reg =, untf = FALSE, ...)

附加参数还可以给出线型、线条颜色，线条宽度等等。


2. 实例
#例1 带方格虚线的线图
# 画空图：参数type设置为"n",并设置坐标系的纵坐标与横坐标的比例为1
plot(c(-2,3), c(-1,5), type = "n", xlab = "x", ylab = "y", asp = 1)
# 绘制一条水平线和垂直线，并指定颜色
abline(h = 0, v = 0, col = "gray60")
#添加网格线或参考线
abline(h = -1:5, v = -2:3, col = "lightgray", lty = 3)
#如绘制y = 2x + 1，即绘制斜率为2，截距为1的直线
abline(a = 1, b = 2, col="red") #这里指定直线颜色为红色



#例2 过几个点，拟合曲线，画出该回归线
#在回归方程中可以添加趋势线,最简单的额情况，过2个点画直线
x <- c(2,5)
y <- c(50,57)
reg <- lm(y~x)
reg #会计算出截距和斜率
## Call:
## lm(formula = y ~ x)
## 
## Coefficients:
## (Intercept)            x  
##      45.333        2.333 
##
plot(x, y, xlab = "x XX", ylab = "y YY")
abline(reg,col="blue")





========================================
|-- R语言低级画图命令: legend() 画图例
----------------------------------------
吐槽吐到累，不如多掌握几个图例（Legend）的软肋，更好地利用R语言绘图。
legend(x, y = NULL, legend, fill = NULL,col =, bty = "o",xjust = 0, yjust = 1, x.intersp = 1, y.intersp =1, adj = c(0, 0.5), text.width = NULL,xpd=TRUE)



1. Legend 定位

整个绘图框的坐标轴范围，
> par("usr")
# [1] -0.24  6.24 -0.24  6.24
# 分别对应着 (xmin, xmax), (ymin, ymax); 可以辅助定位图例的位置。



(1). 如果图例绘在制图区外，必须提前保留绘制legend的空间。如par（mai=c（2,0.5,0.5,0.5）），图例绘制在下方，所以留2，其余3个方向为0.5。

(2). 图例绘在制图区外，必须设置参数xpd=TRUE，否则命令正确也不会出图，因为默认xpd=F。

(3). 图例位置由x，y决定。legend 默认坐标为左上角的坐标（因为设定xjust=0，yjust=1），因此可以通过xjust，yjust来调节。xjust=1，yjust=0，即为右下角坐标。

barplot中图例位置设置：args.legend = list(x="topleft"),


(4)R里面legend图例位置调整函数 inset
http://blog.sciencenet.cn/blog-267448-1021711.html
Legend函数里面有9个文本的位置字符串，但是有时对位置不太满意，比如离边际太远，可以在legend里面直接用inset=c(x,y)进行调整，第一个参数为横轴，第二参数为纵轴，一般可以使用负值来接近边际。





2.Legend布局
(1). 如果图例数量太多，则设置多列（ncol=），如ncol=4，分为4列。
(2). 如果图例不加边框，则设置bty=“n”，“o”为加边框。
(3). 图标和文字的位置，可以通过x.intersp, y.intersp, adj,text.width等来调控。
x（y）.intersp指图标和文字之间的绝对距离adj指图标和文字的相对距离text.
width指图标和文字整体的宽度。

命令1
设置绘图参数mai=c（下，左，上，右）的边界空间。

命令2
绘制柱状图。

命令3
选取绘图区域左下角和右上角的坐标。

命令4
正常绘图，设置xpd=T。xinch()、yinch()，分别表示沿x轴，y轴移动的距离，按绝对距离计算，或按坐标轴的数量级计算。fill=T，即显示图标（默认为矩形填充色）。fill=F的话可以设置pch，选择图标类型。

命令5
设置adj=0.6，adj越接近于0，图标与文字的相对距离越远。
此参数作用于文字，图标不动。


命令6
设置x.intersp=0.6，越接近于0，图标与文字的绝对距离越近。以一侧为标准，图标文字均移动。

命令7
设置text.width=1.4，表示图标和文字整体的宽度。当文字太长时可以调节此参数。

命令8
text.width与x.intersp结合使用，效果最好。

命令9
设置ncol=2，分为两列。





3. 在绘图函数(如barplot)中直接定义图例
实例: 把图例放到图外边
args.legend=list(x="right", border=NA, #不要图例小方块描边
				 box.col="white", inset=-0.25,bty = "n"),
#



4.图例参数详解
legend(x, y = NULL, legend, fill = NULL, col = par("col"),
border = "black", lty, lwd, pch,
angle = 45, density = NULL, bty = "o", bg = par("bg"),
box.lwd = par("lwd"), box.lty = par("lty"), box.col = par("fg"),
pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd,
xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1,
adj = c(0, 0.5), text.width = NULL, text.col = par("col"),
text.font = NULL, merge = do.lines && has.pch, trace = FALSE,
plot = TRUE, ncol = 1, horiz = FALSE, title = NULL,
inset = 0, xpd, title.col = text.col, title.adj = 0.5,
seg.len = 2)


画图调整legend（图例）位置：args.legend=list(x='topleft',bty='n')，
- x, y用于定位图例，也可用单键词"bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right" and "center"；
- bty 是指图例的盒子类型，只能选择o（带方框）或者n（不带方框）。

legend 字符或表达式向量；
fill 用特定的颜色进行填充；

col 图例中出现的点或线的颜色；
border 当fill = 参数存在的情况下，填充色的边框；设为NA表示不要边框。

lty, lwd 图例中线的类型与宽度；
pch 点的类型；
angle 阴影的角度；
density 阴影线的密度；
bty 图例框是否画出，o为画出，默认为n不画出；
bg bty != "n"时，图例的背景色；
box.lty, box.lwd, box.col bty = "o"时，图例框的类型，box.lty决定是否为虚线，box.lwd决定粗线，box.col决定颜色；
pt.bg 点的背景色；
cex 字符大小；
pt.cex 点的大小；
pt.lwd 点的边缘的线宽；
x.intersp 图例中文字离图片的水平距离；
y.intersp 图例中文字离图片的垂直距离；
adj 图例中字体的相对位置；
text.width 图例字体所占的宽度；
text.col 图例字体的颜色；
text.font 图例字体；
merge logical, if TRUE，合并点与线，但不填充图例框，默认为TRUE；
trace logical; if TRUE显示图例信息；
plot logical. If FALSE不画出图例；
ncol 图例中分类的列数；
horiz logical; if TRUE,水平放置图例；
title 给图例加标题；
inset 当图例用关键词设置位置后，inset = 分数，可以设置其相对位置；
xpd xpd=FALSE，即不允许在作图区域外作图，改为TRUE即可，与par()参数配合使用；
title.col 标题颜色；
title.adj 图例标题的相对位置，0.5为默认，在中间。0最左，1为最右；
seg.len lty 与lwd的线长，长度单位为字符宽度。



5. 实例 

(1) 使用 ifelse() 设置点的类别

plot(mpg ~ wt, data = mtcars, col = "grey",
     pch = ifelse(mtcars$am == 0, 1, 16), cex = 1.2)
legend( mean(par('usr')[1:2])/2, par('usr')[4]*1.2,  xpd=T,
        text.width = 1.2,
       legend = c("automatic", "manual"), pch = c(1,16), lty = c(2,1),
       col = "grey", pt.cex = 1.2, bty = "n", horiz = T)

# 红色圈出来那些点
dat=mtcars[which(mtcars$am==1),]
lines(mpg ~ wt, data = dat, col = "#FF0000", type="p",
      pch = 16, cex = 0.5)
#





ref:
https://blog.csdn.net/xiangyong58/article/details/54579293
http://www.360doc.com/content/17/0831/20/46931810_683661129.shtml









========================================
|-- 低水平绘图函数: arrow() 画箭头
----------------------------------------

1. 普通箭头

(1) 
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4)


(2) x0, y0,x1,y1 支持一次设置多个值，同时画多个箭头，示例代码如下：

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = c(1, 1),  y0 = c(1, 2),  x1 = c(4, 4), y1 = c(4, 5))



2. 更多参数

(1) length：控制箭头两边分叉的长度。该参数一次只能设置一个值，默认值为0.25。

op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 0.1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 0.5")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "length = 1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 1)
par(op)


(2)code : 调整箭头的类型，一共有1,2,3 共3种类型，该参数一次只能设置一个值.
code = 1 代表箭头由终止点指向起始点
code = 2 是默认值，箭头由起始点指向终止点
code = 3 代表在起始点和终止点两端都标上箭头

op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 1")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 2")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 2)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "code = 3")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, code = 3)
par(op)


(3) angle: 设置箭头分叉与主干的角度，默认值是45，该参数一次只能设置一个值
op=par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 15")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 15)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 45")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 45)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "angle = 60")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, length = 0.5, angle = 60)
par(op)


(4) 除了上面的针对arrows 的特殊参数之外，也支持一些通用的参数，col , lty ,lwd 等
... graphical parameters such as xpd and the line characteristics lend, ljoin and lmitre: see par.

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
arrows(x0 = 1, y0 = 1, x1 = 4, y1 = 4, col = "red", lwd = 2, lty = 3)



ref: https://www.cnblogs.com/xudongliang/p/6756258.html




========================================
|-- 低水平绘图函数: rect() 画矩形
----------------------------------------

1. 基本使用

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5)

(2)xleft, ybottom, xright, ytop 支持一次设置多个值，同时创建多个矩形，用法如下：
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4))




2. 更多参数

(1) border : 设置矩形边框的颜色，默认为"black"， 支持为多个矩形设置不同的值

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4), border = c("red", "blue"))


(2)col : 设置矩形的填充色，默认为NULL, 表示无填充色，， 支持为多个矩形设置不同的值

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = c(1, 2), ybottom = c(1, 2), xright = c(5, 4), ytop = c(5, 4), col = c("pink", "green"))


(3) density 和 angle : 搭配使用，设置用线条填充矩形，
angle 设置线条的角度，默认为45， 
density 设置填充线条的密度，数值越大越密集


par(mfrow = c(1,3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 1")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 1)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 3")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2)

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", main = "density = 4")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 3) 


(4)lwd:  设置矩形所有线条的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2, lwd = 3)


(5)lty: 设置矩形所有线条的类型

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
rect(xleft = 1, ybottom = 1, xright = 5, ytop = 5, angle = 45, density = 2, lwd = 2, lty = 3)




3. 实例 

(1) 画晃眼睛的方格图 
https://www.zhihu.com/question/458049025/answer/1871631313

plot(NULL, xlim=c(0,10), ylim=c(0,10), 
     xaxs ='i', yaxs ='i', 
     xaxt="n", yaxt="n",
     main="", xlab="", ylab=""); 

drawBox=function(x.adj, y){
  for(x0 in seq(0,11,2)){
    x=x0+x.adj
    rect(x,y, x-1,y-1, col="black")
  }
}
# test
#drawBox(0.4,1)
#drawBox(0.2,2)
#drawBox(-0.1,3)

# ajust for x
arr=c(0.4, 0.2, -0.1, 0.1,
      0.4, 0.2, -0.1, 0.1,
      0.4, 0.2, -0.1)

for(y in seq(1,11,1)){
  drawBox(arr[y], y-1)
}


abline(h=seq(1,10), col="#999999", lty=1, lwd=3)










========================================
|-- R语言低级绘图函数-grid() 画网格线 
----------------------------------------
1. grid 函数用来在一张图表上添加网格线，
(1)基本用法：默认在添加刻度线的地方添加网格线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid()
box()

(2) lwd  : 设置网格线的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(lwd = 3)
box()

(3) lty  : 网格线的类型，默认为虚线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(lty= 1)
box()

(4) col  : 网格线的颜色，默认为 lightgray
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(col = "lightblue")
box()

(5) 控制网格的数量，nx和ny
# nx : 设置x轴方向的网格数，默认是按照对应的坐标轴刻度绘制对应的网格线，当nx 设置具体的值时，
会根据数据的范围均匀分配网格，比如说5，代表画出5个单元格；当设置为NA时，不会画网格线

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(nx = 5)
box()

# ny : 设置y轴的网格数，默认ny的值等于nx 的值，当设置为NA时，不会画网格线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
grid(nx = 5, ny = 4)
box()







========================================
|-- R语言低级绘图函数-points()画点，及点的25个类型 
----------------------------------------
1. points 用来在一张图表上添加点，指定好对应的x和y坐标，就可以添加不同形状，颜色的点了；

(1)基本用法：通过x和y设置点的坐标
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5))


(2)cex : 设置点的大小
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5), cex = c(2, 4))


(3) lwd : 设置点的边框的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n")
points(x = c(3, 3), y = c(3, 5), cex = 4, lwd = c(2, 4))

(4) pch ： 设置点的形状，取值范围为1到25，
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5)
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}

(5) col:  设置点的边框的颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5, col="red") #设置颜色
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}

(6) bg ： 设置点的背景色，其实就是填充色，需要注意的是，只有形状为21到25的点是有填充色的
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", ann=F,xaxt="n",yaxt="n")
index <- 1:25
start <- 0
for (i in 1:5) {
	for (j in 1:5) {
		start <- start + 1
		points(x = i, y = j, pch = index[start], cex = 1.5, bg="red") #设置背景色
		text(x = i, y = j, labels = index[start], pos = 3, offset = 1)
	}
}










========================================
|-- R语言低级绘图函数: title() 函数用来在一张图表上添加标题
----------------------------------------
1. title函数的用法
　　main、sub、xlab和ylab分别表示主标题、副标题、x轴标题和y轴标题；
　　cex.lab表示坐标轴标题的字号大小；
　　font.lab表示坐标轴标题的字体；
　　col.lab表示坐标轴标题的颜色；
　　其余参数和axis中用法一致。

(1). main 表示主标题，通常位于图像的上方; 
sub 表示副标题，位于图像的下方;
xlab 表示x轴的标签; 
ylab 表示y轴的标签

par(oma = c(1, 1, 1, 1))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "figure", col = "red", lwd = 2)
box(which = "plot", col = "blue", lwd = 2)
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab")



(2). 参数设置
col : 设置标题的颜色
cex : 设置标题的文字大小
font : 设置标题的文字的格式

以上三个参数可以针对不同的标题分别进行设置，需要注意的是xlab和ylab 不能分开设置，只能是同时设置，对应的参数为 col.lab, col.cex, font.cex

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab", col.main = "red", cex.sub = 1.5, col.lab = "blue")


(3) outer : 逻辑值，如果为TRUE, 将标题放到plot area的外边

par(oma = c(5, 5, 3, 3))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "figure", col = "red", lwd = 2)
box(which = "plot", col = "blue", lwd = 2)
title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab", outer=TRUE)

(4) title 中也允许表达式

plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
title(main = expression(sqrt(x)), sub = expression(x^2), xlab = "xlab", ylab = "ylab")

更多关于表达式的书写，可以参考plotmath 函数的帮助文档







2. 综合实例 

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#无标题
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4)
axis(2,seq(0, 16, 4), seq(0, 16, 4))
#使用title设置标题
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y')
#使用line调整位置
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y', line = 2)
#调整颜色字体字号
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)
title(xlab= 'x', ylab = 'y', col.lab = 2, font.lab = 4, cex.lab = 2)








========================================
|-- R语言低级绘图函数: polygon() 函数绘制多边形，为指定区域填充背景色
----------------------------------------
1. 简介 
以数据(x,y)为坐标，依次连接所有的点，绘出一个多边形

# polygon draws the polygons whose vertices are given in x and y.
polygon(x, y = NULL, density = NULL, angle = 45,
        border = NULL, col = NA, lty = par("lty"),
        ..., fillOddEven = FALSE)

x, y: vectors containing the coordinates of the vertices of the polygon.
其中density为填充的阴影线的密度，angle为阴影线的斜率(角度)。
值得注意的是，当你需要纯色填充时，density和angle可以忽略不写。
然后border为边框的颜色。同时border也可以是逻辑。即FALSE相当于NULL，TRUE相当于为前景色。




2. 实例
(1)给背景填充颜色
xx=c(1:100, 100:1)
yy=c(rep(0,100), rep(1,100) )
plot(xx, yy, type = "n", bty="n",
     #xaxs ='i', 
     yaxs ='i', 
     xlim=c(0,150),
     xlab = "mpg", ylab = "wt")

polygon(xx, yy, col = "#66C2A566", border = NA) #填充bg1

polygon( c(100:150, 150:100), c(rep(0, 51), rep(0.8,51)), #填充bg2
         col = "#F81082AA", border = NA)
# 
points(mtcars$mpg*4.4, mtcars$wt/6, col="black", pch=21, bg="red" )


(2). 填充更复杂的区域
set.seed(3)
# Distance Between Brownian Motions 布朗运动之间的距离
n <- 100
xx <- c(0:n, n:0)   #生成202个元素的向量，其中前面101与后面101数字对称
yy <- c(c(0, cumsum(rnorm(n))), rev(c(0, cumsum(stats::rnorm(n)))))
plot(xx, yy, type = "n", xlab = "Time", ylab = "Distance")
polygon(xx, yy, col = "gray", border = "red")



(3) 综合实例：上下抖动的点连起来，填充其和坐标轴围成的面积
set.seed(123)
x <- rnorm(30) # 产生 30 个正态随机数

plot(x, xlab = "", type = "l") # plot函数绘制线条

xy <- par()$usr # 获取当前图形区域坐标范围
rect(xy[1], xy[3], xy[2], 0, col = "gray") #将0以下区域覆盖为灰色

polygon(c(1, 1:30, 31), c(0, x, 0), col = "red") # 绘制多边形

#lines(x) # 重画一遍 x 的线条
abline(h = 0, col = "blue",lwd = 4) # 添加水平线











========================================
text(), mtext() 添加文字：R中的字体-font
----------------------------------------
1. text() 添加文字

text(x,y, labels=, adj=, pos=, ...)
参数解释:
pos=1, 数字 1,2,3,4 分别对应着(x,y)点的 bottom, left, top, right.
offset=1 从(x,y)点偏移距离

cex=2 字号倍数
col=c('red', 'blue') 颜色 
adj=0, 0左下对齐，1右上对齐，0.5居中对齐(用于 text, mtext, title)
xpd=T 可以显示到plot区外的figure区
srt=30 顺时针旋转30度，结合adj使用效果更佳


(1). 画个包含坐标的空白图形。
plot(0:4,type="n",xlab = NA,ylab=NA,axes=F)
# 0:4 表示x轴和y轴的坐标刻度; type="n",表示画的点不显示。
# xlab= ,ylab=  表示x轴和y轴的 标签，NA 表示不显示内容；
# axes=F 表示坐标轴的线不显示。因此，该输出结果可以认为是隐藏了所有内容的图性。

(2). 设置字体 
font（字体）参数的取值是一个整数，一般分别用1、2、3、4来表示正常体、粗体、斜体和粗斜体1。

text(2,4,label="font=1 正常体",font=1)
text(2,3,label="font=2 粗体",font=2)
text(2,2,label="font=3 斜体",font=3)
text(2,1,label="font=4 粗斜体",font=4)

# 如果说label 过长的话会横向铺开，由此可见虽然设置了（2,y）的坐标，但横坐标并不是label的起点。

(3). 大小
cex（缩放倍数）参数的取值是一个实数，默认为1，表示不缩放。取值小于1时，表示缩小。取值大于1时，表示放大。

plot(0:4,type="n",xlab = NA,ylab=NA,axes=F) #画空图形
text(2,4,label="cex=1 font=1 正常体",font=1,cex=1)
text(2,3,label="cex=0.5 粗体",font=2,cex=0.5)
text(2,2,label="cex=1.5 font=3 斜体",font=3,cex=1.5)
text(2,1,label="cex=2 font=4 粗斜体",font=4,cex=2)


(4).字体类型

1)windows下使用windowsFont()函数来创建映射，
windowsFonts(
  A=windowsFont("Arial Black"),
  B=windowsFont("Bookman Old Style"),
	C=windowsFont("Comic Sans MS")
)
之后，即可使用A、B、C作为family的取值。
比如使用 par(family="A") 将指定Arial Black作为绘图字体
par(family="A")
plot(1:10,main="plot") 坐标轴、标题的字体都是粗体了。

在Mac下，请改用 quartzFonts()函数。

输出pdf、PostScript格式，则修改字体相对简单。

pdf则直接用如下函数找出系统可用字体，
names(pdfFonts())
# [1] "serif"                "sans"                 "mono"                
# [4] "AvantGarde"           "Bookman"              "Courier"  
#...
然后使用pdf(file="myplot.pdf", family="fontName") 来生成图形。

PostScript格式输出，对应函数为 names(postscriptFonts())和postscript(file="myplot.ps", family="fontname")





2. mtext() 在margin 区添加 text 

mtext(text, side=3, line=0 )
参数解释:
side=1,2,3,4 分别对应着 bottom,left,top,right 4个边界区域。
line=1表示往外偏移的行数，越大越靠外。
outer=T 在外区 outer margin 画(figure区外)；需要设置oma=c()才能看到效果
at=0.2 在 figure 宽高算，相对坐标轴的位置。
其他参数和text()类似。



========================================
|-- plotmath() 函数: R中可视化希腊字母(delta)、上下标、数学公式(根号、分数)等特殊符号
----------------------------------------

1. 数学标注 help(plotmath)
使用类似于TeX中的写法为图形添加数学符号和公示。细节和示例参考help(plotmath); demo(plotmath)。expression()中可以使用的数学表达式，比Latex少，但是比matlab多。

也可以用 plotmath() 函数为图形主体或边界上的标题、坐标轴名称或文本标注添加数学符号。
具体使用是利用text()语句中放入expression表达的数学公式。

画公式的方法由 expression(), bquote(), 和 substitute() 


(1)#Mathematical Annotation in R
plot(1,2,type="b",ylim=c(1.2,2.1),
     pch=21,col="blue",bg="red",cex=2) # 在(1,2)处画一个点
text(1,2,expression(hat(x)), pos=4) # 在(1,2)右加入\hat{x}
#更复杂的公式
formula = expression(italic(Prob) == bgroup("(",atop(n, x),")")%*%p[1]^x%*%(1-p[1])^(n-x))
text(1,1.5,label=formula)


(2)#right: https://stats.idre.ucla.edu/r/codefragments/greek_letters/
set.seed(1)  # for reproducible, pseudo-random numbers
h = rnorm(mean = 5, sd = 1, n = 1000)
hist(h, xlab = expression(h),
     main = expression(paste("希腊字母, ", mu, "=5, ", sigma,"=1")))
#







2. 使用 expression() 函数画公式

在使用R语言作图时，有时需要在图上标注诸如求和、积分、上下标等数学符号，该操作可以通过expression函数完成。
　　expression(...)
括号中输入数学表达式，配合plot、text、title、axis等函数使用，可以将数学公式绘制在图表上。

(1) 简单例子: 显示根号
x <- seq(0, 4, 0.01)
y <- sqrt(x)
tt <- expression(y == sqrt(x))
plot(x, y, type = 'l', main = tt, las = 1)

(2)expression函数支持的表达式语法与Latex类似，常用的表达式语句可以查看plotmath的帮助，即?plotmath。下面简单总结一下：
基础运算符
	sqrt(x) 根号x 
	sqrt(x,y) 根号x开y次方
	frac(x,y) x/y 
	
	x %+-% y	x plus or minus y
大型运算符
	sum(f(x), i=a,b) 对f(x)求和，从i=a到b
	prod(f(x), i=a,b) 对f(x)求乘积，从i=a到b
上下标
	a^b 表示b是上标
	a[b] b是下标
箭头符号
	x%->%y 表示左箭头
	x%<-%y 右箭头
	x%up%y 上箭头
	x%down%y 下箭头
集合运算
导数符号
特殊字体
	bold(x) 粗体x
	italic(x) 斜体x
	bolditalic(x) 粗斜体x
	underline(x) 下划线x
希腊字母:　希腊字母既可以使用其英文名表达，也可以使用symbol()表达。
	alpha or symbol(a)
	Omega
	Gamma 
	Theta
	

(3) 更多实例

1) 累加符号
plot(c(1,2), main=expression(sum(f(x), i=a,b))) 


2) 矩阵运算公式：转置、逆
plot(1:10, 1:10)
text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))


3) 图里如何组合paste()和expression()函数完成特殊字符的文本
注: 不支持paste0(),支持paste(),可以用paste(...,sep="")代替前者。

换行符号：除了 "\n"之外，还可以使用函数 expression(atop(x,y))
plot(x=rnorm(10), y=rexp(10), main =
       expression(atop(paste('N(',mu,',  ',sigma,')'),
            paste('Exp(',lambda,')'))))

4) 上下标：R语言画图中输出上或者下标的方法
## 方法1: [下标]， ^上标
labNames <- c('xLab','yLabl')
plot(c(1:10),xlab=expression(paste(labName[1], x^2)),ylab=expression(paste(labName[2], y^2)))

## 方法2: 斜体 italic()
plot(1,ylab=expression(italic("toto")["subscript"]),xlab=expression(italic("toto")^"superscript"))


par(mar=c(5, 4.3, 4, 2) + 0.1)
# 使用 ~ 连接符，更宽松
plot(c(1:10), xlab = expression(xLab ~ x^2 ~ m^-2),
     ylab = expression(yLab ~ y^2 ~ m^-2),
     main="Plot 1")
# 使用*更紧凑
plot(c(1:10), xlab = expression(xLab * x^2 * m^-2),
     ylab = expression(yLab * y^2 * m^-2),
     main="Plot 2")
# 混合使用~宽松，*紧凑
plot(c(1:10), xlab = expression(xLab ~ x^2 * m^-2),
     ylab = expression(yLab ~ y^2 * m^-2),
     main="Plot 3")
# 下标字母[], 希腊字母
plot(c(1:10), xlab = expression('Your x label' ~ mu[3] * phi),
     ylab = expression("Temperature (" * degree * C *")"))
#


5) 文本换行："\n"
par(mfcol=c(1,3))
plot(1,1,main=expression("first line \n second line x"^2))
plot(1,1,main=expression(paste("first line \n second line", "x"^2)))
plot(1,1,main=paste("first line \n second line", expression("x"^2)))


6) 公式换行: atop()函数
hist(1:10,cex.main=2,cex.axis=1.2,cex.lab=1.2,
     main=expression(atop("Histogram of "*hat(mu), 
                          Bootstrap~samples * ',' ~Allianz^2)))



7)Q: 公式怎么多次换行？使用 atop() 也只能换行一次，嵌套会导致字号不一致。除非逐行绘制。
https://www.zhihu.com/question/469560125/answer/1974822734

A: 文字大小的问题在atop中很容易解决，我们只需保证atop的每一个节点在同一层面上即可，如果所需的行数是偶数，两两搭配即可，如果是奇数，配合phantom(0)将其转换为偶数形式即可，如下：

exp1 <- substitute(
  atop(
    atop(italic(y) == a + b %.% italic(x),   italic(R) ^ 2 == r2),
    atop(italic(P) == p, phantom(0) )
  ),
  list(a = 1, b = 2, r2 = 0.9, p = 0.01)
)

plot(1)
text(0.6, 1, label = exp1, adj = 0, col = "red")



##############
# 实例2
##############

# 三行公式，字号不等
exp2=substitute(
  atop(
    italic(y) == a + b %.% italic(x), 
    atop( italic(R)^2~"="~r2, italic(P)~"="~p)
  ), 
  list(a=1, b=2, r2=0.9, p=0.01)
)
plot(1); 
text(1, 1.2, label=exp2, adj=0.5, col='red')

# 三行公式，字号相同
exp3=substitute( 
  atop(
    atop( phantom(0), italic(y) == a + b %.% italic(x) ),
    atop( italic(R)^2~"="~r2, italic(P)~"="~p)
  ), 
  list(a=1, b=2, r2=0.9, p=0.01)
)
text(1,0.8, label=exp3, adj=0.5, col="blue")









3. 使用 bquote() 函数画公式(支持变量替换)

除了.()子表达式的内容被它们的值替换外，其它表达式都被引用。

注意：bquote()内部可以使用变量！！！使用方法: .(paras), .(paraArr[1])
也就是说p值可以由科学记数法，改为正常乘号x及上标的形式了

(1) 上标
labNames <- c('xLab','yLab')
xlab <- bquote(.(labNames[1]) ~ x^2)
ylab <- bquote(.(labNames[2]) ~ y^2)
plot(c(1:10), xlab = xlab, ylab = ylab)


(2) 实例: 使用非科学计数法 在图中标注p值
annotate_Pvalue=function(p0, ...){
  #p0=1.2e-52; p0
  p0=formatC(p0, format="e", digits=2);#p0 #"1.2e-52"
  # split by e
  p0=strsplit(p0, "e")[[1]]; #p0 #[1] "1.2" "-52"
  # plot
  label = bquote(italic(P)~"=" ~ .(p0[1]) ~ "\u00d7" ~ 10^.(p0[2]) )
  text(labels = label, ...)
}

plot(1:3)
annotate_Pvalue(1.5e-26, x=2, y=1.8)


>> 更新版本请看 NGS/最佳实践: p值怎么画？



(3) 实例: 标注线性拟合曲线的R^2
# 散点图
plot(mpg ~ disp, data=mtcars)
# 拟合曲线
fit=lm(mpg ~ disp, data=mtcars)
abline(fit,col="red")
# 标注R^2
text(x=300,y=30, col='red',
     label=bquote(R^2==.( round(summary( fit )$r.squared, 3))) )



(4) 两行atop()、上标^
boxplot(iris, main = '')
title(bquote(atop("first line", "second line" ~ x ^ 2)))











4. 使用 substitute() 函数画公式(支持变量替换)
变量替换格式是 substitute( paste(nn, x^2), list(nn=labNames[1], x=100))
其中list中，key为前面等待替换的未知量，value为已知量

(1) 上标
labNames <- c('xLab','yLab')
plot(c(1:10),
     xlab=substitute(paste(nn, x^2), list(nn=labNames[1])),
     ylab=substitute(paste(nn, y^2), list(nn=labNames[2])))

(2) 下标
set.seed(1)
plot(0)
for (i in 1:4)
  text(1, 0.2 * i,
       substitute(x[ix] == y, 
                  list(ix = i, y = round(pnorm(i), 4)  )))

(3) 线性拟合公式、R^2、p值
data("faithful")
head(faithful)
model.lm<-lm(formula = waiting ~ eruptions, data = faithful)
summary(model.lm)
#对于一元线性回归方程y=ax+b，Intercept是指的截距，x对应的是系数。

l <- list(a = as.numeric(format(coef(model.lm)[1], digits = 4)),
          b = as.numeric(format(coef(model.lm)[2], digits = 4)),
          r2 = format(summary(model.lm)$r.squared, digits = 2),
          p = format(summary(model.lm)$coefficients[2,4], digits = 2))
eq <- substitute( 
	atop( 
		italic(y) == a + b %.% italic(x),  #怎么换行呢？使用 phantom(0)，见下面的例子。
        atop( italic(R)^2~"="~r2, italic(P)~"="~p)
	), 
l)

相同字号显示3行的例子: 
exp1 <- substitute(
  atop(
    atop(italic(y) == a + b %.% italic(x),   italic(R) ^ 2 == r2),
    atop(italic(P) == p, phantom(0) )
  ),
  list(a = 1, b = 2, r2 = 0.9, p = 0.01)
)


eq
str(eq) #language atop(i...
class(eq) #"call"
#
library(ggplot2)
p <- ggplot(faithful, aes(x=eruptions,y=waiting)) + 
  geom_point() + theme_bw()+
  stat_smooth(method='lm',formula = y~x,colour='red')+
  annotate(geom="text", x=4, y=50, label=as.character(as.expression(eq)), 
              parse = TRUE); p
#











5. 使用字符串拼凑，然后转为公式 

a=1; b=2
str1=paste('y[estimate]~"="~', a, '+~',b,'^italic(x)', sep=""); # 拼凑字符串

# check
str1;  #[1] "y[estimate]~\"=\"~1+~2^italic(x)"
class(str1) #[1] "character"
class( parse(text=str1) ) #[1] "expression"

x=seq(-1,10,0.1);x
plot(x, 1+2^x, type="l", col="red", ylab="Y")


(1) 形式1: parse(text=str1)
text(x=1,y=800, label= parse(text=str1), adj = 0)

(2) 形式2: str2lang(<string>)
text(x=1,y=600, label= str2lang(str1), adj = 0, col='red')

(3) 形式3: str2expression(<character>)
text(x=1,y=300, label= str2expression(str1), adj = 0, col='blue')




(4) 在图片外边缘标注还可以使用 mtext
exp <- 2
Lines <- list(bquote("first line"),bquote("second line x"^2), "3rd line")
Lines

plot(1,1)
mtext(do.call(expression, Lines),side=3,line=2:0)

# https://stackoverflow.com/questions/20549337/expression-and-new-line-in-plot-labels
这里说 plotmath 不支持换行。
plotmath (and therefore expression) doesn't allow linebreaks.

https://stackoverflow.com/questions/13198170/combining-expression-with-n


(5) 存文本换行：三行显示
plot(1, type="b")
lab="xx1"; form="xx2"
title(main=paste("Plot of \u03A6 of:", lab, "\nFunctional form:", form, "\nLine3"), adj=0)












ref:
https://blog.csdn.net/qq_18055167/article/details/92755403
R语言进阶：表达式、数学公式与特殊符号 https://blog.csdn.net/u014801157/article/details/24372443
https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/parse





========================================
|-- 打印 斜体文字(基因名) 的疑难杂症: Italic Font in R
----------------------------------------

1. 单个基因

(1) 图的标题斜体
plot(1,1)
text(1,1.2, labels= substitute(italic('CD8A')) ) #基本结构
text(1,0.8, labels= substitute(paste(italic('CD8A_2'))) ) #基本结构2

#
title(substitute(paste(italic(x)), list(x=c("TP53", "PTEN")[1]) )) #支持变量名替换


(2) 标题中部分斜体
plot(x=1:3, y=1:3, main = substitute(italic('TP53')*': Treat vs. Ctrl') )

换行:




(3) 怎么把换行\n 和 斜体 italic 写到一个图例中?
https://stat.ethz.ch/pipermail/r-help/2016-December/444070.html
# \n and italic() in legend()
plot(1,1)
v1 <- c( expression(italic("p")*"-value"), 
         expression("based on"*italic("t")*"-test"))
v2 <- c( expression(italic("w")*"-value for A"), 
         expression("and Bidentical models"))
legend("topright", legend=c(v1, v2), lty=c(1, 0, 1, 0), y.intersp = 1,
       bty="n", col=c("black", "", "red", ""))


其他版本: https://stat.ethz.ch/pipermail/r-help/2016-December/444071.html
# 单行表达式，不带换行
## legend: expression() call /w single line per variable
plot(1, 1)
v1 <- expression(italic("p")*"-value based on "*italic("t")*"-test") #no \n
v2 <- expression(italic("w")*"-value for A and B identical models")
legend("topright", legend=c(v1, v2), y.intersp = 1.0, bty="n",
       lty=c(1, 1), lwd = c(2,2), col=c("black", "red"))


# 单行表达式，带换行
## legend: expression() call /w two lines per variable
## (note lty, lwd, and col correction)
plot(1, 1)
v1 <- expression(italic("p")*"-value", "based on "*italic("t")*"-test") #有换行
v2 <- expression(italic("w")*"-value", "for A and B identical models")
legend("topright", legend=c(v1, v2), y.intersp = 1.0, bty="n",
       lty=c(1, 0, 1, 0), lwd = c(2, 0, 2, 0), col=c("black", "", "red", ""))


# 单行表达式，小字号
## legend: expression() call /w single line per variable,
## smaller script
plot(1, 1)
v1 <- expression(scriptstyle(bold(italic("p")*"-value based on"*italic("t")*"-test"))) #no \n
v2 <- expression(scriptstyle(bold(italic("w")*"-value for A and Bidentical models")))
legend("topright", legend=c(v1,v2), y.intersp = 1.0, bty="n",
       lty=c(1,1), lwd = c(2,2), col=c("black", "red"))


# 单行表达式，更小字号
## legend: expression() call /w single line per variable,
## even smaller script
plot(1, 1)
v1 <- expression(scriptscriptstyle(bold(italic("p")*"-value based on"*italic("t")*"-test")))
v2 <- expression(scriptscriptstyle(bold(italic("w")*"-value for A andB identical models")))
legend("topright", legend=c(v1,v2), y.intersp = 1.0, bty="n",
       lty=c(1,1), lwd = c(2,2), col=c("black", "red"))






2. 多个基因

(1) 图例中基因斜体








100. ggplot2 中的斜体
https://r-graphics.org/recipe-legend-title-appearance











========================================
|-- 打印\u开头的16进制 Unicode 字符：\u2248 对应 ≈ 
----------------------------------------

1. 打印方法

(1) 基本版
# 16进制Unicode编码 与字符
par(mar=c(2,2,2,1))
plot(1:10, type="n", ann=F, axes=T)
text(1,1, "\u2265 2265", col='red', pos=4)
text(1,2, "\u2264 2264", col='red', pos=4)

text(1,3, "\u2248 2248", col='red', pos=4)
text(1,6, "\u00B1 00B1", col='red', pos=4) #PLUS-MINUS SIGN


(2) 循环版

# 16进制Unicode编码 与字符
par(mar=c(2,2,2,1))
plot(1:10, type="n", ann=F, axes=F, xlim=c(0,3)); box()
mtext(side=1, text='text(1,10, "\\u00B1 00B1", col="red", pos=4)', col='red')
text(1,11, "\u2265 2265", col='red', pos=4, xpd=T)
#
codes=c('2264','2265','2248','00F7','00B1', "0024", "0023", "0022")
for(i in 1:length(codes)){
  code=codes[i]
  #print(code)
  library(stringi)
  cStr=stri_unescape_unicode(paste0("\\u",code)) #"±"
  text(1,10-i, paste0(cStr," ", code ), pos=4)
}






2. 资源
(1) 符号转换

Unicode与中文互转 16进制Unicode编码转换、还原
http://www.msxindl.com/tools/unicode16.asp


(2) 更多符号
https://blog.csdn.net/jiuzaizuotian2014/article/details/107048538/
https://blog.csdn.net/u011094862/article/details/49797015

具体符号	Unicode
±		\u00b1
×		\u00d7
÷		\u00f7
≤		\u2264
≥		\u2265
≈		\u2248
≠		\u2260




←↑→↓↖↗↘↙≈≠≤≥①②③④⑤⑥⑦⑧⑨⑩
⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇
⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛
█■□▲△▼▽◆◇○◎●◢◣◤◥★☆☉♀♂、。
 〃々〈〉《》「」『』【】〒〓〖〗
㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩㈱㊣㎡︳︵︶︷︸︹︺︻︼︽︾︿﹀﹁﹂﹃﹄﹛﹜﹝﹞

﹩＄＇＊｀＇～￣￥ 　 ！ ＇ ， ． ／ ： ； ？
＾ ＿ ｀ ｜ ￣ 、 。 · ‥ … ¨ 〃­ ­- ­― ∥ ＼
∼ ´ ～ ˇ ˘ ˝ ˚ ˙ ¸ ˛ ¡ ¿ ː ＂ （ ） ［ ］ ｛ ｝
‘ ’ “ ” 〔 〕 〈 〉 《 》 「 」 『 』­ 【 】
＋ － ＜ ＝ ＞ ± × ÷ ≠ ≤ ≥ ∞ ∴ ♂ ♀ ∠ ⊥
 ⌒ ∂ ∇ ≡­ ­≒ ­≪ ≫ √ ∽ ∝ ∵ ∫ ∬ ∈ ∋ ⊆ ⊇ ⊂ ⊃
∪ ∩ ∧ ∨ ￢ ⇒ ⇔ ∀ ∃ ∮ ∑ ∏ ＄ ％ ￦ Ｆ ′ ″
℃ Å ￠ ￡ ￥ ¤ ℉ ‰ ㎕ ㎖ ㎗ ℓ ㎘ ㏄





(3) 更多转换

1)# unicode to string
library(stringi)
stri_unescape_unicode(paste0("\\u","00B1")) #"±"

# js版转换 unicode to utf8
> unescape(`\u00b1`) //"±"




2)# unicode in string
x1 <- 'pretty\\u003D\\u003Ebig'
x1
x2 <- parse(text = paste0("'", x1, "'"))
x2
as.character(x2) #"pretty=>big"
x2[[1]] #"pretty=>big"



3)string to unicode









https://blog.csdn.net/u011094862/article/details/49797015




========================================
** 3. 其他辅助设置: par(), 边距, 坐标轴, 
----------------------------------------
1. 除了par()函数，高级绘图函数(plot,hist,boxplot等)也允许自行设定坐标轴和文本标注选项。
标题main, 副标题sub, 坐标轴标签xlab-ylab, 坐标轴范围xlim-ylim。


2.
par(mfrow = c(2, 1)) #布局为2行1列
par()$usr # 获取当前图形区域坐标范围


3.涉及到options和par参数设置时，要注意用on.exit确保函数运行结束后不会修改用户的设置
opar <- par(mai = c(4,3,3,1))
on.exit(par(opar))
注意：函数内使用


实例:
draw=function(){
  opar <- par(mar = c(3,3,3,1))
  on.exit(par(opar)) #离开时恢复原状
  plot(1:5)
}
draw() #左边距几乎没有
plot(1:5) #左边距正常






========================================
|-- R语言绘图布局: oma 参数设置outer margin, mar 参数设置margin
----------------------------------------
1. 在R语言中，par 函数可以设置图形边距，
	其中oma 参数设置outer margin, 
	mar 参数设置margin。

这些边距有什么不同呢，通过box函数可以直观的看到
box 默认在当前图形绘制边框，第一个参数
	which = "plot", 所以在当前图形上绘制边框
	which 的值除了plot 之外，还可以选择 figure, inner, outer

接下来分别用不同的值测试一下，为了区分，为不同的边框设置不同的颜色和类型,代码如下：






1. 外边框边距 oma = c(1, 1, 1, 1) # b,l,t,r

par(oma = c(1, 1, 1, 1))
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", xlab = "", ylab = "")
box(which = "outer", col = "purple", lwd = 3, lty=2) #能看到的边界，最外圈。
box(which = "plot", col = "blue", lwd = 2) #能画点的区域，中间坐标轴方框内(默认)
box(which = "figure", col = "red", lwd = 2) #整个绘图区，包括坐标轴

box(which = "inner", col = "green", lwd = 5, lty=3) #貌似和plot是重叠的

title(main = "main tilte", sub = "sub title", xlab = "xlab", ylab = "ylab")




2. 边界: 图形尺寸与边界尺寸mar
参数： 
pin 图形宽高(英寸) (width, height), in inches.; 
mai边界(英寸),c(bottom, left, top, right); 
mar边界(英分),c(bottom, left, top, right), 默认是c(5, 4, 4, 2) + 0.1.;


mar和mai的区别是什么？单位不同。







https://www.cnblogs.com/xudongliang/p/6741843.html





========================================
|-- par() 的设置项目: 高级绘图重合new=T, 隐藏坐标轴标签及标题 ann
----------------------------------------

1.调用高级绘图时，想重合，可以使用par(new = TRUE)。
为了重叠的更好，需要设置坐标轴范围。

plot(1:5, c(2,3,2,3,2), col = "red", type = "l",  
     xlim = c(1,5), ylim = c(1,5), ylab = "", xlab = "")
par(new = TRUE)
plot(1:5, c(3,4,3,4,3), col = "blue", type = "l", lwd=3, 
     xlim = c(1,5), ylim = c(1,5), ylab = "y", xlab = "x")
#



2.当设置为ann=FALSE时，图片的标题，x轴和y轴的标签、图标题main 就不会显示

par(ann = FALSE)
plot(1:5, 1:5, main = "title", xlab = "x", ylab = "y")

或者写到函数内
plot(1:5, 1:5, main = "title", xlab = "x", ylab = "y", ann=F)







========================================
|-- 低级绘图函数: axis()坐标轴设置
----------------------------------------
R语言作图：坐标轴设置
https://blog.csdn.net/weixin_40628687/article/details/79254791
https://www.cnblogs.com/xudongliang/p/6762618.html
在R语言底层作图中，对坐标轴的调整主要通过调整plot函数、axis函数和title函数的一系列参数完成。


一、plot函数的准备

　　在个性化设置坐标轴之前中，通常需调整plot函数中的ann、bty、xaxt、yaxt、xaxs和yaxs参数：
　　ann取FALSE时将不会画出标题（包括主、副标题及坐标轴标题）；
　　bty用来设置边框形式，默认值为"o"，表示四面边框都画出，其余可选值包括"l"（左下）、"7"（上右）、"c"（上下左）、"u"（左下右）、"]" （上下右）和"n"（无，即不画边框），在很多个性化绘图中，bty设为"n"，后期的边框线再使用其他函数（如axis）自行添加；

　　xaxs和yaxs 用来设置x轴和y轴的范围，默认值取“r”，表示坐标轴比给定作图范围（参数xlim和ylim给出的范围）稍微大一点儿，取”i”时表示坐标轴范围与给定作图范围完全相同，另外还可取”s”、”e”、”d”；

　　xaxt和yaxt 取”n”时，坐标轴、刻度线以及刻度值将不会画出。
#
x <- seq(-4, 4, 0.01)
y <- x^2
par(mfrow = c(2, 2), mar = c(4, 4, 1, 1))
plot(x, y)   # 未作处理
plot(x, y,  xaxs = "i", yaxs ="i")   # 绘图边框未留白
plot(x, y, bty = 'l')   # 只保留左和下两条边框
plot(x, y, ann = F, bty = "n", xaxt = "n", yaxt ="n")   # 边框、坐标轴都去掉






二、axis函数的用法

以x轴为例，一条轴线包含3个元素，
	水平的一条横线，叫做axis line; 
	刻度线，叫做tick line;
	对应的标签 labels


1、基本操作
　　side表示要操作的坐标轴，取值1、2、3、4分别代表下、左、上、右；
　　at表示刻度线及刻度值所在位置；
　　labels表示刻度值；
　　las表示坐标刻度值文字方向，las=0表示文字方向与坐标轴平行，1表示始终为水平方向，2表示与坐标轴垂直，3表示终为垂直方向。
	tick : 逻辑值，是否显示轴线，包括刻度线和对应的轴线， FALSE 表示不显示

(1) 综合实例
x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(1, 2), mar = c(4, 4, 1, 1))
#未设置文字方向
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4)
axis(2,seq(0, 16, 4), seq(0, 16, 4))
#文字方向水平
plot(x,y, ann = F, xaxt = "n", yaxt = "n")  
axis(1,-4:4, -4:4, las = 1)
axis(2,seq(0, 16, 4), seq(0, 16, 4), las = 1)


(2) 使用at手工指定x刻度位置
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, at = c(0, 2, 4, 6))

(3) lables : 指定在刻度上需要标记的内容，默认就是刻度对应的值
# 指定x轴刻度为 0A, 2A 等
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, at = c(0, 2, 4, 6), labels = paste(c(0, 2, 4, 6), "A", sep = ""))


(4) tick=F不显示刻度线
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
axis(side = 1, tick = F)






2、字体字号
　　cex.axis表示坐标轴刻度值的字号大小，
　　font.axis表示坐标轴刻度值的字体，font=1表示正体，2表示黑体，3表示斜体，4表示黑斜体。

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#未设置字体字号
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4)
#cex.axis = 2
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, cex.axis = 2)
#font.axis = 2
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, font.axis = 2)
#font.axis = 3
plot(x,y, ann = F, xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, font.axis = 3)





3、颜色
　　col表示图的颜色，用在axis函数中表示坐标轴线和坐标刻度线的颜色；
　　col.axis 表示坐标轴刻度值的颜色；
　　col.ticks表示坐标轴刻度线的颜色。

x<- seq(-4, 4, 0.01)
y<- x^2
par(mfrow=c(2, 2), mar = c(4, 4, 1, 1))
#未设置颜色
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4)
#col = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col = 2)
#col.axis = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col.axis = 2)
#col.ticks = 2
plot(x,y, ann = F, bty = "n", xaxt = "n", yaxt = "n")
axis(1,-4:4, -4:4, col.ticks = 2)


(1) col  : 设置axis line 和 tick.line 的线条颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue")


(2) col.ticks  : 设置tick line的颜色 
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue", col.ticks = "red")

(3) col.axis 设置刻度数值的颜色
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, col = "blue", col.axis="red")





4、位置
　　line表示坐标轴线位置与图像边框的距离，取负数时会画在图像边框以内；
　　mgp默认值为c(3, 1, 0)，三个数字分别代表坐标轴标题、刻度值和轴线与绘图边框的距离；
　　tcl默认值为-0.5，数值表示刻度线长度，负值表示刻度线朝外，正值朝里；
　　pos 表示轴线所在的位置；
　　line.outer取TRUE时，坐标轴将画在画布边缘处；
　　hadj指将刻度值沿平行坐标轴方向调整的距离；
　　padj指将刻度值沿垂直坐标轴方向调整的距离。

x <- seq(-4, 4, 0.01)
y <- x^2
par(mfrow= c(2, 2), mar = c(4, 4, 1, 1))
# 未设置刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4)
# 使用line调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, line = 2)
# 使用mgp调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, mgp = c(3, 2, 0)) 
# 使用padj调整刻度值位置
plot(x, y, ann = F, xaxt = "n", yaxt ="n")
axis(1, -4:4, -4:4, padj = 1)

(1) line : 轴线的位置
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 3)
axis(side = 1, line = 0, col='red')

(2) pos : 对轴线的位置进行调整，当pos 设置了对应的值之后会覆盖line 参数的值
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, pos = 1)





5、其他

tick取FALSE时，坐标轴线和刻度线不画出；
lty表示线型，用在axis函数中表示坐标轴线型；
lwd表示线的粗细，用在axis函数中表示坐标轴线粗细；
lwd.ticks表示刻度线粗细。


(1) lwd : 设置 axis  line 和 tick line  的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lwd = 2)

(2) lwd.tick : 设置tick line的宽度
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lwd = 1, lwd.tick = 5)

(3) lty : 设置axis line 和tick line的线条类型
plot(1:5, 1:5, xlim = c(0,6), ylim = c (0,6), type = "n", axes = F)
box()
axis(side = 1, line = 1, lty = 3)












========================================
|-- par函数mgp=c(2,0.8,0) 参数-控制坐标轴的位置
----------------------------------------
1. mgp 参数的值为长度为3的一个向量，默认值为 c(3, 1, 0); 3个数值控制的元素不同

(1) 第一个数值：3， 控制xlab 和  ylab的与坐标轴的距离

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(1, 1, 0))
box(which = "figure")

plot(1:10,main = "main", sub = "sub", mgp = c(2, 1, 0))
box(which = "figure")

plot(1:10, main = "main", sub = "sub",mgp = c(3, 1, 0))
box(which = "figure")

注意观察: xlab=index 与x轴的距离。
从左到右我分别设置了1到3; 从图中也可以看出来，影响的元素的包括xlab, ylab, sub



(2) 第二个数值 1， 影响的是坐标轴刻度值和的轴的距离。

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(3,1, 0))
box(which = "figure")
plot(1:10,main = "main", sub = "sub", mgp = c(3, 2, 0))
box(which = "figure")
plot(1:10, main = "main", sub = "sub",mgp = c(3, 3, 0))
box(which = "figure")

注意观察：x坐标刻度值2,4,6,8,10 与x轴的距离。



(3) 第三个数值 0：

par(mfrow = c(1, 3), oma = c(1, 1, 1, 1))

plot(1:10, main = "main", sub = "sub", mgp = c(3,1, 0))
box(which = "figure")
plot(1:10,main = "main", sub = "sub", mgp = c(3, 1, 1))
box(which = "figure")
plot(1:10, main = "main", sub = "sub",mgp = c(3, 1, 2))
box(which = "figure")

可以看到，影响的是坐标轴轴线位置。






2. 比较理想的设置

// todo






ref:
https://www.cnblogs.com/xudongliang/p/7993109.html








========================================
** 4. R中的色彩: colors, RColorBrewr, colortools
----------------------------------------
在R中，可以通过颜色下标、颜色名称、十六进制的颜色值、RGB值或HSV值来指定颜色。举例来说，col=1、col="white"、col="#FFFFFF"、col=rgb(1,1,1)和col=hsv(0,0,1)都是表示白色的等价方式。
函数rgb()可基于红—绿—蓝三色值生成颜色，而hsv()则基于色相—饱和度—亮度值来生成颜色。

专家对颜色的建议 Basic observations from the experts:
• L between 50 and 80
• U between -20 and 60
• V between -20 and 60


1.R颜色列表
https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf
我的版本: http://www.biomooc.com/color/colorsInR.html


(1)R中有多少种颜色？怎么看？
> colors() #查看R内置的657个颜色名字
[1] "white"                "aliceblue"            "antiquewhite"        
[4] "antiquewhite1"        "antiquewhite2"        "antiquewhite3" 

但是初级用户很难从如此长的列表中找到适合场景的颜色。这时候就需要借鉴别人的配色方案，并通过取色工具获取颜色。



(2)R中表示颜色的3种方式
1）颜色名字，即上面所显示的那么多种颜色；

2) 颜色编码。
rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1)
每种颜色是RGB形式的，最终转变为6位16进制的字符串表示，前面加“#”号！
> plot(10:1,type='s',col=rgb(0,1,0,0.5)) #green颜色的，每个颜色默认0-1; 
可以在rgb()中指定maxColorValue=255参数;
> rgb(0,0,255,alpha=255, maxColorValue=255) #[1] "#0000FFFF" 后两位是alpha值，表示不透明度

如红色对应的RGB值为"255 0 0",用16进制表示就是"FF0000",在R中可以用"#FF0000"表示红色。

> plot(10:1,type='s',col='#0096ff')

rgb转为16进制
> myHex<-rgb(red=126,green=0,blue=211,max = 255);myHex
#[1] "#7EFFD3"
> text(2,4,labels="文字",col= myHex)



3) 调色板中的索引。R中用palette()表示调色板，默认的是颜色是下面的几种：
> palette()
[1] "black"   "red"     "green3"  "blue"    "cyan"    "magenta" "yellow" "gray" 

在默认情况下，col=2表示红色。这个颜色会重复利用，如指定col=10同样是红色。
> plot(10:1,type='s',col=2)

可以改变调色板中的颜色，从而改变索引所代表的颜色。
i) 调色板函数palette()是一个非常灵活的函数，可以根据自己的要求改变调色板，如想把调色板变为下面5种颜色:red,green,blue,yellow,cyan.可以这么做：
color <- c("red","green","blue","yellow","cyan")
palette(color)
则palette()会显示下面的颜色：
[1] "red"    "green"  "blue"   "yellow" "cyan" 
这种情况下col=2表示绿色。

可以采用函数来产生颜色模式，如上面提到的rainbow()函数，rgb()函数。rgb(）函数可以产生很多种颜色，如
rgb(1,0,1:100,max=255)会产生一个长度为100的颜色向量。


ii) 如改变为另外一种颜色模式：palette(rainbow(10)),则palette()为：
[1] "red"     "#FF9900" "#CCFF00" "#33FF00" "#00FF66" "cyan"    "#0066FF"
[8] "#3300FF" "#CC00FF" "#FF0099"
在这种情况下，col=1表示红色.








2. 自带配色方案：用rainbow()，heat.colors()，terrain.colors()，topo.colors()，cm.colors()等函数
直接选取颜色，新手很难做到美观。R本身也提供特定颜色主题的配色方案。这些配色方案用一系列渐变的颜色表现特定的主题。
https://book.2cto.com/201408/45551.html

(1)rainbow()即彩虹的颜色，是由“赤、橙、黄、绿、青、蓝、紫”一系列颜色组成的。
该函数的用法如下：
rainbow(n,s=1,v=1,start=0,end=max(1,n-1)/n,gamma=1)

n 设定产生颜色的数目
start和end 设定彩虹颜色的一个子集，生成的颜色将从这个子集中选取，这个子集选取的大致分界线为：
赤色（red）为start=0，end=1/6
黄色（yellow）为start=1/6，end=2/6
绿色（green）为start=2/6，end=3/6
青色（cyan）为start=3/6，end=4/6
蓝色（blue）为start=4/6，end=5/6
紫色（magenta）为start=5/6，end=1

例1: 彩色的圆圈
n=20; plot(1:n, pch=CIRCLE<-16, cex=1:n, col=rainbow(n))

例2: 该例中会产生由赤、橙、黄、绿、青、蓝、紫7色依次合成6组颜色，每组包含6个渐变色。
barplot(rep(1,41),
        col=c(rainbow(n=6,start=0,end=1/6),
              "white",
              rainbow(n=6,start=1/6,end=2/6),
              "white",
              rainbow(n=6,start=2/6,end=3/6),
              "white",
              rainbow(n=6,start=3/6,end=4/6),
              "white",
              rainbow(n=6,start=4/6,end=5/6),
              "white",
              rainbow(n=6,start=5/6,end=1)))
x.text<-c("赤色","黄色","绿色","青色","蓝色","紫色")
axis(side=1,at=seq(from=3,length.out=6,by=8.5),labels =x.text,cex=0.75)


(2)其他主题配色函数
#heat.colors()从红色渐变到黄色，再变到白色
barplot(rep(1,6), col= heat.colors(6) )  

#terrain.colors() 从绿色渐变到黄色，再到棕色，最后到白色  
barplot(rep(1,6),col=terrain.colors(6))

#topo.colors() 从蓝色渐变到青色，再到黄色，最后到棕色  
barplot(rep(1,6),col=topo.colors(6))

#cm.colors() 从青色渐变到白色，再到粉红色
barplot(rep(1,6),col=cm.colors(6))








3. RColorBrewr颜色扩展包 提供了3套配色方案。
#画出来这些颜色
library(RColorBrewer)
display.brewer.all()
（1）连续型 sequential， 颜色渐变。
（2）极端型 Diverging，生成深色强调两端、浅色表示中部的颜色，可用来标注数据中的离群点。
（3）离散型 Qualitative，生成彼此差异明显的颜色，通常用来标记分类数据。


（1）查看连续型的种类。
display.brewer.all(type="seq")# 有9种颜色
#Set1 中只有9个颜色， Set3中有12个颜色，Paired 中有12个颜色
用法：barplot(rep(1,6),col=brewer.pal(9,"Blues")) # 数字9，表示使用色条中颜色的个数，引号内表示色条对应的名称。
可以使用brewer.pal（9, "<某组渐变颜色的名称>"）来获取该组渐变色的全部9种颜色。


（2）极端型。
display.brewer.all(type="div")# 有11种颜色。
用法： barplot(rep(1,6),col=brewer.pal(11,"RdGy")[2:7])# 第二到第七个颜色。



（3）离散型。
display.brewer.all(type="qual")# 颜色种类不确定。
用法： barplot(rep(1,6),col=brewer.pal(8,"Dark2")[1:5]) #参数和上面的相类似。












4.自定义调色板：直接自定义颜色、渐变色
https://blog.csdn.net/u014801157/article/details/24372411

如果觉得R预设调色板不合用，可以用 colorRampPalette 函数自定义调色板。使用之前得熟悉几个R预定义的颜色名称，这些名称可以通过colors函数获得：
> cl <- colors()
> head(cl,10)
> length(cl) #当前版本有657个预置颜色名称

(1)可以用这些颜色名称通过colorRampPalette函数产生自己的颜色系列，也就是渐变色。colorRampPalette的参数如下：

colorRamp(colors, bias = 1, space = c("rgb", "Lab"), interpolate = c("linear", "spline"))
colorRampPalette(colors, ...)


我们用它产生几个颜色系列：

# 红到白渐变
n=10
ramp <- colorRamp(c("red", "white"))  
barplot(rep(1,n), col=rgb( ramp(seq(0, 1, length = n)), max = 255) )


rgb.palette <- colorRampPalette(c(rgb(35,179,225,max=255),rgb(35,24,21,max=255),rgb(247,236,0,max=255)),space = "rgb") #黄黑蓝
rgb.palette(10)
barplot(rep(1,10), col=rgb.palette(10))

rgb.palette <- colorRampPalette(c(rgb(230,247,255,max=255),rgb(35,179,225,max=255)),space = "rgb") #蓝色渐变
barplot(rep(1,10), col=rgb.palette(10))



par(mfrow=c(3,1));par(mar=c(0.1,0.1,0.5,0.1));par(xaxs="i", yaxs="i")
n <- 1000

mycolors <- colorRampPalette(c("blue", "orangeRed"))(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()

mycolors <- colorRampPalette(c("darkgreen", "yellow", "orangered"))(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()

mycolors <- colorRampPalette(c("blue", "white", "darkgreen", "yellow", "orangered"), bias=1.2)(n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()




(2)grey() or gray()函数可以产生不同层次的灰度颜色
> args(grey) 
function (level) 
其中：level指定灰度，为0～1间的数，0为黑，1为白。例如： 

例1:
hist(x,breaks=seq(-250,250,5),col=grey(seq(0,1,0.01))) 

例2: 更多细节设置
n=10
mycolors <- gray(0:n/n)
barplot(rep(1,times=n),col=mycolors,border=mycolors,axes=FALSE); box()




(3)hsv函数通过设置色调、饱和度和亮度获得颜色，三个值都是0-1的相对量：
> args(hsv)  
function (h = 1, s = 1, v = 1, gamma = 1, alpha)  
色调（H），饱和度（S），亮度（V）。 

例1: 条形图，给出不同颜色
x=runif(10000,-250,250)  
hist(x,breaks=seq(-250,250,5),col=hsv(seq(0,1,0.01))) 
#用seq序列，默认饱和度和亮度是1

例2: 所有颜色平铺
par(mfcol=c(11,121)); par(mar=c(0,0,0,0));par(xaxs="i", yaxs="i")
x <- seq(0,10)/10
ndx <- expand.grid(x, x, x)
mycolor <- hsv(ndx[,3],ndx[,2],ndx[,1])
for(i in 1:nrow(ndx)){
	barplot(1,col=mycolor[i],border=mycolor[i],axes=FALSE)
}



(4) hcl() 函数 

> args(hcl)  
function (h = 0, c = 35, l = 85, alpha, fixup = TRUE) 
其中h指定颜色，为0～360间的整数，0为红色，120为绿色，240为蓝色；c指定浓度；l指定亮度；alpha指定透明度。 
 
例子：
x=runif(10000,-250,250)  
hist(x,breaks=seq(-250,250,5),col=hcl(1:100)) 


(5) rgb()函数 
该函数按三元色，红，绿，蓝原理指定颜色，rgb(r=1,g=0,b=0)为红色，
rgb(r=0,g=1,b=0)为绿色，rgb(r=0,g=0,b=1)为蓝色。 

> args(rgb) 
function (red, green, blue, alpha, names = NULL, maxColorValue = 1) 
# maxColorValue(max)设置为255时，rgb可以从1~255变化。与配色表查询值一致。

hist(x,breaks=seq(-250,250,5),col=rgb(r=1,g=0,b=0)) 













5. 配色 R包
(1) scales 包
scales软件包提供了很多颜色设置的函数，其中的alpha对颜色的透明度设置很方便，可以考虑使用。
有人可能喜欢用 RColorBrewer 软件包里面的不连续调色板，萝卜白菜吧。

# 查看颜色，用九宫格
library(scales)
show_col( c("red",'darkred','navy','#FF9600',"#0096FF"), labels = FALSE)




(2) colortools包
install.packages("colortools")
library("colortools")

#
wheel("darkblue", num = 12)

#Analogous color scheme
adjacent("darkblue") 
#or 
analogous("darkblue")

#Complementary color scheme
complementary("steelblue")


#Split Complementary Color Scheme
splitComp("steelblue")


#Tetradic Color Scheme
tetradic("steelblue")

#Square color scheme
square("steelblue")


#Sequential colors
sequential("steelblue")







6. 颜色格式互换

(1) rgb to hsv
rgb2hsv(255,255,255)#rgb转hsv
  [,1]
h    0
s    0
v    1
 

(2) 好看的配色(6个) 及色彩模式转换(named color to hex)
colors=c("firebrick1", "deepskyblue3", "goldenrod1", 
         "mediumpurple1", "orange3", "palegreen4")
barplot(rep(1, length(colors)), col=colors, border = NA, yaxt="n")

colors2=c()
for(i in 1:length(colors)){
  #rs1=col2rgb(colors[i])
  #rs2=rgb2hsv( as.numeric( (t(rs1) ) ) )
  #rs3=hsv( as.numeric( t(rs2[1,]) ) )
  
  col2=col2rgb(colors[i])
  col3=rgb( t(col2), maxColorValue = 255 ) #rgb to hexa "#9ACD32"
  colors2=c(colors2, col3)
}
colors2 #"#FF3030" "#009ACD" "#FFC125" "#AB82FF" "#CD8500" "#548B54"
barplot(rep(1, length(colors2)), col=colors2, border = NA, yaxt="n")











========================================
|-- [漂亮的颜色组合] 提供几个颜色组合，从多到少
----------------------------------------
library(RColorBrewer)
#433种
color433 = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
pie(rep(1,50), col=sample(color433, 50, replace = F))

#74种
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
color74 = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
pie(rep(1,60), col=sample(color74, 60, replace = F))

#37种
color37 = c("#466791","#60bf37","#953ada","#4fbe6c","#ce49d3","#a7b43d","#5a51dc","#d49f36","#552095","#507f2d","#db37aa","#84b67c","#a06fda","#df462a","#5b83db","#c76c2d","#4f49a3","#82702d","#dd6bbb","#334c22","#d83979","#55baad","#dc4555","#62aad3","#8c3025","#417d61","#862977","#bba672","#403367","#da8a6d","#a79cd4","#71482c","#c689d0","#6b2940","#d593a7","#895c8b","#bd5975")
pie(rep(1,37), col=sample(color37, 37))


#40种 (周运来: 读入一套我珍藏多年的颜色列表 https://www.jianshu.com/p/67d2decf5517)
allcolour=c("#DC143C","#0000FF","#20B2AA","#FFA500","#9370DB","#98FB98","#F08080","#1E90FF","#7CFC00","#FFFF00",
            "#808000","#FF00FF","#FA8072","#7B68EE","#9400D3","#800080","#A0522D","#D2B48C","#D2691E","#87CEEB","#40E0D0","#5F9EA0",
            "#FF1493","#0000CD","#008B8B","#FFE4B5","#8A2BE2","#228B22","#E9967A","#4682B4","#32CD32","#F0E68C","#FFFFE0","#EE82EE",
            "#FF6347","#6A5ACD","#9932CC","#8B008B","#8B4513","#DEB887")
length(allcolour)
barplot( rep(1,length(allcolour)), col=allcolour, border = NA, space = 0, ann=F, axes=F )




# 33种颜色
colors33 <- c("#E41A1C","#1E90FF","#FF8C00","#4DAF4A","#984EA3",
            "#40E0D0","#FFC0CB","#00BFFF","#FFDEAD","#90EE90",
            "#EE82EE","#00FFFF","#F0A3FF", "#0075DC", 
            "#993F00","#4C005C","#2BCE48","#FFCC99",
            "#808080","#94FFB5","#8F7C00","#9DCC00",
            "#C20088","#003380","#FFA405","#FFA8BB",
            "#426600","#FF0010","#5EF1F2","#00998F",
            "#740AFF","#990000","#FFFF00")
barplot( rep(1,length(colors33)), col=colors33, border = NA, space=0)


#20种
color20<-c('#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#ffffff', '#000000')
pie(rep(1,20), col=sample(color20, 20))


#彩虹20种
barplot(rep(0.2,20), col=rainbow(20)) #20种彩虹色，再多就区分不明显了




# 16 色
c1=c('#223D6C','#D20A13','#FFD121','#088247','#11AA4D','#58CDD9','#7A142C','#5D90BA','#029149','#431A3D','#91612D','#6E568C','#E0367A','#D8D155','#64495D','#7CC767')
# barplot( rep(1, length(c1)), col=c1, border=NA, yaxt="n")
barplot( rep(1, length(c1)), col=c1, border=NA, yaxt="n", space=0)



# 13 色
colors <-c("#FED439FF","#709AE1FF",
           "#D5E4A2FF","#197EC0FF","#F05C3BFF","#46732EFF",
           "#71D0F5FF","#370335FF","#075149FF","#C80813FF","#91331FFF",
           "#1A9993FF","#FD8CC1FF")





#这个抽样颜色还是值得考虑的，有经济学人柱状图的风格
library(RColorBrewer)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
#处理后有 74 种差异还比较明显的颜色，基本够用
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) 
#看下中间60种颜色的效果
n=30
pie(rep(1,n), col=sample(col_vector, n))
barplot(rep(0.2,n), col=sample(col_vector, n), border = NA, yaxt="n")








# 6颜色组合
c1=c("#FF3030", "#009ACD", "#FFC125", "#AB82FF", "#CD8500", "#548B54")  #dark
c1=c("#F57C63", "#4897D2", "#DEEBB4", "#8EAEE7", "#FFDE63", "#6C9059") #light
barplot( rep(1, length(c1)), col=c1, border=NA, yaxt="n", space=0)






# 3 颜色组合 
col1=c("#F71480", "#FF8101", "#808101") #red, yello, green
col2=c("#00AFBB", "#E7B800", "#FC4E07") #green, yello, redOrange

#
col3=c("#B0A577", "#62C3F2", "#F1C56D") #grey, blue, yellow
#      "#9C8D58","#3CB2EC","#EDB749" #darker
"#EDB749","#4A452A","#3CB2EC","#9C8D58"





========================================
|-- colorRampPalette() 创建颜色梯度(渐变色)
----------------------------------------
1. 使用预制配色集合，生成多个连续的颜色

library(RColorBrewer)
display.brewer.all() #显示全部颜色集合

# 挑选某一个集合
#barplot(rep(1,8),col=brewer.pal(8,"Dark2")[1:8]) #基础语法
myColors=brewer.pal(8,"Dark2")[1:8] #Dark2主题有8种颜色

par(mfrow=c(4,1), mar=c(0,2,2,0) )
barplot(rep(1,8),col= myColors, main="Dark2"  )
#
n=15 #nrow(df);
barplot(rep(1, n ),col= colorRampPalette(colors = myColors)( n ),main="Default:linear") #则由8种生成15种颜色
barplot(rep(1, n ),col= colorRampPalette(colors = myColors, interpolate ="linear")( n ),main="linear" ) #插值方式
barplot(rep(1, n ),col= colorRampPalette(colors = myColors, interpolate ="spline")( n ),main="spline") #插值方式



> colSet2
[1] "#1B9E77" "#D95F02" "#7570B3" "#E7298A" "#66A61E" "#E6AB02" "#A6761D" "#666666"





2. 实例 

library(RColorBrewer)
#(1) 产生11种颜色
col1=brewer.pal(11,'Spectral'); col1
barplot(rep(1,11), col=col1, border = NA)


(2) 根据给定的颜色，产生100个连续的颜色
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100) #减去第六个颜色
colors
barplot(rep(1,100), col=colors, border = NA)



(3) 把某一个连续的数字列，对应到一个连续的颜色区间上
有了颜色梯度之后，我们就可以方便的把数值映射到颜色梯度上
基本的思想是，
1)将数值排序，然后得到每个数值在排序好的序列中的顺序，其实就是rank 函数的返回值，然后利用该顺序去获取颜色
2)另一种思想，颜色更变化平滑，就是把数值切分区间，每个区间的levels对应的颜色就是我们需要的颜色。

plotcol <- colors[ cut( iris$Sepal.Length, breaks=100) ]; plotcol #把数字分成100个区间的因子，每个level对应一个颜色。
barplot(rep(1,length(plotcol)), col=plotcol, border = NA)
#












========================================
|-- 如何控制不透明度？rgb函数的第四个参数，或者16进制第7-8位
----------------------------------------
1.rgb函数的第四个参数
(1) 实例1
> set.seed(1)
> x <- rnorm(200)
> y <- rnorm(200)
> plot(x, y, cex = 3, pch = 16, col = rgb(255, 0, 0, 80, maxColorValue=255))
> plot(x, y, cex = 3, pch = 16, col = rgb(255, 0, 0, 20, maxColorValue=255))


(2). 实例2: 两个峰，重合部分显示不同颜色
#Create data
set.seed(1)
Ixos=rnorm(4000 , 120 , 30)     
Primadur=rnorm(4000 , 200 , 30) 

# First distribution
hist(Ixos, breaks=30, xlim=c(0,300), col=rgb(1,0,0,0.5), xlab="height", 
     ylab="nbr of plants", main="distribution of height of 2 durum wheat varieties" )

# Second with add=T to plot on top
hist(Primadur, breaks=30, xlim=c(0,300), col=rgb(0,0,1,0.5), add=T)

# Add legend
legend("topright", legend=c("Ixos","Primadur"), 
       col=c(rgb(1,0,0,0.5),rgb(0,0,1,0.5)), pt.cex=2, pch=15 )




2. 使用16进制的7-8位控制透明度。最后一位表示【不透明度】。
不透明度从 00(完全透明) 到 FF(完全不透明，默认)。比如:
	#FF0000 表示红色，等价于 #FF0000FF，表示完全 不透明。
	#FF000000 表示完全透明的红色，就是默认的白色背景。

例:
set.seed(1)
d1=rnorm(4000 , 120 , 30)     
d2=rnorm(4000 , 200 , 30) 

hist(d1, breaks=30, xlim=c(0,300), col="#FF000066")
hist(d2, breaks=30, xlim=c(0,300), col="#0000FF66", add=T)







ref:
https://bbs.pinggu.org/thread-4627872-1-1.html
https://www.r-graph-gallery.com/2-two-histograms-with-melt-colors.html





========================================
|-- 颜色深浅：是否深色 r*0.3 + g*0.59 + b*0.11 < 150
----------------------------------------
1. 根据颜色的深浅，决定上面文字的颜色应该使用白或者黑。
颜色转灰度公式为 greyValue = r*0.3 + g*0.59 + b*0.11
应该使用的字体颜色: fontColor = greyValue < 150? "white":"black";


2. 实现
(1) py实现如下: 是否是深色
def isDark(rgb):
    import re
    rs=re.split("[^0-9]+", rgb)
    return int(rs[1])*0.3 + int(rs[2])*0.59 + int(rs[3])*0.11 < 150

#isDark(arr[2])
isDark('rgb(154,205,50)')

(2) R 实现








========================================
** 5. 图形排版
----------------------------------------
http://www.360doc.com/content/14/0831/20/17553313_406108143.shtml
一、图形边距：mar/mai参数
> par(bg="cyan")                #把图形背景设为青色以便观察
> par(mar=c(4, 4, 0.5, 0.5))    #c(下、左、上、右)设定下边距和左边距为4行，另外两边距为0.5行。
> set.seed(1000)                #设此参数是为了下面的rnorm()函数都能获得相同数据
> plot(rnorm(10))


二、坐标轴（标题、刻度标签和刻度线）位置：mgp参数
mgp参数可设三个数值，依次为标题、刻度标签和刻度的位置。mar/mai设定参数后，图形区（用box函数绘制的边框）边缘位置即为0。所以，mgp=c(2, 0.5, 0)就表示标题在第二行，刻度标签在0.5行，刻度线在0行。
par(bg="cyan")
par(mar=c(4, 4, 0.5, 0.5))
set.seed(1000)
par(mgp=c(1.5,0.5,0)) #坐标轴各项的位置设定c(x标题,刻度标签,刻度线)
plot(rnorm(10))


三、获取位置坐标 //不懂没事，看完继续看四
如果要把图例、自定义文字等设置在图形区以外，par函数的usr参数非常有用，获取方法很简单：

usr <- par("usr")
usr
# [1]   0.64 10.36  0.64 10.36
#返回值是一个向量：c(x1, x2, y1, y2)
#如果要通过鼠标点击获得图形上的某些点的坐标，可以用locator()函数：

xy <- locator(n=1)   #参数n表示要获得n个点的坐标，需要点击n次鼠标
xy
#$x
#[1] 0.6516328
#
#$y
#[1] -1.761121




四、在图形区外添加图例和文字
有了以上获取坐标信息的方法，我们可以把图例放在图形区外。先绘制柱形图：
par(mar=c(3, 3, 0.5, 4))      #注意给图例留出空间，右侧4 inch
par(mgp=c(2,0.5,0))
NF <- c(17.44 , 2.56 , 2.70 , 18.71 , 5.61 , 32.98)
CA <- c(11.48 , 0.75 , 1.16 , 12.73 , 2.84 , 20.04)
labels <- paste("S", 1:length(NF),sep="")
the.data <- rbind(NF, CA)
barplot(the.data, ylim=c(0, max(NF,CA)*1.2), col=c("orange", "red"),
	xlab="Sample", ylab="Level", beside=TRUE,
	offset=0, axis.lty=1, names.arg=labels)
box() #外边框

#然后通过坐标设定将图例放到图形区外。
#注意：除坐标（指图例的左上角坐标）数值设定外，
#还要legend函数中的参数xpd值设为TRUE，意思为“允许在图形区外绘制”。

usr <- par("usr")
x <- usr[2]*1.02     #图例左上角的x坐标，向右移动
y <- usr[4]*0.6      #图例左上角的y坐标，向下移动
legend(x, y, legend=c("NF","CA"), fill=c("orange", "red"), box.col="white", xpd=TRUE)


#事实上，使用legend函数的inset参数就可以把图例放到图形区外，不需要设定坐标值。
#inset的值表示相对于图形区的比例，比如：如果位置坐标用 “left”和“right”，inset表示相对于x轴长度的比例。
#要将图例放到图形区外，inset设定为负值，具体数字自己估算。前面的图例可以用下面语句获得：
legend("right",legend=c("NF","CA"), box.col="white", fill=c("orange", "red"), 
       inset=-0.35, xpd=TRUE) #相对于right线，inset为正则向左移动，为负责向右移动。0.1的步长。
#建议还是先获取坐标好点，这个inset太难调了。

#灵活设定inset的值可以把图例放置在图形的其他地方，比如顶部：
par(mar=c(3, 3, 2, 0.5))
par(mgp=c(2,0.5,0))
barplot(the.data, ylim=c(0, max(NF,CA)*1.2), col=c("orange", "red"),
        xlab="Sample", ylab="Level", beside=TRUE,
        offset=0, axis.lty=1, names.arg=labels)
legend("top", legend=c("NF","CA"), box.col="white", fill=c("orange", "red"),
       ncol=2, inset=-0.15, xpd=TRUE)
box() #最后画box好，可以压下legend的白色背景。


顺便简单说说文字添加，更详细的内容留后面介绍。
图形区内添加文字用text()函数，在图形区外添加文字用mtext()函数。这种约束也不是死的，设定合适的参数，两者可以随意使用。
另外，mtext()不能添加旋转的文字，text用srt参数可以获得旋转文字。下面我们用旋转文字设定x轴标签：

NF <- c(17.44 , 2.56 , 2.70 , 18.71 , 5.61 , 32.98)
CA <- c(11.48 , 0.75 , 1.16 , 12.73 , 2.84 , 20.04)
the.data <- rbind(NF, CA)
labels <- paste("Sample", 1:length(NF))
par(mar=c(4, 3, 0.5, 0.5))
par(mgp=c(2,0.5,0))
position <- barplot(the.data, ylim=c(0, max(NF,CA)*1.2),
                    col=c("orange", "red"), legend.text=c("NF","CA"),
                    args.legend=list(x="topleft", box.col="white", inset=0.02),
                    ylab="Level", beside=TRUE, offset=0, axis.lty=1)
#以下为横坐标标签设定
x <- (position[1,] + position[2,])/2
y <- par("usr")[3]-1
text(x, y, labels=labels, adj=1, srt=45, xpd=TRUE) #adj标签与轴的距离，srt设置xlable角度
box()












========================================
|-- layout函数 精确布局
----------------------------------------
五、一页多图

(1) 函数简介
layout(mat, widths = rep.int(1, ncol(mat)),
       heights = rep.int(1, nrow(mat)), respect = FALSE)

mat 参数为一个矩阵，提供了作图的顺序以及图形版面的安排。
0代表空缺，不绘制图形，大于0 的数代表绘图顺序，相同数字代表占位符。

widths 和 heights 参数提供了各个矩形作图区域的长和宽的比例。

respect 参数控制着各图形内的横纵轴刻度长度的比例尺是否一样。

layout.show(n)
n 参数为欲显示的区域的序号。

(2) 示例
#分为6块
layout(matrix(1:6, nrow=3, byrow = T), )
layout.show(6)


# 分为3块，控制高度比例1:2，序号相同的合并为一块
par(oma = c(2,2,2,2))
mat=matrix(c(1, 2, 1, 3), 2); mat
layout(mat, widths = c(1, 1), heights = c(1, 2))
layout.show(3)




(3) 更精细的控制每个小图的边界
把一个页面平分成n份做n个图，用par函数的mfrow和mfcol参数。这两个参数都是两个值的向量，表示行数和列数，但在页面上作图顺序的顺序不一 样。如果用mfrow参数，一行一行从左到右作图；mfcol则是一列一列的做。下面图形的代码只有第一行不一样，注意看每个图内的点（数字）：

#画图函数
myDraw=function(){
  set.seed(1000);plot(rnorm(100),pch="1", cex=0.6)
  set.seed(1001);plot(rnorm(100),pch="2", cex=0.6)
  set.seed(1002);plot(rnorm(100),pch="3", cex=0.6)
  set.seed(1003);plot(rnorm(100),pch="4", cex=0.6)
}

#图片按横着输出
par(mfrow=c(2,2)) #两行两列，mfrow行
par(mar=c(3, 3, 0.5, 0.5))
myDraw()

#图片竖着输出
par(mfcol=c(2,2)) #两行两列，mfcol列
par(mar=c(3, 3, 0.5, 0.5))
myDraw()
#


(4) 数字编号不能有跳跃 
如果页面不均等分隔绘制多图，用layout函数分隔页面。它有四个参数，mat，widths，heights和respect。后三个参数有默认值，这 里我们只设置第一个参数mat。它是一个矩阵，表示绘图区分隔的各部分，相同数字的部分合并成一个绘图区，数字也是它们作图时的顺序。下面的矩阵mat有 2行3列，我们看看它绘出的图形：

注意：mat参数的值必需从1-n顺序依次取值，不能有间隔。

#layout布局1
par(mar=c(2, 2, 0.5, 0.5))
mat <- matrix(c(1,1,2,3,4,4), nrow=2, byrow=TRUE)
mat
#     [,1] [,2] [,3]
#[1,]    1    1    2
#[2,]    3    4    4
layout(mat)
myDraw()


#layout布局2
par(mar=c(2, 2, 0.5, 0.5))
mat <- matrix(c(1,2,3,4,4,4), nrow=2, byrow=TRUE)
mat
#     [,1] [,2] [,3]
#[1,]    1    2    3
#[2,]    4    4    4
layout(mat)
myDraw()









2. 实例: plot an logo for R QQ group

#pdf("logoR.pdf", width=2.5, height=2.5)
png("logoR.png", width=2.5, height=2.5, units = "in", res = 72)
#settings
border_width=30
border_color=c("#71BE4B","#ED245B","#FAC319", "#00A1DF")
r=0.85 #radius of circle
#
par(oma=c(0.1,0.1,0.1,0.1)*0)
layout(matrix(c(1:4),nrow=2,byrow=T), widths = c(1,1), heights =c(1,1)) 
for(i in 1:4){
  par(mar=c(0,0,0,0))
  plot(c(0), col='white', xlim=c(-0.5,0.5), ylim=c(-0.5, 0.5), 
       xaxs ="i", yaxs ="i",
       ann=F, axes=F); 
  #circle
  cir_X=-0.5*(-1)^i
  cir_Y=0.5*ifelse(i<=2, -1, 1)
  symbols(x = cir_X, y = cir_Y, circles = r, inches = FALSE, add = TRUE, lwd=border_width, fg=border_color[i])
  # text R
  text(cir_X, cir_Y, labels="R", col=rev(border_color)[i], cex=15, xpd=T)
}
dev.off()
















========================================
|-- 图片的组合与拼接(任意位置、任意个图, 支持base和grid绘图系统)
----------------------------------------
https://mp.weixin.qq.com/s?__biz=MzA3MTM3NTA5Ng==&mid=2651059193&idx=1&sn=67c8db755cb9e2376b6a49f3af1f473f

customLayout R包可以自由拼图，可以使用矩阵自定义图形位置和顺序，用数字来定义每一个模块的长宽比，试用了一遍简直爱不释手。

这个包不仅支持数字拼图，还支持R内置的base绘图对象、grid绘图对象等（也就是支持ggplot2对象）。
customLayout用于拼图特别方便，尤其是仪表盘布局。
支持R内置的base绘图对象，ggplot2对象（与grid结合）。

这样的话，对于需要制作简单仪表盘的场景，完全不必要使用rmarkdown+flexdashboard或者shiny+shinydashboard也可以快速生成仪表盘原型。






1.安装
customLayout包有CRAN版本，也有github版本可供下载：

install.packages("customLayout")
devtools::install_github("zzawadz/customLayout")



2.简单的数字拼图：

lay_new() 创建拼图画布
lay_show() 显示拼图画布




(1)通过设置简单的数字矩阵以及对应的宽高比，可以非常方便的设置出来数字拼图：

library(customLayout)
#library(magrittr)

lay <- lay_new(
  mat = matrix(1:4, ncol = 2), # 矩阵分布，mat表示指定排版的数字矩阵 
  widths = c(3, 2), # 设定宽度比例
  heights = c(2, 1))   # 设置高度比例)
lay_show(lay) # 显示拼图画布

mat数字矩阵必须从1开始，且必须连续
其中mat指定要拼图的数字矩阵，将1:4数字按照纵向顺序拼成两行，其中宽对比为3:2,高度比为2:1。



(2)
lay2 <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 5),
  heights = c(2, 4))
lay_show(lay2)


(3)画布合并
其它拼图包没有的功能，非常好用
跟合并矩阵类似。分为行合并和列合并

lay_bind_col() 画布列合并
lay_bind_col(x, y, widths = c(1, 1), addmax = TRUE) 参数widths表示指定合并宽度比

lay_bind_row() 画布行合并
lay_bind_row(x, y, heights = c(1, 1), addmax = TRUE) 参数heights表示指定合并高度比


将前两个例子横向拼接，两个模块对象仍然支持设置款对比例（3:1）
cl = lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl)


(4)不同层级的对象仍然支持拼接在一起。
lay3 <- lay_new(matrix(1:2))
lay4 <- lay_bind_row(cl, lay3, heights = c(5, 2))
lay_show(lay4)


(5) 画布嵌套: 将一个模块嵌入到两一个模块特定位置。
这个功能也是其它包没有的，非常有用
关键函数：
lay_split_field(lay, newlay, field)

参数lay表示大画布，参数newlay表示要嵌套进去的小画布，field表示指定要嵌套的区域编号


lay <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 2),
  heights = c(2, 1))
lay_show(lay)

lay2 <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 5),
  heights = c(2, 4))
lay_show(lay2)

slay <- lay_split_field(lay, lay2, field = 4)
lay_show(slay)

这里就将lay2嵌入到lay模块的第四个区域，但may2内部的布局结构任然不变。








3.填充图片: 关于图像对象的布局与拼接
关键函数：
lay_set(layout) 将画布layout设置为绘图布局，用于base绘图对象
lay_grid(grobs, lay, ...) 将绘图对象grobs填充到画布lay中， 用于ggplot2等绘图对象


(1)基础绘图对象的拼接：
par(mar = c(3, 2, 2, 1))
lay  <- lay_new(
  matrix(1:4, nc = 2),
  widths = c(3, 2),
  heights = c(2, 1))
lay2 <- lay_new(matrix(1:3))
cl   <- lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl) #显示画布

##
lay_set(cl) # initialize drawing area

set.seed(123)
plot(1:100 + rnorm(100))
plot(rnorm(100), type = "l")
hist(rnorm(500))
acf(rnorm(100))
pie(c(3, 4, 6), col = 2:4)
pie(c(3, 2, 7), col = 2:4 + 3)
pie(c(5, 4, 2), col = 2:4 + 6)



(2) grid(ggplot2)图形对象的拼接:

library(ggplot2)
#library(gridExtra)

## 创建排版画布
lay  <- lay_new( matrix(1:2, ncol = 1))
lay2 <- lay_new(matrix(1:3))
cl   <- lay_bind_col(lay, lay2, widths = c(3, 1))
lay_show(cl)

# 创建数据
cuts <- sort(unique(diamonds[["cut"]]),decreasing = TRUE)

make_cut_plot <- function(cut) {
  dd <- diamonds[diamonds[["cut"]] == cut, ]
  ggplot(dd) +
    geom_point(aes(carat, price)) +
    facet_wrap("cut") # 封装分面
}

plots <- lapply(cuts, make_cut_plot) # 对不同切割水平的进行作图
lay_grid(plots, cl) # 将绘图对象依次填充到cl画布中


customLayout包的版式布局思想非常简单，就是基于数值矩阵的模块化分割，同时不同层级的模块也可相互拼接，这样就可以像拼七巧板一样拼出很多奇形怪状的版式出来，甚至你使用这种版式来设计一个富有美感的超照片拼图或者海报都有可能。





========================================
|-- 不同的图叠加拼凑在一起展示
----------------------------------------

1. par(new=TRUE) # 每叠加一次新图形，运行一次该程序命令，即可实现在原图上继续叠加数据绘图

x1=iris$Sepal.Length
x2=iris$Sepal.Width
x3=iris$Petal.Length
x4=iris$Petal.Width
  
plot(x1,x3,xlab="维度",ylab="物种多样性数量");    #做散点图
lines(lowess(x1,x3),col=1, lwd=3);    #利用lowess做回归曲线
# 叠加一层
par(new=TRUE)  # 是否叠加新图形，每叠加一次运行一次该命令

plot(x3,x4, col=2,
     yaxt="n", xaxt="n",xlab="",ylab="");    #做散点图
lines(lowess(x3,x4),col=2, lwd=3, lty=4);    #利用lowess做回归曲线







2. 不同的图叠加拼凑在一起展示

用 grid.newpage() 函数命令选择是否进行图形叠加，该命令有先后顺序，要先运行。
小图可以是 png 或另一个 ggplot2 图。


# 绘制一个png图像
png("test.png", width=200, height = 300)
hist(iris$Sepal.Length)
dev.off()
# 读取该图像
library(png)
logo <- readPNG("test.png")


# 绘制大图
library(grid)
library(ggplot2)
gg <- ggplot(mpg, aes(displ, hwy, colour = class)) +  geom_point()
gg
# grid.newpage()
# print(gg)  # 绘制第一个图

# 设置小图png的位置和大小，单位是比例
vp <- viewport(x = 0.6, y = 0.8, width = 0.2, height = 0.2)
# 叠加小图
grid.raster(logo, vp = vp)  



ref:
https://blog.csdn.net/tandelin/article/details/94412733





========================================
|-- R保存图片，强制覆盖前面的空白页
----------------------------------------
1. 先可视化图片，然后再保存到文件。

x=seq(-3,3,0.1)
plot(x,x**2,type='l')
abline(h=2,col='red', lty=2)
lines(x,4/(1+exp(-x**2)),col='blue')
#blablabla...
#dev.copy(postscript, file="myfile.eps", height=6, width=6, horizontal=F, onefile=F)
#dev.copy(png, filename="myfile.png", height=600, width=800, bg="white")
#dev.print(device=postscript, file="yourFileName.ps")
dev.copy2pdf(file="xx_plot.pdf",out.type="pdf")
dev.off()




2. 强制输出到一张: pdf 函数中，有一个参数onefile ,  默认值为TRUE, 表示每张图片占用pdf 中的一页

(1) 两页，第一页是空白
pdf("test.pdf")
plot(1:5, type = "n", xlab = "", ylab = "", bty = "n", xaxt = "n", yaxt = "n")
plot(1:5)
dev.off() 

(2) 只需要设置onefile = FALSE 就可以了，此时后面的图片会覆盖前面空白的图片
pdf("test.pdf", onefile = FALSE)
plot(1:5, type = "n", xlab = "", ylab = "", bty = "n", xaxt = "n", yaxt = "n")
plot(1:5)

# hist(iris$Sepal.Length)
dev.off()

前面不管是不是空白，都会被覆盖掉，只显示最后一个该显示的图。




ref: https://qinqianshan.com/r_code/r_draw/images-export-r/






========================================
高级效果
----------------------------------------
用persp函数作三维曲面图, contour作等值线图， image作色块图。 坐标x和y构成一张平面网格， 数据z是包含z坐标的矩阵，每行对应一个横坐标， 每列对应一个纵坐标。





========================================
|-- 3d散点图: 一次观察4个属性(3个位置、1个颜色)
----------------------------------------
1. 3D散点图，无法拖动 scatterplot3d

library(scatterplot3d)
set.seed(2015)
x <- runif(100)
y <- runif(100)
z <- runif(100)
grp <- as.factor(sample(1:3, 100, replace = T))#这是设置三种颜色标签，一个数字对应一个颜色
dat <- data.frame(x, y, z, grp)#生成数据框
head(dat)
plot3d <- with(dat, scatterplot3d(x, y, z, color = as.numeric(grp), pch = 16))

legend(plot3d$xyz.convert(0.5,0.7,0.5),pch=16,yjust=0,legend=levels(dat$grp), col = seq_along(levels(dat$grp)))


控制点的大小: cex.symbols=0.5,



(1) 理解angle参数
library("scatterplot3d")
z <- seq(-10, 10, 0.01) 
x <- cos(z) 
y <- sin(z) 
for(i in seq(0,360,5) ){
  print(i)
  scatterplot3d(x, y, z, 
                highlight.3d=TRUE, 
                col.axis="blue", 
              col.grid="lightblue",
              angle=i, #x和y轴夹角，就是2d图中目测看到的
              main=paste("scatterplot3d - 1",i), pch=20)
  Sys.sleep(0.05)
}


(2) 根据某一列的值，设置渐变颜色。
## version 1: 不完善，颜色获取容易出bug。原因未知。
mycolors=colorRampPalette(colors = c("yellow",'red','purple'))( 200 )
i=3; #染色的列
scatterplot3d(mtcars[,c(1,2,5)], type = "h", lwd = 1, pch = 16, 
              #x.ticklabs = colnames(my.mat),
             color = mycolors[ round(mtcars[,i]/max(mtcars[,i])*200) ],
               #grey(25:1 / 100), 
             angle=60,
             main = "3D barplot")
#


(3) 更完善的颜色设置
## version 2: 完善颜色获取，使用极值做标准化
# get color list
getColorList=function(df, i){
  mycolors=colorRampPalette(colors = c("yellow",'red','purple'))( 201 )
  stdvalue=round( (df[,i]-min(df[,i]) )/( max(df[,i])- min(df[,i]) )*200 );
  list.color=c()
  for(j in 1:nrow(df) ){
    color=mycolors[stdvalue[j]+1]
    list.color=c(list.color,color)
  }
  return(list.color)
}
#getColorList(rsDF, i)

library("scatterplot3d")
i=3; #染色的列
rsDF=mtcars #测试数据
scatterplot3d(#rsDF[,c(3,4,6)], 
  x=rsDF[,3], y=log2(rsDF[,6]+1), z=rsDF[,4], #zlim=c(0,80),
  xlab=colnames(rsDF)[3],
  ylab='',#paste0('log2 ', colnames(rsDF)[6] ),
  zlab=paste0('', colnames(rsDF)[4]),
  type = "h", #p 点图
  lwd = 1, pch = 16, cex.symbols=0.5,
  color = getColorList(rsDF, i),
  angle=60,
  main = "3D barplot")
#添加y坐标 https://www.jb51.cc/css/217864.html
dims <- par("usr");#dims
x <- dims[1]+ 0.9*diff(dims[1:2])
y <- dims[3]+ 0.08*diff(dims[3:4])
text(x,y,expression(paste(log[2]*'XXX') ),srt=45)












2. rgl:这个可以实现用鼠标对图像进行旋转，从不同的视角看图像。
#install.packages("rgl")
library(rgl)
attach(mtcars)
plot3d(wt,disp,mpg,col="red",size=5) #更多色彩 col=rainbow(12)
detach(mtcars)

attach(dat)
plot3d(x,y,z)
detach(dat)
缺点是不好看，不好控制。







3.如何利用R语言画出三维动画图
http://blog.csdn.net/chen790646223/article/details/45483275




========================================
|-- plotly包：让ggplot2的静态图片变得可交互(基于svg)
----------------------------------------

1. 简介

Plotly 是个交互式可视化的第三方库，官网提供了Python，R，Matlab,JavaScript，Excel的接口，因此我们可以很方便地在这些软件中调用Plotly，从而实现交互式的可视化绘图。

plotly支持facet，不过当facet的图形超过9个以后，legend处会出现bug。


Plotly's R graphing library makes interactive, publication-quality graphs. Examples of how to make line plots, scatter plots, area charts, bar charts, error bars, box plots, histograms, heatmaps, subplots, multiple-axes, and 3D (WebGL based) charts.

官网: https://plotly.com/r/
文档: https://plotly.com/r/reference/

也可以用于python: https://plotly.com/python/




2. 例子
# 安装包
## install.packages("plotly")

# 运行时会自动载入ggplot2包
library(plotly)
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
p <- plot_ly(d, x = ~carat, y = ~price, color = ~carat,
        size = ~carat, text = ~paste("Clarity: ", clarity),
        type = "scatter", mode = "markers")
print(p) #鼠标悬浮可显示提示
#embed_notebook(p) #显示到jupyter notebook




ref:
https://zhuanlan.zhihu.com/p/24917856




========================================
|-- image 和 barplot 的组合
----------------------------------------

1. 实例：左边是热图，右侧是条形图。

par(mfrow = c(1, 2)) #1行2列

# c(bottom, left, top, right)
par(mar = c(1, 5, 3, 0), las = 1, ann = F)
set.seed(1)
image(x=1:100, y=1:20,  z= scale(  matrix(sample(1:2000), ncol = 20) ), 
      xaxt = "n", yaxt = "n", #不要坐标轴
      axes = FALSE)
axis(side = 2, at = 1:20, 
     labels = paste("gene", seq(1:20), sep = "") , 
     tick = F, 
     col.ticks ="red", #刻度线颜色
     col="blue", #轴线颜色
     mgp=c(1,0.3,0), #刻度标签和图的距离
     lwd=5)

par(mar = c(1, 0.5, 3, 3))
barplot(1:20,  horiz = T, 
        ylim = c(0.1, 20.1), 
        yaxs = "i", 
        width = 0.8, 
        space = 0.25, 
        xaxt = "n", border = NA)

需要注意barplot 中space 函数的应用，space 的值为柱子宽度的百分比；
通过ylim 展示y轴的一部分；





========================================
|-- dendrogram 和 barplot 的组合
----------------------------------------
1. 实例 
左边是树，右边是 barplot。中间是共同的文字

data <- mtcars[1:10, ]
hc  <- hclust(dist(data))
hcd <- as.dendrogram(hc)
plot(hc)
plot(hcd)


par(mfrow = c(1, 2))

par(mar = c(1,1 , 1, 0))
plot(hcd, horiz = T, yaxs = "i", axes = F, leaflab = "none") # 左边的树

sep <- 5 * max(strwidth(rownames(data), units = "inches")) + 1.2
par(mar = c(1, sep , 1, 1), adj = 0.5, mgp = c(3, sep / 2, 0), las = 1)
b <- barplot(1:10,  horiz = T,  
             ylim = c(0.1, 10.1), 
             yaxs = "i", 
             width = 0.8, space = 0.25,  # space 调节距离
             xaxt = "n", border = NA)

# 中间的文字
axis(side = 2, at = b, rownames(data), 
     line = NA, tcl = FALSE, lwd = 0, hadj = 0.5, padj = 0.5)





========================================
|-- 实现分面效果：使用sapply(data, fn)
----------------------------------------

1. 例: 3行1列, 每个图是 hist+density
par(mfrow = c(3,1), mar = c(2,1,2,1), oma = c(2,3,0,0))
sapply(levels(iris$Species), function(f) {
  hist(iris$Sepal.Length[iris$Species == f], main = f, xlab = "", n=25, xlim=c(4,8) )
  par(new=T)
  plot(density(iris$Sepal.Length[iris$Species == f], n=50), xlim=c(4,8), 
       lwd=5,col='#FF000066', ann=F, axes=F )
  #lines(density(iris$Sepal.Length[iris$Species==f], n=50), xlim=c(4,8), col='green')
})
mtext(side = 1, outer = T, line = 1, "Sepal.Length", cex = 0.8) #x标签
mtext(side = 2, outer = T, line = 2, "Freq", cex = 0.8) #y标签






========================================
|-- 散点图：连续性变量到渐变色的映射（使用cut函数）
----------------------------------------
1. 基本原理 
ref: http://biomooc.dawneve.cc/R/R-color.html#2_4

cut函数: 把数值型转为因子型
#cut(x, breaks): Convert Numeric to Factor

# 生成数据
set.seed(20211119)
dat_1=rnorm(100, 0, 1)

# 测试 cut 函数
total_bins=10 #定义渐变色的阶梯数，也是数据划分的组数
dat_2=cut(dat_1, breaks=total_bins) #可以传入整数，表示分成几份；或者传入截断点数组
#table(dat_2) #total_bins=5时的结果
# (-1.87,-0.935] (-0.935,-0.0025]   (-0.0025,0.93]      (0.93,1.86]       (1.86,2.8] 
#       18               26               37               15                4 






2. 基本示例
#options(repr.plot.width=4, repr.plot.height=4)

dat=iris$Sepal.Length

# 生成100个颜色
#colors2=colorRampPalette(colors = c('navy','white','firebrick3'), interpolate ="linear")(100 )
colors2=colorRampPalette(colors = c('green4','white','maroon3'), interpolate ="linear")(100 )

# 预览颜色(optional)
barplot(rep(1, length(colors2)), col=colors2, yaxt="n", space=0, border = NA)

# 连续型变量dat和颜色colors2的映射：cut把dat分成100个区间，每个level对应一个颜色；每一份变成一个区间因子，
plotcol <- colors2[ cut( dat, breaks=100) ]; plotcol[1:10]

# 主图
#pdf("01.pdf", width=3.5, height=2.8)
#png("01.png", width=3.5*72, height=2.8*72, res=72)
par( mar=c(3,3,1,4) )
plot(dat, col=plotcol, pch=19, cex=0.5, mgp=c(2,1,0) )

# 画图例
par(mar=c(0,0,0,0), fig=c(0.82,0.87, 0.3,0.8), new=T )
barplot( rep(1, length(colors2)), col=colors2, 
         border=NA, space=0, horiz =T,
         ann=F, axes=F)
# 图例上的编号怎么能和整数靠拢?
axis(side=4, at=seq(0,100,20), labels=seq( min(dat), max(dat), (max(dat)-min(dat))/5 ), tcl=-0.1, # 刻度长度
     #padj=-1.5, # 刻度值距离
     mgp=c(2,0.5,0),
     las=2)
#dev.off()


3. 更多示例 
散点图: 连续型变量到渐变色的映射(cut函数)(原生)
http://tool.dawneve.cc/R_scripts/index.html#t7_2








========================================
R 绘图的输出: 完整格式和省略格式、单位换算
----------------------------------------

https://github.com/rstudio/rmarkdown/issues/2261


# Knitr will open a png device using the size provided
grDevices::png(filename = plot_file,
               width = 2.2,
               height = 1,
               units = "in",
               res = 72)







========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


