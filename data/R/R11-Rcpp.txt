Rcpp 的难点是 C++

C++ 很繁杂，可以说是最艰巨的计算机方向了。


https://cran.r-project.org/doc/manuals/r-devel/R-exts.html
https://dirk.eddelbuettel.com/papers/useR2019_rcpp_tutorial.pdf
https://teuder.github.io/rcpp4everyone_en/100_matrix.html  在线电子书资源



========================================
R 调用 C 语言：Rcpp包等
----------------------------------------

1. 先找资料

(1).Rcpp 简明入门
https://cosx.org/2013/12/rcpp-introduction/

Rcpp4everyone: https://teuder.github.io/rcpp4everyone_en/070_data_types.html


(2).R语言与C语言混合编程——R语言中调用C语言函数（Windows+RStudio）
https://blog.csdn.net/qq_37395039/article/details/104706452


(3)Sparse Model Matrix Optimizations in C++
Using Rcpp to decrease memory usage and increase throughput.
https://jeffreycwong.com/posts/2021-04-10-sparse-model-matrix-optimizations-in-c/




2. Rcpp包写c++代码的方式和效率对比
https://blog.rstudio.com/2018/10/11/rstudio-1-2-preview-cpp/


(1) 直接混合书写C++代码和R代码

# c 版的函数
library(Rcpp)
cppFunction(
    'int fib_cpp_0(int n){
         if(n==1||n==2) return 1;
         return(fib_cpp_0(n-1)+fib_cpp_0(n-2));
    }'
)

# R 版的函数
fib_r <- function(n){
    if(n==1||n==2) return(1)
    return(fib_r(n-1)+fib_r(n-2))
}


> system.time(fib_r(30))
   user  system elapsed 
  0.448   0.027   0.475 
> system.time(fib_cpp_0(30))
   user  system elapsed 
  0.002   0.000   0.002 
#
我们可以发现，fib_cpp_0比fib_r快得多了。

虽然如此，我觉得这个比较没有什么意思，原因在于这个对比中没有体现 R 向量化运算的优势。不过考虑到相当多的人在写 R 的代码时根本不考虑向量化（我忏悔，我就是其中之一），Rcpp 还真的能解决很多效率问题。





(2) 单独文件写C++代码，然后在R中调用(sourceCpp，类似 R 里面的 source功能)

$ cat func1.cpp 
#include <Rcpp.h>
using namespace Rcpp;

//[[Rcpp::export]]
int fib_cpp_1(int n)
{
    if(n==1||n==2) return 1;
    return fib_cpp_1(n-1)+fib_cpp_1(n-2);
}


# 在 R 中
> library("Rcpp")
> sourceCpp("func1.cpp") #在Rstudio的Environment可见函数名 fib_cpp_1，可见文件名不重要。
> system.time(fib_cpp_1(30))
   user  system elapsed 
  0.001   0.001   0.002
#

在上面可以看出用sourceCpp生成的函数fib_cpp_1在计算速度上，
和用cppFunction生成的fib_cpp_0差不多。




(3) cppFunction和sourceCpp的本质是什么？

我们来回忆一下在没有 Rcpp 之前我们是如何调用 C/C++ 的。在那个年代，我们会先写出 C/C++ 的代码，然后用R CMD SHLIB生成一个动态链接库，然后再用dyn.load载入这个动态链接库。最后用.Call(或者. C，当然这个太老了），调用库中的函数。

然后我们直接输入fib_cpp_1看看它们的庐山真面目：
> fib_cpp_0
function (n) 
.Call(<pointer: 0x7f482d4f84b0>, n)
<bytecode: 0x1c002f70>

> fib_cpp_1
function (n) 
.Call(<pointer: 0x7f482d7074b0>, n)
<bytecode: 0x1bffb680>

可见，通过cppFunction和sourceCpp得到的这个函数，本质上还是用.Call调用动态链接库中编译好的 C++ 函数。
只不过 Rcpp 帮你把一些麻烦的步骤省略下来了。




(4) Rcpp 包终极参考资料
https://adv-r.hadley.nz/rcpp.html
Scalar input and scalar output
Vector input and scalar output
Vector input and vector output
Matrix input and vector output

前者里面有很多基础操作的代码，包括：向量->向量；向量->矩阵；标量->矩阵等等，里面都有示例函数及相关代码，复制到自己的cpp文件中运行并理解就很容易上手。



https://gallery.rcpp.org/
后者相当于一个搜索库，要使用Rcpp进行矩阵运算、并行计算、常用算法等操作，直接在里面进行搜索，就可以看到大神写的一些相应代码，同时知道该调用哪些库中的函数。




(5) 矩阵计算 

利用RcppEigen进行矩阵运算
https://blog.csdn.net/weixin_41929524/article/details/81978734







========================================
|-- R 作者不建议使用 C++，原生代码建议使用C
----------------------------------------
https://blog.r-project.org/2019/03/28/use-of-c-in-packages/index.html

A summary of the recommendation would be: don’t use C++ to interface with R. If you need to implement some computation in native code, use C (or perhaps Fortran), not C++, or completely avoid interacting with the R runtime (e.g.  .C or .Fortran interfaces are fine, indeed, many external libraries are written in C++).

不用用C++和R交互。
如果需要实现一些原生代码，用C或者 Fortran，而不是C++。

避免和R运行时交互。.C or .Fortran 接口可以，实际上，很多外部库是C++写的。



主要是担心内存泄漏：
	https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Memory-allocation

但是该文档又有C/C++的支持描述：
1.6.4 Portable C and C++ code

C++ standards: 
	From version 3.6.0 (3.6.2 on Windows), R defaulted to C++11 where available98; 
	from R 4.1.0 to C++14 and from R 4.3.0 to C++17 (where available). 
	However, in earlier versions the default standard was that of the compiler used, often C++98 or C++14, and the default is likely to change in future. 
	For maximal portability a package should either specify a standard (see Using C++ code) or be tested under all of C++11, C++98, C++14 and C++17. (Specifying C++14 or later will limit portability.)
	
	Note that the ‘TR1’ C++ extensions are not part of any of these standards and the <tr1/name> headers are not supplied by some of the compilers used for R, including on macOS. (Use the C++11 versions instead.)




========================================
不用包，R 原生调用C/C++ 的三种方式
----------------------------------------
The following functions provide a standard interface to compiled code that has been linked into R: 
 .C 
 .Call
 .External



https://jbhender.github.io/Stats506/F17/Using_C_Cpp.html




========================================
|-- 1. 使用 .C 接口 
----------------------------------------
http://dept.stat.lsa.umich.edu/~yizwang/software/maxLinear/noteonR.html
http://users.stat.umn.edu/~geyer/rc/
https://github.com/cjgeyer/foo

(1) 主要包括四步

1) 写c/c++代码

How to obtain returned values from C functions?

The C functions should have no return value. To return some values from a C function to R, one should set an argument as the value passer. Recall that in the C functions to be called by R, all the arguments are pointers. Therefore, the C functions should assign the to-be-returned value(s) to the value(s) pointed by this value-passer pointer.
大概就是说，C中要使用指针接收和返回数据。


# 先写好代码
$ cat func2.c
#include<stdio.h>
void add(int* x, int* y){
	*x = *x + *y;
}
int main(){
	int a=1, b=2, a0;
	a0=a;
	add(&a,&b);
	printf("Hello R, from C, %d+%d=%d\n", a0, b, a);
    return 0;
}

$ gcc func2.c -o func2.out
$ ./func2.out
Hello R, from C, 1+2=3


2) 编译写好的c/c++代码为 a shared library (.dll in Windows and .so (.o) in linux)
win下安装 Rtools、mingw并配置环境; linux下不需要。

## 在RStudio中运行
setwd("/data/wangjl/test/testR/learnR/") #设置c文件的路径
system("R CMD SHLIB massdistnew.c") #编译c文件

## 或者直接在shell下编译
$ R CMD SHLIB func2.c

输出2个文件
-rwxr-xr-x 1 wangjl wangjl  11K Jul  5 11:26 func2.so
-rw-r--r-- 1 wangjl wangjl 7.6K Jul  5 11:26 func2.o


3) load the shared library by dyn.load("LIBNAME"), 在R中载入.dll文件(win)/.so(linux), 
> dyn.load('/data/wangjl/test/testR/learnR/func2.so')

4) 调用C文件的函数
call the compiled C function by .C("FUNNAME",...). 
Here LIBNAME is the name of the shared library file and FUNNAME is the name of the C function.

# y = .C("massdisttest", x = as.double(xtrunc), xmass = as.double(tau[trunc]/sum(tau[trunc])), nx = nx, xlo = as.double(lo), xhi = as.double(up),y = double(2 * n), ny = as.integer(n))$y

> y = .C("add", a=as.integer(100), b=as.integer(123) )$a
> y #223




(2) R包装函数
R Wrapper Functions
It is considered user-friendly to wrap the call to .C in an R function.
为了方便使用R风格的代码，把.C包装到R函数中。


例子2: 求一个数组的平方。
$ cat foo.c
void foo(int *nin, double *x)
{
	int n = nin[0], i;
	for (i=0; i<n; i++)
	x[i] = x[i] * x[i];
}

$ R CMD SHLIB foo.c

在R中载入
> dyn.load('foo.so')

## 测试1
> .C("foo", n=as.integer(3), x=as.double(c(1,2,3)))
$n
[1] 3

$x
[1] 1 4 9

## 测试2
> arr=rnorm(5); print(arr); .C("foo", n=as.integer(5), x=as.double(arr))
[1] -0.4847097 -1.2398497 -0.5159316 -0.1128015 -0.3207237
$n
[1] 5

$x
[1] 0.23494350 1.53722723 0.26618537 0.01272419 0.10286372



# 写个R包装函数
foo <- function(x) {
	   if (!is.numeric(x)){ stop("argument x must be numeric") }
	   out <- .C("foo",
			   n=as.integer(length(x)),
			   x=as.double(x))
	   return(out$x)
}

> foo(c(1,2,3))
[1] 1 4 9


包装函数有三个好处: 在R中做错误检测、可在R中准备某些参数、只返回需要的部分。
This has three benefits
- It allows some error checking in R, where it is easier than in C.
- It allows some arguments (like n here) to be calculated so they don't have to be supplied by the user.
- It allows you to return only what the user needs.





(3) 怎么在C中使用R的函数呢？(进一步的，怎么直接引用R低层引用的C函数呢？)
例子3: Using R Random Number Generators in C

$ cat baz.c
#include <R.h>
#include <Rmath.h>

void baz(int *nin, double *sin, double *tin, double *x)
{
    int n = nin[0];
    double s = sin[0];
    double t = tin[0];

    int i;

    GetRNGstate();

    for (i = 0; i < n; i++)
        x[i] = rbeta(s, t);

    PutRNGstate();
}

注意C代码中的如下两行，他们之间的部分代码像是在R中一样运行。
	GetRNGstate();
	PutRNGstate();
must be done before and after (respectively) all calls to random number functions (in this example rbeta). With that done, the random numbers work in C just like in R.


$ R CMD SHLIB baz.c

在R中载入
set.seed(42)
rbeta(5, 1.5, 2.5) #[1] 0.2311371 0.4824677 0.5662345 0.4951170 0.3454934
#
dyn.load("baz.so")
baz <- function(n, s, t) {
    .C("baz", n = as.integer(n), s = as.double(s), t = as.double(t),
        x = double(n))$x
}
set.seed(42)
baz(5, 1.5, 2.5) #[1] 0.2311371 0.4824677 0.5662345 0.4951170 0.3454934

输出结果一样。
经过测试，只支持函数，语法是不支持的：比如必须分号结尾，不能使用<-代替=。
怎么在C中调用C的 rbeta 函数呢？就是R函数低层调用的C函数？不知道，可能要读源码了。
> rbeta
function (n, shape1, shape2, ncp = 0) 
{
    if (missing(ncp)) 
        .Call(C_rbeta, n, shape1, shape2)
    else {
        X <- rchisq(n, 2 * shape1, ncp = ncp)
        X/(X + rchisq(n, 2 * shape2))
    }
}
<bytecode: 0x3dac2a8>
<environment: namespace:stats>

这个函数在哪里？ .Call(C_rbeta
$ which R
/usr/bin/R


如果R安装到这里：
/APPS/src/R-2.6.2
则所需要的函数可能在这里:
/APPS/src/R-2.6.2/src/nmath/rbeta.c
如果移动过位置，就不好找了，那么重新下载一个函数吧: https://cran.r-project.org/






(4) 处理来自C语言的错误
Error Messages from C
Use the R error or warning function. They work just like printf but produce an R error or warning as the case may be. Here is an example (downloadable as qux.c).

$ cat qux.c
#include <R.h>
void qux(int *nin, double *x)
{
    int n = nin[0];
    int i;

    if (n < 1)
        error("arg n was %d, must be positive\n", n);

    for (i = 0; i < n; i++)
        x[i] = x[i] * x[i];
}
$ R CMD SHLIB qux.c

在R中: 
> dyn.load("qux.so")
> .C("qux", n = as.integer(4), x = as.double(1:4))
$n
[1] 4

$x
[1]  1  4  9 16
> .C("qux", n = as.integer(0), x = as.double(1:4)) #故意报错
Error: arg n was 0, must be positive






(5) 再给出2个例子 Using .C
I. Calling C with an integer vector

/* useC1.c */
void useC(int *i) {
	i[0] = 11;
}

函数只能是void类型，不能有返回值。返回值只能通过自己的参数传递。
The C function should be of type void.
The compiled code should not return anything except through its arguments.

$ R CMD SHLIB useC1.c

## 在R中 
> dyn.load("useC1.so")
> .C("useC", n = as.integer(1:4))
$n
[1] 11  2  3  4


在C中要为传入的参数设置正确的长度。
.C()函数的第一个参数是C函数名。
其余的是传入C函数的R对象。所有参数必须强制转为正确的R存储格式，防止出错。
.C()函数返回一个list对象。

总结：没有新东西，不过数组本质上是指针。




II. Calling C with different vector types

/* useC2.c */
void useC2(int *i, double *d, char **c, int *l) {
	i[0] = 11;
	d[0] = 2.333;
	c[1] = "g";
	l[0] = 0;
}

$ R CMD SHLIB useC2.c

注: To compile more than one c file:
R CMD SHLIB file1.c file2.c file3.c
to get file1.so 编译多个的C文件，输出名字就是第一个文件的名字。

## 在R中 
> dyn.load("useC2.so")
> .C("useC2", a = as.integer(1:4), b=as.double(3.1415926), 
		c=as.character( c("this", "is", "a string") ), d=c(T, F) )
$a
[1] 11  2  3  4

$b
[1] 2.333

$c
[1] "this"     "g"        "a string"

$d
[1] FALSE FALSE

不用管C的形式参数名字，传入相同类型的实参即可。
其他R对象也能传入.C()，但是最好使用其他接口。

- 在.C()中，R对象在传递给C前先复制一份，在编译后的C代码返回时再拷贝一份给R。
- 而.Call() 和 .External() 接口都不复制他们的参数。
- 你应该把通过接口传入的参数当作只读的。




========================================
|-- dll 文件及dyn.load()载入：测试C函数是否可用
----------------------------------------
1. 查看文档 
> help("dyn.load")
	Foreign Function Interface
	Description
	Load or unload DLLs (also known as shared objects), and test whether a C function or Fortran subroutine is available.

	Usage
	dyn.load(x, local = TRUE, now = TRUE, ...)
	dyn.unload(x)

	is.loaded(symbol, PACKAGE = "", type = "")





2. 已经载入的 dll 文件
(1) 整体列表和数量
> ?getLoadedDLLs
Get DLLs Loaded in Current Session
Description
This function provides a way to get a list of all the DLLs (see dyn.load) that are currently loaded in the R session.

> getLoadedDLLs() #输出太多
> getLoadedDLLs() |> head(n=5) #输出前5行
                                                      Filename Dynamic.Lookup
base                                                      base          FALSE
methods       /usr/local/lib/R/library/methods/libs/methods.so          FALSE
utils             /usr/local/lib/R/library/utils/libs/utils.so          FALSE
grDevices /usr/local/lib/R/library/grDevices/libs/grDevices.so          FALSE
graphics    /usr/local/lib/R/library/graphics/libs/graphics.so          FALSE

> getLoadedDLLs() |> length()
[1] 93



(2) 具体的dll条目
> getLoadedDLLs()[5] |> str()
List of 1
 $ graphics:List of 5
  ..$ name         : chr "graphics"
  ..$ path         : chr "/usr/local/lib/R/library/graphics/libs/graphics.so"
  ..$ dynamicLookup: logi FALSE
  ..$ handle       :Class 'DLLHandle' <externalptr> 
  ..$ info         :Class 'DLLInfoReference' <externalptr> 
  ..- attr(*, "class")= chr "DLLInfo"
 - attr(*, "class")= chr "DLLInfoList"

> getLoadedDLLs()[2] |> str()
List of 1
 $ methods:List of 5
  ..$ name         : chr "methods"
  ..$ path         : chr "/usr/local/lib/R/library/methods/libs/methods.so"
  ..$ dynamicLookup: logi FALSE
  ..$ handle       :Class 'DLLHandle' <externalptr> 
  ..$ info         :Class 'DLLInfoReference' <externalptr> 
  ..- attr(*, "class")= chr "DLLInfo"
 - attr(*, "class")= chr "DLLInfoList"

> getLoadedDLLs()[16]
                                            Filename Dynamic.Lookup
Rcpp /usr/local/lib/R/site-library/Rcpp/libs/Rcpp.so           TRUE
> getLoadedDLLs()[16] |> str()
List of 1
 $ Rcpp:List of 5
  ..$ name         : chr "Rcpp"
  ..$ path         : chr "/usr/local/lib/R/site-library/Rcpp/libs/Rcpp.so"
  ..$ dynamicLookup: logi TRUE
  ..$ handle       :Class 'DLLHandle' <externalptr> 
  ..$ info         :Class 'DLLInfoReference' <externalptr> 
  ..- attr(*, "class")= chr "DLLInfo"
 - attr(*, "class")= chr "DLLInfoList"





3. 如果载入的dll文件达到最大值报错怎么办？
修改 ~/.Renviron file 增加dll上限：
R_MAX_NUM_DLLS=150


ref: https://r.acidgenomics.com/packages/pointillism/




========================================
|-- 2. .Call 是更高级的调用接口 
----------------------------------------

1. .Call() 接口简介
https://www.r-bloggers.com/2012/11/using-r-callhello/


(1) .Call() 和 .C() 的区别

.C()
	allows you to write simple C code that knows nothing about R | 无须知道R及其头文件，就可以写C语言;
	only simple data types can be passed
	all argument type conversion and checking must be done in R
	all memory allocation must be done in R
	all arguments are copied locally before being passed to the C function (memory bloat)

.Call()
	allows you to write simple R code | 一般需要加载 Rxx.h 头文件
	allows for complex data types 
	allows for a C function return value
	allows C function to allocate memory
	does not require wasteful argument copying | 参数传递不用耗时的复制
	requires much more knowledge of R internals | 需要知道R的内部细节
	is the recommended, modern approach for serious C programmers | 推荐，现代、严肃的C程序员使用

To allow readers to compare for themselves how difficult or easy it is to switch from .C() to .Call() we will re-implement our three “Hello World!” examples using the .Call() interface.


https://github.com/cjgeyer/qux/blob/master/package/qux/src/qux.c

逐条总结一下.Call() 接口的优缺点（相对于 .C()）：
- 需要对 R 的头文件有足够的了解; 而 .C() 只需要会C语言;
- 能传递复杂参数; 而 .C() 只能传递简单参数;
- 能返回值了；而 .C() 不能返回值，只能依靠指针传递计算结果;
- 没那么多复制了: 传递R参数给C时不复制数据;
- 在C代码中对答案进行维度划分的能力
- 获取其他类型。Access to other types, e.g. expressions, raw type and the ability to easily execute R code (call_R is a pain).
- 能获取vector的name属性等。Access to the attributes of the vectors, for example the names.
- 容易处理缺失值。The ability to handle missing values easily。



.Call 比 .C 接口更复杂，功能更全面。
.Call 需要一些安装标准R的时候安装过的头文件，以便访问一个新数据类型 SEXP。
如下代码展示用法:

The .Call interface is the more fully featured and complex cousin of the .C interface. Unlike .C, .Call requires header files that come standard with every R installation. These header files provide access to a new data type, SEXP. 
The following code, stored in the file, doubler2.c, illustrates its use.



(2) R 调用C的接口教程:

Calling C code from R (Sigal Blay, 2004) * http://www.sfu.ca/~sblay/R-C-interface.ppt
Calling other languages from R (R.M. Ripley, 2009) * http://www.stat.purdue.edu/~liu105/STAT598G_lab/Rcourse94up.pdf
R API cheat sheet (Simon Urbanek, 2012) * http://tolstoy.newcastle.edu.au/R/e17/devel/att-0724/R_API_cheat_sheet.pdf


(3) 认识 SEXP

We’ll get the definition of SEXP and everything else we need by including both R.h and Rdefines.h in our code.  

An SEXP (or S-Expression Pointer) is used for everything
(An older C trick approximating object-oriented programming)

We can ignore the details but retain that
	• everything in R is a SEXP
	• the SEXP is self-describing
	• can matrix, vector, list, function, …
	• 27 types in total

The key thing for Rcpp is that via C++ features we can map
	• each of the (limited number of ) SEXP types
	• to a specific C++ class representing that type
	• and the conversion is automated back and forth


Key Features
	• (Fairly) Easy to learn: as it really does not have to be that complicated – there are numerous examples
		相对好学，例子多。
	• Easy to use: as it avoids build and OS system complexities thanks to the R infrastrucure
		易用。建立在R之上，消除了操作系统的复杂性。
	• Expressive: as it allows for vectorised C++ using Rcpp Sugar
		表达性强: 可以使用 Rcpp语法糖实现 向量化 C++
	• Seamless access to all R objects: vector, matrix, list, S3/S4/RefClass, Environment, Function, …
		可以无缝访问R对象: vector, matrix, list, S3/S4/RefClass, Environment, Function, …
	• Speed gains for a variety of tasks Rcpp excels precisely where R struggles: loops, function calls, …
		速度快: R 慢的地方都可以使用 Rcpp: 循环、函数等
	• Extensions greatly facilitates access to external libraries directly or via eg Rcpp modules
		扩展性强: 可以访问外部 cpp 库。










2. 实战操作

(1) 也是四个步骤

1) 写 c 代码 

$ cat doubler2.c
#include <R.h>
#include <Rdefines.h>
SEXP double_me2(SEXP x) {
  // Doubles the value of the first integer element of the SEXP input
  SEXP result;
  PROTECT(result = NEW_INTEGER(1)); // i.e., a scalar quantity
  INTEGER(result)[0] = INTEGER(x)[0] * 2;
  UNPROTECT(1); // Release the one item that was protected
  return result;
}


和 .C 不一样，double_me2 函数有返回值。

Unlike our experience with the .C interface, double_me2 is a function and does return a value. While that appeals to intuition, no matter what the native input and output types, they must now live in a SEXP object. To code double_me2, you must know that there’s an integer in the input x, and extract it as if it were the first item in a C array. For the return value, you must add your integer result to a SEXP object in an equally unnatural way. The PROTECT function must be used to prevent R’s automatic garbage collection from destroying all the objects.


2) 编译 
$ R CMD SHLIB doubler2.c
我遇到报错了，找不到 r.h, 要大写R.h 


3) 在R中引用和调用
> setwd("/data/wangjl/test/testR/learnR")
> dyn.load("doubler2.so")
> .Call("double_me2", as.integer(5))
[1] 10







(2) 探索一下头文件

## on CentOS
$ R RHOME
/usr/lib64/R

$ ls -1 `R RHOME`/include
Rconfig.h
Rdefines.h
Rembedded.h
R_ext
R.h
Rinterface.h
Rinternals.h
Rmath.h
Rversion.h
S.h

# on Ubuntu
$ sudo find /usr/ | grep -P "Rinterface" --color=auto 2>/dev/null
/usr/share/R/include/Rinterface.h
$ ls /usr/share/R/include
Rconfig.h  Rdefines.h  Rembedded.h  R_ext  R.h  Rinterface.h  Rinternals.h  Rmath.h  Rversion.h  S.h


解释 Here’s what they contain:
- Rconfig.h	various configuration flags
- Rdefines.h	lots of macros of interest, includes Rinternals.h
- Rembedded.h	function declarations for embedding R in C programs
- R_ext	directory of include files for specific data types, etc.
- R.h	includes all the files found in R_ext
- Rinterface.h	provides hooks for external GUIs
- Rinternals.h	core R data structures R核心数据类型
- Rmath.h	math constants and function declarations
- Rversion.h	version string components
- S.h	macros for S/R compatibility

With the .Call() interface, the C function needs to be of type SEXP — a pointer to a SEXPREC or Simple EXPression RECord.  We’ll get the definition of SEXP and everything else we need by including both R.h and Rdefines.h in our code.  So here is the C code for our first, brain dead C function — helloA1.c:

$ cat helloA1.c
#include <R.h>
#include <Rdefines.h>
#include <stdio.h>
SEXP helloA1() {
  printf("Hello World!\n");
  return(R_NilValue);
}

函数返回值类型是 SEXP，参数也是该类型。C代码决定着从其他类型转为或转出 SEXP 类型。
Note that, even though we are returning R_NilValue (aka NULL), the function is declared to be of type SEXP.  The function will always be of type SEXP, as will any arguments.  It will be up to the C code to convert other data types into and out of SEXP.  

$ R CMD SHLIB helloA1.c

## 在R中写 包装函数 
# wrapper function to invoke helloA1
dyn.load("helloA1.so")
helloA1 <- function() {
  result <- .Call("helloA1")
}

> greeting <- helloA1()
Hello World!
> class(greeting)
[1] "NULL"

是不是感觉很复杂？这是有价值的，继续看。






(3) 防止垃圾回收 PROTECT against garbage collection

R会自动回收垃圾，这是很有用的。
为了防止C的数据被回收，需要标记一下，就是函数 PROTECT 和 UNPROTECT。

新版本的 hello world，为R字符串向量分配空间，把问候语分配给第一个元素，然后返回该向量。

$ cat hello3.c 
#include <R.h>
#include <Rdefines.h>
SEXP helloB1() {
  SEXP result;
  PROTECT(result = NEW_CHARACTER(1));
  SET_STRING_ELT(result, 0, mkChar("Hello World!"));
  UNPROTECT(1);
  return(result);
}

为一个字符串向量分配内存使用的是 NEW_CHARACTER(长度)。
我们该看看R包含的头文件中这一类的宏是怎么定义的。
Note that we allocate memory for a character vector of length # with NEW_CHARACTER(#).  It is worth taking a look in the R include files to see how this and similar macros are defined:

$ R RHOME
/usr/share/R

$ grep NEW_ /usr/lib/R/include/*.h
$ grep NEW_ /usr/share/R/include/*.h
/usr/share/R/include/Rdefines.h:#define NEW_LOGICAL(n)		Rf_allocVector(LGLSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_INTEGER(n)		Rf_allocVector(INTSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_NUMERIC(n)		Rf_allocVector(REALSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_CHARACTER(n)	Rf_allocVector(STRSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_COMPLEX(n)		Rf_allocVector(CPLXSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_LIST(n)		Rf_allocVector(VECSXP,n)
/usr/share/R/include/Rdefines.h:#define NEW_STRING(n)		NEW_CHARACTER(n)
/usr/share/R/include/Rdefines.h:#define NEW_RAW(n)		Rf_allocVector(RAWSXP,n)
/usr/share/R/include/Rdefines.h:/* NEW_OBJECT is recommended; NEW is for green book compatibility */
/usr/share/R/include/Rdefines.h:#define NEW_OBJECT(class_def)	R_do_new_object(class_def)


看到 NEW_CHARACTER(1) 低层使用的其实是 Rf_allocVector(STRSXP,1)，能看到很多R源码中的老名字。
So we could have used allocVector(STRSXP,1) instead of NEW_CHARACTER(1) and you will see plenty of the former in R source code and packages.   

类似的，我们可以使用 grep 查找关键词 “_ELT” 或 “mkChar”。
Similarly you can grep for “_ELT” or “mkChar” and learn about those.  

这并不是信息的最终源码，我们将围绕代码实例google，检查R包含文件，甚至检查 R-devel 邮件列表，来对获取可以让C代码和R对象共用的方法。
There really isn’t any definitive source for information and you will have to get comfortable googling, poking around source code examples, examining the R include files and even checking the R-devel mailing list to get a sense of the R functions that are available for getting C code to work with R objects.  

我推荐多花时间看看 Rinternals.h 和 Rdefines.h。
I would recommend spending some time with Rinternals.h and Rdefines.h.


## 编译
$ R CMD SHLIB hello3.c

在R中 
dyn.load("hello3.so")
helloB1  <- function() {
  result <- .Call("helloB1")
  return(result)
}
helloB1 () #[1] "Hello World!"

终于看到返回值了。不过感觉还是过于复杂化了。
复杂-收益总是平衡的，接着看例子。








(4) 在头文件中做类型映射 Casting about in the R header files

如标题所说，在C代码做的事情越来越多，你很可能需要把字符串类型转为 SEXP 对象，SEXP对象转为 整数等等。
The title of this section really says it all.  As you start to do more in your C code you will need to learn how to cast character strings into SEXP objects, SEXP objects into integers, etc. etc.  

要想成为专家，还有有限、但大量的知识点。
There is a finite, but large, amount to know before you become expert.  

这个资料的“习惯使用SEXP”一节中的两个链接的例子很好。
The two links in the “Getting used to SEXP” section above have excellent examples as does Programming with Data: Using and Extending R by Dirk Eddelbuettel.
http://dirk.eddelbuettel.com/papers/uofc_acm_feb2010.pdf



接下来是最后一个 hello world 例子，用来计数问候语的字符长度。
Here is our last “Hello World!” example, the one that counts the characters in incoming greetings.  

本例演示 Rdefines.h 中定义的R 宏是怎么从vector 中抽取元素的，vector怎么映射为字符和整数，怎么使用 UNPROTECT 在 PROTECT stack上 去掉已保护的同样数量的元素。
This example shows how R macros defined in Rdefines.h are used to extract elements from a vector, how vector elements are cast into char and int and how you need to UNPROTECT the same number of elements that you placed on the PROTECT stack.


$ cat demo4.c 
#include <R.h>
#include <Rdefines.h>
#include <string.h>
SEXP helloC1(SEXP greeting) {
  int i, vectorLength, stringLength;
  SEXP result;
  PROTECT(greeting = AS_CHARACTER(greeting));
  vectorLength = LENGTH(greeting);
  PROTECT(result = NEW_INTEGER(vectorLength));
  for (i=0; i<vectorLength; i++) {
    stringLength = strlen(CHAR(STRING_ELT(greeting, i)));
    INTEGER(result)[i] = stringLength;
  }
  UNPROTECT(2);
  return(result);
}

$ R CMD SHLIB demo4.c


在R中 
# wrapper function to invoke helloC1 
dyn.load("demo4.so")
helloC1 <- function(greeting) {
  result <- .Call("helloC1", greeting)
  return(result)
}
# source('wrappers.R')
greeting <- c("Hello World!", "Bonjour tout le monde!", "Привет мир!")
helloC1(greeting) #[1] 12 22 20








(5) III. Sending R integer vectors to C (在C中打印传入的整数)
/* useCall1.c */
#include <R.h>
#include <Rdefines.h>
SEXP getInt(SEXP myint, SEXP myintVar) {
	int Imyint, n; // declare an integer variable
	int *Pmyint; // pointer to an integer vector
	PROTECT(myint = AS_INTEGER(myint));


## 解释: 
- Rdefines.h是某种程度上比 Rinternal.h 高级，如果在任何时候想和S语言共享则推荐使用。 
- SEXP 意思是 简单表达式(Simple EXPression)
- myint 是 SEXP 类型的，这是一个泛型类，所以需要转为正确的类型。
- C代码创建的R对象，需要使用 PROTECT 宏把要给指针指向该对象。这告诉R这个对象在使用，不要销毁。

• Rdefines.h is somewhat more higher level then Rinternal.h, and is preferred if the code might be shared with S at any stage.
• SEXP stands for Simple EXPression
• myint is of type SEXP, which is a general type, hence coercion is needed to the right type.
• R objects created in the C code have to be reported using the PROTECT macro on a pointer to the object. This tells R that the object is in use so it is not destroyed.


	Imyint = INTEGER_POINTER(myint)[0];
	Pmyint = INTEGER_POINTER(myint);
	n = INTEGER_VALUE(myintVar);
	printf(" Printed from C: \n");
	printf(" Imyint: %d \n", Imyint);
	printf(" n: %d \n", n);
	printf(" Pmyint[0], Pmyint[1]: %d %d \n", Pmyint[0], Pmyint[1]);
	UNPROTECT(1);
	return(R_NilValue);
}

## 解释:
- 保护机制是基于堆的，所以 UNPROTECT(n) 是不保护最后一个 n 对象。返回前 PROTECT 和 UNPROTECT 必须配对。
- 对于实数，replace int with double and INTEGER with NUMERIC ??

• The protection mechanism is stack based, so UNPROTECT(n) unprotects the last n objects which were protected. The calls to PROTECT and UNPROTECT must balance when the user's code returns.
• to work with real numbers, replace int with double and INTEGER with NUMERIC


$ R CMD SHLIB useCall1.c

## 在R中 
> dyn.load("useCall1.so")
> .Call("getInt", a=c(10,2,3), b=c(4,5) )
NULL
 Printed from C: 
 Imyint: 10 
 n: 4 
 Pmyint[0], Pmyint[1]: 10 2
#




(6) IV. Sending R character vectors to C (在C中为指针分配内存，获取R传入的字符串数组)
/* useCall2.c */
#include <R.h>
#include <Rdefines.h>
SEXP getChar(SEXP mychar) {
	char *Pmychar[5]; // array of 5 pointers
	
	// to character strings
	PROTECT(mychar = AS_CHARACTER(mychar)); 
	
	// allocate memory:
	Pmychar[0] = R_alloc(strlen(CHAR(STRING_ELT(mychar, 0))), sizeof(char));
	Pmychar[1] = R_alloc(strlen(CHAR(STRING_ELT(mychar, 1))), sizeof(char));
	
	// ... and copy mychar to Pmychar:
	strcpy(Pmychar[0], CHAR(STRING_ELT(mychar, 0)));
	strcpy(Pmychar[1], CHAR(STRING_ELT(mychar, 1)));
	
	printf(" Printed from C:");
	printf(" %s %s \n",Pmychar[0],Pmychar[1]);
	UNPROTECT(1);
	
	return(R_NilValue);
}
$ R CMD SHLIB useCall2.c


In R:
> dyn.load("useCall2.so")
> mychar <- c("do","re","mi", "fa", "so")
> out <- .Call("getChar", mychar)
 Printed from C: do re 
> out
NULL





(7) V. Getting an integer vector from C (在R中获取C传来的整数)
/* useCall3.c */
#include <R.h>
#include <Rdefines.h>
SEXP setInt() {
	SEXP myint;
	int *p_myint;
	int len = 5;
	
	// Allocating storage space:
	PROTECT(myint = NEW_INTEGER(len)); 
	
	p_myint = INTEGER_POINTER(myint);
	p_myint[0] = 7;
	
	UNPROTECT(1);
	return myint;
}
// to work with real numbers, replace
// int with double and INTEGER with NUMERIC
$ R CMD SHLIB useCall3.c

In R:
> dyn.load("useCall3.so")
> out<- .Call("setInt")
> out [1] 7 0 0 0 0
[1]        7        0 25514720        0 59062360 
## 为什么我的结果不符合预期? 不全是0? 因为没有初始化，里面的数字是原始内存残留的。






(8) VI. Getting a character vector from C (从C获取字符串)
/* useCall4.c */
#include <R.h>
#include <Rdefines.h>
SEXP setChar() {
	SEXP mychar;
	PROTECT(mychar = allocVector(STRSXP, 5));
	SET_STRING_ELT(mychar, 0, mkChar("A"));
	UNPROTECT(1);
	return mychar;
}
$ R CMD SHLIB useCall4.c

In R:
> dyn.load("useCall4.so")
> out <- .Call("setChar")
> out
[1] "A" ""  ""  ""  "" 

注: 如果把中间改为 SET_STRING_ELT(mychar, 0, mkChar("About"));
则返回一个字符串 "About"





(9) VII. Getting a list from C (从C获取一个字符串)
/* useCall5.c */
#include <R.h>
#include <Rdefines.h>
SEXP setList() {
	int *p_myint, i;
	double *p_double;
	SEXP mydouble, myint, list, list_names;
	char *names[2] = {"integer", "numeric"};
	
	// creating an integer vector:
	PROTECT(myint = NEW_INTEGER(5));
	p_myint = INTEGER_POINTER(myint);
	
	// ... and a vector of real numbers:
	PROTECT(mydouble = NEW_NUMERIC(5));
	p_double = NUMERIC_POINTER(mydouble);
	for(i = 0; i < 5; i++) {
		p_double[i] = 1/(double)(i + 1);
		p_myint[i] = i + 1;
	}

	// Creating a character string vector
	// of the "names" attribute of the
	// objects in out list:
	PROTECT(list_names = allocVector(STRSXP,2));
	for(i = 0; i < 2; i++)
		SET_STRING_ELT(list_names,i,mkChar(names[i])); 

	// Creating a list with 2 vector elements:
	PROTECT(list = allocVector(VECSXP, 2));
	
	// attaching myint vector to list:
	SET_VECTOR_ELT(list, 0, myint);
	
	// attaching mydouble vector to list:
	SET_VECTOR_ELT(list, 1, mydouble);
	
	// and attaching the vector names:
	setAttrib(list, R_NamesSymbol, list_names);
	
	UNPROTECT(4);
	return list;
}

注: SET_VECTOR_ELT stands for Set Vector Element

$ R CMD SHLIB useCall5.c

In R:
> dyn.load("useCall5.so")
> out <- .Call("setList")
> out
$integer
[1] 1 2 3 4 5

$numeric
[1] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000









(n) 更多例子
.Call() 接口在R包中大量使用。

- 更多资料参考: https://cran.r-project.org/doc/manuals/R-exts.html

- Hadley Wickham has written an excellent tutorial on using the .Call() interface.
	http://adv-r.had.co.nz/C-interface.html








========================================
|-- 3. .External 函数 //todo
----------------------------------------


C_selectlist
C_dataviewer
C_optimhess

提供一个指针，指向已经编译好的C代码并执行。上述三个函数的源代码位于R/src/library/utils/src目录下
可以直接在R命令行调用：
.External2(utils:::C_selectlist, choices, preselect, multiple, title) （位于R selectlist函数）
注意如果去掉utils:::就无法找到对象

winDialog("yesno",sprintf(a,sQuote("D:\\用户目录\\Documents/R/win-library/3.1")))
能打开一个yesno的对话框
其实是调用了
.External2(C_winDialog, type, message)














========================================
|-- 4. .C() 与 .Call() 对比与总结
----------------------------------------

(1) 这两个R调用C代码的接口概述如下：
The important differences between the two R interfaces to C code are summarized here:

.C() 简单数据类型
- allows you to write simple C code that knows nothing about R
- only simple data types can be passed
- all argument type conversion and checking must be done in R
- all memory allocation must be done in R
- all arguments are copied locally before being passed to the C function (memory bloat)


.Call() 复杂数据类型
- allows you to write simple R code
- allows for complex data types
- allows for a C function return value
- allows C function to allocate memory
- does not require wasteful argument copying
- requires 【much】 more knowledge of R internals
- is the 【recommended】, modern approach for serious C programmers

To allow readers to compare for themselves how difficult or easy it is to switch from .C() to .Call() we will re-implement our three “Hello World!” examples using the .Call() interface.









########
总结： 

.C() 很简洁，不需要要任何依赖，但是使用指针来获取参数和返回结果。很多项目中使用这个。
.Call() 更繁琐，本质也是指针。需要对R内部结构很了解，是【推荐方法】。
Rcpp 包，大项目中使用有风险，因为依赖很多 macro，在有些案例中会损失精度，但是用户获取不到任何warning/error。

	https://github.com/satijalab/seurat/blob/master/R/RcppExports.R
	ComputeSNN <- function(nn_ranked, prune) {
		.Call('_Seurat_ComputeSNN', PACKAGE = 'Seurat', nn_ranked, prune)
	}
	https://github.com/satijalab/seurat/blob/master/src/RcppExports.cpp
	Rcpp (>= 0.11.0) 也就是说 Seurat 也是依赖 Rcpp包的?



R 高级话题:
https://www.r-bloggers.com/2014/02/three-ways-to-call-cc-from-r/
http://mazamascience.com/WorkingWithData/?p=1099


更多资料 
Calling C code from R (Sigal Blay, 2004) *
	http://www.sfu.ca/~sblay/R-C-interface.ppt
Calling other languages from R (R.M. Ripley, 2009) *
	http://www.stat.purdue.edu/~liu105/STAT598G_lab/Rcourse94up.pdf
R API cheat sheet (Simon Urbanek, 2012) *
	http://tolstoy.newcastle.edu.au/R/e17/devel/att-0724/R_API_cheat_sheet.pdf




========================================
|-- If you are developing an R package: 在R包中调用c++
----------------------------------------
http://dept.stat.lsa.umich.edu/~yizwang/software/maxLinear/noteonR.html
http://dept.stat.lsa.umich.edu/~yizwang/software/maxLinear/AlanRPackageTutorial.pdf

And lastly, tips on creating an R package with compiled code


1. 如果你在开发R包，把 useC.c 复制到 myPackage/src/ 下。
包的用户就不需要手动用dyn.load()加载编译后的c代码了。

所以，把 zzz.R 文件加到myPackage/R 下， 
zzz.R 文件要包含这一句

.First.lib <-function (lib, pkg) {
	library.dynam("myPackage", pkg, lib)
}



2. 修改 .C() 函数：参数列表最后添加 PACKAGE="compiled_file".

比如，编译后的C代码名字是 useC1.so:
.C("useC", b = as.integer(a), PACKAGE="useC1")

如果使用 Makefile ，注意看 R CMD SHLIB myfile.c 的输出，以获得需要合并到 Makefile 中的 flag。
If you are using a Makefile, look at the output from R CMD SHLIB myfile.c for flags that you may need to incorporate in the Makefile. 




3. 即使你的代码通过了 'R CMD check'

- 尝试这样编译C代码: 'gcc -pedantic -Wall'，您应该只得到您有理由不消除的警告。
(you should get only warnings that you have reasons not to eliminate)

- 检查R代码 'R CMD check --use-gct'，
(It uses 'gctorture(TRUE)' when running examples/tests, and it's slow) 

如果您不这样做，CRAN将为您做，并将把您送回绘图板(?撤回版)。
If you won't, CRAN will do that for you and will send you back to the drawing board.








========================================
Rcpp 包必须掌握的C++知识点(GPT)
----------------------------------------
1. C++ knowledge required to learn Rcpp includes:
(1)Understanding of basic C++ programming concepts such as data types, control structures, and functions.
数据类型，控制结构，函数。

(2)Knowledge of C++ classes, inheritance, and object-oriented programming (OOP) principles, as Rcpp modules allow programmers to expose C++ functions and classes to R [3].
C++类，继承，OOP原则，因为Rcpp允许将C++函数和对象暴露给R。

(3)Familiarity with the C++ Standard Template Library (STL) and its containers, iterators, and algorithms, as Rcpp provides broad support for these C++ idioms [4].
熟悉 STL库，迭代器，算法，因为Rcpp对这些提供了广泛支持。

(4)Understanding of C++ memory management, including the use of pointers and dynamic memory allocation, as this is important for efficient data transfer between R and C++ [5].
理解C++内存管理，包括使用指针和动态内存分配，这对在R和C++之间高效转移数据很重要。

The Rcpp package simplifies the integration of C++ code with R by providing a consistent C++ class hierarchy that maps various types of R objects to dedicated C++ classes, making the data transfer between the two languages nearly seamless [4]. Additionally, Rcpp modules allow programmers to expose C++ functions and classes to R with relative ease, further facilitating the integration of C++ and R [3].

参考资料：
> [3] https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-modules.pdf
> [4] https://www.jstatsoft.org/article/view/v040i08 Rcpp: Seamless R and C++ Integration Dirk Eddelbuettel, Romain Francois
> [5] Improving robustness and computational efficiency using modern C++ 
/M Paterno1, J Kowalkowski1 and C Green1
Journal of Physics: Conference Series, Volume 513, Issue 5
Citation M Paterno et al 2014 J. Phys.: Conf. Ser. 513 052026
DOI 10.1088/1742-6596/513/5/052026





2. 







========================================
Rcpp 包: hadley: Rewriting R code in C++ //todo
----------------------------------------

【推荐】Rcpp 必须掌握的基础知识: http://jmonlong.github.io/Hippocamplus/r/#rcpp
Rcpp 作者的广告片: https://dirk.eddelbuettel.com/papers/rcpp_rfinance_may2012.pdf


1. 教程list
https://github.com/hadley/adv-r/
https://adv-r.hadley.nz/rcpp.html

http://adv-r.had.co.nz/C-interface.html
http://adv-r.had.co.nz/Rcpp.html


(1)Rcpp: Seamless R and C++ Integration
https://www.rcpp.org/
https://gallery.rcpp.org/


book: https://link.springer.com/content/pdf/10.1007/978-1-4614-6868-4.pdf 可能过时了，太古老了。
ebook: https://teuder.github.io/rcpp4everyone_en/
Rcpp 需要的C++ 知识: https://zhuanlan.zhihu.com/p/150630210


Extending and growing R applications via an easy-to-use, robust, and performant C++ interface.

All key R data types map naturally into key C++ data structures, and simple interfaces make transfer back and forth very easy. And by composing more complex interfaces become possible.

Numerous examples, as well as extensive documentation, facilitate its use.




(2) 中文版 Rcpp 博客/公众号
https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5NjAyMzU1OA==&action=getalbum&album_id=1510985345260158978




2. 入门 
Rcpp是R的一个包，通过调用这个包里的函数，比如cppFunction和sourceCpp来实现R与C++的结合。
Rcpp是R的扩展包，Windows用户需安装CRAN镜像网络提供的Rtools套件<https://cran.r-project.org/bin/windows/Rtools/> 

Rcpp的使用

(1) cppFunction
直接在R中运用Rcpp中的cppFunction函数，用法是cppFunction(‘C++语句书写’)

例子：斐波那契数列
library("Rcpp")

cppFunction(
  'int fib_cpp_0(int n){
  if(n==1||n==2) return 1;
  return(fib_cpp_0(n-1)+fib_cpp_0(n-2));
  }')

(2) sourceCpp
运用sourceCpp函数在R中调用cpp格式的文件（也就是C++文件）。

在cpp文件中，头文件要用#include <Rcpp.h>,把需要输出到R中的函数放置在//[[Rcpp::export]]后，如果需要调用其他C++函数，可以把这些函数放在//[[Rcpp::export]]之前

例子：斐波那契数列
$ cat rcpp2.cpp
#include <Rcpp.h>
using namespace Rcpp;

//[[Rcpp::export]]
int fib_cpp_1(int n){
  if(n==1||n==2) return 1;
  return(fib_cpp_1(n-1)+fib_cpp_1(n-2));
}

# R 中
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")  #用C++11的标准来编译文件
sourceCpp("rcpp2.cpp")


(3) 本质
上述两个函数其本质是相同的，其本质都是先写出 C/C++ 的代码，然后用R CMD SHLIB生成一个动态链接库，再用dyn.load载入这个动态链接库。最后用.Call(或者. C），调用库中的函数。


(4) Rcpp优势
R是解释型语言，即在运行时先要把程序翻译成机器语言再运行，每执行一次就要翻译一次，而C++则为编译型语言，只需要编译一次。因此，在循环、递归等内含大量重复性过程的算法中，只用R语言是非常缓慢的，而使用Rcpp则可以提高效率。

例子：斐波那契数列，比较用R代码、cppFunction和sourceCpp三种方式写出的斐波那契数列函数的运行速度

（cppFunction和sourceCpp代码上文已给出，此处为R语言中的代码）：

fib_r <- function(n){
  if(n==1||n==2) return(1)
  return(fib_r(n-1)+fib_r(n-2))
}

*用system.time()函数测算运行时间：
> system.time(fib_r(30))
   user  system elapsed 
  0.547   0.000   0.547 
> system.time(fib_cpp_0(30))
   user  system elapsed 
  0.002   0.000   0.002 
> system.time(fib_cpp_1(30))
   user  system elapsed 
  0.003   0.000   0.002 
可以很明显地看到使用Rcpp的后两种方法速度远远快于第一种（时间显示为零是由于四舍五入的原因）


## 可选: *microbenchmark函数可视化多次运行时间
library(microbenchmark)
res<-microbenchmark(30,fib_r(30),fib_cpp_0(30),fib_cpp_1(30),times=100L)  #time为跑100次
autoplot.microbenchmark(res)   #将这3个函数各运行100次的时间以图像显示

如上图所示，使用Rcpp函数的两个斐波那契数列运算100次每次的时间约在10^5纳秒左右，而使用R语言运行100次每次的时间则超过了10^8纳秒，超过前两个方式用时的1000倍，使用Rcpp的效率提高程度明显。



(5) R包制作中Rcpp的应用
在Rstudio中，按顺序点击file - new file - C++file ，然后运行devtools::use_rcpp语句，以此创建了一个.cpp文件和对应DESCRIPTION文件 。在RStudio提供的 默认模板中最重要的是头文件#include和特别属性// [[Rcpp::export]] ，其用法和C++相同。

修改默认模板（注意函数和示例一起修改） 后，点击Build&Reload进行创建即可。

例子：汉诺问题

C++代码：
#include <Rcpp.h>
#include<stdio.h>
using namespace Rcpp;

// [[Rcpp::export]]
void han(int n,char a,char b, char c)
{
  if(n==1)
  {
    int move(char x,char y);
    move(a,b);
  }else
  {
    int move(char x,char y);
    han(n-1,a,c,b);
    move(a,c);
    han(n-1,b,a,c);
  }
}

int move(char x,char y)
{
  printf("%c>>>%c\n",x,y);
  return 0;
}


R语言代码：
> sourceCpp("./backup/hnt_code.cpp")
> han(4, "a", "b", "c")





###
ref:《Rcpp：R 与 C++ 的无缝整合》.西安交通大学出版社 [法] 德克 · 埃德比特尔著 寇强 张晔译






========================================
Rcpp在R语言中实现C++与R的无缝交互
----------------------------------------
1.
在R中如何直接调用C++的函数进行数据的计算。在这里需要用到的包是Rcpp。此工具包中有四个核心的包：RcppArmadillo使得线性代数的引入语法更加接近matlab；RcppEigen 高优化的线性代数计算；RInside实现在C++中调用R代码；RcppParallel基于Rcpp实现计算的并行运算。

install.packages('Rcpp')
install.packages("inline")


(1)C++与R进行数据交互的共有数据格式及其函数名称：

向量:NumericVector、IntegerVector、CharacterVector
矩阵:NumericMatrix、IntegerMatrix、CharacterMatrix
数据框:DataFrame
列表:List
函数:Function
其他类型:Environment, ComplexVector, RawVector,DottedPair, Language, Promise, Symbol, WeakReference
 

(2)Rcpp中数学运算及处理函数：

数学函数: abs(), acos(), asin(), atan(),beta(), ceil(), ceiling(), choose(), cos(), cosh(), digamma(), exp(), expm1(),factorial(), floor(), gamma(), lbeta(), lchoose(), lfactorial(), lgamma(),log(), log10(), log1p(), pentagamma(), psigamma(), round(), signif(), sin(),sinh(), sqrt(), tan(), tanh(), tetragamma(), trigamma(), trunc().
汇总函数: mean(), min(), max(), sum(), sd(),and (for vectors) var()
返回向量的汇总函数: cumsum(), diff(), pmin(), andpmax()
查找函数: match(), self_match(), which_max(),which_min()
重复值处理函数: duplicated(), unique()


(3) 如何构建一个可以被Rcpp识别的C++文件，我们可以直接在Rstudio中进行构建，构建结果如下：

#include <Rcpp.h>
#include<stdio.h>
using namespace Rcpp; //前2行是头文件

//Rcpp 识别标记，放到哪个函数前面，就表示该函数暴漏到R中，该标示符和函数定义之间不能有注释！
//[[Rcpp::export]]
NumericVector timesTwo(NumericVector x){ //定义函数
	return x*2;
}


在R中调用函数 
> Rcpp::sourceCpp("test.cpp")
> timesTwo(42)


(4) C++函数的定义
// 返回类型 函数名(参数类型 形参 = 默认值)

#include <Rcpp.h>
#include<stdio.h>
using namespace Rcpp;

// [[Rcpp::export]]
bool is_odd_cpp(int n=10){ //a function defination
  bool v = (n %2 == 1); //body
  return v; //return value
}

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x){
  return x*2;
}


# 直接测试c++函数
> Rcpp::sourceCpp("./src/hnt_code.cpp")
> han(3,'a','b','c') #正常了
> GEB::han(3,'a','b','c') #依然报错



(5) 在R包中我们需要怎么去调用C++呢？
那就需要构建对应的代码，引入所需要的库文件。

首先，我们需要在Rstudio中构建包含Rcpp 的R包的框架，具体，可以自己操作下，都是可视化的单击。
也可以使用命令行新建包框架:  >Rcpp.package.skeleton()
构建后的文件框架如下：
	DESCRIPTION
	NAMESPACE
	man/
	R/ 
	src/ #C++代码、库文件所在地

1) 如果已经有包框架，新添加了 src/ 中的几个函数，
则需要手动为DESCRIPTION文件添加Rcpp导入: DESCRIPTION 文件添加2行
Imports: Rcpp (>= 1.0.5)
LinkingTo: Rcpp

2) [重要!]在 NAMESPACE 中需要添加 importFrom(Rcpp,evalCpp) 引入Rcpp环境。
useDynLib(GEB, .registration=TRUE)
importFrom(Rcpp, evalCpp)
exportPattern("^[[:alpha:]]+")


3) 然后构建，安装。
先清空变量，并重启 Rsession。
> library(devtools)
> Rcpp::compileAttributes() #这一句没啥用，貌似可以跳过。
> load_all() #载入所有函数，测试效果

调试报错:
> GEB::han(3,'a','b','c') #后来发现，NAMESPACE 文件中加入那3行就能找到了
Error in .Call("_GEB_han", PACKAGE = "GEB", n, a, b, c) : 
  "_GEB_han" not available for .Call() for package "GEB"
而普通R函数正常:
> GEB::hello()
[1] "Hello, world!"


4) 整体测试需要安装:
先修改 DESCRIPTION 中的 Version 号，然后:
#清空变量
> devtools::document() #需要在 NAMESPACE 中添加那三行(见5.2)
> devtools::build()

# install and test
> install.packages("~/data/r-pkg/GEB_0.1.8.tar.gz", repos = NULL, type = "source")
> library(GEB)


报错，可以通过 在 NAMESPACE 中添加那三行解决(见5.2)
> GEB::han(3,'a','b','c')
Error: 'han' is not an exported object from 'namespace:GEB'






(6) 我们看看 load_all() 时发生了什么？怎么用R调用c++函数的?

编译时，自动生成函数文件，都是程序自动维护的，不要手动编辑：
	一个是 src/RcppExports.cpp，其中看不懂，先跳过。
	另一个是 R/RcppExports.R，里面的内容类似:

timesTwo <- function(x) {
    .Call(`_GEB_timesTwo`, x) ##此处为反斜点，不是单引号。不过不用担心细节，反正靠程序生成。
}


当然，有时候我们需要引入外部的库文件以及头文件，那就需要书写 Makevars 进行库的引入，一般我们会放在inst/include,文件中需要加入下面的代码：

PKG_CPPFLAGS+= -I ../inst/include

至此，Rcpp的基础应用已经介绍完了，当然在知道基本的原理后，再加入更深的功能或者需求就是看个人对C++的熟悉程度了。





========================================
|-- how to debug Rcpp
----------------------------------------

https://stackoverflow.com/questions/53622354/how-to-debug-line-by-line-rcpp-generated-code-in-windows
https://gist.github.com/alexg9010/1ab89ecb28c43f8bc217d2facca77f0a

https://dirk.eddelbuettel.com/papers/useR2019_rcpp_tutorial.pdf





========================================
|-- 使用 Rcpp 和 RcppEigen 进行矩阵计算
----------------------------------------
https://stephenberg.github.io/presentations/materials/bergSeminarPres.pdf

J3:/home/wangjl/data4/others/wangjl2/PCAwithNA/script/


1. 相关背景
(1) 教训 
- 不要用Rstudio，用shell R。
- 参数中不要有注释行

(2) 编译环境变量
矩阵运算属于高性能运算，默认使用服务器了。我的环境是
- CentOS7.9
- g++ (GCC) 12.3.0
- R version 4.3.3 (2024-02-29)
- Rcpp v1.0.12
- RcppEigen v0.3.3.9.4

$ cat ~/.R/Makevars
#CXX17 = g++ -std=c++17 -fPIC
CXX11=/home/wangjl/soft/gcc-12.3.0/bin/g++ -std=c++11 -fPIC
CXX14=/home/wangjl/soft/gcc-12.3.0/bin/g++ -std=c++14 -fPIC
CXX17=/home/wangjl/soft/gcc-12.3.0/bin/g++ -std=c++17 -fPIC
gcc=/home/wangjl/soft/gcc-12.3.0/bin/gcc






2. 先跑起来Rcpp代码

(1) 写文件
$ cat test_mat1.cpp
#include <Rcpp.h>

using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}

文件解释：
* 第1行：头文件
* 第2行：命名空间，下文的 NumericVector 类型全名是 Rcpp::NumericVector
* 第3行：// [[Rcpp::export]] 表示该函数暴漏到R中，可以在R中直接调用。
* 接着是函数体，就是标准的C++代码了：
	返回类型 函数名(参数类型 虚参数){
		函数体
		return 返回值;
	}


(2) 编译
shell 进入c++文件所在文件夹：
$ cd /path/to/cpp_file/

$ mkdir tmp #新建文件夹，作为编译目录

直接在当前文件夹内的shell中打开 shell R
$ R

编译和加载函数
> library(Rcpp)
> sourceCpp("test_mat1.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)
参数解释： 
* 第一个参数是 c++文件名
* cacheDir 是指定编译文件夹
* verbose=T 输出详细日志
* rebuild=T 前置重新编译。这个很重要，默认是F，修改代码不会重新编译，看不到修改的效果。

最后几行如果没有报错，则表示正常编译。


(3) 测试
> timesTwo(c(-10,3, 20))
[1] -20   6  40
确实乘以2了

修改cpp文件，把函数体改为 *3，再次编译，运行：
> timesTwo(c(-10,3, 20))
[1] -30   9  60
确实乘以3了。




(4) 查看编译产物
$ ls -lth tmp/sourceCpp-x86_64-pc-linux-gnu-1.0.12/sourcecpp_108c6c552e9/
total 1.5M
-rwxrwxrwx+ 1 wangjl jinlab 550K Oct 20 19:33 sourceCpp_3.so
-rw-rw-rw-+ 1 wangjl jinlab 945K Oct 20 19:33 test_mat1.o
-rw-r--r--+ 1 wangjl jinlab  643 Oct 20 19:33 test_mat1.cpp
-rw-rw-rw-+ 1 wangjl jinlab  302 Oct 20 19:33 test_mat1.cpp.R



(5) 复用该 so 函数库：失败 //todo
$ R 
> dyn.load("tmp/sourceCpp-x86_64-pc-linux-gnu-1.0.12/sourcecpp_108c6c552e9/sourceCpp_3.so")
> timesTwo(c(-10,3, 20))
Error in timesTwo(c(-10, 3, 20)) : could not find function "timesTwo"
貌似不能调用了？！

> .C("timesTwo", c(-10, 3, 20))
Error in .C("timesTwo", c(-10, 3, 20)) : 
  C symbol name "timesTwo" not in load table
> .Call("timesTwo", c(-10, 3, 20))
Error in .Call("timesTwo", c(-10, 3, 20)) : 
  C symbol name "timesTwo" not in load table


使用命令行工具检查 .so 文件是否包含正确的符号。
$ nm -D tmp/sourceCpp-x86_64-pc-linux-gnu-1.0.12/sourcecpp_108c6c552e9/sourceCpp_4.so  | grep -in two
62:0000000000005b10 T sourceCpp_1_timesTwo
71:0000000000005860 T _Z8timesTwoN4Rcpp6VectorILi14ENS_15PreserveStorageEEE

原来是函数名不对，重新调用：
> library(Rcpp)
> .Call("sourceCpp_1_timesTwo", c(-10, 3, 20))
直接死机了，ctrl+C无法退出！只好断开shell，重新连接！！

> .Call("sourceCpp_1_timesTwo", PACKAGE="", c(-10, 3, 20))
> .Call("_Z8timesTwoN4Rcpp6VectorILi14ENS_15PreserveStorageEEE", c(-10, 3, 20))
//todo 放弃复用









3. 矩阵运算：outerSize() 是行还是列？

矩阵包括：常规矩阵和稀疏矩阵。
R中和c++中有对应类型，调用时要保持类型配对。


We may need to supply:
• header location via -I,
• library location via -L,
• library via -llibraryname


(1) 写函数：如何输入正确的参数？
$ cat test_mat2.cpp
#include <Rcpp.h>
#include <RcppEigen.h>

using namespace Rcpp;

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
void SNN_SmallestNonzero_Dist2(
    Eigen::SparseMatrix<double> snn,
    Eigen::MatrixXd mat,
    int n,
    std::vector<double> nearest_dist
) {
  
  for (int i=0; i < snn.outerSize(); ++i){
    Rcpp::Rcout << i <<  std::endl;
  }
}



(2) 编译
> Rcpp::sourceCpp("test_mat2.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)

该函数已经加载到R环境中：
> SNN_SmallestNonzero_Dist2
function (snn, mat, n, nearest_dist) 
invisible(.Call(<pointer: 0x7f9ca25137f0>, snn, mat, n, nearest_dist))





(3) 测试
这个调用不容易，参数的几个类型都不能出错。
> library(Matrix);
> sparse_matrix <- Matrix(c(0, 0, 3, 0,   4, 0, 0, 0), nrow = 2, ncol = 4, byrow=T, sparse = TRUE);sparse_matrix
[1,] . . 3 .
[2,] 4 . . .
> class(sparse_matrix)
[1] "dgCMatrix"
attr(,"package")
[1] "Matrix"

转变格式为 "dgCMatrix"
> sparse_matrix_dgC <- as(sparse_matrix, "dgCMatrix");print(class(sparse_matrix_dgC))
[1] "dgCMatrix"
attr(,"package")
[1] "Matrix"

一般矩阵形式
> mat = as.matrix(sparse_matrix); mat
     [,1] [,2] [,3] [,4]
[1,]    0    0    3    0
[2,]    4    0    0    0

调用1：第二个参数不是一般矩阵，是稀疏矩阵（"dgCMatrix"），就报错！
> SNN_SmallestNonzero_Dist2(sparse_matrix_dgC, sparse_matrix, 8, c(1,2,3))
Error: Not a matrix.

调用: 正确
> SNN_SmallestNonzero_Dist2(sparse_matrix_dgC, mat, 8, c(1,2,3))
0
1
2
3
结论：可见，outerSize() 是列数。
教科书的数学上，矩阵是列向量组成的。向量默认值的是列向量。








4. 对矩阵的非零元素进行遍历

(1) 写函数：如何对稀疏矩阵遍历
$ cat test_mat3.cpp
#include <Rcpp.h>
#include <RcppEigen.h>

using namespace Rcpp;

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
void SNN_SmallestNonzero_Dist3(
    Eigen::SparseMatrix<double> snn
) {
  
  for (int j=0; j < snn.outerSize(); ++j){ //遍历列
    for (Eigen::SparseMatrix<double>::InnerIterator it(snn, j); it; ++it) { //对非0行遍历
      int row = it.row();
      double value = it.value();
      Rcpp::Rcout << "Row: " << row << ", Column: " << j << ", Value: " << value << std::endl;
    }
  }
}


(2) 编译
> Rcpp::sourceCpp("test_mat3.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)

> SNN_SmallestNonzero_Dist3
function (snn) 
invisible(.Call(<pointer: 0x7f9ca18c9f70>, snn))


(3) 调用
> mat = Matrix(c(0, 0, 3, 0,   4, 0, 0, 0), nrow = 2, ncol = 4, byrow=T); mat
2 x 4 sparse Matrix of class "dgCMatrix"
            
[1,] . . 3 .
[2,] 4 . . .

> SNN_SmallestNonzero_Dist3(mat)
Row: 1, Column: 0, Value: 4
Row: 0, Column: 2, Value: 3
注意：在C++中下标从0开始计数。R中则从1开始计数。









5. 求向量的欧氏距离(L2范数)：.norm() 方法

(1) cpp函数
$ cat test_mat4.cpp
#include <Rcpp.h>
#include <RcppEigen.h>

using namespace Rcpp;

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
void SNN_SmallestNonzero_Dist2(
    Eigen::SparseMatrix<double> snn,
    Eigen::MatrixXd mat,
    int n,
    std::vector<double> nearest_dist
) {
  
  for (int i=0; i < snn.outerSize(); ++i){
    Rcpp::Rcout << i <<  std::endl;
  }
  
  //第一行
  size_t cell = 0;
  int i=1;
  double res = (mat.row(cell) - mat.row(i)).norm();
  Rcpp::Rcout << "mat.row(0): " << mat.row(cell) <<  std::endl;
  Rcpp::Rcout << "mat.row(1): " << mat.row(i) <<  std::endl;
  Rcpp::Rcout << "(mat.row(0) - mat.row(1)).norm() = " << res <<  std::endl;
}


(2) 编译
> Rcpp::sourceCpp("test_mat4.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)


(3) 运行
> sparse_matrix <- Matrix(c(0, 0, 3, 0,   4, 0, 0, 0), nrow = 2, ncol = 4, byrow=T, sparse = TRUE);sparse_matrix
> mat = as.matrix(sparse_matrix); mat
     [,1] [,2] [,3] [,4]
[1,]    0    0    3    0
[2,]    4    0    0    0

> SNN_SmallestNonzero_Dist2(sparse_matrix, mat, 3, c(1,2))
0
1
2
3
mat.row(0): 0 0 3 0
mat.row(1): 4 0 0 0
(mat.row(0) - mat.row(1)).norm() = 5

结论：
* mat.row(i) 就是取第i行的元素
* .norm() 就是取欧氏距离：求平方和，再开方。
	默认是到原点的欧氏距离。
	上述例子是自己主动求向量的差，再调用.norm()方法，相当于两点之间的欧氏距离。








6. std::accumulate() 方法：累加

$ cat test_mat5.cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
void fn5() {
  // accumulate?
  std::vector<double> dists;
  dists.push_back(1);
  dists.push_back(2);
  dists.push_back(3);
  dists.push_back(4);
  dists.push_back(5);
  Rcpp::Rcout << "dists.size():" << dists.size() <<  std::endl;
  
  double avg_dist;
  avg_dist = std::accumulate(dists.begin(), dists.end(), 0.0) / dists.size();
  Rcpp::Rcout << "avg_dist:" << avg_dist <<  std::endl;
}


编译：
> Rcpp::sourceCpp("test_mat5.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)

运行：
> fn5()
dists.size():5
avg_dist:3

结论：std::accumulate() 就是从头到位累加。








7. 自定义函数 sort_indexes() 稳定排序: 相等的值，保持之前出现的顺序

$ cat test_mat6.cpp
#include <Rcpp.h>
using namespace Rcpp;

template <typename S>
std::vector<size_t> sort_indexes(const std::vector<S> &v) {
  // initialize original index locations
  std::vector<size_t> idx(v.size()); //声明空数组，等长度
  std::iota(idx.begin(), idx.end(), 0); //从0开始递增填充：0,1,2,...
  std::stable_sort(idx.begin(), idx.end(), //
                   [&v](size_t i1, size_t i2) {return v[i1] < v[i2];});
  return idx;
}

// [[Rcpp::export]]
void fn6() {
  // accumulate?
  std::vector<double> nonzero={2.2, 1.1, 3.3, 1.1, 4.4};
  Rcpp::Rcout << "nonzero.size():" << nonzero.size() <<  std::endl;
  
  
  std::vector<size_t> nonzero_order = sort_indexes(nonzero);
  for(int i=0; i<nonzero_order.size(); i++){
    size_t idx = nonzero_order[i];
    Rcpp::Rcout << i << " " << idx <<" " << nonzero[idx] << std::endl;
  }
}

> Rcpp::sourceCpp("test_mat6.cpp", cacheDir="./tmp/", verbose=T, rebuild=T)

> fn6()
nonzero.size():5
0 1 1.1
1 3 1.1
2 0 2.2
3 2 3.3
4 4 4.4

结论：sort_indexes 返回值 是输出第二列，可见是原数组的下标。
	其中两个1.1出现2次，按出现顺序排列。

> a1=c(2.2, 1.1, 3.3, 1.1, 4.4)
> order(a1)
[1] 2 4 1 3 5
> order(a1)-1 #和R的order()函数的效果一致，只是R是1-based下标。
[1] 1 3 0 2 4








Ref:
Seurat v4.4.0 R包源码
http://www2.uaem.mx/r-mirror/web/packages/RcppEigen/index.html
Integrating with C++ using Rcpp and RcppEigen: https://kohei-kawaguchi.github.io/EmpiricalIO/rcpp.html

https://blog.csdn.net/wangjunliang/article/details/143096799






========================================
RcppParallel 包: 把顺序for循环变成多线程并行执行
----------------------------------------

https://gallery.rcpp.org/articles/parallel-matrix-transform/
https://github.com/RcppCore/RcppParallel


我写的实例: https://blog.csdn.net/wangjunliang/article/details/126273684?

1. 基于2个C++库 
Intel TBB(v4.3): C++库，基于x86系统；
TinyThread: C++库。

这两个库负责高层工作，比如分配工作任务到不同的核心/处理器上。

RcppParallel 默认在 Win, OS X, Linux 是哪个使用TBB，其他不支持的则使用 TinyThread.

(2) TBB 库改名为 oneTBB
https://github.com/ManyThreads/tbb 这里说转载自: https://github.com/intel/tbb
点开后已经改名为: https://github.com/oneapi-src/oneTBB
新的官网: https://oneapi-src.github.io/oneTBB/

中文介绍: http://t.zoukankan.com/ybqjymy-p-13679446.html
intel: https://www.intel.com/content/www/us/en/developer/articles/guide/get-started-with-tbb.html




2. 解决的问题

paralleleFor(): 顺序for变并行
parallelReduce(): 并行计算并累加结果。

使用TBB机制，Worker 类接受任务。

//C++代码
parallelFor(std::size_t begin, std::size_t end, Worker worker);

用户可以实现 RcppParallel::Worker 的子类，实现对每一部分data的处理的处理方法。


3. 使用方法

(1) RcppParallel: Using a Worker
// stub for our LogWorker class
struct LogWorker: public RcppParallel::Worker{ /* ... */}

// [[Rcpp::export]]
Rcpp::NumericVector paralleleLog(Rcpp::NumericVector input){
	Rcpp::NumericVector output = no_init(input.size());
	LogWorker worker(input, output);
	RcppParallel::parallelFor(0, input.size(), worker);
	return output;
}


(2) RcppParallel: implementing a Worker 

//[[Rcpp::depends(RcppParallel)]]
#include<RcppParallel.h>
#include<Rcpp.h>

// define a small functor that computes the logarithm of a value 
struct log {
	double operator()(double value){
		return ::log(value);
	}
}

// implement our worker (subclass RcppParallel::Worker)
struct LogWorker: public RcppParallel::Worker{
	// initialize inputs + outputs
	RcppParallel::Rvector<double> input, output;
	LogWorker(Rcpp::NumericVector input, Rcpp::NumericVector output)
		: input(input), output(output){}
	
	// define work (accepts a range of items to work on)
	void operator()(std::size_t begin, std::size_t end){
		std::transform(
			input.begin() + begin, input.begin()+end,
			output.begin()+begin,
			Log()
		);
	}
};



(3) 性能比较

library(microbenchmark)
x=as.numeric(1:1E7)
microbenchmark(R = log(x),
	RcppParallel= parallelLog(x),
	time=10
)

并行块 ~3-4倍节省时间，取决于核心个数。


(4) 为什么快？

TBB 做了调度优化
- Grain size 粒度 ?? 不懂
- 看哪个 thread 空闲，就把任务派发过去


(5) 内积

// [[Rcpp::export]]
Rcpp::NumericVector parallelInnerProduct(Rcpp::NumericVector input){
	Rcpp::NumericVector output = no_init(input.size());
	InnerProductWorker worker(input, output);
	RcppParallel::parallelFor(0, input.size(), worker);
	return output;
}

double product(double lhs, double rhs){
	return lhs * rhs;
}

struct InnerProductWorker: public RcppParallel::Worker{
	RcppParallel::RVector<double> lsh_, rhs_;
	double output_;
	
	InnerProductWorker(const InnerProductWorker& self, RcppParallel::Split)
		: lhs_(self.lsh_), rhs_(self.rhs_), output_(0) {}
	void operator()(std::size_t begin, std::size_t end){
		output_ += std::inner_product(
			lhs_.begin() + begin,
			lhs_.begin() + end,
			rhs_.begin() + begin,
			0.0		
		); 
	}
	
	double value() const { return output_;}
	
	void join(const InnerProductWorker& worker){
		output_ += worker.output_;
	}
};


in R 
> Rcpp::sourceCpp("inner-product.cpp");

> n=1e6
lhs=rnorm(n);
rhs=rnorm(n);
all.equal( sum(lhs*rhs), parallelInnerProduct(lhs, rhs) )





========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


