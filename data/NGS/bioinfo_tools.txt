bioinfo_tools

生信工具：本地化安装的
	与序列处理有关的工具



========================================
生信工具 概述
----------------------------------------

收录一些常见的生信工具，这样就不用重复造轮子了。
或者想造轮子时，有一个参照。






========================================
bedtools : a powerful toolset for genome arithmetic 强有力的基因组算法瑞士军刀
----------------------------------------
1. 简介 
(1)bedtools: flexible tools for genome arithmetic and DNA sequence analysis.
usage:    bedtools <subcommand> [options]


软件相关论文：
Quinlan, A.R. & Hall, I.M. BEDTools: a flexible suite of utilities for comparing genomic features. Bioinformatics 26, 841-842 (2010).

bedtools说明书：
https://bedtools.readthedocs.io/en/latest/index.html
http://quinlanlab.org/tutorials/bedtools/bedtools.html


最新版的官网：
http://bedtools.readthedocs.io/en/latest/index.html

旧版本的pdf：
https://insidedna.me/tool_page_assets/pdf_manual/bedtools.pdf

Collectively, the bedtools utilities are a swiss-army knife of tools for a wide-range of genomics analysis tasks. The most widely-used tools enable genome arithmetic: that is, set theory on the genome. For example, bedtools allows one to intersect, merge, count, complement, and shuffle genomic intervals from multiple files in widely-used genomic file formats such as BAM, BED, GFF/GTF, VCF. While each individual tool is designed to do a relatively simple task (e.g., intersect two interval files), quite sophisticated analyses can be conducted by combining multiple bedtools operations on the UNIX command line.

bedtools is developed in the Quinlan laboratory at the University of Utah and benefits from fantastic contributions made by scientists worldwide.



(2)为什么不得不用bedtools？

速度，当数据到达百万级以上，R和C的速度差别就非常明显了
专业，但凡涉及到region、peak的处理，bedtools都可以胜任

https://www.cnblogs.com/leezx/p/14475092.html






2. 安装方法：

(1) 最新安装步骤 (202305)
https://github.com/arq5x/bedtools2/releases

@容器内：
$ /home/wangjl2/data/Downloads
$ wget https://github.com/arq5x/bedtools2/releases/download/v2.31.0/bedtools-2.31.0.tar.gz
$ tar -zxvf bedtools-2.31.0.tar.gz
有报错: tar: Ignoring unknown extended header keyword `LIBARCHIVE.xattr.com.apple.quarantine' 
这个报错可以不用管，主要原因是压缩包是在mac系统上压缩的，在linux系统解压会生成一些无法识别的信息，问题不大

$ cd bedtools2
$ make -j20 #gcc (GCC) 12.1.0
$ make prefix=~/soft/bedtools2 install  # 如果设置 ~/ 则安装到家目录下的bin/bedtools/中

添加到工作目录
$ vim ~/.bashrc #添加一行
export PATH=/home/$USER/soft/bedtools2/bin:$PATH
载入配置
$ source ~/.bashrc

查看版本号
$ which bedtools
~/soft/bedtools2/bin/bedtools

$ bedtools --version
bedtools v2.31.0





(2) 之前的安装步骤
#apt-get install bedtools #Debian/Ubuntu. 
#yum install BEDTools #Fedora/Centos
或者：
$ wget https://github.com/arq5x/bedtools2/releases/download/v2.25.0/bedtools-2.25.0.tar.gz
$ tar -zxvf bedtools-2.25.0.tar.gz
$ cd bedtools2
$ make
$ make prefix=~/ install #安装到家目录下的bin文件夹中。



### 如果缺少 include <zlib.h>
http://zlib.net/ download zlib
$ wget http://zlib.net/zlib-1.2.11.tar.gz
$ tar zxvf zlib-1.2.11.tar.gz
$ cd zlib-1.2.11/
$ ./configure
$ make 
$ sudo make install

直到两年后我才理解 linux下 的软件安装需要指定路径，而且是自己有权限的路径
./configure --prefix=/home/wangjl/bin/
-- 再在bwa目录使用make，正常了。（bwa的安装也依赖zlib）



查看版本号：
$ bedtools -version 
## bedtools v2.25.0












3. 使用细节

查看帮助：
$ bedtools -help 



$ bedtools
bedtools: flexible tools for genome arithmetic and DNA sequence analysis.
usage:    bedtools <subcommand> [options]

The bedtools sub-commands include:

[ Genome arithmetic ]
    intersect     Find overlapping intervals in various ways.
    window        Find overlapping intervals within a window around an interval.
    closest       Find the closest, potentially non-overlapping interval.
    coverage      Compute the coverage over defined intervals.
    map           Apply a function to a column for each overlapping interval.
    genomecov     Compute the coverage over an entire genome. 基因组覆盖度
    merge         Combine overlapping/nearby intervals into a single interval.
    cluster       Cluster (but don't merge) overlapping/nearby intervals.
    complement    Extract intervals _not_ represented by an interval file.
    subtract      Remove intervals based on overlaps b/w two files.
    slop          Adjust the size of intervals.
    flank         Create new intervals from the flanks of existing intervals.
    sort          Order the intervals in a file.
    random        Generate random intervals in a genome.
    shuffle       Randomly redistrubute intervals in a genome.
    sample        Sample random records from file using reservoir sampling.
    spacing       Report the gap lengths between intervals in a file.
    annotate      Annotate coverage of features from multiple files.

[ Multi-way file comparisons ] 多文件比较
    multiinter    Identifies common intervals among multiple interval files.
    unionbedg     Combines coverage intervals from multiple BEDGRAPH files.

[ Paired-end manipulation ] 双端操作
    pairtobed     Find pairs that overlap intervals in various ways.
    pairtopair    Find pairs that overlap other pairs in various ways.

[ Format conversion ] 格式转变
    bamtobed      Convert BAM alignments to BED (& other) formats.
    bedtobam      Convert intervals to BAM records.
    bamtofastq    Convert BAM records to FASTQ records.
    bedpetobam    Convert BEDPE intervals to BAM records.
    bed12tobed6   Breaks BED12 intervals into discrete BED6 intervals.

[ Fasta manipulation ] fasta 文件操作
    getfasta      Use intervals to extract sequences from a FASTA file.
    maskfasta     Use intervals to mask sequences from a FASTA file.
    nuc           Profile the nucleotide content of intervals in a FASTA file.

[ BAM focused tools ] bam 操作
    multicov      Counts coverage from multiple BAMs at specific intervals.
    tag           Tag BAM alignments based on overlaps with interval files.

[ Statistical relationships ] 统计关系
    jaccard       Calculate the Jaccard statistic b/w two sets of intervals.
    reldist       Calculate the distribution of relative distances b/w two files.
    fisher        Calculate Fisher statistic b/w two feature files.

[ Miscellaneous tools ] 其余工具
    overlap       Computes the amount of overlap from two intervals.
    igv           Create an IGV snapshot batch script.
    links         Create a HTML page of links to UCSC locations.
    makewindows   Make interval "windows" across a genome.
    groupby       Group by common cols. & summarize oth. cols. (~ SQL "groupBy")
    expand        Replicate lines based on lists of values in columns.
    split         Split a file into multiple files with equal records or base pairs.

[ General help ]
    --help        Print this help menu.
    --version     What version of bedtools are you using?.
    --contact     Feature requests, bugs, mailing lists, etc.
##










使用方法：
# bedtools sorted
$ bedtools intersect \
           -a ccds.exons.bed -b aln.bam.bed \
           -c \
           -sorted

# bedtools unsorted
$ bedtools intersect \
           -a ccds.exons.bed -b aln.bam.bed \
           -c

# bedmap (without error checking)
$ bedmap --echo --count --bp-ovr 1 \
         ccds.exons.bed aln.bam.bed

# bedmap (no error checking)
$ bedmap --ec --echo --count --bp-ovr 1 \
         ccds.exons.bed aln.bam.bed

# bam to bed(bed文件比bam文件坐标小1)
$ bedtools bamtobed -i reads.bam | head -3
-i 后面跟着输入的bam文件





4. 使用实例

(1) 第一个功能 genomecov
我们先看第一个功能，把alignment的结果文件转为bedgraph格式文件。 不过这个功能用处不是很大。

参考：http://bedtools.readthedocs.io/en/latest/content/tools/genomecov.html

bedtools genomecov [OPTIONS] [-i|-ibam] -g (iff. -i)
genomeCoverageBed  [OPTIONS] [-i|-ibam] -g (iff. -i)

这个命令本身并不是设计来做格式转换的，bam2bedgraph也只是其中的一个小功能而已，需要加上-bg参数，就可以Report depth in BedGraph format. For details, see: http://genome.ucsc.edu/goldenPath/help/bedgraph.html

大家观摩我下面给出的测试例子，就明白该功能如何使用了

bedtools genomecov  -bg -i E001-H3K4me1.tagAlign -g mygenome.txt >E001-H3K4me1.bedGraph
bedtools genomecov  -bg -i E001-Input.tagAlign -g mygenome.txt >E001-Input.bedGraph
nohup bedtools genomecov  -bg -ibam BAF180_CT10.unique.sorted.bam >BAF180_CT10.bedGraph &
nohup bedtools genomecov  -bg -ibam BAF180_CT22AM.unique.sorted.bam >BAF180_CT22AM.bedGraph &
nohup bedtools genomecov  -bg -ibam BAF180_CT22.unique.sorted.bam >BAF180_CT22.bedGraph &
nohup bedtools genomecov  -bg -ibam inputCT10sonication.unique.sorted.bam >inputCT10sonication.bedGraph &

首先alignment的文件必须是sort的，
然后如果是bed格式的比对文件，用-i 参数来指定输入文件，需要加入参考基因组的染色体大小记录文件(mygenome.txt )，
如果是bam格式的比对文件，用-ibam指定输入文件，而且不需要参考基因组的染色体大小记录文件。




(2) 
















更多用法：
http://bedtools.readthedocs.io/en/latest/content/example-usage.html
高级用法：
http://bedtools.readthedocs.io/en/latest/content/advanced-usage.html

Report the number of genes that each alignment overlaps.
$ bedtools intersect -a reads.bed -b genes.bed -c

https://www.jianshu.com/p/f8bbd51b5199






========================================
|-- bedtools multicov: 统计 bed 每行区间内bam中的reads数
----------------------------------------

对RNA-seq的比对文件中的比对到各个基因的reads进行计数。
或者对于合并call peak后得到的bed文件，统计每个样本在这些峰中的reads数，获得count 矩阵。


参考: http://www.bio-info-trainee.com/745.html
http://bedtools.readthedocs.io/en/latest/content/tools/multicov.html


1. 示例
(1) 需要对bam做index。
$ samtools index xx.bam

(2) bed格式可以是4列或6列的，可以从 MACS2 的输出文件中使用 awk 生成。
$ awk '{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6}' macs2_result/total_peaks.narrowPeak > macs2_result/total.bed
$ head macs2_result/total.bed
chr1    633888  634322  total_peak_1    628     .
chr1    1724255 1724472 total_peak_2    61      .
chr1    2133178 2133401 total_peak_3    32      .


(3) 获取矩阵
$ bedtools multicov -bams aln1.bam aln2.bam aln3.bam -bed ivls-of-interest.bed
# ivls-of-interest.bed这个文件是必须的，可能需要自己制作，其实用gtf文件也可以的，如下：
chr1 0   10000   ivl1
chr1 10000   20000   ivl2
chr1 20000   30000   ivl3
chr1 30000   40000   ivl4

输出结果前三列是坐标，第四列是基因名，跟我们的bed文件一样，只是最后三列是三个样本的计数，是添加上来的！
chr1 0       10000   ivl1    100 2234    0
chr1 10000   20000   ivl2    123 3245    1000
chr1 20000   30000   ivl3    213 2332    2034
chr1 30000   40000   ivl4    335 7654    0
可以看到，它实现的需求，跟htseq这个软件差不多。


2) 改进版，如果需要更多sample，可以使用shell子命令
$ bedtools multicov -bams `ls map_clean/P1*.final.bam` -bed macs2_result/total.bed >macs2_result/matrix0.txt




(4) 矩阵优化：添加行名、列名

1) 获取样本名字
$ ls map_clean/*.final.bam |  sed -e 's/map_clean\///' -e 's/\.final\.bam//' >matrix/colname.txt


2) R script
dt=read.table("macs2_result/matrix0.txt", header = F)
dim(dt)
dt[1:4,1:8]
rownames(dt)=dt$V4

dt2=dt[, -c(1:6)]
colnames(dt2)=readLines("matrix/colname.txt")
dt2[1:4,1:8]
dim(dt2) #3560   96

write.table(dt2, "P1_raw_counts.txt")


然后就可以用 Seurat 分析了。









========================================
|--  getfasta: 根据坐标区域来从基因组里面提取fasta序列
----------------------------------------
http://bedtools.readthedocs.io/en/latest/content/tools/getfasta.html

1. 简介
bedtools getfasta extracts sequences from a FASTA file for each of the intervals defined in a BED/GFF/VCF file.

(1)注意：
1). The headers in the input FASTA file must exactly match the chromosome column in the BED file.
fa和bed的chr名字要一致。

2). You can use the UNIX fold command to set the line width of the FASTA output. For example, fold -w 60 will make each line of the FASTA file have at most 60 nucleotides for easy viewing.
可以使用 -w 60 指定每60个碱基换行。方便预览。

3). BED files containing a single region require a newline character at the end of the line, otherwise a blank output file is produced.
bed文件只有一行时，结尾必须有换行符，否则输出空白。


(2) 命令格式
$ bedtools getfasta [OPTIONS] -fi <input FASTA> -bed <BED/GFF/VCF>
(or):
$ getFastaFromBed [OPTIONS] -fi <input FASTA> -bed <BED/GFF/VCF>

参考基因组用-fi参数指定具体位置，输出的fasta序列文件用-fo参数指定





2. 示例

(1) 从fa文件获取bed指定坐标的碱基
$ cat test.fa
>chr1
AAAAAAAACCCCCCCCCCCCCGCTACTGGGGGGGGGGGGGGGGGG

$ cat test.bed
chr1 5 10

$ bedtools getfasta -fi test.fa -bed test.bed
>chr1:5-10
AAACC

# optionally write to an output file
$ bedtools getfasta -fi test.fa -bed test.bed -fo test.fa.out

$ cat test.fa.out
>chr1:5-10
AAACC


(2) 在bed文件第4列添加名字，作为新生成的fasta的序列名字
$ cat test.fa
>chr1
AAAAAAAACCCCCCCCCCCCCGCTACTGGGGGGGGGGGGGGGGGG

$ cat test.bed
chr1 5 10 myseq

$ bedtools getfasta -fi test.fa -bed test.bed -name
>myseq
AAACC



(3) 
$ bedtools getfasta -fi ~/biosoft/bowtie/hg19_index/hg19.fa  -bed ../macs14_results/highQuality_summits.bed  -fo highQuality.fa
$ bedtools getfasta -fi ~/biosoft/bowtie/hg19_index/hg19.fa  -bed ../macs14_results/highQuality_peaks.bed  -fo highQuality.fa

我的例子脚本里面用的是bed格式来记录坐标区域。





========================================
|-- bedtools intersect / samtools: 取 大bam文件 的子集
----------------------------------------
http://bedtools.readthedocs.io/en/latest/content/tools/intersect.html


原始序列
$ samtools view apa/190705PAS/hg19/CutA_c01_ROW31_Aligned.sortedByCoord.out.bam | wc
2158830 32382450 581771742



1. 使用 bedtools intersect 取子集
$ samtools view CutA_c01_ROW31_Aligned.sortedByCoord.out.bam |grep chr8| grep 14601 | wc
   2362   35430  690623

(1).建立一个bed文件，限定区域
$ vim RPL8.bed
chr8	146015076	146015318


(2).从bam中取出该范围的行
$ bedtools intersect -a CutA_c01_ROW31_Aligned.sortedByCoord.out.bam -b RPL8.bed >c01_ROW31_RPL8.bam

检查:
$ samtools view c01_ROW31_RPL8.bam |wc
   2363   35445  690971
#



2. 使用samtools view  获取
(1) 获取某染色体序列
$ samtools view apa/190705PAS/hg19/CutA_c01_ROW31_Aligned.sortedByCoord.out.bam | grep chr8 | wc
  67760 1016400 17762256

直接在bam后加染色体名字
$ samtools view apa/190705PAS/hg19/CutA_c01_ROW31_Aligned.sortedByCoord.out.bam chr8 | wc
  67759 1016385 17762079

(2) 获取某个染色体某范围的reads
$ samtools view apa/190705PAS/hg19/CutA_c01_ROW31_Aligned.sortedByCoord.out.bam chr8:146015076-146015318 | wc
	2363   35445  690971

(3) 输出成bam格式 -b，保存头部信息-h
$ samtools view -b -h apa/190705PAS/hg19/CutA_c01_ROW31_Aligned.sortedByCoord.out.bam chr8:146015076-146015318 >test.bam

$ samtools view test.bam |wc
   2363   35445  690971



ref:
使用samtools/bedtools提取bam/sam文件指定区域reads 
http://www.dengfeilong.com/note/290.html




========================================
|-- 区域注释 intersect，及实例若干
----------------------------------------
http://bedtools.readthedocs.io/en/latest/content/tools/intersect.html

1. 注释CNV区域时哪个基因？

(1) 从gencode数据库里面下载，然后解析成bed格式
$ head ~/reference/gtf/gencode/protein_coding.hg19.position
chr1    69091   70008   OR4F5
chr1    367640  368634  OR4F29
chr1    621096  622034  OR4F16
chr1    859308  879961  SAMD11
chr1    879584  894689  NOC2L
chr1    895967  901095  KLHL17
chr1    901877  911245  PLEKHN1
chr1    910584  917473  PERM1
chr1    934342  935552  HES4
chr1    936518  949921  ISG15


(2) 下载的CNV文本文件，转为bed格式的，就是把列的顺序调换一下：

$ head Features.bed  
chr1    3218610 95674710    TCGA-3C-AAAU-10A-01D-A41E-01    53225   0.0055
chr1    95676511    95676518    TCGA-3C-AAAU-10A-01D-A41E-01    2   -1.6636
chr1    95680124    167057183   TCGA-3C-AAAU-10A-01D-A41E-01    24886   0.0053
chr1    167057495   167059336   TCGA-3C-AAAU-10A-01D-A41E-01    3   -1.0999
chr1    167059760   181602002   TCGA-3C-AAAU-10A-01D-A41E-01    9213    -8e-04
chr1    181603120   181609567   TCGA-3C-AAAU-10A-01D-A41E-01    6   -1.2009
chr1    181610685   201473647   TCGA-3C-AAAU-10A-01D-A41E-01    12002   0.0055
chr1    201474400   201474544   TCGA-3C-AAAU-10A-01D-A41E-01    2   -1.4235
chr1    201475220   247813706   TCGA-3C-AAAU-10A-01D-A41E-01    29781   -4e-04

(3) 命令很简单，如下：
$ bedtools intersect -a Features.bed  -b  ~/reference/gtf/gencode/protein_coding.hg19.position \
-wa -wb   | bedtools groupby -i - -g 1-4 -c 10 -o collapse

参数解释：
-g -grp		Specify the columns (1-based) for the grouping.
			The columns must be comma separated.
			- Default: 1,2,3
-c -opCols	Specify the column (1-based) that should be summarized.
			- Required.
-o -ops		Specify the operation that should be applied to opCol.
			Valid operations:
			    sum, count, count_distinct, min, max,
			    mean, median, mode, antimode,
			    stdev, sstdev (sample standard dev.),
			    collapse (i.e., print a comma separated list (duplicates allowed)), 
			    distinct (i.e., print a comma separated list (NO duplicates allowed)), 
			    distinct_sort_num (as distinct, but sorted numerically, ascending), 
			    distinct_sort_num_desc (as distinct, but sorted numerically, descending), 
			    concat   (i.e., merge values into a single, non-delimited string), 
			    freqdesc (i.e., print desc. list of values:freq)
			    freqasc (i.e., print asc. list of values:freq)
			    first (i.e., print first value)
			    last (i.e., print last value)
			- Default: sum

注释结果如下：可以看到，每个CNV片段都注释到了对应的基因，有些特别大的片段，会被注释到非常多的基因。

chr8    42584924    42783715    TCGA-5T-A9QA-01A-11D-A41E-01    CHRNB3,CHRNA6,THAP1,RNF170,HOOK3
chr8    42789728    42793594    TCGA-5T-A9QA-01A-11D-A41E-01    HOOK3
chr8    42797957    42933372    TCGA-5T-A9QA-01A-11D-A41E-01    RP11-598P20.5,FNTA,HOOK3
chr8    70952673    70964372    TCGA-5T-A9QA-01A-11D-A41E-01    PRDM14
chr10    42947970    43833200    TCGA-5T-A9QA-01A-11D-A41E-01    BMS1,RET,RASGEF1A,ZNF33B,CSGALNACT2
chr10    106384615   106473355   TCGA-5T-A9QA-01A-11D-A41E-01    SORCS3
chr10    106478366   107298256   TCGA-5T-A9QA-01A-11D-A41E-01    SORCS3
chr10    117457285   117457859   TCGA-5T-A9QA-01A-11D-A41E-01    ATRNL1
chr11    68990173    69277078    TCGA-5T-A9QA-01A-11D-A41E-01    MYEOV
chr11    76378708    76926535    TCGA-5T-A9QA-01A-11D-A41E-01    LRRC32,B3GNT6,OMP,TSKU,MYO7A,ACER3,CAPN5






2. 更多实例

加-wa参数可以报告出原始的在A文件中的feature，
加-wb参数可以报告出原始的在B文件中的feature, 
加-c参数可以报告出两个文件中的overlap的feature的数量，
参数-s可以得到忽略strand的overlap

注意：使用tab分割！

(1) 案例一：包含着染色体位置的两个文件，分别记为A文件和B文件。
分别来自于不同文件的染色体位置的交集是什么？
$ cat A.bed
chr1	10	20
chr1	30	40

$ cat B.bed
chr1	15	25

$ bedtools intersect -a A.bed -b B.bed 
chr1	15	20


(2) 案例二：包含着染色体位置的两个文件，分别记为A文件和B文件。
求A文件中哪些染色体位置是与文件B中的染色体位置有overlap.
-wa 报告a中的行。

$ bedtools intersect -a A.bed -b B.bed -wa
chr1	10	20

(3) 案例三：包含着染色体位置的两个文件，分别记为A文件和B文件。
求A文件中染色体位置与文件B中染色体位置的交集，以及对应的文件B中的染色体位置.
-wb 报告交集，及B的行

$ bedtools intersect -a A.bed -b B.bed -wb
chr1	15	20	chr1	15	25




(4) 案例四（常用）： 包含着染色体位置的两个文件，分别记为A文件和B文件。
求对于A文件的染色体位置是否与文件B中的染色体位置有交集。
	如果有交集，分别输入A文件的染色体位置和B文件的染色体位置；
	如果没有交集，输入A文件的染色体位置并以'. -1 -1'补齐文件。

-loj	Perform a "left outer join". That is, for each feature in A report each overlap with B.  
		If no overlaps are found, report a NULL feature for B.
左外连接，保持左边a的完整性。有交集就输出b的行，没有交集则输出 . -1 -1 占位。

$ bedtools intersect -a A.bed -b B.bed -loj
chr1 10 20 chr1 15 25
chr1 30 40 . -1 -1


(5) 案例五： 包含着染色体位置的两个文件，分别记为A文件和B文件。
对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度.

-wo	Write the original A and B entries plus the number of base pairs of overlap between the two features.
		- Overlaps restricted by -f and -r.
		  Only A features with overlap are reported.
报告原始的A和B的行，及重叠的碱基数。
只报告A中有重合的行。

$ cat A.bed
chr1	10	20
chr1	30	40

$ cat B2.bed
chr1	15	20
chr1	18	25

$ bedtools intersect -a A.bed -b B2.bed -wo
chr1	10	20	chr1	15	20	5
chr1	10	20	chr1	18	25	2



(6)  包含着染色体位置的两个文件，分别记为A文件和B文件。
对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度；如果和B文件中染色体位置都没有overlap,则用'. -1-1'补齐文件

加了all参数，则报告全部A的行。

$ bedtools intersect -a A.bed -b B2.bed -wao
chr1	10	20	chr1	15	20	5
chr1	10	20	chr1	18	25	2
chr1	30	40	.	-1	-1	0



(7) 案例七： 包含着染色体位置的两个文件，分别记为A文件和B文件。
对于A文件中染色体位置，输出在A文件中染色体位置和有多少B文件染色体位置与之有overlap.

-c	For each entry in A, report the number of overlaps with B.
	- Reports 0 for A entries that have no overlap with B.
	- Overlaps restricted by -f, -F, -r, and -s.
报告每行A与几个B行重合。

$ bedtools intersect -a A.bed -b B2.bed -c
chr1	10	20	2
chr1	30	40	0




(8) 案例八(常用)： 包含着染色体位置的两个文件，分别记为A文件和B文件。
对于A文件中染色体位置，输出在A文件中染色体位置和与B文件染色体位置至少有X%的overlap的记录。


$ cat A3.bed
chr1	100	200

$ cat B3.bed
chr1	130	201
chr1	180	220

$ bedtools intersect -a A3.bed -b B3.bed -f 0.50 -wa -wb
chr1	100	200	chr1	130	201




========================================
|-- 文件转换 bam to fastq
----------------------------------------
1. 命令使用
bedtools bamtofastq [OPTIONS] -i <BAM> -fq <FASTQ>

可选项
Option	Description
-fq2	FASTQ for second end. Used if BAM contains paired-end data. BAM should be sorted by query name (samtools sort -n aln.bam aln.qsort) if creating paired FASTQ with this option.
-tags	Create FASTQ based on the mate info in the BAM R2 and Q2 tags.




(1)实例: 输入10x 单端一个cell barcode的bam文件
$ bedtools bamtofastq -i ../mapRaw/AGCCTAATCCTGCCAT_raw_R2_Aligned.sortedByCoord.out.bam -fq aa.fq

$ head aa.fq 
@A00129:409:HKVNVDSXX:2:2173:24551:24752
ACCGCCATGGACAACGCCAGCAAGAACGCTTCTGATATGATTGACAAATTGACCTTGACTTTCAACCGCACCCGCCAGGCTGTCATCACAAAGGAGTTGATTGAAATCATCTCTGGGGCTGCTGCTCTGGATTAATGAAAATCAAGTTGC
+
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFF



(2) -fq2 Creating two FASTQ files for paired-end sequences.
注意Note:
When using this option, it is required that the BAM file is sorted/grouped by the read name. 
This keeps the resulting records in the two output FASTQ files in the same order. 
One can sort the BAM file by query name with samtools sort -n aln.bam aln.qsort.


$ samtools sort -n aln.bam aln.qsort

$ bedtools bamtofastq -i aln.qsort.bam \
                      -fq aln.end1.fq \
                      -fq2 aln.end2.fq

$ head -8 aln.end1.fq

ref: https://bedtools.readthedocs.io/en/latest/content/tools/bamtofastq.html



========================================
|-- bedtools 其他小功能
----------------------------------------
1. bedtools merge

用于合并位于同一个bed/gff/vcf 文件中的重叠区域。

$ bedtools merge [OPTION] –i

-s 必须相同(正负)链的区域才合并（软件默认不考虑正负链特征）
-n 报告合并的区域数量，没有被合并则1
-d 两个独立区域间距小于（等于）该值时将被合并为一个区域
-nms 报告被合并区域的名称
-scores 报告几个被合并特征区域的scores




其它小功能
1）pairToPair
比较BEDPE文件搜索overlaps, 类似于pairToBed。

2）bamToBed
将BAM文件转换为BED文件或者BEDPE文件。
bamToBed -i reads.bam

3）windowBed类似于intersectBed, 但是可以指定一个数字，让A中的genome feature增加上下游去和B中的genome features进行overlap。默认情况这个值为1000，可以使用-w加定义，可以用-l指定是上游，用-r指定下游
windowBed -a A.bed -b B.bed -w 5000
windowBed -a A.bed -b B.bed -l 200 -r 20000

4）subtractBed在A中去除掉B中有的genome features
5）coverageBed可以计算深度和覆盖度。如计算基因组任意1Kb的测序read的覆盖度
6）genomeCoverageBed。可以计算给定bam文件在基因组上的覆盖度及每个碱基的深度。











========================================
samtools用法 – Utilities for the Sequence Alignment/Map (SAM) format
----------------------------------------
代码： https://github.com/samtools/samtools
文档： http://www.htslib.org/doc/samtools.html


SAM (Sequence Alignment/Map) format is a generic format for storing large nucleotide sequence alignments. SAM aims to be a format that:
http://samtools.sourceforge.net/


1. [2022.10]CentOS 7.9 重装 samtools 新版本(1.16.1)

git clone https://github.com/samtools/samtools.git
git clone https://github.com/samtools/htslib.git 

先下载子模块
$ cd htslib
$ git submodule update --init --recursive

$ make #编译库


开始编译主程序
$ cd ../samtools
$ autoheader            # Build config.h.in (this may generate a warning about
                      # AC_CONFIG_SUBDIRS - please ignore it).
$ autoconf -Wno-syntax
$ ./configure prefix=/home/wangjl/
$ make 
$ make install


检查版本号
$ samtools --version
samtools 1.16.1-18-g410d910
Using htslib 1.16-10-g6366029
Copyright (C) 2022 Genome Research Ltd.


2. 功能
按照标签筛选序列，标签在文件中
$ samtools view -D BC:barcodes.txt -o /data_folder/data.barcodes.bam /data_folder/data.bam

http://www.htslib.org/doc/samtools-sort.html










### old part: 

1.安装

(1) 方法1：不一定work...
第一步，从github下载所需版本samtools软件包
https://github.com/samtools/samtools


或
https://sourceforge.net/projects/samtools/files/samtools/1.5/
$ wget https://sourceforge.net/projects/samtools/files/samtools/1.10/samtools-1.10.tar.bz2/download


第二步，解压，此处以目前最新版samtools-1.5为例：
tar -jxf samtools-1.5.tar.bz2
cd samtools-1.5


第三步，编译，安装：
make
make prefix=/opt/biosoft/samtools-1.5 install


第四步，加入环境变量
echo 'export PATH=$PATH:/opt/biosoft/samtools-1.5/bin' >> /etc/profile


现在你已经不需要刚刚下载和解压的软件包了，愉快的删除吧。
cd ../ && rm -rf samtools-1.5 samtools-1.5.tar.bz2



bcftools安装几乎完全一样。需要注意的是，此处我用了root账户。对于普通用户，可以把软件安装在自己有读写权限的目录下，也就是说，要更改prefix=xxx和/etc/profile至你自己的文件目录和文件。
https://samtools.github.io/bcftools/howtos/install.html




(2) 方法2：CentOS 亲测可用
从github获取最新版本的包
git clone https://github.com/samtools/samtools.git
git clone https://github.com/samtools/htslib.git #并列放到同一个文件夹下


1)然后安装hslib
autoheader
autoconf
./configure  #根据提醒，先做 $ git submodule update --init --recursive
make
make prefix=~/ install


make 报错:
cram/cram_encode.c: In function ‘cram_build_ref’:
cram/cram_encode.c:2883:17: error: ‘for’ loop initial declarations are only allowed in C99 mode
                 for (int j = 0; j < cigar[i] >> BAM_CIGAR_SHIFT; j++)
                 ^
cram/cram_encode.c:2883:17: note: use option -std=c99 or -std=gnu99 to compile your code
make: *** [cram/cram_encode.o] Error 1
无解，使用 docker Ubuntu 吧。





2)进入samtools文件夹，执行命令：
autoheader            # Build config.h.in (this may generate a warning about
                      # AC_CONFIG_SUBDIRS - please ignore it).
autoconf -Wno-syntax  # Generate the configure script
./configure           # Needed for choosing optional functionality #如果samtool并列没有HTSlib会报错。
##make
##make install #error install: cannot create regular file ‘/usr/local/bin/samtools’: Permission denied

make prefix=~/ install #或在~/bin建软链接
make install


检查版本号：
$ samtools --version
samtools 1.9-69-gb217a91











2. Ubuntu上安装 https://blog.csdn.net/cuicanlianyue/article/details/79458594

git clone https://github.com/samtools/samtools.git
git clone https://github.com/samtools/htslib.git

需要先安装两个库
sudo apt-get install libbz2-dev #进行编译时出现error：建立HTSlib需要libbzip2文件，需要安装
sudo apt-get install liblzma-dev #进行编译时出现error：需要liblzma文件

然后安装htslib
autoheader
autoconf
./configure 
make
make prefix=~/ install
然后同样命令安装samtools











========================================
|-- samtools常用功能：sam-bam格式转化、排序索引
----------------------------------------
Version: 1.9-69-gb217a91 (using htslib 1.9-149-gf5b75ff)

常用语句：
samtools view -bS input.sam >aln.bam 	#1.转换为bam
samtools sort -o aln.sorted.bam aln.bam #2.排序
samtools index aln.sorted.bam 		#3.建索引


适用于1.3及之后的版本。一步sam转bam并排序。老版本需要2步：1先转bam，2再排序。
$ nohup samtools sort -@ 8 -o ERR188044_chrX.bam ERR188044_chrX.sam 2>ERR188044_sam.err &


常用参数: 
$ samtools sort --help
Usage: samtools sort [options...] [in.bam]
-@, --threads INT     线程数 Number of additional threads to use [0]
-o FILE    Write final output to FILE rather than standard output 输出文件



服务器自带的古老的 0.1.19 可能只支持这么写
Usage:   samtools sort [options] <in.bam> <out.prefix>
最后一个是参数是输出文件的前缀，如：
$ samtools sort c12_ROW03.Mm.bam c12_ROW03.Mm.s
吐槽：CentOS7自带的软件版本都太古老！可靠===过时，不适用于追新的科研。还是用Ubuntu省劲，源都比较新。





$ samtools view -@ 10 -bS -F 4 input.sam > aln.bam
## -F INT   only include reads with none of the FLAGS in INT present [0]

$ samtools depth aln.sorted.bam >depth_reads.txt
$ wc -l depth_reads.txt > Coverage-aln_reads.txt


更多命令：http://www.htslib.org/doc/samtools.html






2.sam 和 bam 格式转换
https://www.cnblogs.com/emanlee/p/4316581.html

(1)SAM转换为BAM
samtools view -bS input.sam >out.bam
samtools view -b -S NA12878.sam > NA12878_2.bam

$ samtools view -bS ../c12_A1_Aligned.out.sam -o c12_A1.bam -@ 10

-b 输出BAM format
-S 输入格式自动检查(sam,bam,cram)。 如果@SQ 缺省， 要写-t (?)
-t FILE:  FILE listing reference names and lengths (see long help) [null]
-o File 输出文件名
-@ 额外使用的线程数

所以如果没有@SQ
samtools faidx ref.fa
samtools view -bt ref.fa.fai out.sam > out.bam


(2)BAM转换为SAM
samtools view -h -o out.sam input.bam
samtools view -h NA12878.bam >NA12878_2.sam
# 参数
 -h       include header in SAM output
 -H       print SAM header only (no alignments)

 -@, --threads INT:  Number of additional threads to use [0]
 -o FILE  output file name [stdout] 输出文件名字[默认是输出到屏幕]
 -O, --output-fmt FORMAT[,OPT[=VAL]]...
        Specify output format (SAM, BAM, CRAM) 指定输出文件的格式




3.排序
$ samtools sort c12_A1.bam -o c12_A1.sorted.bam -@ 10
$ samtools sort -T /tmp/aln.sorted -o aln.sorted.bam aln.bam

# -T 是指定临时文件
-o File 输出到文件而不是标准输出
-@ 线程数


4.建索引
$ samtools index aln.sorted.bam

或者批量化
$ head getIndex.sh
for id in `cat id.txt`
do
  samtools index ${id}.sorted.bam;
done





5. 找snp
对于sort和index过的bam文件
$ samtools pileup -vcf  ref.fa  aln.bam | tee raw.txt | samtools.pl varFilter -D100 > flt.txt
以上命令是寻找最大深度为100的SNP，raw.txt是原始SNP的文件

The -D option of varFilter controls the maximum read depth
$ awk '($3=="*"&&$6>=50)||($3!="*"&&$6>=20)' flt.txt > final.txt
以上是根据sam文件的第三列和第六例进行质量控制。这个根据自己设定的阈值，进行筛选。




========================================
|-- 命令行 文本基因组浏览器: samtools tview xx.bam xx.fa
----------------------------------------
1. 文字浏览器:
$ samtools tview -p chr1:3128088 xx.bam hg38.fasta
-p 指定染色体的位置，tview从指定的位置开始显示
xx.bam 比对结果bam文件,需要构建索引（NA12878.bam.bai）
hg38.fasta 比对时使用的fasta文件，如果不提供则第一行会显示为N. 需要提供fai索引（hg38.fasta.fai）



2. docker容器内
$ cd /data/jinwf/wangjl/chenxi/PBMC/18hRep2/
$ samtools tview -p chr1:32631983 B04_bam_pA/pA_GCTATCGG.bam /home/$USER/data/ref/hg38/gencode/GRCh38.p13.genome.fa
按下 “shift+?” 即可显示帮助菜单栏

快捷键:
- 按下 g ，则提示输入要到达基因组的某一个位点
- 使用H(左）J（上）K（下）L（右）移动显示界面。
- Ctrl+H 向左移动1kb碱基； Ctrl+L 向右移动1kb碱基
- space 右翻一屏，backspace 倒着翻一屏（左翻）(这个控制的不好，倒着翻屏的太快)

- 可以用颜色标注比对质量，碱基质量，核苷酸等。
	30～40的碱基质量或比对质量使用白色表示；
	20～30黄色；
	10～20绿色；
	0～10蓝色。
- 使用点号’.'切换显示碱基和点号；
	“.”代表和ref.fa内容完全一样；. (dot) 与正链匹配的碱基
	“，”表示比对到ref.fa的互补链；, (comma) 与反链匹配的碱基
	写了字母就代表mismatch。
		AGTCN (upper case) denotes a base that did not match the reference on the forward strand
		agtcn (lower case) denotes a base that did not match the reference on the reverse strand
- 使用r切换显示read name

更多格式解释: Pileup format https://en.wikipedia.org/wiki/Pileup_format



ref: http://www.chenlianfu.com/?p=1399




========================================
|-- samtools其他功能: 可视化、统计、去重
----------------------------------------
4. tview 直观显示reads比对到基因组的情况，和基因组浏览器有点类似。
-d display		输出类型
-p chr:pos 		直接定位到该位置
-s STR		只显示该sample或group的reads

利用sort进行排序，再利用index建立索引后 samtools tview xx.sort.bam 



(1) 截取bam子集：按染色体、位置
view  从bam/sam文件中提取/打印部分比对结果。默认为所有的区域，也可以染色体区域（1-based，须sort并index）。
例如：
samtools view -bt ref_list.txt -o aln.bam aln.sam.gz
samtools view aln.sorted.bam chr2:20,100,000-20,200,000
samtools view aln.sorted.bam chr2:20,100,000-20,200,000 > sample.sam #到igv中查看

例：
samtools view -b -h B.addgroup.bam chr2 chr3 chr5 >B_others.bam
以空格分隔要截取的染色体数据，这样，得到比对到chr2，chr3，和chr5的部分bam文件，保存在B_others.bam文件中。
-h: 输出的sam文件带header，默认不带

samtools view -b -h 225.sort.bam chr14 >sample.bam
samtools view -b -h 225.sort.bam chr7 >sample.bam
samtools index sample.bam 
## 然后可以用IGV载入了。
## 太慢了，可以考虑多线程 -@ 20



(2) 截取 bam 子集，按照flag(就是sam的第2列)
https://www.bioinfo-scrounger.com/archives/245/

1 0x1 这序列是PE双端测序
2 0x2 这序列和参考序列完全匹配，没有错配和缺失
4 0x4 这序列没有mapping到参考序列上
8 0x8 这序列的mate序列没有mapping到参考序列上
16 0x10 这序列比对到参考序列的负链上
32 0x20 这序列的mate序列比对到参考序列的负链上
64 0x40 这序列是read1
128 0x80 这序列是read2
256 0x100 这序列不是【主要的比对】，因为序列可能比对到参考序列的多个位置上
512 0x200 这序列没有通过QC
1024 0x400 这序列是PCR重复序列
2048 0x800 这序列是补充比对

$ samtools view [options] in.sam|in.bam|in.cram [region...]
-f INT   only include reads with all  of the FLAGs in INT present [0]
-F INT   only include reads with none of the FLAGS in INT present [0]
-G INT   only EXCLUDE reads with all  of the FLAGs in INT present [0]

-f 提取 ## -f 4 提取出没有mapping上的reads
-F 过滤 ## -F 4 过滤掉没有mapping上的reads，也就是说提取出mapping上的reads
-u 输出格式为未压缩的bam格式
-q 过滤掉MAPQ值低某个阈值 ## -q 1 过滤掉MAPQ值低于1的情况
-h 设定输出的SAM文件带有header
-b 输出格式设定为BAM
-S 输入格式为SAM

按flag提取的示例
提取比对到参考序列的结果: samtools view -bF 4 tmp.bam > tmp_F.bam
提取双端序列都比对到参考序列（4+8）的结果：samtools view -bF 12 tmp.bam > tmp_F.bam
提取比对到chr1的结果 samtools view -b tmp.bam chr1 > tmp_chr1.bam

默认
$ samtools view map/c13ROW40_Aligned.sortedByCoord.out.bam|awk '{print $2}' | sort | uniq -c
   7777 0
   6124 16
   1632 256
   1258 272

只要比对到负链上的
$ samtools view -f 16 map/c13ROW40_Aligned.sortedByCoord.out.bam|awk '{print $2}' | sort | uniq -c
   6124 16
   1258 272

只要主要比对，次要比对去掉
$ samtools view -F 256 map/c13ROW40_Aligned.sortedByCoord.out.bam|awk '{print $2}' | sort | uniq -c
   7777 0
   6124 16

一下两条对比可见，MAPQ=255的全部是最佳比对(过滤前后counts一样)。而主要比对并不全是MAPQ=255的，为什么不是全部？
$ samtools view -F 256 map/c13ROW40_Aligned.sortedByCoord.out.bam|awk '{print $5}' | sort | uniq -c
    140 0
    438 1
  12234 255
   1089 3
$ samtools view map/c13ROW40_Aligned.sortedByCoord.out.bam|awk '{print $5}' | sort | uniq -c
    935 0
   1444 1
  12234 255
   2178 3






(3) 保留 mapQ=255 (第5列)
$ samtools view -h -q 255 -F 4 -F 256 -b  c12ROW02_A2Aligned.sortedByCoord.out.bam > c12ROW02_A2.sort.dedup.unique.bam
-q 1：过滤掉比对质量小于1的reads；
-F 4：过滤掉没有比对上的reads；
-F 256：过滤掉比对上的多次的reads。
-b 输出二进制 bam文件

$ samtools view c12ROW02_A2.sort.dedup.unique.bam |awk '{print $5}' | sort | uniq -c
3546246 255





(4) 
samtools tview -p B05:53425172 accepted_hits.bam Bju.genome.fa
“.” 比对到正链;
“，” 表示比对到负链;
“<”或“>” 表示reference skip   RNA-seq当中内含子剪切;
"ATCGN"  表示正向mismatch;
"atcgn"  表示反向mismatch;
‘+[0-9]+[ACGTNacgtn]+’ insertion;
‘-[0-9]+[ACGTNacgtn]+’ 表示deletion;
“^”标记reads起始;
“$”标记reads segment结尾;

实例









5.flagstat 对reads的比对情况统计

samtools flagstat xx.sort.bam 





6.depth 每个碱基位点的测序深度
samtools depth [options] [in1.sam|in1.bam|in1.cram [in2.sam|in2.bam|in2.cram] [...]]

-a 输出所有的碱基深度，包括0
-b/-r 控制深度的范围(后面跟染色体)
-f bam文件名字
-l 设置read长度阈值
-d/-m 最大覆盖深度
-q 碱基质量阈值
-Q 比对质量阈值

samtools depth -a -r chr3 x.sort.bam 
#显示chr3染色体上所有碱基的测序深度，
第一列chr名字，第二列碱基位置，第三列测序深度。


$ samtools depth -r chr1:1116029-1116298 -d 10000000 -a xx.bam >  xx.coverage







7.mpileup 对参考基因组每个位点做碱基堆积，用于call SNP和INDEL。主要是生成BCF、VCF文件或者pileup一个或多个bam文件。比对记录以在@RG中的样本名作为区分标识符。如果样本标识符缺失，那么每一个输入文件则视为一个样本。

用法：
生成一个简单的vcf文件
samtools mpileup -vu test.sort.bam

如果有参考基因组的话
samtools mpileup -vuf genome.fasta  test.sort.bam



7.dict 建立参考基因组字典
samtools dict  test.sort.bam sequences.fa 




8.fastq bam文件转换为fastq
samtools fastq test.bam



9.idxstats 检索和打印与输入文件相对应的index file里的统计信息
Usage: samtools idxstats <in.bam>

用法：
samtools idxstats test.sort.bam
结果返回一个表格，4列。
第一列：染色体名
第二列：序列长度
第三列：比对上的reads数
第四列：未比对数目



10. stats 对bam文件做详细统计,其统计结果可用mics/plot-bamstats作图
samtools stats test.bam

输出的信息比较多，部分如下：
Summary Numbers，raw total sequences，filtered sequences, reads mapped, reads mapped and paired,reads properly paired等信息
Fragment Qualitites：根据cycle统计每个位点上的碱基质量分布
Coverage distribution：深度为1，2，3，，，的碱基数目
ACGT content per cycle：ACGT在每个cycle中的比例
Insert sizes：插入长度的统计
Read lengths：read的长度分布






========================================
|-- bam 抽样: 随机百分比抽样、按 cell barcode 抽样
----------------------------------------

1. 随机按百分比抽样
(1). 取样 25%
$ samtools view -s 0.25 -b BMMC_donor1_chr7.bam > BMMC_donor1_chr7.sample0.25.bam
要加 -h 标签吗？不需要
$ samtools view -h BMMC_donor1_chr7.sample0.25.bam | less #结果中自动有head信息

(2). 取样 5%
$ samtools view -s 0.05 -b -@ 50 BMMC_donor1_chr7.bam > BMMC_donor1_chr7.sample0.05.bam


查看大小:
$ ls -lth bams/
total 881M
-rw-r--r-- 1 wangjl jinwf  39M May 20 21:47 BMMC_donor1_chr7.sample0.05.bam
-rw-r--r-- 1 wangjl jinwf 177M May 20 21:45 BMMC_donor1_chr7.sample0.25.bam
-rw-r--r-- 1 wangjl jinwf 667M May 20 21:39 BMMC_donor1_chr7.bam



2. 按 cell barcode 抽样
https://www.htslib.org/doc/samtools-view.html

Only keep reads with tag BC and were the barcode matches the barcodes listed in the barcode file.
$ samtools view -D BC:barcodes.txt -o /data_folder/data.barcodes.bam /data_folder/data.bam

注意根据bam文件的标签修改合适的标签名字。对于 10x cell ranger 产生的bam文件，cell barcode 是 CB:
D000684:453:HJ7VJBCXX:1:2214:13656:49037        272     1       10002   1       98M     *       0       0       AACCCTTATCCTATCCCTAACCCTATCCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAA      <<...<.....<...<<<<<.GA<..<A<<<..AG<..AGA<<...<<.<.GGAA.IGGGGAGGGA<<GGGGG<AGG<AGIIIGIIIGGAGG<GGGAG      NH:i:3  HI:i:3  AS:i:88 nM:i:4  NM:i:4  CR:Z:CCCAACACGCTAAC     CQ:Z:GGA<AGAAAGGGGG     CB:Z:CCCAACACGCTAAC-1   UR:Z:CGCTG      UQ:Z:GGAAA      UB:Z:CGCTG      BC:Z:CCTGCGGT   QT:Z:AGGAGIIG









========================================
|-- bam 去重: remove PCR 重复 [推荐 gatk MarkDuplicates 一步法]
----------------------------------------
1. 基本原则

RNA-seq一般不去重复
ChIP-seq一般去重复
call SNP一般去重复

还需参考起始量和PCR扩增数判断是否去重复。reads mapping覆盖均匀度可以判断是否需要去重复。

PCR去重工具首选Picard

根源上解决去重复问题：起始量高，循环数少，reads能长不短，能双端不单端



2. PCR重复的危害
理论上不同序列在PCR扩增时，扩增的倍数应该相同。但是由于聚合酶的偏好性，PCR扩增次数过多的情况下，会导致一些序列持续扩增，而另一些序列扩增到一定程度后便不再进行，也就是常说的PCR偏好性。

这种情况对于定量分析（如ChIP-seq），会造成严重影响。此外，PCR扩增循环数过多，会出现一些扩增偏差，进而影响一些突变识别（比如call SNP)的置信度。

因此，在一些NGS分析流程中需要考虑去除PCR重复。但这并不代表可以无脑去除。

测序所得到的reads是由于超声波或者酶切断裂得到的，这些reads比对到基因组上的位置是完全随机。那么两个reads比对到相同位置的概率是非常低的。如果两个reads比对情况相同或者极其相似，则很有可能是由于PCR重复所导致的。而我们常用的去重工具主要也是遵循这一思想。








3. PCR 去重 
(1) samtools markdup
操作SAM/BAM文件，samtools肯定是首选的工具。在samtools中也提供了去除PCR重复的命令markdup, 该命令对输入的bam文件有以下两点要求

必须是经过samtools fixmate命令处理之后的文件

必须是按照比对上染色体坐标位置排序之后的文件

另外，由于fixmate命令要求输入的bam文件为按照read name,即序列名称排序之后的文件，所以在使用markdup命令时，需要以下4步转换过程
 

# 第一步，按照read name排序bam文件
samtools sort -n -o namesort.bam input.bam
# 第二步，运行fixmate命令
samtools fixmate -m namesort.bam fixmate.bam
# 第三步，按照coordinate排序bam文件
samtools sort -o positionsort.bam fixmate.bam
#第四步，运行markdup命令
samtools markdup positionsort.bam markdup.bam

虽然samtools处理bam文件的速度很快，但是经过这一系列的排序操作之后，整个duplicate做的过程耗时非常久。





(2)【过时】rmdup一般已经过时，一般不要用这个方法！(我的 samtools v1.9 直接输入 samtools 回车已经没有这个子命令了)
rmdup 将由PCR duplicates 获得的reads去掉，并保留高比对质量的reads
-s    rmdup for SE reads
-S    treat PE reads as SE in rmdup (force -s)
用法：
samtools rmdup -sS test.bam  output.bam

单端测序结果去除PCR重复
$ samtools rmdup -s tmp.sorted.bam tmp.rmdup.bam

仔细探究samtools的rmdup是如何行使去除PCR重复reads功能的
http://www.bio-info-trainee.com/2003.html

只需要开始-s的标签， 就可以对单端测序进行去除PCR重复。其实对单端测序去除PCR重复很简单的~，因为比对flag情况只有0,4,16，只需要它们比对到染色体的起始终止坐标一致即可，flag很容易一致。

但是对于双端测序就有点复杂了~

很明显可以看出，去除PCR重复不仅仅需要它们比对到染色体的起始终止坐标一致，尤其是flag，在双端测序里面一大堆的flag情况，所以我们的94741坐标的5个reads，一个都没有去除！


这样的话，双端测序数据，用samtools rmdup效果就很差，所以很多人建议用picard工具的MarkDuplicates 功能~~~
The optimal solution depends on many factors - the consensus seems to be the the picard markduplicates could be the best current solution.
最优的方案依赖很多因素，最一致的似乎就是picard markduplicates 可以达到目前最好的结果。

The appropriateness of duplicate removal depends on coverage - one would want to only remove artificial duplicates and keep the natural duplicates.
去除重复的适当性取决于覆盖度——人们只希望去除人工重复并保留自然重复。

MarkDuplicates is "more correct" in the strict sense. Rmdup is more efficient simply because it does handle those tough cases. Rmdup works for single-end, too, but it cannot do paired-end and single-end at the same time. It does not work properly for mate-pair reads if read lengths are different.
MarkDuplicates功能在严格模式下更“正确”，rmdup更高效仅仅是因为它确实处理这些事情。rmdup对于SE数据有效，但是对于同时有PE和SE的无效，对于长度不等的 mate-pair数据也无效。








4. picard 或者 gatk MarkDuplicates 子命令
Picard也是一款去重的软件，只不过要用Java来启动它，所以你的服务器上要安装Java
下载地址：https://github.com/broadinstitute/picard/releases/tag/2.21.6
选择第一个，直接下载就可以用了.

picard的MarkDuplicates命令称得上是使用的最广泛的去除PCR重复的工具了，要求输入的bam文件为按照比对位置排序之后的文件，用法如下
但是利用picard去重所用的sam文件或者bam文件是需要加header的，如果你的文件没有，我们可以用samtools加个表头：

#加header
samtools view -Sb -T genome.fa sample_no_header.sam >sample_with_header.bam
#genome.fa为参考基因组序列
并且bam文件还是要按名字排过序的：

#按名字排序
samtools sort -n -o sorted.bam unsorted.bam

Picard去重：
$ java -jar ~/biosoft/picard.jar MarkDuplicates
REMOVE_DUPLICATES=true
I= input.bam
O= output.bam
M= out.txt \ #相当于log文件



(2) 教程2: 不好

# 第一步，按照coordinate排序bam文件
samtools sort -o positionsort.bam input.bam
# 第二步，运行MarkDuplicate命令
java -jar picard.jar MarkDuplicate \
I=positionsort.bam \
O=markdup.bam \
M=markdup.metrc.csv #相当于日志文件


(3) 实例: 对于 STAR 的输出文件进行去重:
$ gatk MarkDuplicates \
--REMOVE_DUPLICATES=true \
-I=map/SRR9689349_Aligned.sortedByCoord.out.bam \
-O=rmdup/gatk_markdup.bam \
-M=rmdup/gatk_markdup.metrc.csv

输入文件:
map/SRR9689349_Aligned.sortedByCoord.out.bam #7536360=7,536,360=7.536M
输出文件:
rmdup/gatk_markdup.bam #3250342=3,250,342=3.25M






========================================
|-- 合并几个bam文件: samtools merge output.bam 1.bam 2.bam ...
----------------------------------------
例: 把c1-c4合并成total.bam文件 

$ samtools merge total.bam c1.bam c2.bam c3.bam c4.bam


例2: 把某个文件夹下的一类 bam 全部合并
$ samtools merge merged/total.bam `ls map_clean/*final.bam |xargs`



一般合并后要 index 一下：
$ samtools merge -@ $threads condition1.merged.bam sample1.bam sample2.bam sample3.bam
$ samtools index -@ $threads condition1.merged.bam






========================================
|-- How to calculate coverage using samtools
----------------------------------------

1. Command to calculate coverage from bam file:

$ samtools sort accepted_hits.bam -o sorted_accepted_hits.bam
$ samtools index -b sorted_accepted_hits.bam
$ samtools view -b sorted_accepted_hits.bam > accepted_reads.bam

$ samtools depth accepted_reads.bam > read_coverage.txt

ref: https://github.com/arefeen/TAPAS






========================================
|-- Python包pysam: htslib(samtools) interface for python
----------------------------------------
https://pysam.readthedocs.io/en/latest/index.html
Pysam is a python module for reading, manipulating and writing genomic data sets.

1.
>>> line2
<pysam.libcalignedsegment.AlignedSegment object at 0x7f68cb20f888>
>>> samfile
<pysam.libcalignmentfile.AlignmentFile object at 0x7f68ca3800d0>

2. line2的方法名：
['__class__', '__copy__', '__deepcopy__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__pyx_vtable__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'aend', 'alen', 'aligned_pairs', 'bin', 'blocks', 'cigar', 'cigarstring', 'cigartuples', 'compare', 'flag', 'get_aligned_pairs', 'get_blocks', 'get_cigar_stats', 'get_overlap', 'get_reference_positions', 'get_reference_sequence', 'get_tag', 'get_tags', 'has_tag', 'infer_query_length', 'infer_read_length', 'inferred_length', 'is_duplicate', 'is_paired', 'is_proper_pair', 'is_qcfail', 'is_read1', 'is_read2', 'is_reverse', 'is_secondary', 'is_supplementary', 'is_unmapped', 'isize', 'mapping_quality', 'mapq', 'mate_is_reverse', 'mate_is_unmapped', 'mpos', 'mrnm', 'next_reference_id', 'next_reference_name', 'next_reference_start', 'opt', 'overlap', 'pnext', 'pos', 'positions', 'qend', 'qlen', 'qname', 'qqual', 'qstart', 'qual', 'query', 'query_alignment_end', 'query_alignment_length', 'query_alignment_qualities', 'query_alignment_sequence', 'query_alignment_start', 'query_length', 'query_name', 'query_qualities', 'query_sequence', 'reference_end', 'reference_id', 'reference_length', 'reference_name', 'reference_start', 'rlen', 'rname', 'rnext', 'seq', 'setTag', 'set_tag', 'set_tags', 'tags', 'template_length', 'tid', 'tlen', 'tostring']

3. 常用方法
line2.get_tags()[2]
a=line2

#获取所有标签，并给出第n个。缺点：这些数据并不是标准化的，标签位置不完全一样。
a.get_tags()[9] #('CB', 'ACACCCTCATCGGACC-1')
a.get_tags()[12] #('UB', 'ATACATGGTA')

line.get_tag("NH")!=1 #标签NH是否为1
line.has_tag("CB") #是否有CB标签

line.cigarstring # 匹配情况 1S74M
line.flag #16 表示负链， 0表示正链



4.实例代码：从bam文件中逐行读取，NH不等于1的不要，不包含键CB或UB的不要，CB不在预定列表内的不要，
通过三种过滤的条目，保存到一个bam文件。

$ cat filterBAMby3rules_B116.py
################
#第3个脚本，按照NH、CB_UB、cell barcode list过滤bam文件
################
import re
import time
import os


######### 需要修改的文件名
projectName="B116"
path_in = '../hg19_B116/outs/'
fcb=open("B116"+"_CellBarCode_list.txt",'r') #cell barcode部分
########

#读取cb
cbset=set();#cb保存的地方
for lineR in fcb.readlines():
    arr=re.split(" ",lineR.strip())
    cbset.add( arr[0] )
print(len(cbset)) #5973 cell barcode


#读取bam文件
import pysam
samfile = pysam.AlignmentFile(path_in+"possorted_genome_bam.bam", "rb")
#写入bam文件
samOut=pysam.AlignmentFile(projectName+"_NH_CB_list_filtered.bam", "wb",template=samfile)

print("begin for") #
i=0
for line in samfile:
    i=i+1
    ######################
    #进度条
    ######################
    if i%1000000==0:
        tstr=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        print( tstr+" Processing line:",i)
    #if i>10000:
    #    pass
        #break

    #########
    #三次过滤
    #1
    if line.get_tag("NH")!=1:
        continue;
    #2
    if (not line.has_tag("CB")) or (not line.has_tag("UB")):
        continue;
    #3
    cb=line.get_tag("CB")
    if cb not in cbset:
        continue;

    #########
    #写入文件
    samOut.write(line)


#关闭文件
fcb.close()
samfile.close()
samOut.close()

print("===the End===")











========================================
|-- samtools faidx 命令: 生成fa索引，或者提取提取fa中的序列
----------------------------------------
1.对fasta 序列建立一个后缀为.fai 的文件

$ samtools faidx xx.fa
该命令对输入的fasta序列有一定要求：对于每条序列，除了最后一行外， 其他行的长度必须相同

$ xx.fa
>one
ATGCATGCATGCATGCATGCATGCATGCAT
GCATGCATGCATGCATGCATGCATGCATGC
ATGCAT
>two another chromosome
ATGCATGCATGCAT
GCATGCATGCATGC

最后生成的.fai文件如下， 共5列，\t分隔；
one	66	5	30	31
two	28	98	14	15

第一列 NAME   :   序列的名称，只保留“>”后，第一个空白之前的内容；
第二列 LENGTH :   序列的长度， 单位为bp；
第三列 OFFSET :   第一个碱基的偏移量， 从0开始计数，换行符也统计进行；
第四列 LINEBASES : 除了最后一行外， 其他代表序列的行的碱基数， 单位为bp；
第五列 LINEWIDTH : 行宽， 除了最后一行外， 其他代表序列的行的长度， 包括换行符。
	在linux系统中换行符为\n, 要在序列长度的基础上加1；
	在windows系统中换行符为\r\n, 要在序列长度的基础上加2；



(2) 提取序列：
$ samtools faidx input.fa chr1 > chr1.fa
$ samtools faidx input.fa chr1:100-200 > chr1.fa

测试
$ samtools faidx xx.fa one 
>one
ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGC
ATGCAT


对于UCSC的chr肯定是可以用的：
>chr1
>chr2
...

对于ensemble呢？可行
>1 dna:chromosome chromosome:GRCh38:1:1:248956422:1 REF
>2 dna:chromosome chromosome:GRCh38:2:1:242193529:1 REF


# samtools faidx input.fa 1 > chr1.fa
# head -n 2 chr1.fa

# samtools faidx input.fa 1 2 3 > chr1+2+3.fa
# samtools faidx input.fa chr1 chr2 chr3 > chr1_2_3.fa 


提取all：
$ samtools faidx GRCh37.p13.genome.fa chr1 chr2 chr3 chr4 chr5 chr6 chr7 chr8 chr9 chr10 chr11 chr12 chr13 chr14 chr15 chr16 chr17 chr18 chr19 chr20 chr21 chr22 chrX chrY > GRCh37.chr.fa







========================================
提取参考基因组某位置的碱基(4种方法)： 根据基因组坐标获得碱基序列(注意bed文件是0-based)
----------------------------------------

1. 利用samtools faidx
samtools faidx 常常用来对参考基因组建立索引，但它还有个鲜为人知的功能，就是序列提取，如下：
-i, --reverse-complement Reverse complement sequences. 反向互补


(1)实例1：(+链上)获得bam文件后面的几个碱基
$ samtools view rmdup_c16_ROW17.bam |head -n 25008|tail -n 1
E00300:165:H3CMMALXX:5:1118:27082:64896	0	chr14	56078824	255	115M	*	0	0	GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAG	AAFFFKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKFFKKKKKKKFKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK	NH:i:1	HI:i:1	AS:i:113	nM:i:0


$ bedtools bamtobed -i rmdup_c16_ROW17.bam |head -n 25008|tail -n 1
chr14	56078823	56078938	E00300:165:H3CMMALXX:5:1118:27082:64896	255	+

结论： bed的坐标是0-based，比原始bam文件(和genome坐标)小1。 



#samtools根据sam坐标获取序列：起点bed比bam小1， 终点56078824+115-1=56078938 同bed。
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr14:56078824-56078938
>chr14:56078824-56078938
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCA
AAACAGAAAAGAGAACAAAAGCTTATTCCTACCaaaacagataaaaagaaagcag
##去掉换行符和第一行，多行变一行。和bam文件中的目标序列一致: 
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr14:56078824-56078938 | grep -v ">" | awk BEGIN{RS=EOF}'{gsub(/\n/,"");print}' 
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCaaaacagataaaaagaaagcag

查看下游10nt在genome上是什么碱基？(start=oldEnd 算一个， end=start+10-1)
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr14:56078938-56078947 | grep -v ">" | awk BEGIN{RS=EOF}'{gsub(/\n/,"");print}' 
gaaaagaaaa #不能包含这个上一个的结束，此后的序列，则应该末尾坐标+1。

#start=oldEnd+1; end=start+10-1
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr14:56078939-56078948 | grep -v ">" | awk BEGIN{RS=EOF}'{gsub(/\n/,"");print}'
aaaagaaaaa  #该位置后面在基因组上有4个A。



2)搜索原始RNAseq raw data，发现该序列后面是polyA。不过polyA前面多事GA或TA，而refer后面也有A，不过没有RNA那么多，也就是无法判断从哪里断开的。
$ grep -i GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCaaaacagataaaaagaaagcag c16_ROW17.10A.fq 
CCTTCAATAGTTATTACAGTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAGAAAAAAAAAAAAAAAAA
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAGG
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAGTAAAAAAAAAAAAAAAATAAAAATAAAAAAAATTT
AGTTATTACAGTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAGTAAAAAAAAAAAAAAAAAAAAAAAA
CAGTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCAAAACAGATAAAAAGAAAGCAGTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA





(2)实例2：(-链上)获得bam文件后面的几个碱基
$ samtools view rmdup_c16_ROW17.bam |head -n 10000|tail -n 1
E00300:165:H3CMMALXX:5:1110:4208:28294	16	chr11	65651393	255	49M	*	0	0	CCAAACTCAGAGCAACTTTATTGTCAGCATGGGCGGAGCGTTGGGAGGC	KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKFFFAA	NH:i:1	HI:i:1	AS:i:46	nM:i:1
[wangjl@bio_svr1 MAPQ255]$

$ bedtools bamtobed -i rmdup_c16_ROW17.bam |head -n 10000|tail -n 1
chr11	65651392	65651441	E00300:165:H3CMMALXX:5:1110:4208:28294	255	-

#samtools根据sam坐标获取序列：起点bed比bam小1， 终点 65651393+49-1=65651441 同bed。
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr11:65651393-65651441
>chr11:65651393-65651441
CCAAACTCAGAGCAACTTTATTGTCAGCGTGGGCGGAGCGTTGGGAGGC

CCAAACTCAGAGCAACTTTATTGTCAGCA (from RNA seq). RNA结果其实和refer相差一个碱基


查看下游10nt在genome上(因为是负链，其实是genome上游)是什么碱基？(end=oldStart-1, start=start-10+1)
$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr11:65651389-65651398 | grep -v ">" | awk BEGIN{RS=EOF}'{gsub(/\n/,"");print}'
GTCTCCAAAC #测试发现向右多延伸5个碱基，出现CCAAAC结尾，3'端多6个碱基。

$ samtools faidx /home/wangjl/data/ref/hg19/hg19.fa chr11:65651383-65651392 | grep -v ">" | awk BEGIN{RS=EOF}'{gsub(/\n/,"");print}'
GGACCAGTCT
#右端没有出现genomic polyT。


2)bam是按照refer的顺序写的RNA序列，序列保留了RNA的突变信息。+基因和RNA相同，-链基因则和RNA序列反向互补。
搜原始RNA raw data时，需要求bam序列的反向互补序列。
$ grep GCCTCCCAACGCTCCGCCCATGCTGACAATAAAGTTGCTCTGAGTTTGG c16_ROW17.10A.fq 
GCCTCCCAACGCTCCGCCCATGCTGACAATAAAGTTGCTCTGAGTTTGGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATCGGCAGATGCAGATGGGAAGAGCGTCGGGTGGGGAAAGAGTGTAGATCTCGGTGGTCGCCGTATCATTA







(3)根据 序列ID 查找序列(fq/sam/bed)
$ head -n 1272166 c16_ROW17.fq|tail -n 1
GTAGATGCTATAATAAAAATAGCTGTTTGGTAACCATAGTTTCACTTGTTCAAAGCTGTGTAATCGTGGGGGTACCATCTCAACTGCTTTTGTATTCATTGTATTAAAAGAATCTGTTTAAACAACAAAAAAAAAAAAAAAAAAAAAAAA
$ head -n 1272165 c16_ROW17.fq|tail -n 1
@E00300:165:H3CMMALXX:4:2209:10774:12666 2:N:0:TAGGCATG

$ grep E00300:165:H3CMMALXX:4:2209:10774:12666 2:N:0:TAGGCATG  c16_ROW17.sam
grep: 2:N:0:TAGGCATG: No such file or directory #说明到空格name就断开了
c16_ROW17.sam:E00300:165:H3CMMALXX:4:2209:10774:12666	0	chr5	10265001	255	126M	*	0	0	GTAGATGCTATAATAAAAATAGCTGTTTGGTAACCATAGTTTCACTTGTTCAAAGCTGTGTAATCGTGGGGGTACCATCTCAACTGCTTTTGTATTCATTGTATTAAAAGAATCTGTTTAAACAAC	AAFFFKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKFKKKKKKKKKKKKKKKKKKKKKKKKKKFKKKKKKKKKKKKKKKKKAFKKKK	NH:i:1	HI:i:1	AS:i:124	nM:i:0

$ grep E00300:165:H3CMMALXX:4:2209:10774:12666 h_c16_ROW17.bed 
chr5	10265000	10265126	E00300:165:H3CMMALXX:4:2209:10774:12666	255	+











2. 利用bedtools getfasta (只能输出到文件，但可以批量处理)
bedtools说明文档中对getfasta的描述是“Extract DNA sequences into a fasta file based on feature coordinates.”显而易见，bedtools getfasta的功能就是根据坐标信息提取序列信息。操作如下：


需要准备bed文件，至少三列chr start end。
$ cat pos.bed 
chr14	56078823	56078938	E00300:165:H3CMMALXX:5:1118:27082:64896	255	+

$ bedtools getfasta -fi /home/wangjl/data/ref/hg19/hg19.fa -bed pos.bed -s -fo result.txt
bedtools getfasta有三个必选参数：
-fi即参考基因组fasta文件；
-bed即需要提取的位置坐标信息，格式：chr\tstart\tend；
-fo：输出文件。
-s	Force strandedness. If the feature occupies the antisense, strand, the sequence will be reverse complemented. 根据第六列信息，如果是-则给出反向互补序列。
	- By default, strand information is ignored. 
	不加-s则默认忽略掉链方向，也就是都按照+处理。
有一点需要说明，bedtools接收的是bed文件，而bed文件是0-based。
要获取chr1:n位点的序列，就需要减去1，前闭后开区间 chr1:(n-1)-n

$ cat result.txt 
>chr14:56078823-56078938(+)
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCaaaacagataaaaagaaagcag


(2)如果位置文件有很多行bed格式数据，则能批量获取reads。









3. 利用Python3的pysam模块
import pysam 
ref=pysam.FastaFile("/home/wangjl/data/ref/hg19/hg19.fa")
chr,start,end='chr14','56078823','56078938' #如果是bed文件坐标，则直接用；如果是sam文件坐标，start要减1。
print(ref.fetch(chr)[int(start)-0: int(end)])

## 
GTAATTTTCCTCTTCTTCTGGCTTTTCATGAAAGAAACATTATATGATGAAGTTCTTGCAAAACAGAAAAGAGAACAAAAGCTTATTCCTACCaaaacagataaaaagaaagcag








4.使用UCSC的web接口
http://genome.ucsc.edu/cgi-bin/das/hg19/dna?segment=chr14:56078824,56078938
说明： 使用的起始位置是bam文件中的，比bed文件大1。end=start+115-1，和bed一致。

去除空格后，和上文序列一致。
gtaattttcctcttcttctggcttttcatgaaagaaacattatatgatgaagttcttgcaaaacagaaaagagaacaaaagcttattcctaccaaaacagataaaaagaaagcag








5. 性能比较
三种方法耗时如下：
 	  samtools	bedtools	python
time	0.002s	0.034s	2.077s
可以看出，samtools和bedtools的性能很好，python的性能就比较尴尬了。

其实，个人比较推荐bedtools，比较容易进行批量处理，把想处理的位置信息写到输出文件，然后就可以轻松的进行序列提取。


refer: https://blog.csdn.net/whenfree/article/details/85305616






========================================
判断测序文库的链特异性: IGV法, RSeQC统计法
----------------------------------------

#################
#一、IGV法
#################

1.官网
http://www.igv.org/
http://software.broadinstitute.org/software/igv/

官方培训文档： http://www.igv.org/workshops/




#IGV color: A(009600)green; T(FF0000)red; G(D17105)orange; C(0000FF)blue



2. 安装 
(1)
略


3.首先，需要辨明正反链，正义/反义链，编码链，模板链的概念。

DNA 的正链和负链，就是那两条反向互补的链。参考基因组给出的那个链就是所谓的正链（forword），另一条链是反链（reverse）。但是这正反一定不能和正义链（sense strand）反义链（antisense strand）混淆，两条互补的DNA链其中一条携带编码蛋白质信息的链称为正义链，另一条与之互补的称为反义链。但是携带编码信息的正义链不是模板，只是因为它的序列和RNA相同，正义链也是编码链。而反义链虽然和RNA反向互补，但它可是真正给RNA当模板的链，因此反义链也是模板链。

总结两点
- 正义链（sense strand）= 编码链（coding strand）= 非模板链
- forword strand 上可以同时有sense strand 和 antisense strand。因为这完全是两个不同的概念。


(2)最后谈谈正链和正义链。
正链一般是固定的，DNA双链中上面这条链就是正链（+）。
正义链是相对的，它是依据基因的转录方向看的，向右转录（👉）的基因，正链即是它的正义链或有义链或非模板链，向左转录（👈）的基因，负链即是它的正义链。





4.操作步骤
(1).使用star比对获得bam文件
然后对bam文件 sort和index。
如果是star获得的sort过的bam，只需要再用samtools index即可。


(2).使用IGV看比对结果
1) 向IGV中导入参考基因组
Genomes -> Creat a .genome file…
在弹出窗口中加入基因组序列fasta文件与基因组结构注释gff/gtf文件

2)导入比对文件
File -> Load from File…
比对的bam/sam文件需要具有索引
左侧右键，勾上“show coverage track”，即可看到比对上的reads数目和方向。



可能还需要选择菜单 Tools - run igvtools, 把bam转变成tdf文件。
关掉igv，再重新load bam文件，才能看到reads的峰值。




3)检验转录组文库是否具有链特异性

(右键track, 选color alignments by | read strand )
在IGV的Read strand模式中，显示的reads分为红蓝两色，其中红色代表read方向与DNA正链方向相同(5’ -> 3’)，蓝色代表read方向与DNA正链方向相反


如果是双端测序：在First-of-pair strand模式中，红色代表成对的reads中，第一链的方向与正链相同(5’ -> 3’)，蓝色代表成对的reads中，第一链的方向与正链相反(5’ -> 3’)。这对于展示链特异性的文库特别有帮助。
也就是说双末端测序，第一次测得是反义链，第二次测得是正义链。这应该就是链特异性建库。



### For a given transcript, non-directional libraries will show a mix of red and blue reads aligning to the locus.
Directional libraries will show reads of one color in the direction matching the transcript orientation.
### 对于非链特异性的文库，匹配到同一个基因的reads会表现出红蓝混合的情况；
### 对于链特异性的文库，匹配到同一个基因的reads则会表现出与转录本方向相匹配的颜色。




refer:
https://sr-c.github.io/2018/11/06/STAR/
http://www.omicsclass.com/article/300


什么是链特异性建库？https://www.jianshu.com/p/a63595a41bed





#################
#二、使用RSeQC统计
#################
http://rseqc.sourceforge.net/#infer-experiment-py


$ infer_experiment.py -r /home/wangjl/data/ref/hg19/hg19_ucsc_genes-20190509.bed -i c16_ROW17.bam
Reading reference gene model /home/wangjl/data/ref/hg19/hg19_ucsc_genes-20190509.bed ... Done
Loading SAM/BAM file ...  Total 200000 usable reads were sampled


This is SingleEnd Data
Fraction of reads failed to determine: 0.0717
Fraction of reads explained by "++,--": 0.9136
Fraction of reads explained by "+-,-+": 0.0147





========================================
处理fa/fq神器的学习记录: Seqtk (李恒，C语言写的)
----------------------------------------
seqtk: Toolkit for processing sequences in FASTA/Q formats

Seqtk is a fast and lightweight tool for processing sequences in the FASTA or FASTQ format. It seamlessly parses both FASTA and FASTQ files which can also be optionally compressed by gzip.

seqtk在生信届被誉为序列处理的瑞士军刀，其出自生信大神李恒之手，李恒是SAMtools、BWA、MAQ等著名生信软件的核心作者。
seqtk基于C语言编写的软件，运行速度极快，极大的提高工作效率。
seqtk日常序列的处理包括，比如：fq转换为fa，格式化序列，截取序列，随机抽取序列等。




1. 安装
The only library dependency is zlib.

$ git clone https://github.com/lh3/seqtk.git
$ cd seqtk
$ make   

$ ln -s /home/wangjl/software/seqtk/seqtk ~/bin/


在linux操作系统上直接敲seqtk回车后，即返回seqtk所有功能选项：
$ seqtk
Usage:   seqtk <command> <arguments>
Version: 1.3-r117-dirty

Command: seq       common transformation of FASTA/Q
         comp      get the nucleotide composition of FASTA/Q
         sample    subsample sequences
         subseq    extract subsequences from FASTA/Q
         fqchk     fastq QC (base/quality summary)
         mergepe   interleave two PE FASTA/Q files
         split     split one file into multiple smaller files
         trimfq    trim FASTQ using the Phred algorithm

         hety      regional heterozygosity
         gc        identify high- or low-GC regions
         mutfa     point mutate FASTA at specified positions
         mergefa   merge two FASTA/Q files
         famask    apply a X-coded FASTA to a source FASTA
         dropse    drop unpaired from interleaved PE FASTA/Q
         rename    rename sequence names
         randbase  choose a random base from hets
         cutN      cut sequence at long N
         gap       get the gap locations
         listhet   extract the position of each het
         hpc       homopolyer-compressed sequence



有人给的注释: 
Command: seq       common transformation of FASTA/Q // 常用格式转换FASTA/Q
         comp      get the nucleotide composition of FASTA/Q // 获得FASTA/Q的核苷酸组成
         sample    subsample sequences	//	子样本序列
         subseq    extract subsequences from FASTA/Q //	从FASTA/Q中提取子序列
         fqchk     fastq QC (base/quality summary) //	FASQ QC（基本/质量摘要）
         mergepe   interleave two PE FASTA/Q files //叠合两个 PE FASTA/Q 文件
         trimfq    trim FASTQ using the Phred algorithm //使用Phred 算法修剪 FASTQ 文件

         hety      regional heterozygosity // 区域杂合性 
         gc        identify high- or low-GC regions // 识别高的或者低的GC区域
         mutfa     point mutate FASTA at specified positions // 在指定位置突变 FASTA 文件
         mergefa   merge two FASTA/Q files // 融合两个FASTA/Q 文件
         famask    apply a X-coded FASTA to a source FASTA //将X-coded FASTA 应用到源FASTA上
         dropse    drop unpaired from interleaved PE FASTA/Q //从叠合的PE FASA/Q中删除未成对
         rename    rename sequence names // 重命名序列名称
         randbase  choose a random base from hets // 从HETS中随机选择碱基 
         cutN      cut sequence at long N //切割序列
         listhet   extract the position of each het //抓取每一个het的位子




2. 使用 

造个测试文件
$ head -n 8 ../raw/SRR13730617_1.fastq | gzip -c - > in.fq.gz
$ gunzip -c in.fq.gz >in.fq

-rw-r--r--. 1 wangjl jinwf 412 Sep  1 22:12 in.fq
-rw-r--r--. 1 wangjl jinwf 206 Sep  1 22:10 out.fa
-rw-r--r--. 1 wangjl jinwf 197 Sep  1 22:07 in.fq.gz

$ gunzip -c in.fq.gz 
@SRR13730617.1 1 length=75
TCCTTGAACACCAACAGGGCCANGCTCTCNCTTAGCANCNGNCTCTTNTACANATCTCCGANCCCACGAGACCGA
+SRR13730617.1 1 length=75
AAAFFJJJJJJJJJJJJFJJJJ#AJFJJJ#JJJJJJJ#J#J#JJJJJ#JJJJ#JJJFJJJJ#JJJJJJJJJJJFJ
@SRR13730617.2 2 length=75
GCGTGGTTTCATGTAAGCTGTGCTGTTTAGAAACAACATCTCAGACTTTACAAAGAAATGACAAAGAAGGCAATT
+SRR13730617.2 2 length=75
AAFFFFJFJJJJJJJJJJJJJFJ-FJJJJJJJJJJJJJJJ7FFJJJJJJJJJJJJJJJJJJJJJAJFJJJJJJJJ


(1) fq to fa
$ seqtk seq -a in.fq.gz > out.fa

(2) Convert ILLUMINA 1.3+ FASTQ to FASTA and mask bases with quality lower than 20 to lowercases (the 1st command line) or to N (the 2nd):

$ seqtk seq -aQ64 -q20 in.fq > out.fa
$ seqtk seq -aQ64 -q20 -n N in.fq > out.fa


(3)Fold long FASTA/Q lines and remove FASTA/Q comments:
每行60个碱基，之后换行
-l 60 每行60个碱基 
-C fq的第三行仅保留+，抛掉名字，只保留低1行的名字。且名字第一个空格后的部分抛弃
$ seqtk seq -Cl60 in.fa > out.fa



(4) Convert multi-line FASTQ to 4-line FASTQ:
$ seqtk seq -l0 in.fq > out.fq
不知道这个有啥用，fq不都是4行吗？还能换行吗？能，见命令3。



(5) Reverse complement FASTA/Q: 
反向互补
$ seqtk seq -r in.fq > out.fq




(6) Extract sequences with names in file name.lst, one sequence name per line:
按照 name.lst 中的名字，从 in.fq 中提取序列

$ cat name.lst 
SRR13730617.1

$ seqtk subseq in.fq name.lst > out.fq



(7) Extract sequences in regions contained in file reg.bed:
按照bed文件从fa中提取碱基序列
$ seqtk subseq in.fa reg.bed > out.fa

实例: 
$ cat reg.bed 
SRR13730617.1   2       4       .       +
SRR13730617.1   4       8       .       +

$ seqtk seq -a in.fq.gz > in.fa
$ head -n 2 in.fa 
>SRR13730617.1 1 length=75
TCCTTGAACACCAACAGGGCCANGCTCTCNCTTAGCANCNGNCTCTTNTACANATCTCCGANCCCACGAGACCGA


测试:
$ seqtk subseq in.fa reg.bed > out.fa

>SRR13730617.1:3-4 1 length=75
CT
>SRR13730617.1:5-8 1 length=75
TGAA

解释: bed 坐标是0-based，而fa是1-based。
所以 bed 2-4 换算成 fa 是 [3,5)，是左闭右开区间，包含3,4位的碱基: CT
同理， bed 4-8，就是 fa5-8: TCCT [TGAA]




(8) Mask regions in reg.bed to lowercases:
$ seqtk seq -M reg.bed in.fa > out.fa

>SRR13730617.1 1 length=75
TCcttgaaCACCAACAGGGCCANGCTCTCNCTTAGCANCNGNCTCTTNTACANATCTCCGANCCCACGAGACCGA



(9) Subsample 10000 read pairs from two large paired FASTQ files (remember to use the same random seed -s to keep pairing):
抽样
$ seqtk sample -s100 read1.fq 10000 > sub1.fq
$ seqtk sample -s100 read2.fq 10000 > sub2.fq



(10) Trim low-quality bases from both ends using the Phred algorithm:
从两端去掉低质量分数的测序数据。
$ seqtk trimfq in.fq > out.fq

11) Trim 5bp from the left end of each read and 10bp from the right end:
$ seqtk trimfq -b 5 -e 10 in.fa > out.fa




3. 抽样

lh3大神的seqtk工具集就实现了蓄水池算法，只需运用seqtk sample命令。


(1) 貌似是抽样？
$ seqtk sample
Usage:   seqtk sample [-2] [-s seed=11] <in.fa> <frac>|<number>
Options: -s INT       RNG seed [11]
         -2           2-pass mode: twice as slow but with much reduced memory


1)设置抽样百分比
$ seqtk sample -s seed=2022 in.fa 0.1
# [W::stk_sample] when sampling a fraction, option -2 is ignored

$ cd /data/jinwf/wangjl/chenxi/MDA/test2/
$ mkdir sample
$ zcat raw/L.R1.fastq.gz | wc -l
100000

$ seqtk sample -s seed=2022 raw/L.R1.fastq.gz 0.1 | gzip -c >sample/R1.fq.gz
$ seqtk sample -s seed=2022 raw/L.R2.fastq.gz 0.1 | gzip -c >sample/R2.fq.gz


$ zcat sample/R1.fq.gz |wc
   9996   12495  896392
$ zcat sample/R2.fq.gz |wc
   9996   12495  896392

head 看名字也一样。





2)设置抽样目标数量（n个reads是4*n行）
$ seqtk sample -2 -s seed=2022 in.fa 2000

$ zcat raw/L.R1.fastq.gz | wc -l
100000

i) 不带-2 时：更快，但占内存（大服务器，优先用这个）
$ seqtk sample -s seed=2022 raw/L.R1.fastq.gz 100 | gzip -c >sample/t.R1.fq.gz
$ seqtk sample -s seed=2022 raw/L.R2.fastq.gz 100 | gzip -c >sample/t.R2.fq.gz
$ zcat sample/t.R1.fq.gz |wc
    400     500   35871


ii) 带 -2 参数：更慢，但是内存占用更少
$ seqtk sample -2 -s seed=2022 raw/L.R1.fastq.gz 100 | gzip -c >sample/t2.R1.fq.gz
$ seqtk sample -2 -s seed=2022 raw/L.R2.fastq.gz 100 | gzip -c >sample/t2.R2.fq.gz
$ zcat sample/t2.R1.fq.gz |wc
    400     500   35871








Ref:
https://zhuanlan.zhihu.com/p/59034116








========================================
处理fa/fq神器的学习记录: Seqkit (Go语言编写，静态链接库)
----------------------------------------
SeqKit is implemented in Go programming language, statically-linked executable binary files are freely available.

1. 简介
https://bioinf.shenwei.me/seqkit/usage/

功能 Quick Guide
Basic: seq, stats, subseq, sliding, faidx, watch, sana, scat
Format conversion: fq2fa, fx2tab, tab2fx, convert, translate
Searching: grep, locate, amplicon, fish
Set operation: sample, rmdup, common, duplicate, split, split2, head, head-genome, range, pair
Edit: concat, replace, restart, mutate, rename
Ordering: sort, shuffle
BAM processing: bam

(1) 安装 
根据自己的机器下载合适的版本
https://bioinf.shenwei.me/seqkit/download/

$ wget https://github.com/shenwei356/seqkit/releases/download/v2.3.1/seqkit_linux_amd64.tar.gz
$ tar -zxvf seqkit_linux_amd64.tar.gz
$ mkdir -p $HOME/bin/; cp seqkit $HOME/bin/

$ seqkit version
seqkit v2.3.0
Author: Wei Shen <shenwei356@gmail.com>

Seqkit utlizies the pgzip (https://github.com/klauspost/pgzip) package to
read and write gzip file, and the outputted gzip file would be slighty
larger than files generated by GNU gzip.

Seqkit writes gzip files very fast, much faster than the multi-threaded pigz,
therefore there's no need to pipe the result to gzip/pigz.

Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0.








2. 使用 

SeqKit uses the author's lightweight and high-performance bioinformatics package bio for FASTA/Q parsing, which has high performance close to the famous C lib klib (kseq.h).

(1) 子命令
$ seqkit
SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation

Available Commands:
  amplicon        extract amplicon (or specific region around it) via primer(s)
  bam             monitoring and online histograms of BAM record features
  common          find common sequences of multiple files by id/name/sequence
  concat          concatenate sequences with the same ID from multiple files
  convert         convert FASTQ quality encoding between Sanger, Solexa and Illumina
  duplicate       duplicate sequences N times //重复序列
  fa2fq           retrieve corresponding FASTQ records by a FASTA file
  faidx           create FASTA index file and extract subsequence
  fish            look for short sequences in larger sequences using local alignment
  fq2fa           convert FASTQ to FASTA
  fx2tab          convert FASTA/Q to tabular format (and length, GC content, average quality...)
  genautocomplete generate shell autocompletion script (bash|zsh|fish|powershell)
  grep            search sequences by ID/name/sequence/sequence motifs, mismatch allowed
  head            print first N FASTA/Q records
  head-genome     print sequences of the first genome with common prefixes in name
  locate          locate subsequences/motifs, mismatch allowed
  mutate          edit sequence (point mutation, insertion, deletion)
  pair            match up paired-end reads from two fastq files
  range           print FASTA/Q records in a range (start:end)
  rename          rename duplicated IDs
  replace         replace name/sequence by regular expression
  restart         reset start position for circular genome
  rmdup           remove duplicated sequences by ID/name/sequence  #去重：id/name/seq
  sample          sample sequences by number or proportion
  sana            sanitize broken single line FASTQ files
  scat            real time recursive concatenation and streaming of fastx files
  seq             transform sequences (extract ID, filter by length, remove gaps, reverse complement...)
  shuffle         shuffle sequences
  sliding         extract subsequences in sliding windows
  sort            sort sequences by id/name/sequence/length
  split           split sequences into files by id/seq region/size/parts (mainly for FASTA)
  split2          split sequences into files by size/parts (FASTA, PE/SE FASTQ)
  stats           simple statistics of FASTA/Q files
  subseq          get subsequences by region/gtf/bed, including flanking sequences
  sum             compute message digest for all sequences in FASTA/Q files
  tab2fx          convert tabular format to FASTA/Q format
  translate       translate DNA/RNA to protein sequence (supporting ambiguous bases)
  version         print version information and check for update
  watch           monitoring and online histograms of sequence features


(2) 格式转换 






3. 抽样 
$ seqkit sample -h
sample sequences by number or proportion.

Attention:
1. Do not use '-n' on large FASTQ files, it loads all seqs into memory!
   use 'seqkit sample -p 0.1 seqs.fq.gz | seqkit head -n N' instead!

Usage:
  seqkit sample [flags]


-2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin
-s, --rand-seed int      rand seed (default 11)
-p, --proportion float   sample by proportion
-n, --number int         sample by number (result may not exactly match), DO NOT use on large FASTQ files.

i) 按比例抽
$ seqkit sample -2 -s 2022 -p 0.1 raw/L.R1.fastq.gz | gzip -c >sample/kit_p.R1.fq.gz
[INFO] sample by proportion
[INFO] 2526 sequences outputted

$ seqkit sample -2 -s 2022 -p 0.1 raw/L.R2.fastq.gz | gzip -c >sample/kit_p.R2.fq.gz
[INFO] sample by proportion
[INFO] 2526 sequences outputted

$ zcat sample/kit_p.R1.fq.gz |wc
  10104   12630  906097
$ zcat sample/kit_p.R2.fq.gz |wc
  10104   12630  906097




ii) 按个数抽（n个reads是4*n行）
$ seqkit sample -2 -s 2022 -n 100 raw/L.R1.fastq.gz | gzip -c >sample/kit_n.R1.fq.gz
[INFO] sample by number
[INFO] first pass: counting seq number
[INFO] seq number: 25000
[INFO] second pass: reading and sampling
[INFO] 100 sequences outputted

$ seqkit sample -2 -s 2022 -n 100 raw/L.R2.fastq.gz | gzip -c >sample/kit_n.R2.fq.gz
[INFO] sample by number
[INFO] first pass: counting seq number
[INFO] seq number: 25000
[INFO] second pass: reading and sampling
[INFO] 100 sequences outputted

$ zcat sample/kit_n.R1.fq.gz |wc
    400     500   35867
$ zcat sample/kit_n.R2.fq.gz |wc
    400     500   35867






4. 分割 bam文件 //todo
$ seqkit split hairpin.fa.gz -r 1:3 -2  #按前三个序列碱基来区分





ref: https://www.jianshu.com/p/309b79238553





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



