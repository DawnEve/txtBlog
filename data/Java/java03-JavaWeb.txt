java03-JavaWeb 前后端技术
主要是后端部分

Html网页, Css样式, JavaScript 脚本;
XML 配置
Tomcat 服务器
http & 请求 & 响应
Servlet 请求处理
Filter 过滤器
Listener 监听器
Cookie & Session 会话控制

Vue.js 前端框架
Ajax 异步请求
Thymeleaf 模板引擎
综合: 书城

目标: 掌握web原理，熟悉前端技术，为后续框架学习打下基础。


Java 刷题(收费): https://www.lintcode.com/course/3


========================================
bean
----------------------------------------
1. 就是只有 属性和 getter 和 setter 的类。

2. 使用IDE可以自动生成 方法
public class Person {
    private String name;
    private int age;
    private boolean isChild;
}

Eclipse: 点击右键，在弹出的菜单中选择“Source” - “Generate Getters and Setters”，
在弹出的对话框中选中需要生成getter和setter方法的字段，点击确定即可由IDE自动完成所有方法代码。

生成的内容如下：
	其他都是get和set前缀
	boolean字段比较特殊，它的读方法一般命名为isXyz()

class Person {
    private String name;
    private int age;
    private boolean isChild;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public boolean isChild() {
		return isChild;
	}
	public void setChild(boolean isChild) {
		this.isChild = isChild;
	}
}







========================================
Tomcat9 的安装、使用和 Eclipse 自动发布项目
----------------------------------------
1.Tomcat是一个Web服务器（同时也是Servlet容器），通过它我们可以很方便地接收和返回到请求
（如果不用Tomcat，那我们需要自己写Socket来接收和返回请求）。

Tomcat其实我们并不需要学太多的知识，只要学会安装和启动以及了解一下各个目录的含义就差不多了。


(0) 使用xampp的 tomcat 
位置在: G:\xampp\tomcat

怎么查版本号?
http://localhost:8080/ 显示是 Apache Tomcat/7.0.56
太古老了，安装新的吧。


(1) 安装
https://tomcat.apache.org/

比如tomcat9.x需要的最低版本JDK为8.0。
如果你使用的是JDK7.0版本，那么你就是想用tomcat9.x也用不了，只能选择tomcat8.5.x及以下版本。
不过即使在JDK7.0的限制下，也尽量升级到tomcat8.5.x系的最新版本，以预防安全漏洞和少量提升性能。

当然最直接的提升tomcat性能的根本方法，还是升级服务器的硬件配置来的最有效果。

我的jdk8的版本:
> java -version
java version "1.8.0_161"

选择最新的 64-bit Windows tomcat9.0：
https://tomcat.apache.org/download-90.cgi
https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.73/bin/apache-tomcat-9.0.73-windows-x64.zip

解压后就算安装好了。
放到一个没有空格和中文的路径中。
D:\ProgramFiles\apache-tomcat-9.0.73
	bin\
	conf\
	...

Tomcat各个目录的含义：
	bin/ 存放启动和关闭 Tomcat 的脚本文件
	conf/ 存放 Tomcat 服务器的各种配置文件
	lib/ 存放 Tomcat 服务器的支撑jar包
	logs/ 日志文件
	temp/ 运行时临时文件
	webapps/ web 应用所在的目录，外界访问的web资源的存放目录。自定义文件就放到这里。
	work/ Tomcat 工作目录
	其他文件


(2) Tomcat配置环境变量
- 右击此电脑，中间的 属性；
- 新窗口左侧 高级系统设置，
- 新窗口 底部 环境变量。
- 下一半 系统变量：新建
	CATALINA_HOME
	D:\ProgramFiles\apache-tomcat-9.0.73
- 找系统变量中的Path，点击编辑：后面添加 %CATALINA_HOME%\bin;
- 一路2个确定回去。

验证: 
win+R输入cmd回车，然后再DOS窗口输入startup.bat回车。
- 之后会出现Tomcat启动窗口。疑似乱码的内容，是正常的。
- 代表配置成功。
- 黑窗口不能关！关了网页就打不开了。


可能的异常:
- 如果出现报错或者一闪而过，可能是端口号被占用。Tomcat默认窗口时8080。
- 可以尝试重启电脑，再启动Tomcat试试。不行的话，就修改Tomcat端口号。

如果配置成功，打开浏览器，输入 http://localhost:8080/
可以看到网页: Apache Tomcat/9.0.73


==> CLASSPATH 末尾也要新增内容: %CATALINA_HOME%\lib;
	D:\ProgramFiles\apache-tomcat-9.0.73\lib


(3) Tomcat 的Hello world!


(4) 怎么查看源码？
https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.73/src/apache-tomcat-9.0.73-src.zip
下载后移动到 D:\ProgramFiles\apache-tomcat-9.0.73\ 改名为 src.zip。
在Eclipse中 ctrl+单击 关键词，查看源代码。如果没找到，点击添加，选 external 那一行，单击找到该zip包。
确定，即可查看源码。









2. 配置 Eclipse 
(1) 配置
环境配置 https://www.runoob.com/servlet/servlet-environment-setup.html

超详细Eclipse配置Tomcat配置教程 https://blog.csdn.net/qq_45344586/article/details/123976839

Window -> Preferences
Server -> Runtime Environments -> Add 
	选择对应的Tomcat版本（tomcat9）
	选择路径 D:\ProgramFiles\apache-tomcat-9.0.73
-> Finish -> apply and close;


(2) 创建服务器
Eclipse For JavaEE 底部标签 切换到 Servers，
点击 create a new server.
新窗口中，选择Apache 下拉 - Tomcat v0.9.0 Server, Finish;
底部出现: Tomcat v9.0 Server at localhost [Stopped, Republish]


(3) 设施部署路径
双击刚出现的字样[stopped]，弹出新页面
左侧第二个标题 Server Locations 处
	选中第二条 Use Tomcat installation
	将部署路径 Depoly path: 的 wtpwebapps 改为 webapps
		我点击浏览，改为了 D:\ProgramFiles\apache-tomcat-9.0.73\webapps
	保存此设置（叉掉后点击Save）

(3) 启动Tomcat服务
Eclipse 底部 Servers 标签，右击 [Stopped] 后，选择 start
弹出网络提醒，点击允许访问。

底部文字变为[Started, Synchronized]

浏览器访问 http://localhost:8080
可以访问。



(4) 设置密码
访问：http://localhost:8080/
登录密码：
1)打开文件 conf/tomcat-users.xml
2)增加2条
<role rolename="admin-gui"/>
<user username="tomcat" password="tomcat" roles="admin-gui"/>

现在把两处 admin-gui 改为了 manager-gui

3)重启tomcat。





(5) 怎么发布应用？手动发布

$ cat HelloServlet.java
package chapter18;

// 导入必需的 java 库
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

// 扩展 HttpServlet 类
public class HelloServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private String message;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		message = "Hello World";
	}
	
	public void doGet(HttpServletRequest request,
			HttpServletResponse response)
					throws ServletException, IOException
	{
		// 设置响应内容类型
		response.setContentType("text/html");
		
		// 实际的逻辑是在这里
		PrintWriter out = response.getWriter();
		out.println("<h1>" + message + " </h1>");
	}
	
	public void destroy()
	{
		// 什么也不做
	}
}




1) Tomcat主目录下的webapp文件夹内，新建文件夹 mywebsite/。
mywebsite/
	WEB-INF/ 文件夹;
		web.xml 文件,记录网站的配置信息
		classes/ 文件夹 存放你的servlet
			如果有包名，则要按照报名建立文件夹

编译的包放到 webapps\mywebsite\WEB-INF\classes\chapter18\HelloServlet.class

2) 在web.xml中加入如下内容：
<servlet>
	<!--给你的servlet起名字，任意的-->
	<servlet-name>hi2</servlet-name>
	<!--指明servlet的路径，包名+类名 注意类名后不能加上java-->
	<servlet-class>chapter18.HelloServlet</servlet-class>
</servlet>
 
<servlet-mapping>
	<!--mapping  自然就是映射了  于是乎 这个同上,一致-->
	<servlet-name>hi2</servlet-name>
	<!--这是浏览器中输入的访问该servlet的url 任意的-->
	<url-pattern>/testHi2</url-pattern>
</servlet-mapping>

3) 启动tomcat，访问你的Servlet
http://localhost:8080/mywebsite/testHi2

报错: 编译用的版本太高。
java.lang.UnsupportedClassVersionError: chapter18/HelloServlet has been compiled by a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 52.0 (无法载入的类 [chapter18.HelloServlet])
https://blog.csdn.net/wstever/article/details/128492151
52 Java8
57 Java13
...
怎么改变版本号，参考 Java00-prep 准备。

重新编译，放置class文件，重启tomcat，即可打开网页内容。





(6) Eclipse 自动发布项目到指定容器
The Tomcat server configuration at \Servers\Tomcat v9.0 Server at localhost-config is missing. Check the server for errors.

- 菜单-文件-新建-Dynamic Web Project
- 设置 
	Project name: Servlet_2
	Target runtime: tomcat v9.0
	next;
- source folder: src\main\java
	底下的默认输出文件: build\classes
- web modele
	Context root: Servlet_2
	Content directory: src/main/webapp
	勾选 Generate web.xml deployment descriptor
- 菜单文件-file-新建servelt
	包: com.mio.hi, 类: Hello1
	url: /Hello1 
	只要 doGet方法。

现在点击顶部的运行三角，Run on server.
	选中 tomcat9，next，右侧选中项目名字，finish。
	一会重启tomcat，浏览器打开页面: http://localhost:8080/Servlet_2/Hello1



注意: 从 Servlet3开始支持注解写路径，不再需要直接配置xml文件。


package com.mio.hi;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class Hello1
 */
@WebServlet("/Hello1")
public class Hello1 extends HttpServlet {
	private static final long serialVersionUID = 1L;
	String message="hello world, form Tomcat9";
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public Hello1() {
        super();
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append("Served at: ").append(request.getContextPath());
		
		// 设置响应内容类型
		response.setContentType("text/html");
		
		// 实际的逻辑是在这里
		PrintWriter out = response.getWriter();
		out.println("<h1>" + message + "</h1>");
	}

}



(7) 移动项目位置
- Eclipse 左侧右击，删除。
- 文件夹移动
- Eclipse 菜单 文件-从文件系统导入项目。选中 G:\learngit\Servlet_2，finish
- 需要等一会？才能运行。


(8) 怎么使用 web.xml形式指定路由？
- 首先注释掉路由注解：//@WebServlet("/Hello1")  这时浏览器打不开了
- 找到路径 Servlet_2/src/main/下的 webapp/WEB-INF/web.xml
在最后一行前添加: 
	一个是 给类(带包名的全称)绑定一个名字(任意名字)
	另一个是给名字绑定一个域名(在项目名子文件夹下的路径)。

<servlet>
	<!--给你的servlet起名字，任意的-->
	<servlet-name>hi2</servlet-name>
	<!--指明servlet的路径，包名+类名 注意类名后不能加上java-->
	<servlet-class>com.mio.hi.Hello1</servlet-class>
</servlet>
 
<servlet-mapping>
	<!--mapping  自然就是映射了  于是乎 这个同上,一致-->
	<servlet-name>hi2</servlet-name>
	<!--这是浏览器中输入的访问该servlet的url 任意的-->
	<url-pattern>/Hello1</url-pattern>
</servlet-mapping>

- 重启tomcat。浏览器又可看到输出。







========================================
【要精通】Servlet 请求处理(了解jsp)
----------------------------------------
这里只有大纲，更详细的见专题 Servlet。

https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf

0. 需不需要学？

(1)有人说可以不学
可以直接学spring boot 入门，然后再学习servlet。

其实现在很少谈论servlet 了，一方面由于spring mvc 做的太方便了，另一方面是servlet 本身配置太繁琐了。学习servlet 的最终目标一般是更好的理解spring mvc


(2) “需要学Servlet，不要跳过Servlet去学框架”
现在的项目一般来说还是以SpringMVC-Spring-Mybatis / SpringBoot居多。
面试也几乎不会问Servlet的知识（无论是校招还是社招）

我因为好好学了Servlet，在学Struts2（没错，我还学过Struts2）和SpringMVC的都非常容易上手，几天就基本会用了。

如果了解Struts2或SpringMVC的同学就会知道，其实他俩的底层都离不开Servlet。
	Struts2的核心用的是Filter（过滤器），
	而SpringMVC的核心用的就是Servlet。


(3) 怎么学？
学Servlet之前，首先我们要学学Tomcat。





1. Servlet 几个关键点
https://www.zhihu.com/question/452255228/answer/1810876466

	引入
	使用
	生命周期
	继承结构 
	读取初始化参数 ServletConfig
	读取上下文参数 ServletContext


(1) CGI -> FastCGI -> Servlet 服务器端小程序

Servlet 使用单进程多线程方式运行。
	单继承：单实例，全局只有一个对象
	多线程：


(2) 数据请求的结构

三个过程：首尾两步都是一致的，已经封装好了。
	接收请求 Request
	处理请求 Servlet 差异很大
	响应请求 Response


其中网站内的 处理请求 差异很大，每个网站有自己的处理逻辑：地图、购物、音乐。
	互联网出现三层架构，有些逻辑从 Servlet 抽取出来，分担到 Service 和 Dao
	Servlet 不擅长输出 html 页面，所以出现了 jsp。
	Spring家族出现，Servlet 退居幕后，取而代之的是方便的SpringMVC。
		SpringMVC的核心组件DispatcherServlet其实本质就是一个Servlet。
		但它已经自立门户，在原来HttpServlet的基础上，又封装了一条逻辑。
		很多新手程序员框架用久了，甚至觉得SpringMVC就是SpringMVC，和Servlet没半毛钱关系。

Tomcat 后，我再也没有写过main方法！甚至没有new过对象，它是怎么跑起来的呢？
	Servlet/Filter/Listener 都没有main方法，也没有new，都是写个类后在web.xml中配置就能运行了。
	Filter用到了责任链模式
	Listener用到了观察者模式
	Servlet也不会放过使用设计模式的机会：模板方法模式。
		只需继承HttpServlet并重写doGet()/doPost()










========================================
注解 annotation: 自定义、元注解
----------------------------------------
https://www.bilibili.com/video/BV1Kb411W75N?p=504

1. 什么是注解
就是代码中的特殊标记 @Override 等。从Jdk5.0开始的。
和 注释 不同，注释编译时去掉了。

用途：测试、日志等

java以前依赖xml，现在都开始转向注解。

框架=注解+反射+设计模式。

(2) 举例
- 生成文档相关的注解 
	@author 旺财
	@version 版本号

- 编译时进行格式检查(Jdk内置的三个基本注解)
	@Override 重写父类方法，只能用于方法；编译时调用，校验是父类方法，否则报错；
	@Deprecated 限定某个元素（类、方法等）已经过时，通常是因为所修饰的类危险或有更好的选择
	@SuppressWarnings 抑制编译器警告，可以放到方法上、类上。编译器检查
		还可以写多个值 @SuppressWarnings("unused", "rawtypes")


- 跟踪代码依赖性，实现替代配置文件功能
	Servlet3.0提供了注解（annotation），不用在web.xml中进行Servlet部署。
	@WebServlet("/login") 映射该url到底下的类
	Spring框架中关于“事务”的管理
	@Transational(propagation=Propagation.REQUIRES_NEW, 
		isolation=Isolation.READ_COMMITTED, readOnly=false, timeout=3)

- 单元测试 Junit
	@Test(timeout=1000)
	@Before
	@After






2. 自定义注释
(1) 就仿照 SuppressWarnings 来定义

package java.lang;

import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}

第一步定义:
package chapter3;

/*
 * 1.声明为 public @interface MyAnno {}
 * 2.成员变量: 用无参数方法的形式声明。其方法名和返回值定义了该成员变量的名字和类型
 * 	可以是以下类型：8种基本类型，String 类型, Class类型，enum类型，Annotation类型的数组
 * 	如果只有一个成员变量，建议名字叫 value
 * 	如果指定成员变量的初始值，可以使用 default 关键字。
 * 	如果没有成员变量，则叫做标记，使用时不用加()指定值
 * 3.使用时，如果只有一个变量且名字为value，则可以省略名字
 * 
 * */

public @interface MyAnno {
	String[] value();
	
	int[] number() default 100; //指定默认值
}

第二步使用:
package chapter3;

/**
 * 测试 自定义注释
 */
public class MyAnnoTest {
	@SuppressWarnings(value = { "xx" })
	public static void main(String[] args) {
		demo1();
		demo2();
	}
	
	@MyAnno(value="book2", number= {1,2,3})
	private static void demo2() {
		System.out.println("hello 123");
	}

	@MyAnno(value="hi11")
	private static void demo1() {
		System.out.println("hello");
	}
}

具体作用，还需要后面的 反射 部分，读取注解后进行处理。







3. 四个元注解，就是修饰其他注解的注解
(1) 比如上文 SuppressWarnings 前面的 
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
	指定能修饰的范围，类，成员变量，方法，参数，构造器，局部变量
@Retention(RetentionPolicy.SOURCE)
	指定生命周期，值有三个枚举值。
	默认是 CLASS。
	如果想用反射读取，只能设置为 RUNTIME
	
	public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE, //编译后看不到该注解，被编译器抛弃

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default behavior.
     */
    CLASS, //被编译到class文件中，但是运行时不保留。【默认行为】

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME //编译后在class文件中，运行时也保留，能被反射读取。只有这个能被反射读取
}

(2) 其余两个出线频率比较低
@Documented 所修饰的注解，javadoc 将提取该注解信息。
@Inherited 父类有某个注解，子类自动获得该注解。





4. 通过反射获得注解信息
(1) 定义注解
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
//@Target({ FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.RUNTIME) //只有RUNTIME才能被反射获取
@Inherited //该注释修饰后，注释能被继承
public @interface MyAnno {
	String[] value();
	
	int[] number() default 100; //指定默认值
}


(2) 使用注解
@MyAnno({"MyAnno for Person2", "class"})
class Person2{}

class Student2 extends Person2{}

	private static void demo2() {
		//测试继承 子类
		Class clazz=Student2.class; //获取类
		//System.out.println(clazz);//class chapter3.Student2
		
		Annotation[] annotations=clazz.getAnnotations();
		for(int i=0; i<annotations.length; i++) {
			System.out.println(annotations[i]);
		}
	}
输出: @chapter3.MyAnno(number=[100], value=[MyAnno for Person2, class])





5. jdk8新特性
(1)可重复注解
支持在类名上写多个同名注解 MyAnno，本质是引导到其复数版本了。

1) 声明一个单数 MyAnno 注解，其中使用单数成员变量
2) 则还要在定义一个复数的 MyAnnos，其中使用数组成员变量
3) 在单数 MyAnno 上声明 @Repeatable(MyAnnos.class)，关联复数形式
4) 单复数两个的 Target 和 Retention 等要一致，否则报错。
5) 可以使用了

@MyAnno()
@MyAnno()
class XX{}


(2) 类型注解 
1) 类的对泛型进行注解，Target 需要加上 TYPE_PARAMETER
SuppressWarnings 点开，顶部 @Target 的 TYPE 点开，最底部有
public enum ElementType {
	...
	
    /**
     * Type parameter declaration
     *
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * Use of a type
     *
     * @since 1.8
     */
    TYPE_USE
}


@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER})
public @interface MyAnno {
	String[] value() default "";
}

// 注解加到 类的泛型，需要 Target 加上 TYPE_PARAMETER
class Generic<@MyAnno T>{ }


2) 对集合框架的泛型进行注解，Target 需要加上 TYPE_USE
定义同上。
使用示例:

	// 数据类型前修饰，甚至异常前，需要 Target 加上 TYPE_USE
	public void show() throws @MyAnno RuntimeException{
		ArrayList<@MyAnno String> list = new ArrayList<>();
		int num = (@MyAnno int)10L;
	}


以上这些注解，都可以通过反射拿到，然后进一步操作。




ref:
https://www.bilibili.com/video/BV1Kb411W75N?p=512





========================================
|-- Servlet 注解中URL匹配方式
----------------------------------------

Servlet注解中URL匹配方式有四种分别为
	精确匹配：例如  "/dog"
	目录匹配：例如  "/animal/*" 表示匹配/animal下的所有请求，例如 /animal/dog
	后缀名匹配：例如 "/*.jpg"  表示匹配所有以.jpg结尾的，例如 /xyy.jpg
	任意匹配："/" 和"/*"都表示任意匹配，这样所有请求都会匹配成功。
		(注意，使用任意匹配会导致静态资源无法访问的问题，尽量不要使用)


由于这个比较简单，尤其是对于学过正则表达式的兄弟，我就不使用代码进行演示了。

但是URL匹配有个优先级的问题，下面进行展示。
	匹配优先级： 精确匹配 > 目录匹配 > 扩展名匹配 > /* > /
	其实这和我们的思维一样，就是一步一步往下找。




















========================================
反射 与 数据库
----------------------------------------
关系型数据库
非关系型数据库
SQL里的各种JOIN
Java 反射机制






========================================
|-- 动态代理
----------------------------------------
https://www.bilibili.com/video/BV1Kb411W75N/?p=662 to 665 

1. 代理对象和被代理对象都实现同一个接口

接口
	实现类1
	实现类2(代理1)

- 静态代理
	一个代理负责一个类
	在编译期间确定代理关系
- 动态代理 
	一个类完成所有的代理
	不能在编译期间确定，运行期间确定代理关系
	需要代理哪个类，就实现其接口
	更灵活



2. 实例

(1) 静态代理类
package chapter3.reflect.proxy;

public class StaticProxy {
	public static void main(String[] args) {
		//1.被代理对象
		NikeClothFactory nike=new NikeClothFactory();
		//2.代理对象
		ProxyClothFactory proxy_nike = new ProxyClothFactory(nike);
		//3.使用代理调用 被代理类的方法
		proxy_nike.produceCloth();
	}
}



// 静态代理例子：代理类和被代理类在编译期间就已经确定了，写死了
//定义接口
interface ClothFactory{
	void produceCloth();
}

//代理类
class ProxyClothFactory implements ClothFactory{
	private ClothFactory factory; //用被代理的对象进行初始化

	public ProxyClothFactory(ClothFactory factory) {
		super();
		this.factory = factory;
	}

	@Override
	public void produceCloth() {
		System.out.println("代理工厂 开始的准备工作");
		factory.produceCloth();
		System.out.println("代理工厂 首尾工作");
	}
}


// 被代理类
class NikeClothFactory implements ClothFactory{

	@Override
	public void produceCloth() {
		System.out.println("Nike工厂生产一批衣服");
	}
	
}



(2) 动态代理
十分复杂，记住就行了。
用到的挺多，但是不用自己实现。

package chapter3.reflect.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DynamicProxy {
	public static void main(String[] args) {
//		demo1();
//		demo2();
		demo3();
	}

	private static void demo3() {
		//使用上一节静态代理的例子，测试
		NikeClothFactory obj = new NikeClothFactory();
		ClothFactory proxy2=(ClothFactory) ProxyFactory.getProxyInstance(obj);
		proxy2.produceCloth();
	}

	private static void demo2() {
		//获取动态代理对象
		Flyable proxyInstance = (Flyable) ProxyFactory.getProxyInstance(new FlyMouse());
		//调用方法:通过代理类调用方法时，自动调用被代理类的同名方法
		System.out.println( proxyInstance.getName() );
		proxyInstance.fly(10);
	}

	private static void demo1() {
		Bird bird=new Bird();
		//获取动态代理对象
		Flyable proxyInstance = (Flyable) ProxyFactory.getProxyInstance(bird);
		//调用方法:通过代理类调用方法时，自动调用被代理类的同名方法
		System.out.println( proxyInstance.getName() );
		proxyInstance.fly(1000); //带参数的调用
	}

}

//定义接口
interface Flyable{
	String getName();
	void fly(int speed);
}

//被代理类
class Bird implements Flyable{

	@Override
	public String getName() {
		return "I am a bird";
	}

	@Override
	public void fly(int speed) {
		System.out.println("Bird can fly at speed: "+speed);
	}
}

//被代理类2
class FlyMouse implements Flyable{

	@Override
	public String getName() {
		return "I am a FlyMouse";
	}

	@Override
	public void fly(int speed) {
		System.out.println("FlyMouse can fly at speed: "+speed);
	}
}

/*实现动态代理类，需要解决的问题？
*问题1.如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象？
*问题2.通过代理类的对象调用方法时，怎么动态的调用被代理类的同名方法？
*/
class ProxyFactory{
	//1.返回一个代理类的对象
	public static Object getProxyInstance(Object obj) { //obj就是被代理对象
		//触发器负责调用方法
		MyInvocationHandler handler = new MyInvocationHandler(); //该类的实现见下文
		handler.bind(obj); //传入 被代理类的对象
		
		//3个参数：类加载器、接口、触发器，返回一个代理类的对象，解决问题1
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(), 
				obj.getClass().getInterfaces(), 
				handler);
	}
}

class MyInvocationHandler implements InvocationHandler{
	private Object obj; //赋值时，需要使用被代理类的对象进行赋值
	public void bind(Object obj) { //这里赋值
		this.obj=obj;
	}
	
	//通过代理类的对象，调用方法时，会自动调用如下方法 invoke()
	//被代理类要执行的方法的功能，声明在 invoke() 中
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		//极为重要！代理类对象调用的方法，也在这里调用 被代理类对象的同名方法
		//注意3个参数的来源 A.invoke(B, C); A是要调用的方法，B是被代理类的对象(bind(传入))，C是参数
		Object returnValue = method.invoke(obj, args);
		//被代理对象调用的返回值，作为 invoke 方法的返回值
		return returnValue;
	}
}





========================================
|-- Aspect-Oriented Programming(AOP) 面向切面编程
----------------------------------------
aop（面向切面编程）是一种对oop的完善，比如在进行数据库操作的时候执行方法前或者后加入一条日志记录，使用一个额外的类去做日志操作，让dao类更专注。

1. 场景
每个方法都需要相同的记录日志的代码。
	方法1：代码1+日志1
	方法2：代码2+日志1
	方法3：代码3+日志1

可以把日志部分抽离到方法A中，但是它们又会依赖方法A
	要把方法A写到一个工具类的静态方法？又增加耦合。
最理想的效果是：方法1-3既可以执行方法A，又无需在程序中以硬编码的方式直接调用方法A。
	使用动态代理可以实现：
	动态代理中
		调用通用方法1
		回调 被代理类的方法
		调用通用方法2


2. 例子

接上文的动态代理例子，添加一个类，修改一个动态调用方法

(1) 切面方法
class MyUtil{
	static void method1() {
		System.out.println("\n======前处理步骤~~======");
	}
	static void method2() {
		System.out.println("======后处理步骤！~~======");
	}
}

(2) 修改调用方法，在其前后分别执行切面方法

class MyInvocationHandler2 implements InvocationHandler{
	private Object obj; //赋值时，需要使用被代理类的对象进行赋值
	public void bind(Object obj) { //这里赋值
		this.obj=obj;
	}
	
	//通过代理类的对象，调用方法时，会自动调用如下方法 invoke()
	//被代理类要执行的方法的功能，声明在 invoke() 中
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		MyUtil util=new MyUtil();
		util.method1();
		
		//极为重要！代理类对象调用的方法，也在这里调用 被代理类对象的同名方法
		//注意3个参数的来源 A.invoke(B, C); A是要调用的方法，B是被代理类的对象(bind(传入))，C是参数
		Object returnValue = method.invoke(obj, args);
		//被代理对象调用的返回值，作为 invoke 方法的返回值
		
		util.method2();
		return returnValue;
	}
}

输出:
======前处理步骤~~======
======后处理步骤！~~======
I am a bird

======前处理步骤~~======
Bird can fly at speed: 1000
======后处理步骤！~~======








========================================
====> //todo Current: 当前进度 https://www.bilibili.com/video/BV1Kb411W75N?p=666
----------------------------------------







========================================
监听器、拦截器
----------------------------------------












========================================
websocket 协议 goto 本博客 html/http协议
----------------------------------------





========================================
MVC 思想
----------------------------------------







========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



