Servlet使用

http://www.runoob.com/servlet/servlet-tutorial.html

基础：
	Java 编程语言有一个很好的理解。
	如果您对 web 应用程序和互联网如何工作的有基本的认识，将有助于您理解本教程。

英语教程:
	https://www.oracle.com/java/technologies/java-servlet-tec.html
		https://javaee.github.io/
		https://javaee.github.io/servlet-spec/
	https://www.javatpoint.com/servlet-tutorial;
	https://developer.ibm.com/tutorials/j-javaee8-servlet4/
	https://beginnersbook.com/2013/05/servlet-tutorial/
	https://www.geeksforgeeks.org/introduction-java-servlets/




========================================
Servlet 简介 与 大纲
----------------------------------------
1. 定义
- 没有main方法，不能自己运行。
- Servlet 遵守规则(就是实现接口)，才能被容器识别，并由容器运行。


Servlet 包
Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。
Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。



(2) 一般步骤
- 创建 JavaEE 项目
- 定义一个类，实现 Servlet 接口
- 实现接口中的抽象方法
- 配置类的名字和URL: web.xml
- 启动tomcat并访问，发现方法被调用了！
	可以自定义路径，添加虚拟目录 //how?

(3) 查找与调用过程
	url 被解析，获取访问 Servlet 的资源路径。
	在xml中进行查找，看url对应的路径是啥名字，该名字对应的类是啥？
	知道类名，使用反射获取该类的对象
	调用接口规定的方法，比如 service()



2. Servlet 生命周期：五个方法，主要是前3个

(1) Servlet 生命周期可被定义为从创建直到毁灭的整个过程。
以下是 Servlet 遵循的过程：
	init () 被创建: 方法进行初始化：只执行一次
	service() 提供服务：处理客户端的请求；每次访问都执行，可指定多次
	destroy() 销毁：Servlet 在服务器关闭时执行
		最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。
	ServletConfig 配置对象
	getServletInfo 获取 Servlet信息

(2) init() 方法
	什么时候 Servlet 被创建呢？
		启动时创建: web.xml 配置<servlet>中加入<load-on-startup>2</load-on-startup>，中间是>=0的值时。
		第一次被访问时创建，如果是<0则访问时创建
	只执行一次，说明是单例模式，全局 Servlet 只有一个对象。
		多个用户同时访问时，可能有线程安全问题。
			怎么解决？不要定义全局变量，只在方法中定义变量。全局变量定义了别改变值。

(3) destroy() 方法 
	Servlet 被销毁时执行。服务关闭时，Servlet被销毁
	只有服务正常关闭时，才会执行destroy方法
	destroy方法在servlet被销毁前执行，一般用于释放资源




3. 使用注解配置URL

最繁琐的步骤：url配置
Servlet 3.0 开始(JavaEE 6之后)，可以使用注解定义url，不再需要xml文件。

现在创建 Servlet 流程:
- 创建 JavaEE 项目
- 定义一个类，实现 Servlet 接口
- 实现接口中的抽象方法
- 在类前添加注解来定义URL  @WebServlet("/hello") #这一步大大简化了！
- 启动tomcat并访问，发现方法被调用了！

	可以给一个类定义多个访问路径，使用花括号 @WebServlet({"/hello", "/hello2", "/getOne"})
	三种定义方式:
		"/xx"
		"/xx/yy", "/xx/*"  使用通配符
		"*.htm"  限定资源后缀名，"*.do" ，前面不能有斜杠！



tomcat 虚拟路径：
IDEA 与 Tomcat 相关配置: https://www.bilibili.com/video/BV1CM411a7s1/?p=7 

WEB-INF 目录不能被访问到。




4. 怎么打断点？
使用小虫子启动：debug 方式。












5. Tomcat 简介
http://tomcat.apache.org/
Apache Tomcat version 7.0 implements the Servlet 3.0 and JavaServer Pages 2.2 specifications from the Java Community Process.

>2016-11-08 Tomcat 8.5.8 Released





资源:
https://www.runoob.com/servlet/servlet-first-example.html





========================================
环境配置、工具配置
----------------------------------------

最新的 Tomcat9 的使用和配置参考 专题: java Web

Tomcat 的配置
Eclipse 的配置



========================================
|-- xampp中的tomcat怎么激活
----------------------------------------
环境变量：https://zhidao.baidu.com/question/256492455.html
添加注册表项：http://www.ithao123.cn/content-3176358.html


环境变量：
JAVA_HOME=jdk主目录 
TOMCAT_HOME=tomcat的主目录 

--
catalina_start.bat
[XAMPP]: Searching JDK HOME with reg query ...
错误: 系统找不到指定的注册表项或值。
. [XAMPP]: Cannot find current JDK installation!
. [XAMPP]: Cannot set JAVA_HOME. Aborting ...
done.
请按任意键继续. . .
说找不到键值，我们打开这个bat看看！！！

解决方法：
我们regedit打开注册表：HKEY_LOCAL_MACHINE—>SOFTWARE—>Wow6432Node
新建项JavaSoft
在JavaSoft下新建项Java Development Kit和Java Runtime Environment

Java Development Kit默认值指定为你jdk的路径
我的jdk路径为：
D:\Program Files\Java\jdk1.8.0_66

Java Runtime Environment指定你jre路径
比如我的jre路径为：
D:\Program Files\Java\jdk1.8.0_66\jre

自己安装版的java应该是不会出现这样的现象的，只有当你免安装的时候才会出现这样的现象
我们再来运行一下xmapp的tomcat看完美解决了问题没有！！！

访问：http://localhost:8080/
登录密码：
（1）打开文件conf/tomcat-users.xml
（2）增加2条
<role rolename="admin-gui"/>
<user username="tomcat" password="tomcat" roles="admin-gui"/>
（3）重启tomcat。



被拒绝后提示详细的用户设置
You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp.

For example, to add the admin-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above.

<role rolename="admin-gui"/>
<user username="tomcat" password="s3cret" roles="admin-gui"/>
Note that for Tomcat 7 onwards, the roles required to use the host manager application were changed from the single admin role to the following two roles. You will need to assign the role(s) required for the functionality you wish to access.

admin-gui - allows access to the HTML GUI
admin-script - allows access to the text interface
The HTML interface is protected against CSRF but the text interface is not. To maintain the CSRF protection:

Users with the admin-gui role should not be granted the admin-script role.
If the text interface is accessed through a browser (e.g. for testing since this interface is intended for tools not humans) then the browser must be closed afterwards to terminate the session.




========================================
|-- Servlet版HelloServlet，和 Eclipse 中配置servlet
----------------------------------------

Servlet的四步开发流程。
1.首先在Tomcat的主目录下的webapp文件夹内新建mywebsite文件夹，里面新建WEB-INF文件夹;
在WEB-INF文件夹下建立classes子文件夹 存放你的servlet
然后在WEB-INF文件夹下建立一个web.xml文件,记录网站的配置信息

当然这个操作你可以自己完成 也可以在root目录下拷贝一份
大家可以看到 这个地方传递过来了一个信息，什么信息呢？
文件夹结构：

F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml 

webapps/WEB-INF/web.xml 
webapps/WEB-INF/classes/HelloServletDemo.class 




2.开发Servlet（引入Servlet-api.jar）
右击项目的 Libraries 路径，选择 Bild path，添加和修改本地的jar文件。

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class HelloServletDemo implements Servlet{
	// 用于得到servlet配置文件 与生命周期无关
	@Override
	public ServletConfig getServletConfig() {
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return "Servlet info here...";
	}

	// 该函数用于初始化该servlet， 类似于我们的类的构造函数
	// 该函数只是会被调用一次， 当用户第一次访问该servlet的时候被调用
	@Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init it !");
	}


	// service 函数用于处理业务逻辑
	// 程序员应当把业务逻辑代码写在这里
	// 该函数在用户每次访问servlet的时候都会被调用
	// ServletRequest 对象用于获得客户端信息，
	//ServletResponse 对象用于向客户端返回信息	（客户端可以理解为浏览器）
	// servelt jsp b/s
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		System.out.println("Service start");
		PrintWriter pw=res.getWriter();
		pw.println("Hello world, Servlet");
	}
	
	
	// 销毁servlet实例（释放内存）
	// 1 reload 该servlet(webApp)
	// 2 关闭Tomcat 或者说 关机之后 都会调用这个函数
	@Override
	public void destroy() {
		System.out.println("destory it");
	}

}






3.部署Servlet。在web.xml中加入如下内容：
<servlet>
	<!--给你的servlet起名字，任意的-->
	<servlet-name>hello_servlet</servlet-name>
	<!--指明servlet的路径，包名+类名 注意类名后不能加上java-->
	<servlet-class>com.tsinghua.Hello</servlet-class>
</servlet>
 
<servlet-mapping>
	<!--mapping  自然就是映射了  于是乎 这个同上,一致-->
	<servlet-name>hello_servlet</servlet-name>
	<!--这是浏览器中输入的访问该servlet的url 任意的-->
	<url-pattern>/sp</url-pattern>
</servlet-mapping>



web.xml的最终内容如下：
<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://java.sun.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>
 	  
  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>HelloServletDemo</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
	
</web-app>

这里面，servlet标签标注着我们的servlet名字和class名，而mapping标签则是代表着servlet的访问地址。




4.启动tomcat，访问你的Servlet
http://localhost:8080/mywebsite/hello

显示：Hello world, Servlet


注意：WEB-INF不要写错！不是WEB_INF，也不是WEB-INFO。
https://www.zhihu.com/question/21416727






我的实践：
1.在Eclipse中提示 找不到类 javax.servlet.http.HttpServletResponse
http://bbs.csdn.net/topics/370187655?page=1

在tomcat的lib目录下可以找到的。如果你把J2EE的相关包加到buildPath里面去，那应该不会出错的。

到tomcat的安装路径下\lib\servlet-api.jar 复制到WEB-INF/lib下，然后点项目名按F5，应该就OK了。


2.如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。
web.xml中也必须是包的全称 com.myorg.MyServlet。




========================================
|-- EclipseEE不能编译Servlet
----------------------------------------
能编译java。
能编译jsp。
不能编译Servlet，修改后不编译，更新后不编译。
重启eclipse和tomcat都没用。

Deleted .classpath and project settings files from project folder. Then imported the maven project again.
It works fine after that.
我就删除了这2个文件，然后重新import到eclipse中。
一切正常。


http://stackoverflow.com/questions/24416569/eclipse-project-cannot-reference-itself


在左侧的package explorer中右击这个class所在包的上一级目录--build path--设置。
填写符合servlet的build路径： Servlet/WEB-INF/classes
这样就解决问题了。



========================================
|-- Eclipse+Tomcat环境下部署Servlet步骤如下
----------------------------------------
一、建立项目：建立一个动态的web项目（Dynamic Web Project），起名为BlogWeb，并在Target runtime下配置tomcat 
二、在WebContent下WEB-INF的lib里放入mysql-connector-java.5.0.5-bin.jar 
三、编写数据库操作和servlet页面信息的代码：在src里编写pojo类，数据库连接类，数据库操作类dao以及servlet中用于显示页面信息的类 
四、编写html页面，并放在WEB-INF下 
五、配置web.xml中的信息，即servlet中的页面信息 
六、创建Server并启动 
七、打开IE，输入地址进行测试 
八、发布WEB项目：将项目以WAR file形式导出，并将导出的文件置于tomcat目录下的webapps里。
这样不用启动server，也能直接用IE看见我们编写的html了




========================================
网络 与 HTTP 概述
----------------------------------------
1. 网络传输三要点
	IP
	端口
	传输协议


2.状态码
HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：
	初始状态行 + 回车换行符（回车+换行）
	零个或多个标题行+回车换行符
	一个空白行，即回车换行符
	一个可选的消息主体，比如文件、查询数据或查询输出

(1) http 特点
基于 TCP/IP 协议
默认端口 80
请求-响应 模型
无状态


(3) 版本 
1.0 用一次建立一次连接
1.1 会复用连接


(4) request 信息
第一行是 请求行
接着的键值对是请求头

GET /index.php?k=Java&id=2_2 HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Connection: keep-alive
Cookie: __gads=ID=c29ed4286fe501b6-2202309e82d3001c:T=1653627286:RT=1653627286:S=ALNI_Ma7PXyumhEYghvx8SHsZ8dABgB0-Q; __gpi=UID=00000544b84bf2d3:T=1652272297:RT=1678695027:S=ALNI_MbtIeZPrysnEbJewqdf4gd0ciukhw
Host: blog.dawneve.cc
Referer: http://blog.dawneve.cc/index.php?k=Java&id=4_0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36


post有请求体，get没有（get参数在url中）。
url长度限制，post没有限制，get有限制。

User-Agent 浏览器信息，可以根据浏览器提供兼容信息。
Referer 用户来自哪里？
	防盗链
	统计用户来源




(5) request 的继承结构

ServletReqeust  接口 
	HttpServletRequet 接口 
		org.apache.catalina.connector.RequestFacade 类(tomcat)

import javax.servlet.http.HttpServletRequest;





========================================
|-- Servlet Request 获取请求信息: 请求行、请求头、请求体
----------------------------------------
1. 获取请求行(第一行信息)

package com.mio.param;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/getRequestLine")
public class GetRequestLine extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
		//URL: http://localhost:8080/Servlet_2/getRequestLine?name=wangcai&age=5#foot
		//获取请求头 GET /Servlet_2/getHeader?name=wangcai HTTP/1.1 
		// GET
		String str1=req.getMethod(); //请求方法 method
		// /Servlet_2
		String str2=req.getContextPath(); //重要。获取虚拟目录
		// /getRequestLine
		String str3=req.getServletPath(); //获取Servelt 路径
		
		// /Servlet_2/getRequestLine
		String str4=req.getRequestURI(); //重要，权限控制很重要！
		// http://localhost:8080/Servlet_2/getRequestLine
		StringBuffer str5=req.getRequestURL(); //URL比URL长，多了协议+IP+端口号
		
		// name=wangcai&age=5
		String str6=req.getQueryString(); //参数列表
		// HTTP/1.1
		String str7=req.getProtocol(); //请求协议 父类
		// 0:0:0:0:0:0:0:1
		String str8=req.getRemoteAddr(); //获取客户机的地址 父类
		int str9 = req.getServerPort(); //端口号 8080
		
		System.out.println(str4);
	}
}








2. 获取请求体（若干键值对）
两个方法
	Enumeration<String> getHeaderNames(); 获取所有名字
	String getHeader(); 通过名字获取值
		作用：从后台知道用户的浏览器类型

@WebServlet("/getHeader")
public class GetHeader extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
		res.setContentType("text/html;charset=UTF-8");
		// 向浏览器写内容
		PrintWriter out=res.getWriter();
		String title="Http header 请求实例";
		out.println("<h1>"+title+"</h1>");
		
		//获取请求头
		Enumeration<String> headerNames = req.getHeaderNames();
		out.printf("<p><b> 键: 值</b></p>");
		while(headerNames.hasMoreElements()) {
			String key=headerNames.nextElement();
			String val=req.getHeader(key);
			out.printf("<p><b>%s</b>: %s</p>", key, val);
		}
		
		//作用：后台判断浏览器类型
		String agent=req.getHeader("user-agent");
		if(agent.contains("Chrome")) {
			System.out.println("google ...");
		}else if(agent.contains("Firefox")) {
			System.out.println("Firefox ...");
		}
	}
}


http://localhost/163/index2.html 跳转到 http://localhost:8080/Servlet_2/getHeader
		//作用：从哪里开
		String Referer=req.getHeader("Referer");
		String referer=req.getHeader("referer");
		System.out.println("Referer: "+Referer + ", referer: "+referer);
		// 防盗链
		if(referer != null) {
			if(referer.contains("Header")) {
				// 正常访问
				System.out.println("不做限制");
			}else {
				// 防盗链
				System.out.println("外站不能播放");
			}
		}
输出为: 
Referer: http://localhost/, referer: http://localhost/
外站不能播放







3. 获取请求体（只有post请求才有）Request Body
(1) 步骤 
- 获取流对象 
	BufferedReader getReader(); 获取字符输入流，只能操作字符数据
	ServeletInputStream getInputSream(); 获取字节输入流，可以操作所有类型数据
		* 在文件上传时讲解

需要先写一个注册页面。
Eclipse 文件-新建-other，搜索html，地址选 Servlet_2/src/main/webapp/ 和 WEB-INF 并列的位置，新建 login.html.
测试，真的可以访问 http://localhost:8080/Servlet_2/login.html

$ cat login.html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Login page</title>
</head>
<body>

	<form action="/Servlet_2/getRequestBody" method="post">
        <div class="item">
            <span>用户名：</span>
            <input type="text" name="account">
        </div>
        <div class="item">
            <span>密码：</span>
            <input type="text" name="password">
        </div>
        <div class="btn">
            <input type="submit" name="login" value="Login">
        </div>
        <div class="double">
            <a href="register.html">注册</a>
            <a href="">忘记密码</a>
	</form>

</body>
</html>


填表，点击 Login 登录，控制台输出：account=wangcai&password=123456&login=Login
这个格式和get一模一样，就是放的位置不同。






========================================
|-- Servlet get/post 获取参数，请求转发，共享数据，获取 ServletContext
----------------------------------------
4. 其他功能
(1)获取请求参数通用方法：兼容 get 和 post
	String getParameter(String name); 根据参数名获取参数值 username=zs&password=123
	String[] getParameterValues(String name); 根据参数名获取参数值的数组 hobby=xx&hobby=yy 复选框
	Enumeration<String> getParameterNames(); 根据参数名 迭代器
	Map<String, String[]> getParameterMap(); 获取所有参数的键值对map的集合
	好处: 代码只需要写一份，另一份调用 this.doPost(req, res);
	频率：1和4用的多.

Tomcat 中文乱码：
	get: tomcat 8 get 解决中文乱码
	post 中文还是乱码。需要首行设置流的编码，解决post时中文乱码 
	//测似: http://localhost:8080/Servlet_2/login2.html
	req.setCharacterEncoding("utf-8");



(2) 请求转发：一种服务器内部的资源跳转方法
步骤
	通过reqest对象获取转发器对象：RequestDispatcher getRequestDispatcher(String path)
	使用 RequestDispatcher 对象来进行转发 forward(ServletRequest req, ServletResponse res);

	//转发给demo2
	/*
	//1. 获取转发器对象: 参数是要转发的目标地址
	RequestDispatcher requestDispatcher = req.getRequestDispatcher("/requestDispatcherDemo2");
	//2. 转发
	requestDispatcher.forward(req, res);
	*/
	// 推荐合成一行
	req.getRequestDispatcher("/requestDispatcherDemo2").forward(req, res);

特点：
	浏览器地址栏没有变化
	不能访问服务器外部资源：只能转发到当前服务器内部资源
	只有一次http请求：转发的跳转发生在服务器内部



(3) 共享数据
域对象：一个有作用域的对象，可以在范围内共享数据
request 域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据。

方法：
	setAttribute(String name, Object obj); //存储数据
	Object getAttribute(String name); //通过键获取值
	void removeAttribute(String name); //通过键获取值
	可用于传递数据，转发前向转发后





(4) 获取 ServletContext
	req.getServletContext();

示例:
	ServletContext servletContext = req.getServletContext();
	System.out.println(servletContext);  //org.apache.catalina.core.ApplicationContextFacade@6313107e










2.示例
(1) get方式获取传递过来的变量

package com.mio.param;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/GetPara")
public class GetPara extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
		res.setContentType("Text/html"); //设置内容类型
		//获取变量
		String usr=req.getParameter("username");
		String pass=req.getParameter("password");
		//打印结果
		PrintWriter out=res.getWriter();
		out.println("<h1>usr:"+usr+", pass:"+pass+"</h1>");
	}
}

// http://localhost:8080/Servlet_2/GetPara?username=xiaoming&password=123



(2) post 表单内容与位置
位置和 WEB-INF/ 并列。
Servlet_2/src/main/webapp/login2.html

$ cat login2.html 
<!DOCTYPE html>
<html><head><meta charset="UTF-8"><title>Login page</title></head>
<body>
<!-- 测试中文 post 乱码-->
	<form action="/Servlet_2/requestDemo" method="post">
        <div class="item">
            <span>用户名：</span>
            <input type="text" name="username">
        </div>
        <div class="item">
            <span>密码：</span>
            <input type="text" name="password">
        </div>

        <div class="item">
            <label><input type="checkbox" name="hobby" value="篮球">篮球</label>
            <label><input type="checkbox" name="hobby" value="run">run</label>
            <label><input type="checkbox" name="hobby" value="足球">足球</label>
        </div>

        <div class="btn">
            <input type="submit" name="login" value="Login">
        </div>
        <div class="double">
            <a href="register.html">注册</a>
            <a href="">忘记密码</a>
        </div>
	</form>
</body></html>










========================================
|-- Servlet获取参数，获取汉字参数（另一种 解决中文乱码方法）
----------------------------------------

注意：如果表单提交的数据中有中文数据则需要转码：
String name =new String(request.getParameter("name").getBytes("ISO8859-1"),"UTF-8");


1.GetDemo.java 
package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class GetDemo
 * url: http://localhost:8080/mywebsite/getDemo
 * 
 */
//@WebServlet("/GetDemo")
public class GetDemo extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * 获取参数，获取汉字参数。
     * @see HttpServlet#HttpServlet()
     */
    public GetDemo() {
        super();
        System.out.println("1.this is construct method.数据库打开");
        // TODO Auto-generated constructor stub
    }
    
    // 该函数用于初始化该servlet， 类似于我们的类的构造函数
 	// 该函数只是会被调用一次， 当用户第一次访问该servlet的时候被调用
 	@Override
 	public void init(ServletConfig arg0) throws ServletException {
 		System.out.println("2.init it !");
 	}


	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//response.setContentType("text/html");//有这句话，后面的html标签才起作用
		response.setContentType("text/html;charset=UTF-8");//输出中文
		
		System.out.println("3.this is a doGet method.");
		response.getWriter().append("Served at: ").append(request.getContextPath());
		PrintWriter out = response.getWriter();
		out.println("<h1>hello, test Get Method.好的</h1>");
		
		//获取参数
		//http://localhost:8080/mywebsite/getDemo?token=sfd
		String token=request.getParameter("token");
		if(token!=null){
			//token="null";
			out.println("token="+token+"<br>");
		}
		
		//获取汉字参数
		//http://localhost:8080/mywebsite/getDemo?keyword=sfd事务
		String _keyword=request.getParameter("keyword");
		if(_keyword!=null){
			String keyword=new String(_keyword.getBytes("ISO8859-1"),"UTF-8");//转码
			out.println("_keyword="+_keyword+"<br>");//乱码
			out.println("keyword="+keyword+"<br>");//正常显示
		}
		
	}
	
	public void destroy() {
		System.out.println("4.destory it数据库关闭");
	}
}


2.web.xml添加配置：
	<servlet>
		<servlet-name>getDemo</servlet-name>
		<servlet-class>com.dawn.servlet.GetDemo</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>getDemo</servlet-name>
		<url-pattern>/getDemo</url-pattern>
	</servlet-mapping>










========================================
Response 对象
----------------------------------------
通过 response 对象，我们可以尝试写一些Demo，比如：

	给浏览器输出一些简单的内容
	实现文件下载的功能
	实现页面自动刷新的功能
	实现对数据的压缩
	生成验证码图片
	重定向跳转
	.....


1. 常用方法
(1) 输出到屏幕
	//输出到屏幕
	PrintWriter out = response.getWriter();
	String title = "HTTP Header 设置实例-自动刷新";
	out.println("<h1>"+title+"</h1>");


(2) 设置刷新自动加载时间为 10 秒
刷新网页的最简单的方式是使用响应对象的方法 setIntHeader()。以下是这种方法的定义：
	public void setIntHeader(String header, int headerValue)
	
	response.setIntHeader("Refresh", 10);
	// 把头信息 "Refresh" 连同一个表示时间间隔的整数值（以秒为单位）发送回浏览器

(3) 设置响应内容类型
	response.setContentType("text/html;charset=UTF-8");


(4) 设置头信息 	void addHeader(String name, String value)
	resp.addHeader("author", "Tom");

(5) 设置响应状态
	//resp.setStatus(404, "not found now..."); //2参数的已被废除
	resp.setStatus(404); //只能有一个参数
更多http状态码 https://www.runoob.com/servlet/servlet-http-status-codes.html


(6) 重定向
	// 重定向到 demo1
	resp.sendRedirect("responseDemo1"); //不能写成 "/responseDemo1"，否则会忽略项目名导致找不到路径

(7) 发送错误信息
	resp.sendError(404, "not found on this server!~~"); //一个格式化404页面，参数2是显示的信息





2. 实例

package com.mio.response;

import java.io.IOException;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/responseDemo1")
public class ResponseDemo1 extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
			throws ServletException, IOException {
		//页面自动刷新:10s
		resp.setIntHeader("Refresh", 10);
		//设置响应内容类型，防止中文乱码
		resp.setContentType("text/html;charset=UTF-8");
		
		//使用默认时区，获取时间字符串
		String now = new Date().toString();
		//浏览器输出 时间
		resp.getWriter().
			append("ResponseDemo1 10秒刷新<br> Served at: ").
			append(req.getRequestURI()).append("<h2>"+now+"</h2>");
	}
}






========================================
|-- Servlet 网页重定向
----------------------------------------
1.
最简单的方式是使用 response 对象的 sendRedirect() 方法。
该方法把响应连同状态码和新的网页位置发送回浏览器。
public void HttpServletResponse.sendRedirect(String location)
throws IOException

response.sendRedirect("http://www.163.com");



2.也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果：
....
String site = "https://www.baidu.com" ;
response.setStatus(response.SC_MOVED_TEMPORARILY);
response.setHeader("Location", site); 
....




3.实例：
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class SRedirect extends HttpServlet{

	private static final long serialVersionUID = 1L; 
	
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=UTF-8");
		
		PrintWriter out=response.getWriter();
		out.println("跳转中...");
		
		//1.
		response.sendRedirect("http://www.163.com");
		
		//2.
		String site="https://www.baidu.com";
		response.setStatus(response.SC_MOVED_TEMPORARILY);
		response.setHeader("Location", site);
	}
}










========================================
Cookie和session会话机制
----------------------------------------
首先我们了解一下Cookie是存储在哪的，以及Cookie的基本API使用，包括：
	Cookie的有效期如何设置
	Cookie如何保存中文
	Cookie的不可跨域性是什么意思
	使用Cookie来显示用户上次访问的时间
	使用Cookie来显示上次浏览过的商品


Cookie的API使用基本会了以后，我们就可以学习Session了，学Session的时候我们需要解决：
	有了Cookie，为什么需要Session（因为他俩都是会话机制）
	Session的API基本使用
	Session的生命周期和有效期
	Session的实现原理，如果禁用Cookie，还能使用Session吗
	尝试完成Session的几个小Demo
	使用Session完成购物的功能
	使用Session完成简单的登录注册
	使用Session完成防止表单重复提交
	使用Session完成一次性校验码

完了以后，我们可以对比一下Cookie和Session的区别主要有哪些。

一句话总结：
	Cookie是检查用户身上的“通行证”来确认用户的身份，
	Session就是通过检查服务器上的“客户明细表”来确认用户的身份的。
		Session相当于在服务器中建立了一份“客户明细表”。









========================================
|-- Servlet Cookie
----------------------------------------
问题：
Cookie1 cookie的读写: cookie时间总是不准确，超前24小时左右。但是时间5和10s还是有区别的。
	ame	tomcat	localhost	/mywebsite	2017-01-01T17:03:09.672Z	10				
	pass	123	localhost	/	2017-01-01T17:03:14.672Z	7	


1.Servlet Cookie 处理需要对中文进行编码与解码，方法如下：
HttpServletRequest request  
HttpServletResponse response

(1) 无生命周期的cookie: 失效日期是 本 Session
	Cookie cookie = new Cookie("cookiename","cookievalue");
	response.addCookie(cookie);

(2)立一个有生命周期的cookie,可以设置他的生命周期
	cookie = new Cookie("cookiename","cookievalue");
	cookie.setMaxAge(3600);
	//设置路径
	//"/"即该工程下都可以访问该cookie; 如不设置路径，那么只有设置该cookie路径及其子路径可以访问
	cookie.setPath("/"); 
	response.addCookie(cookie);


(3)有空格时也可以这么处理，避免报错。
	String   str   =   java.net.URLEncoder.encode("中文");            //编码
	String   str   =   java.net.URLDecoder.decode("编码后的字符串");   // 解码


(4)读取cookie，读取cookie代码如下
	Cookie[] cookies = request.getCookies();//获取一个cookie数组
	for(Cookie cookie : cookies){
		cookie.getName();// get the cookie name
		cookie.getValue(); // get the cookie value
	}


(5)删除某个cookie
删除 Cookie 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：
	读取一个现有的 cookie，并把它存储在 Cookie 对象中。
	使用 setMaxAge() 方法设置 cookie 的最大年龄为0，来删除现有的 cookie。
	把这个 cookie 添加到响应头。

实例:
	Cookie cookie = new Cookie("name", null);
	cookie.setMaxAge(0);
	res.addCookie(cookie);






2. 封装成函数
(1) 增加一个cookie，我们关注的是cookie的name，value，生命周期，及 resp 对象
/**
 * 设置cookie
 * @param response
 * @param name  cookie名字
 * @param value cookie值
 * @param maxAge cookie生命周期  以秒为单位
 */
public static void addCookie(HttpServletResponse response, String name, String value, int maxAge){
    Cookie cookie = new Cookie(name,value);
    cookie.setPath("/");
    if(maxAge>0)  cookie.setMaxAge(maxAge);
    response.addCookie(cookie);
}


(2) 读取cookie，提供cookie的name，可获取cookie的value
/**
 * 根据名字获取cookie
 * @param request
 * @param name cookie名字
 * @return
 */
public static Cookie getCookieByName(HttpServletRequest request,String name){
    Map<String,Cookie> cookieMap = ReadCookieMap(request);
    if(cookieMap.containsKey(name)){
        Cookie cookie = (Cookie)cookieMap.get(name);
        return cookie;
    }else{
        return null;
    }    
}

/**
 * 将cookie封装到Map里面
 * @param request
 * @return
 */
private static Map<String,Cookie> ReadCookieMap(HttpServletRequest request){    
    Map<String,Cookie> cookieMap = new HashMap<String,Cookie>();
    Cookie[] cookies = request.getCookies();
    if(null!=cookies){
        for(Cookie cookie : cookies){
            cookieMap.put(cookie.getName(), cookie);
        }
    }
    return cookieMap;
}






3.文件Cookie1.java 
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;
import java.util.TimeZone;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Cookie1 extends HttpServlet{

	/**
	 * cookie封装： http://www.cnblogs.com/muzongyan/archive/2010/08/30/1812552.html
	 * 
	 * http://localhost:8080/mywebsite/cookie1?option=get 获取cookie
	 * http://localhost:8080/mywebsite/cookie1 删除cookie name
	 * http://localhost:8080/mywebsite/cookie1?option=set 设置cookie name pass
	 */
	private static final long serialVersionUID = 1L;
	static{
		TimeZone.getTimeZone("Asia/Shanghai");//
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		String option=req.getParameter("option");
		if(option==null){
			System.out.println("没有参数");
			
			//清空cookie name
			Cookie cookie = new Cookie("name", null);
			cookie.setMaxAge(0);
			//删除指定路径上的Cookie，不设置该路径，默认为删除当前路径Cookie；
			//cookie.setPath("/");
			res.addCookie(cookie);
			
			return;
		}
		if(option.equals("set")){
			mySet(req,res);
		}
		if(option.equals("get")){
			myGet(req,res);
		}
		
	}
	
	//设置cookie
	static void mySet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		//分别设定cookie，和生命周期
		Cookie name=new Cookie("name","tomcat");
		//如果设置为负值的话，则为浏览器进程Cookie(内存中保存)，关闭浏览器就失效
		name.setMaxAge(5);//5s
		res.addCookie(name);

		Cookie pass=new Cookie("pass","123");
		pass.setMaxAge(10);//10s
		//设置路径，这个路径即该工程下都可以访问该cookie 
		//如果不设置路径，那么只有设置该cookie路径及其子路径可以访问
		pass.setPath("/");
		res.addCookie(pass);
		
//		Cookie c = new Cookie("lastAccessTime",System.currentTimeMillis()+"");
		Cookie c = new Cookie("lastAccessTime", new Date().toString());
		// 如果报错，可能是cookie中不能保存空格，后面加上 .replace(" ", "-")
		//c.setMaxAge(0);//0s不保存
		c.setMaxAge(-1);//浏览器关闭前有效
		res.addCookie(c);
		
		System.out.println("cookie设定完成！");
	}
	
	//读取cookie
	static void myGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		Cookie[] cookies = req.getCookies();//这样便可以获取一个cookie数组
		if (null==cookies) {
            System.out.println("没有cookie=========");
        } else {
        	PrintWriter out=res.getWriter();
			for(Cookie cookie : cookies){
			    String str=cookie.getName()+"="+cookie.getValue();
			    System.out.println(str);
			    out.println(str);
			}
        }	
		System.out.println("cookie读取完成");
	}
}






========================================
|-- Servlet Session
----------------------------------------
页面间信息传递的几种方式：
	1.cookies方式；
	2.隐藏表单字段；
	3.url重写
	4.session方式；

URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。



1. session 操作

获取 HttpSession 对象:
	HttpSession hs = request.getSession();
设置session时间.默认是30min。
	hs.setMaxInactiveInterval(10);//10s

获取 sessionid
	String id=hs.getId();


添加键值对：
	hs.setAttribute("gender", "M");
查询键值对：
	String str=(String) hs.getAttribute("gender");
删除键值对：
	hs.removeAttribute("gender");


遍历 session 
	//获取 session 键 的 枚举类型
	Enumeration<String> enu = hs.getAttributeNames();
	// 输出流
	PrintWriter out=resp.getWriter();
	out.println("<b>session item, key: value, </b><br>");
	while(enu.hasMoreElements()){
		String key = enu.nextElement();
		String value = (String) hs.getAttribute(key);
		out.printf("<p>%s: %s,</p>", key, value);
	}




2. 用例
(1)判断是否有session值，给阅读权限

	res.setContentType("text/html;charSet=utf8");
	//关于session部分
	HttpSession hs=req.getSession(true);
	
	//判断是否合格
	String val=(String) hs.getAttribute("pass");
	if(val==null){
		//非法登录
		res.sendRedirect("hello4?info=error");//重定向到某个url
		return;
	}

	// 实际的逻辑是在这里
	PrintWriter out = res.getWriter();
	out.println("<h1>" + "保密内容" + "</h1>");




3.删除 Session 会话数据
当您完成了一个用户的 session 会话数据，您有以下几种选择：
 - 移除一个特定的属性：您可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。
 - 删除整个 session 会话：您可以调用 public void invalidate() 方法来丢弃整个 session 会话。
 - 设置 session 会话过期时间：您可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。

 - 注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。
 - web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：
  <session-config>
    <session-timeout>15</session-timeout>
  </session-config>
上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。


在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。









========================================
|-- ServletContext 对象
----------------------------------------
1.定义 
(1)
Web容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext对象，这个对象代表当前Web应用。
并且它被所有客户端共享（比如你在淘宝登陆了，那你的登陆信息会被带到很多页面，就是跳到其他页面发现也是登陆上的）。

(2) 和 session 的区别

极其相似，只是 session 只适用于当前会话，而 ServletContext 是全局一份。
	如果三个用户分别访问服务器，每个有自己的 session。
	但是他们共有一份 ServletContext。


(3) 作用域
Servlet中有三大域对象，分别为：
	request域对象：在一次请求中有效，请求转发有效，重定向失效
	session域对象：在一次会话中有效，请求转发和重定向都有效，session销毁后失效
	servletContext域对象：在整个应用程序中有效，服务器关闭后失效

生命周期
    ServletContext中的属性的生命周期从创建开始，到服务器关闭而结束




2. 方法 
(1)四种获取方式:
	//1. 通过request获取ServletContext对象
	ServletContext servletContext1 = req.getServletContext();
	System.out.println(servletContext1);
	//org.apache.catalina.core.ApplicationContextFacade@14e5f2f5 后面略
	
	//2.通过session获取ServletContext对象
	ServletContext servletContext2 = req.getSession().getServletContext();
	System.out.println(servletContext2);
	
	//3.通过getServletConfig获取ServletContext对象
	ServletContext servletContext3 = this.getServletConfig().getServletContext();
	System.out.println(servletContext3);
	
	//4.直接获取ServletContext对象
	ServletContext servletContext4 = this.getServletContext();
	System.out.println(servletContext4);


(2)ServletContext的两种常用方法
	//Part II ServletContext的两种常用方法
	//1.获取当前服务器的信息
	String serverInfo = req.getServletContext().getServerInfo();
	System.out.println("服务器信息："+serverInfo); //Apache Tomcat/9.0.73
	//2.获取当前项目的真实路径
	String realPath=req.getServletContext().getRealPath("/");
	System.out.println("项目的真实路径:"+realPath);
	//D:\ProgramFiles\apache-tomcat-9.0.73\webapps\Servlet_2\



(3)在ServletContext作用域创建、获取、移除 键值对
添加属性：setAttribute(String name, Object obj);
得到值：getAttribute(String name)，这个方法返回Object
删除属性：removeAttribute(String name)

	ServletContext servletContext = request.getServletContext();
	//设置
	servletContext.setAttribute("uname","admin");
	//获取
	servletContext.getAttribute("uname");
	//移除
	servletContext.removeAttribute("uname");

在一个浏览器中在ServletContext和Session中分别设置一个变量，在另一个Servlet中查看，
	demo2> ServletContext: uname=admin
	demo2> Session: uname2=admin2
在另一个浏览器中打开：
	demo2> ServletContext: uname=admin  #正常
	demo2> Session: uname2=null  #没了
结果发现，ServletContext 对不同浏览器打开都能访问该变量。
	但是，重启服务器后，ServletContext 肯定没了，但是 Session 可能还在。



(4) 获取配置的初始化参数
在web.xml里配置的初始化参数可以用 getInitParameter()方法获取
https://blog.csdn.net/weixin_50606278/article/details/124280308

<context-param>
	<param-name>url</param-name>
	<param-value>jdbc:mysql://localhost:3306/mybatis</param-value>
</context-param>

或使用注解配置：
@WebServlet(urlPatterns ="/servletContextDemo3",
	initParams = {
			@WebInitParam(name="url", value="jdbc:mysql://localhost:3306/mybatis2"),
	})

代码
	ServletContext context = this.getServletContext();
	String url = context.getInitParameter("url");
	resp.getWriter().print(url); //输出的是xml种的，注解中怎么获取？ //todo



(5) 请求转发
RequestDispatcher 代表请求的派发者。
Forward是指内部转发。
	当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。

例如，我们已经编写了一个能处理/hello3的ServletDemon03，
	继续编写一个能处理/hello4的ServletDemon04，
	ServletDemon04在收到浏览器的请求后，它并不自己发送响应，
		而是把请求和响应都转发给路径为/hello3的ServletDemon03，
	后续请求的处理实际上是由ServletDemon03完成的。
	这种处理方式称为转发（Forward）

浏览器 -> 请求 demo4 -> 服务器内部转发给 demo3 -> 响应用户请求。
	转发时，浏览器URL不改变，就一次请求。

实例:
	resp.setContentType("text/html;charset=UTF-8");
	resp.getWriter().append("this is demo4<br>"); //转发后，没有原来的显示了？
	
	//1. 通过request获取ServletContext对象
	ServletContext context = req.getServletContext();
	//2. 获取请求派发器
	RequestDispatcher dispatcher = context.getRequestDispatcher("/servletContextDemo3");
	//3. 派发
	dispatcher.forward(req, resp);




(6) 记录日志 //todo
	ServletContext context = this.getServletContext();
	context.log(email);    //email为要添加进的参数

ServletContext 把它的文本消息记录到 Servlet 容器的日志文件中。
对于 Tomcat，这些日志可以在 <Tomcat-installation-directory>/logs 目录中找到。
但是，我看到的是访问记录，而不是这些自定义输出。这些自定义输出到控制台了。

https://www.tutorialspoint.com/servlets/servlets-debugging.htm



















========================================
Servlet, JDBC, 分页：连不上数据库怎么办？
----------------------------------------
使用 Java 可以访问数据库，
使用Servlet就不行：java.sql.SQLException: No suitable driver found for jdbc:mysql://localhost:3306/test

1, 连接URL格式出现了问题(Connection conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/XX","root","XXXX")
2, 驱动字符串出错(com.mysql.jdbc.Driver)
3, Classpath中没有加入合适的mysql_jdbc驱动
4, 尝试着将mysql-connector-java-5.1.34-bin.jar的jar包加入C:\Program Files\Java\jre1.6.0_02\lib\ext文件夹下(或者直接导入项目中),问题解决
5, 检查是不是jdbc:mysql://写成了jdbc:mysql// 连接写不对也会报这个找不到驱动的错


采取的措施：
1. 保证可编译
	右击项目-Build Path-设置，点add jar，选中 mysql-connector-java-5.1.40-bin.jar
2. 保证可运行：
	把 mysql jar 包放到 jre1.6.0_02\lib\ext\下
	我试了下，jre下不行，要jdk下: C:\Program Files\Java\jdk1.8.0_161\jre\lib\ext





1.文件 
Hello7.java 
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello7 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello7~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			//1.连接数据库
			Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_user;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_user limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>name</td><td>pass</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页代码
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}
					
			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}

2.配置文件：
F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml
	  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello7</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>Hello7</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello7</servlet-name>
		<url-pattern>/hello7</url-pattern>
	</servlet-mapping>

3.url 
http://localhost:8080/mywebsite/hello7?page=3

id	name	pass
6	Smith	e10adc3949ba59abbe56e057f20f883e
7	timoc	e10adc3949ba59abbe56e057f20f883e
11	石劲	e10adc3949ba59abbe56e057f20f883e
25	Tomcat	e10adc3949ba59abbe56e057f20f883e
27	Tomcat@qq.com	e10adc3949ba59abbe56e057f20f883e
上一页 1 2 3 下一页





========================================
servlet设置-列举文件、改端口、设置虚拟目录、添加用户
----------------------------------------
http://www.cnblogs.com/webqiand/p/4315618.html

1.控制列举文件夹
打开Tomcat目录下的/conf/web.xml，将下面listings的属性设置为True。
    <servlet>
        <servlet-name>default</servlet-name>
        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
        <init-param>
            <param-name>debug</param-name>
            <param-value>0</param-value>
        </init-param>
        <init-param>
            <param-name>listings</param-name>
            <param-value>true</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
如果把false设成true，那么将允许在网页中列出目录，让Tomcat 支持文件列表显示
因此注意，这里为了安全，应该设置成false

2.改端口
在conf目录下的server.xml文件里面，修改
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"
redirectPort="8443" />
8080是默认的端口！可以改成80，这样在地址栏就不需要写端口号了。

3.设置tomcat虚拟目录
tomcat7的安装路径下，D:\Program Files\java\Tomcat 7.0\conf，修改server.xml文件
在</Host>标签前，添加上图选中部分即可，
  path ： 地址栏访问路径。
  docBase : 文件的真实路径。注意这里如果有文件上传，则将上传的文件路径设置为docBase，而不是path。  
例如： 
<Context path="/carapp" docBase="D:\nginx-1.8.1\html\carapp" debug="0" reloadable="true" />

可添加多个 目录
修改好之后，重启tomcat7

通过路径http://localhost:8080  即可访问了
本人在测试时，把上面选中部分删掉后，访问路径http://localhost:8080,还是访问的演示工程，而不是tomcat7欢迎页面，
这是tomcat缓存目录在作怪，删除路径Tomcat 7.0\work\Catalina\localhost下的文件夹名是 -  (横杠)的文件夹即可。


以上虚拟目录一直无效，因为eclipse默认的build路径和tomcat不一致。
eclipse的java EE配置一直无效。//todo 


/////////////////////////////////////////
起作用的设置如下，我新建了个ServletDemo项目：
（1）修改Eclipse的build路径：
右击项目，选择 properties，右侧选择Java Build Path，Source选项卡， 
底部默认输出文件夹：ServletDemo/build/classes，改为 ServletDemo/WEB-INF/classes

(2)查看文件夹结构
Servlet/ 这个文件夹的绝度路径放到comcat\conf\server.xml的Context标签的docBase中。
 |-放图片、文本等资源文件。
 |-WEB-INF
    |-web.xml 部署class文件
    |-classes 其中就是eclipse生成的class文件。
看时间戳，确保eclipse修改后classes文件也会重新生成。

（3）配置tomcat虚拟目录，
F:\xampp\tomcat\conf\server.xml文件，在底部</Host>标签前增加一行
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet"></Context>
  path ： 地址栏url访问路径。
  docBase : 文件的真实路径。注意其中的文件结构符合（2）；
（4）重启tomcat，输入路径 http://localhost:8080/mywebsite/readnum
即可访问其中的Servlet文件了。


备注：
F:\xampp\tomcat\conf\context.xml中设置web.xml文件的位置：
    <WatchedResource>WEB-INF/web.xml</WatchedResource>
	
	
4.tomcat添加用户
空密码是不安全的。
设置方式：F:\xampp\tomcat\conf\tomcat-users.xml中添加：

<tomcat-users>
	<role rolename="admin-gui"/>
	<user username="tomcat" password="tomcat" roles="admin-gui"/>

	<role rolename="manager-gui"/>
	<user username="tomcat" password="tomcat" roles="manager-gui"/>
</tomcat-users>

重启tomcat即可。



========================================
tomcat如何设置数据源和连接池（公司常用）？
----------------------------------------
什么是数据库连接池
数据库连接池技术的思想非常简单，将数据库连接作为对象存储在一个Vector对象中，一旦数据库连接建立后，不同的数据库访问请求就可以共享这些连接，这样，通过复用这些已经建立的数据库连接，可以克服上述缺点，极大地节省系统资源和时间。

在实际应用开发中，特别是在WEB应用系统中，如果JSP、Servlet或EJB使用JDBC直接访问数据库中的数据，每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。数据库连接池技术是解决这个问题最常用的方法，在许多应用程序服务器（例如：Weblogic,WebSphere,JBoss）中，基本都提供了这项技术，无需自己编程，但是，深入了解这项技术是非常必要的。


数据库连接池的主要操作如下：
（1）建立数据库连接池对象（服务器启动）。
（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）。
（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。
（4）存取数据库。
（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。
（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。

配置步骤：
1.在Tomcat/conf/content.xml中<Context>节点内添加如下内容
<Resource name="jdbc/user" auth="Container" type="javax.sql.DataSource" maxActive="100" maxIdle="30" maxWait="10000" username="sa" password="120010" driverClassName="com.microsoft.sqlserver.jdbc.SQLServerDriver" url="jdbc:sqlserver://localhost:1433;DatabaseName=user"/>

	name:之后我们要调用resource时候用到 
	type:是链接数据库时候用到的java扩展包下的类 
	maxActive:最大连接数 
	maxIdle:是空闲时候最大连接数 
	maxwait:空闲判断标准 

注意： 
1.该配置文件里不允许有中文；各个属性间的用一个空格隔开 
2.要将对应链接数据库的jar包放到tomcat/lib文件夹中工程中就不需要存放了 
下面还中是链接oracle的
<Resource type="javax.sql.DataSource" name="jdbc/user" url="jdbc:oracle:thin:@192.168.2.102:1521:orcl" driverClassName="oracle.jdbc.driver.OracleDriver" password="bg" username="test" maxWait="10000" maxIdle="30" maxActive="100" auth="Container"/>
2.在工程的web.xml中添加如下代码
<resource-ref>
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
</resource-ref>
这里<res-ref-name>标签里面的名字就是在content.xml文件中的name的名字

3.得到数据库连接池中的Connection对象

Context context=new InitialContext();
DataSourceds=(DataSource)context.lookup("java:comp/env/jdbc/user");
Connectionconn = ds.getConnection();

context是javax.namingx下的类 
dataSource是javax.sql下的类 
"java:comp/env/jdbc/user"中：java:comp/env是固定写法 jdbc/user是jndi名称（Tomcat中配置的那个name）




如果我们不是在web.xml中配置数据源，我们用spring来控制数据库链接方法步骤：
1.在配置文件中添加如下节点
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
    <property name="jndiName" value="java:comp/env/jdbc/user"/> 
</bean>
配置好了获取sql语句查询数据有多少条：

    调用的时候直接Dao类继承JdbcDaoSupport类（spring.jar中的类） 
    int count = this.getJdbcTemplate().queryForInt("select * from users");

http://www.jb51.net/article/36705.htm






/////////////////////////////////////////
我的配置：
参考：【推荐】http://kingxss.iteye.com/blog/1479451
1.
修改tomcat/conf/server.xml 
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet">
	<Resource name="jdbc/user" auth="Container"   
    type="javax.sql.DataSource"  
    driverClassName="com.mysql.jdbc.Driver"  
    url="jdbc:mysql://localhost:3306/think"  
    username="root"  
    password=""  
    maxActive="50"  
    maxIdle="10"  
    maxWait="10000" />
</Context>

使用的是think数据库。


2.
在项目文件件下web.xml的根节点配置：
  <resource-ref>
      <description>mysqlDB Connection</description>  
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
 </resource-ref>

完成上述步骤数据源的连接池配置已经完成，但是为了提高项目的可移植性，
最好将上述第一步的内容放入到工程的META-INF目录的context.xml中（这个文件需要自行建立）：
<?xml version="1.0" encoding="UTF-8"?>  
<Context>  
      <Resource name="jdbc/demoDB" auth="Container"   
      type="javax.sql.DataSource"  
      driverClassName="com.mysql.jdbc.Driver"  
      url="jdbc:mysql://localhost:3306/demo"  
      username="root"  
      password="123"  
      maxActive="50"  
      maxIdle="30"  
      maxWait="10000" />  
</Context>  


3.使用配置数据源的数据库连接池时的数据库操作工具类
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.sql.DataSource;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello8 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello8~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		System.out.println("use 连接池");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			
			//1.2.使用数据库连接池获得连接
			Context context=new InitialContext();
			DataSource ds=(DataSource)context.lookup("java:comp/env/jdbc/user");
			if( ds == null ){  
		           throw new Exception("Data source not found!");  
		    }
			conn = ds.getConnection();
			
			//1.连接数据库
			//Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			//conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_weibo;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_weibo limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>uid</td><td>content</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页按钮
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			//如果太多，怎么显示分页按钮呢？模仿网易博客
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}

			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}
数据库连接写到init方法中。
数据库销毁放到destroy方法中。







========================================
Servlet 过滤器 Filter 类 (Javax.servlet.Filter接口)
----------------------------------------
1. 定义
Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：
	在客户端的请求访问后端资源之前，拦截这些请求。
	在服务器的响应发送回客户端之前，处理这些响应。


根据规范建议的各种类型的过滤器：
	身份验证过滤器（Authentication Filters）。
	数据压缩过滤器（Data compression Filters）。
	加密过滤器（Encryption Filters）。
	触发资源访问事件过滤器。
	图像转换过滤器（Image Conversion Filters）。
	日志记录和审核过滤器（Logging and Auditing Filters）。
	MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。
	标记化过滤器（Tokenizing Filters）。
	XSL/T 过滤器（XSL/T Filters），转换 XML 内容。


过滤器的作用：
	过滤器可以对所有的请求和响应做拦截操作。




2. 传统写法：使用xml定义
(1) 先写过滤器类，需要实现Filter接口。
对每个访问进行过滤。

$ cat LogFilter.java 
package com.dawn.test;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class LogFilter implements Filter{
	@Override
	public void init(FilterConfig config) throws ServletException {
		// 获取初始化参数，从web.xml文件获取配置信息
		String site = config.getInitParameter("Site"); 
		// 输出初始化参数
		String site2=site;
		try {
			site2 = new String(site.getBytes("ISO8859-1"),"UTF-8");//防止中文乱码
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		System.out.println("init: 网站名称=" + site2); 
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		// 输出站点名称
		System.out.println("站点网址：http://www.biomooc.com");
		
		// 把请求传回过滤链
		chain.doFilter(request,response);
	}


	@Override
	public void destroy() {
		/* 在 Filter 实例被 Web 容器从服务移除之前调用 */
		System.out.println("destroy logfilter.");
		
	}
}

(2) 在web.xml中配置：
<!--s filter1 -->
<filter>
	<filter-name>LogFilter</filter-name>
	<filter-class>com.dawn.test.LogFilter</filter-class>
	<init-param>
		<param-name>Site</param-name>
		<param-value>Servlet EXAMPLES.教程-中文乱码吗？</param-value>
	</init-param>
</filter>
<filter-mapping>
  <filter-name>LogFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
<!--e filter1 -->

定义一个filter类，与类关联。其中可以定义参数，在类中调用。
定义一个filter mapping，和url关联。*表示给所有类使用该过滤器。


(3) 也可以定义多个过滤器，其中<filter-mapping>的顺序，决定着使用过滤器的顺序。

(4) 测试：访问http://localhost:8080/mywebsite/getHeader
即可看到控制器台上的输出：
站点网址：http://www.biomooc.com






3. 使用注解定义
(1) 过滤器和Servlet的关系
package com.mio.filter;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

@WebFilter("/*")
public class LogFilterDemo implements Filter {
	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {
		//1.发生在 servlet 之前
		System.out.println("LogFilter begin...");

		//2. 传给servlet
		chain.doFilter(req, res); //这一行把控制权交给 Servlet
		
		//3. 发生在 Servlet 之后
		System.out.println("LogFilter End...");
	}
}



(2) 过滤拦截实例
如果url中的参数name的值不是admin，则不能访问Servlet，被拦截

package com.mio.filter;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

@WebFilter("/filter/*")
public class LogFilterDemo implements Filter {
	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {
		//1.发生在 servlet 之前
		System.out.println("LogFilter begin...");

		//2. 传给servlet。可以做判断
		String name=req.getParameter("name");
		if(name.equals("admin")) {
			chain.doFilter(req, res); //这一行把控制权交给 Servlet
		}else {
			//设置返回内容，不再传给Servlet处理
			res.setContentType("text/html;charset=UTF-8");
			//在页面输出响应信息
			PrintWriter out=res.getWriter();
			out.append("<b>name不正确，请求被拦截，不能访问资源</b>");
			System.out.println("被拦截: name 不正确");
		}
		
		//3. 发生在 Servlet 之后
		System.out.println("LogFilter End...\n");
	}
}





4. Servlet 过滤器中的注解配置

属性名	类型	描述
filterName	String	指定过滤器的 name 属性，等价于 <filter-name>
value	String[]	该属性等价于 urlPatterns 属性。但是两者不应该同时使用。
urlPatterns	String[]	指定一组过滤器的 URL 匹配模式。等价于 <url-pattern> 标签。
servletNames	String[]	指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 <servlet-name> 的取值。
dispatcherTypes	DispatcherType	指定过滤器的转发模式。具体取值包括： ASYNC、ERROR、FORWARD、INCLUDE、REQUEST。
initParams	WebInitParam[]	指定一组过滤器初始化参数，等价于 <init-param> 标签。
asyncSupported	boolean	声明过滤器是否支持异步操作模式，等价于 <async-supported> 标签。
description	String	该过滤器的描述信息，等价于 <description> 标签。
displayName	String	该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签。


(1) 将所有的请求都过滤掉
@WebFilter("/*")
public class LogFilterDemo implements Filter {}

(2) 指定servlet，则其他页面不受影响：
@WebFilter("/servlet1")

(3) 多个页面配置过滤器
@WebFilter(urlPatterns={"/servlet1", "/index.jsp"})


(4) initParams 指定一组过滤器初始化参数，等价于init-param标签。
注意用法，属性名是initParams,但属性值得类型是 WebInitParam[]
@WebFilter(urlPatterns="/filter/demo1", initParams = {
		@WebInitParam(name="username", value="admin"),
		@WebInitParam(name="password", value="123"),
})

在init初始化中的取得初始化参数值
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		Filter.super.init(filterConfig);
		
		String name=filterConfig.getInitParameter("username");
		String passwd=filterConfig.getInitParameter("passwd");
		System.out.println("init: "+name+" "+passwd);
	}

输出：竟然是嵌套的
LogFilter begin...
LogFilter2 begin...
LogFilter2 End...

LogFilter End...


(5) dispatcherTypes 指定转发模式，比如默认请求时调用，而内部转发不调用过滤器。
@WebFilter(urlPatterns="/filter/demo1", initParams = {
		@WebInitParam(name="username", value="admin"),
		@WebInitParam(name="passwd", value="123"),
}, dispatcherTypes = DispatcherType.REQUEST)

FORWARD 转发时触发过滤器
INCLUDE login.jsp 中的 include包含触发
ERROR 出错404时触发
支持多个值
	dispatcherTypes = {DispatcherType.REQUEST, DispatcherType.ERROR }



(6) 问题: 怎么用注解定义多个过滤器的顺序？
如果是注解，会按照名称的ASCII码值进行过滤？ // 貌似是 过滤器 类名: LogFilterDemo 先于 LogFilterDemo2 执行

如果是配置文件进行设置，顺序就是配置文件设置的先后顺序：放在上面的会比放在下面的先执行.

	<!-- 用户登录检测过滤器 -->
    <filter>
         <filter-name>UserLoginFilter</filter-name>
         <filter-class>net.tfgzs.demo.filter.UserLoginFilter</filter-class>
    </filter>
    <filter-mapping>
         <filter-name>UserLoginFilter</filter-name>
         <url-pattern>/*</url-pattern>
    </filter-mapping>
    <!--接口日志过滤器-->
    <filter>
        <filter-name>ApiLog</filter-name>
        <filter-class>net.tfgzs.demo.filter.ApiLog</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>ApiLog</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>



(7) 销毁阶段的触发机制
reload会调用销毁函数
Web容器在卸载Web应用程序前







more: https://www.bilibili.com/video/BV1Kv411r7JM/?p=2







========================================
文件上传与jar包位置
----------------------------------------
http://www.runoob.com/servlet/servlet-file-uploading.html
该页面有一个错误，共出现2处都需要改：
错误：getServletContext()
正确：request.getServletContext()

一共三个文件。涉及到2个包。
	upload.jsp : 文件上传表单。
	message.jsp : 上传成功后跳转页面。
	UploadServlet.java : 上传处理 Servlet。
	需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。

下面的实例依赖于 FileUpload，所以一定要确保在您的 classpath 中有最新版本的 commons-fileupload.x.x.jar 文件。可以从 http://commons.apache.org/proper/commons-fileupload/ 下载。
FileUpload 依赖于 Commons IO，所以一定要确保在您的 classpath 中有最新版本的 commons-io-x.x.jar 文件。可以从 http://commons.apache.org/proper/commons-io/ 下载。

	http://static.runoob.com/download/commons-fileupload-1.3.2.jar
	http://static.runoob.com/download/commons-io-2.5.jar

	
问题：
1.为什么这两个包需要存在2份？
一份是Servlet/WebContent/WEB-INF/lib下，一份是Servlet/WEB-INF/lib/下。
前者是eclipse生成用，后者是tomcat运行用。
能否少一份，以便减少git文件体积。只能减少前者了。
删除Servlet/WebContent/WEB-INF/lib/下的2个jar包，UploadServlet.java报错，右击该java文件，选择build path,
configure build path, libraries, add JARs,选择Servlet/WEB-INF/lib/下的2个jar包确定即可。

2.jar包存放的位置？
jar包如果是项目运行必须的，则2个地方至少放一个。
一个tomcat级别的lib文件夹：\tomcat\lib\
一个是具体项目级别的lib文件夹：\项目名\WEB-INF\lib\
tomcat级别的所有项目都可用，而项目级别的只有该项目可用该jar包。

其他位置则可能是编辑器IDE的要求。可以简化。

	
	
	
	
	
	以下是 UploadServlet 的源代码，同于处理文件上传，在这之前我们先确保依赖包已经引入到项目的 WEB-INF/lib 目录下：
	
	
1.upload.jsp : 文件上传表单。
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传实例</title>
</head>
<body>
<h1>文件上传实例</h1>
<form method="post" action="/mywebsite/UploadServlet" enctype="multipart/form-data">
	选择一个文件:
	<input type="file" name="uploadFile" />
	<br/><br/>
	<input type="submit" value="上传" />
</form>
</body>
</html>


2.message.jsp : 上传成功后跳转页面。
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传结果</title>
</head>
<body>
    <center>
        <h2>${message}</h2>
    </center>
</body>
</html>

3.UploadServlet.java : 
package com.dawn.test;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
 

/**
 * Servlet implementation class UploadServlet
 */
@WebServlet("/UploadServlet")
public class UploadServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
     
    // 上传文件存储目录
    private static final String UPLOAD_DIRECTORY = "upload";
 
    // 上传配置
    private static final int MEMORY_THRESHOLD   = 1024 * 1024 * 3;  // 3MB
    private static final int MAX_FILE_SIZE      = 1024 * 1024 * 40; // 40MB
    private static final int MAX_REQUEST_SIZE   = 1024 * 1024 * 50; // 50MB
 
    @Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init it ! uploading");
	}
    /**
     * 上传数据及保存文件
     */
    protected void doPost(HttpServletRequest request,
		HttpServletResponse response) throws ServletException, IOException {
		// 检测是否为多媒体上传
		if (!ServletFileUpload.isMultipartContent(request)) {
		    // 如果不是则停止
		    PrintWriter writer = response.getWriter();
		    writer.println("Error: 表单必须包含 enctype=multipart/form-data");
		    writer.flush();
		    return;
		}
 
        // 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        // 设置临时存储目录
        factory.setRepository(new File(System.getProperty("java.io.tmpdir")));
 
        ServletFileUpload upload = new ServletFileUpload(factory);
         
        // 设置最大文件上传值
        upload.setFileSizeMax(MAX_FILE_SIZE);
         
        // 设置最大请求值 (包含文件和表单数据)
        upload.setSizeMax(MAX_REQUEST_SIZE);
 
        // 构造临时路径来存储上传的文件
        // 这个路径相对当前应用的目录
        
        System.out.println(request.getServletContext().getRealPath("./"));
        
        String uploadPath = request.getServletContext().getRealPath("./") + File.separator + UPLOAD_DIRECTORY;
       
         
        // 如果目录不存在则创建
        File uploadDir = new File(uploadPath);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }
 
        try {
            // 解析请求的内容提取文件数据
            @SuppressWarnings("unchecked")
            List<FileItem> formItems = upload.parseRequest(request);
 
            if (formItems != null && formItems.size() > 0) {
                // 迭代表单数据
                for (FileItem item : formItems) {
                    // 处理不在表单中的字段
                    if (!item.isFormField()) {
                        String fileName = new File(item.getName()).getName();
                        String filePath = uploadPath + File.separator + fileName;
                        File storeFile = new File(filePath);
                        // 在控制台输出文件的上传路径
                        System.out.println(filePath);
                        // 保存文件到硬盘
                        item.write(storeFile);
                        request.setAttribute("message", "文件上传成功!");
                    }
                }
            }
        } catch (Exception ex) {
            request.setAttribute("message",
                    "错误信息: " + ex.getMessage());
        }
        // 跳转到 message.jsp
        request.getServletContext().getRequestDispatcher("/message.jsp").forward(request, response);
    }
}


4.在web.xml中注册类
 <servlet>
    <display-name>UploadServlet</display-name>
    <servlet-name>UploadServlet</servlet-name>
    <servlet-class>com.dawn.test.UploadServlet</servlet-class>
  </servlet>
   
  <servlet-mapping>
    <servlet-name>UploadServlet</servlet-name>
    <url-pattern>/UploadServlet</url-pattern>
  </servlet-mapping>

5.访问 http://localhost:8080/mywebsite/upload.jsp
即可上传图片到根目录下的upload文件夹。








========================================
Servlet 处理日期
----------------------------------------
Java 提供的 java.util 包中的 Date 类，这个类封装了当前的日期和时间。Date 类支持两个构造函数。

1.第一个构造函数初始化当前日期和时间的对象。
Date( )

2.下面的构造函数接受一个参数，该参数等于 1970 年 1 月 1 日午夜以来经过的毫秒数。
Date(long millisec)

一旦您有一个可用的 Date 对象，您可以调用下列任意支持的方法来使用日期：

3.CurrentDate.java

import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.*;

public class CurrentDate extends HttpServlet {

	private static final long serialVersionUID = 1L;
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=UTF-8");
		
		PrintWriter out=response.getWriter();
		
		//当前时间
		Date date=new Date();
		out.println("1.当前日期和时间："+date.toString());
		
		//java的时间戳
		out.println("<br>2.java时间戳 （单位：ms）："+date.getTime()+", 需要缩小1000倍后和php一样:"+ date.getTime()/1000);
		out.println("<br>(php[10位]:1482674513)<br>");
		
		//格式化显示
		SimpleDateFormat ft = 
				new SimpleDateFormat ("yyyy.MM.dd hh:mm:ss E a");
		out.println("3.格式化后："+ft.format(date));
	}
}

4.在web.xml中定义类和url
 <servlet>
    <display-name>currentDate</display-name>
    <servlet-name>currentDate</servlet-name>
    <servlet-class>CurrentDate</servlet-class>
  </servlet>
   
  <servlet-mapping>
    <servlet-name>currentDate</servlet-name>
    <url-pattern>/currentDate</url-pattern>
  </servlet-mapping>

5.访问： http://localhost:8080/mywebsite/currentDate 显示：

1.当前日期和时间：Tue Jan 03 17:20:36 CST 2017 
2.java时间戳 （单位：ms）：1483435236806, 需要缩小1000倍后和php一样:1483435236 
(php[10位]:1482674513)
3.格式化后：2017.01.03 05:20:36 星期二 下午





========================================
计数器
----------------------------------------
1.网页计数器

package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class PageHitCounter extends HttpServlet{ 
	private static final long serialVersionUID = 1L;
	
	private int hitCount; 
    
	public void init() {
		// 重置点击计数器
		hitCount = 0;
	}
	
	public void doGet(HttpServletRequest req, HttpServletResponse res)
			throws ServletException, IOException {
		res.setContentType("text/html;charset=utf-8");
		hitCount++;
		PrintWriter out=res.getWriter();
		String str="本页面的点击次数()："+hitCount;
		out.println(str);
		System.out.println(str);
	}
	
	public void destroy() { 
		// 这一步是可选的，但是如果需要，您可以把 hitCount 的值写入到数据库
	} 
}




2.网站点击计数器
很多时候，您可能有兴趣知道整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器做到这一点。

详见上述过滤器部分。












========================================
Servlet 发送电子邮件
----------------------------------------
使用 Servlet 发送一封电子邮件是很简单的，但首先您必须在您的计算机上安装 JavaMail API 和 Java Activation Framework）JAF）。
您可以从 Java 网站下载最新版本的 JavaMail（http://www.oracle.com/technetwork/java/javamail/index.html），打开网页右侧有个 Downloads 链接，点击它下载。
您可以从 Java 网站下载最新版本的 JAF（版本 1.1.1）（http://www.oracle.com/technetwork/articles/java/index-135046.html）。




========================================
Servlet 包
----------------------------------------

1.涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定。给定一个顶级目录名 myapp，目录结构如下所示：
/myapp
    /images
    /WEB-INF
        /classes
        /lib
WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。所有的 HTML 文件都位于顶级目录 myapp 下。对于 admin 用户，您会发现 ROOT 目录是 myApp 的父目录。




2.创建包中的 Servlet
WEB-INF/classes 目录包含了所有的 Servlet 类和其他类文件，类文件所在的目录结构与他们的包名称匹配。例如，如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于以下目录中：
/myapp/WEB-INF/classes/com/myorg/MyServlet.class


========================================
servlet国际化
----------------------------------------

GetLocale.java 文件，获取语言，国家，日期。


import java.io.IOException;
import java.io.PrintWriter;
import java.text.DateFormat;
import java.util.*;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class GetLocale extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=utf-8");
		Locale locale =request.getLocale();
		String language=locale.getLanguage();//语言
		String country=locale.getCountry();//国家

		String date = DateFormat.getDateTimeInstance(
                DateFormat.FULL, 
                DateFormat.SHORT, 
                locale).format(new Date( ));//本地化日期

		//输出
		PrintWriter out=response.getWriter();
		out.println("language:"+language+"<br>");
		out.println("country:"+country+"<br>");
		
		out.println("date:"+date+"<br>");
		//language:zh
		//country:CN
	}
}



========================================
servlet 案例：用户登录
----------------------------------------
(3) 实例: 用户登录案例 https://www.bilibili.com/video/BV1CM411a7s1/?p=28
输入用户名和密码，点登录。
	把用户名和密码包装成bean，调用该user的login方法。
	JDBC 工具类 JDBCUtils 类，使用 Durid 连接池。
		连接池对象
		Connection 对象
	UserDao 中实现 login(User loginUser) 方法，根据username查询用户并返回真正的 user。
		比较查询和用户的输入是否一致？
	如果成功，跳转新页面，提示成功并显示用户名。
	失败，跳转新页面，提示失败。


要点: 工具类 BeanUtils 简化网页信息到 Bean 的过程，用于封装 JavaBean
	User loginUser=new User(uername, password); // 只有两个信息
	Map<String, String[]> map=req.getParameterMap();
	BeanUtils.populate(loginUser, map); //把map信息封装到 loginUser 变量中；放到try...catch中


JavaBean 定义: 就是一个类，必须public类，提供空参构造器，成员变量private，提供 getter 和 setter 方法。
BeanUtils 类的方法
	setProperty();
	getProperty();
	populate(Object obj, Map map); map 键值对 封装到 obj 这个 JavaBean 中




========================================
servlet更多资料
----------------------------------------
 - servlet:http://www.oracle.com/technetwork/java/javaee/servlet/index.html 官方网站上关于 Servlet 的相关资料。
 - tomcat:http://tomcat.apache.org/ Apache Tomcat 是一个开源软件，实现了对 Java Servlet 和 JSP（JavaServer Pages）技术的支持。
 - mysql Connector/J: http://dev.mysql.com/downloads/connector/j/5.1.html   MySQL Connector/J 是 MySQL 官方 JDBC 驱动程序。MySQL Connector/J is the official JDBC driver for MySQL.

 - The Java™ Tutorials: http://docs.oracle.com/javase/tutorial/index.html   Java 编程语言入门教程。
 - java8: http://docs.oracle.com/javase/8/   Java Platform, Standard Edition (Java SE) 8

 - JDK: https://www.java.com/en/download/
 - JAVA 官网： http://www.oracle.com/technetwork/java/index.html




========================================
异常处理 // todo
----------------------------------------
https://www.runoob.com/servlet/servlet-exception-handling.html













========================================
----------------------------------------









========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



