Spring5 MVC
    因为spring6 mvc 一直没运行成功，学的基于spring5的mvc

IDE:
    使用官方的 spring tool suit 4.0
    尝试IDEA 社区版
        卸载git2.15,安装git2.40: https://git-scm.com/download/win


SSH已经过时了
    Struts2 已被 Spring MVC/ Spring Boot 所取代，
        struts1是古代，struts2是近代，spring mvc是现代
        Struts2 漏洞太多 (国内大厂都中过招)
        SpringMVC 更兼容Spring(2013年开始)
            Spring Boot 大行其道，零 XML 配置，开箱即用
        除了老项目，还有谁会在新项目上用 Struts2 的？
            建议不用学 struts ，直接学 spring mvc
    Hibernate 也逐渐被 MyBatis/ Spring Data JPA 所取代

现在流行:
    SSM = Spring + Spring MVC/ Spring Boot + MyBatis




https://itbaima.net/#/document
https://itbaima.net/#/curriculum



========================================
Spring MVC 该怎么学？
----------------------------------------

https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc
主要内容:
    MVC: 请求和响应
    REST
    WebSocket
    Other: SSM 整合
    拦截器


目标:
    获取请求参数，响应json数据
    REST风格进行开发
    前后端通信协议的实现
    SSM整合技术


1.SpringMVC的几大组件：
1）DispatcherServlet 根据请求的不同，将请求分发到不同的Controller处理器

2）Dispatcher 具体处理请求，返回逻辑视图

3）Handler Mapping 

3）ModelAndView 返回的逻辑视图，注意，是逻辑视图，并不是真正的视图比如JSP页面，而是通过通过视图解析器VierResoler解气逻辑视图，返回真正的要发送给前端的视图

4）ViewResolver View 视图解析类



2. 教程
详解SpringMVC: https://zhuanlan.zhihu.com/p/487488437





3.Spring6 MVC 的变化
(1). 依赖的servlet命名空间改变。
原来是javax，现在是 jakarta。
    <dependency>
      <groupId>jakarta.servlet</groupId>
      <artifactId>jakarta.servlet-api</artifactId>
      <version>6.0.0</version>
    </dependency>

(2). 支持的jdk变化
原来是 jdk1.8，现在是jdk17

(3). tomcat 版本号变化
spring6支持 tomcat10.0






========================================
Spring MVC 入门案例
----------------------------------------
1. 三层架构的演进

(1) 开始：请求 - Servlet 处理和响应

(2) 把Servlet分成三份
    Web 接收操作
    service 处理业务逻辑
    dao 数据持久化
这样一个servlet只能处理一个请求。

(3) 继续拆分成MVC
请求 -> controller ->service ->dao 
    dao和service 返回的数据叫模型 Model
    模型整合后拼接界面，叫视图 View


(4) 最后把视图抛给浏览器处理拼接：异步调用模式
后端: controller ->service ->dao，只返回json数据。
前端: 接收json并用js处理页面。
前后端交互：json

这就是 Spring MVC 模型。

Spring MVC 是一种基于MMC模型的轻量级web框架。




2. 步骤
(1) Servlet 开发web程序的流程
    1) 创建web工程：maven结构
    2) 设置tomcat服务器，加载web工程（tomcat插件）
    3) 导入坐标（Servelt）
    4) 定义处理请求的功能：UserService
    5) 设置请求的映射：配置映射关系

(2) Spring MVC技术开发web程序的流程
    1) 创建web工程：maven结构
    2) 设置tomcat服务器，加载web工程：tomcat插件
    3) 导入坐标：spring MVC + servlet
    4) 定义处理请求的功能类：UserController
    5) 设置请求映射：配置映射关系
    6) 将Spring MVC设定加载到Tomcat容器中。






3. 创建空白文件 with Eclipse
(0) File - new - Dynamic Web Project (跳过)
Project name: spring6-MVC-web
不勾选 Use default location
Location: G:\learngit\spring6-mvc

Target runtime: Tomcat v9.0
Dynamic web module version: 4.0

勾选 Generate web.xml deployment descripter

左侧右击项目，build path，选择 本机的 jdk-17

删掉该项目。


(1) 创建maven 父项目
File - new - other, 输入 maven，选择 maven project
勾选 Create a simple project
不勾选 Use default Workspace location
Location: G:\learngit\spring6-mvc


Group Id: com.mio
Artifact Id: spring-mvc
打包方式: pom
Finish;


(2) 在父项目 pom.xml 中配置依赖
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mio</groupId>
  <artifactId>spring-mvc</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>
  <modules>
    <module>spring6-mvc-first</module>
  </modules>
  
  <dependencies>
    <!-- Servlet API-->
    <dependency>
      <groupId>jakarta.servlet</groupId>
      <artifactId>jakarta.servlet-api</artifactId>
      <version>6.0.0</version>
      <scope>provided</scope>
      <!-- 这有啥影响？-->
    </dependency>
          
    <!-- spring web MVC -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>6.0.8</version>
    </dependency>
    
    <!-- junit 5-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.9.2</version>
    </dependency>
    
  </dependencies>
  
  <!-- 配置tomcat插件-->
  <build>
    <plugins>
      <plugin>
        <groupId>org.opoo.maven</groupId>
        <artifactId>tomcat9-maven-plugin</artifactId>
        <version>3.0.1</version>
        <configuration>
          <!-- 设定端口 -->
          <port>8081</port>
          <!-- 路径 -->
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>


(3) 创建子模块 spring6-mvc-start
https://blog.csdn.net/m0_73533108/article/details/126949474

击外部项目 spring6-mvc，new- Maven Module
    不勾选 skip archetype selection
    Module name: spring6-mvc-first
    父项目: spring6-mvc

选择一个模式：
    选择 org.apache.maven.archetypes / maven-archetype-webapp，其他保持默认即可

Parameter:
    group id: com.mio
    artifact id: spring6-mvc-first
    version:
    packaging: org.spring6.mvc.first
Finish

会下载一些东西。
最后回车。

删除 index.jsp 和 web.xml 文件。










4. 创建类文件

(1) 创建配置类，扫描包
$ cat SpringMvcConfig.java
package com.mio.first.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration //配置类，代替配置文件
@ComponentScan("com.mio.first") //扫描路径
public class SpringMvcConfig {

}




(2) 创建实体类，响应请求
$ cat UserController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class UserController {
    
    @RequestMapping("/save")
    public void save() {
        System.out.println("user save ...");
    }
}



(3) 创建容器类，注册配置文件
$ cat ServeletInitConfig.java
package com.mio.first.config;

import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;

public class ServeletInitConfig extends AbstractDispatcherServletInitializer{

    //加载的配置对象
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context=
                new AnnotationConfigWebApplicationContext();
        //注册 配置类
        context.register(SpringMvcConfig.class);
        return context;
    }

    //设置spring 管理的范围，其余归tomcat处理
    @Override
    protected String[] getServletMappings() {
        return new String[] {"/"}; //所有请求都归Spring处理
    }

    //加载Spring的配置对象上下文，可以忽略
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}




(4A) 运行在tomcat中
右击子模块，run as, mvn build ...
Goals: tomcat9:run
勾选 slip test
确定。

运行失败。。。无法找到对应的路径。






==> 使用 spring tool suite 4.0 创建基于maven的web工程
也找不到怎么启动。







========================================
|-- 使用 IDEA 创建基于maven的web工程: 基于 spring5
----------------------------------------
1. 配置工具 
(1)配置maven
File -settings
Build-Bild Tools-Maven
    Maven home path: 选择安装的 D:...maven-3.9.1
    这两个会自动更新
    User settings file: C:\Users\admin\.m2\settings.xml 这个貌似不对
        勾选后面的 Override，改为: D:\ProgramFiles\apache-maven-3.9.1\conf\settings.xml
    Local repository: D:\ProgramFiles\myMavenRepo




2. 新建工程
new - project
name: spring-mvc3
Location: G:\java_code\test3
Lang: Java
Build sys: Maven
JDK: 17
勾选 add sample code

adv settings:
    groupId: com.mio
    artifactId: spring-mvc3

保存，右上角Maven面板展开，点刷新。
展开，可见已经加载的项目。



3. 在pom.xml中配置依赖
$ cat pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mio</groupId>
    <artifactId>spring-mvc3</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>


    <dependencies>
        <!-- servlet 依赖 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- spring mvc 依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.26</version>
        </dependency>
    </dependencies>

    <!--编译依赖，端口8081，根路径/ -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>common-tomcat-maven-plugin</artifactId>
                <version>2.2</version>
                <configuration>
                    <port>8081</port>
                    <path>/</path>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>



4. 其他类文件见上。



5. 运行
(1) 尝试1：失败
菜单 Run-Edit Configurations
    左侧:add new: maven
    右边: 
        name: 随便写
        Run: tomcat7:run
        失败，只是编译并退出。


(2) 使用插件 配置tomcat
https://blog.csdn.net/bsegebr/article/details/126384293

菜单File-settings
    Plugins: 搜索 Smart Tomcat，安装。
    点底部OK，关闭窗口。
右上角运行前下拉框，点第一个编辑
    左上角+，选择Smart Tomcat;
    右边配置：
        Tomcacat server, 右边 Configure 选择安装的 Tomcat9版本。
            确定后，下拉框选择刚设置的Tomcat。
        Doployment dir: D:\ProgramFiles\apache-tomcat-9.0.73\webapps\
        User Classpath of module: spring-mvc3
        Context path: test1
        Server port: 8080, Admin port:8005
        点ok。

可以启动，并输入url: http://localhost:8080/test1/save
    解释: 
        Context path 就是整个项目的地址。
        后面的路径是方法上设置的路径。
        说明配置文件中国的端口号8081没生效，还是这个Smart tomcat中配置的端口号。
    这时，页面是报错的，只有控制台有内容输出: user save...
    点右上角运行后的方块，暂停运行。


(3) 修改实体类
$ cat UserController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save...");
        return "{'msg': 'spring5 mvc'}";
    }
}

再次启动Tomcat9，输入url: http://localhost:8080/test1/save
    网页上看到 {'msg': 'spring5 mvc'}
    控制台看到 user save...

说明调用成功。

感觉比Eclipse使用体验好多了！


(4) 尝试修改端口
右上角：
    停止服务器。
    下拉框第一行，修改端口号为 8083
    启动: 确实已经变成 http://localhost:8083/test1






6. 入门案例总结
(1)一次性工作:
    创建工程、设置服务器，加载工程
    导入坐标
    创建web容器启动类（设置配置类，扫描包路径，加载Controller控制器bean）

(2)多次工作:
    定义处理请求的控制器类
    定义处理请求的控制器方法，并配置映射路径(@RequestMapping)与返回json数据(@ResponseBody)

一个项目，就是写url映射，写对应的方法。






7.入门案例工作流程分析
初始化流程
请求流程

(1)tomcat启动，执行容器初始化: ServeletInitConfig 类
  (2)该类执行createServletApplicationContext()，创建WebApplicationContext对象
    (3)该方法加载 SpringMvcConfig 类：代替xml配置文件。 
      (4)该配置方法中执行 @ComponentScan 加载对应的bean
        (5)于是 UserController 加载，每个 @RequestMapping 的名称对应一个具体的方法。
        (6)getServletMappings()方法规定，哪些请求通过 Spring mvc

具体加载到web容器的哪里呢？只有一个地方： 
Web容器:
  ServletContext
    WebApplicationContext
      UserController 类
        //save -> save()


一个请求过程:
    - 发送 http://localhost/save
    - web 容器发现所有请求都经过 spring mvc，经请求交给它处理
    - 解析请求路径 /save
    - 由 /save 匹配执行对应的方法 save()
    - 执行 save()
    - 检测到有 @ResponseBody 直接把save()返回值作为响应体返回。





8. 文件结构
com
 |-mio
   |-config
   |-controller
   |-service
   |-dao

Spring mvc 相关的bean: 表现层 bean
Spring 控制的bean:
    业务 bean: service
    功能 bean: DataSource 等

(1) 因为功能不同，怎么避免 Spring 错误的加载到 SpringMVC 的bean?
加载 Spring 控制的bean的时候排除掉 SpringMVC 控制的bean。
    - SpringMVC 加载bean对应的包均在 com.mio.controller 包中
    - Spring相关的bean加载:
        * 方式1: 扫描 com.mio，排除掉 controller 包。比如，使用注解排除
        * 方式2: 只扫描 com.mio 下的 service、dao包等。
        * 方式3: 不区分 spring和springMVC，都加载。







9. Servlet 初始化类的简化写法
$ cat ServeletInitConfig.java
package com.mio.first.config;

import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import javax.servlet.Filter;

public class ServeletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

/*    //应对中文乱码：get和post参数
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter=new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        //return super.getServletFilters();
        return new Filter[]{filter};  //多个过滤器还可以继续往后写
    }*/
}















========================================
|-- postMan 简介： 接口测试工具
----------------------------------------
1. postman是一款功能强大的网页调试与发送网页HTTP请求的chrome插件
作用：用于接口调试
特征：
    简单
    实用
    美观
    大方

异步调用的好工具。



2. 安装
(1) https://www.postman.com/

下载，免安装；
注册账号: 
    如果无法注册，可以去网站上注册。
    postman, poster469@163; dawneve/nk16!
    身份: James Wang, Student; 邀请好友: https://app.getpostman.com/join-team?invite_code=04be117e45ef46585cabc4795fcdee6e
然后app登录，跳转网页认证，回到app。



3. 使用

(1) 先创建工作空间，有云备份的作用。

点击左侧 workspace，
右上角 Create Workspace，
    name: springMVC5
    确定。

新界面
    左上角，可以切换工作空间。

(2) 发送请求
右侧 requests 右侧的加号点击，
新页面，选择请求类型，比如 GET，输入 http://localhost:8081/test1/save 回车
这就相当于浏览器的请求，可以看到底下的页面返回值: {'msg': 'spring5 mvc'}

保存该请求: 右上角 save 点击，起名字，创建收藏该请求的集合，确定。
    这时，左侧多一个保存条目。


(3) 若干天后
点击左侧记录，直接点击send，就可以测试了。






========================================
请求与响应: 各种请求与参数、json响应
----------------------------------------
请求要点:
    请求前缀
    请求类型
    请求参数类型




1. 路径前缀
@RequestMapping 注解可以加到 类上和方法上，类前的是url的前缀。

$ cat BookController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("/book")
public class BookController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("book save...");
        return "{'msg': 'spring5 mvc, Book'}";
    }
}

比如，上面的路径就是 /book/save






2. 怎么区分get和post请求

(1) 后台代码不变
@Controller
@RequestMapping("/book")
public class BookController {

    @RequestMapping("/save")
    @ResponseBody
    public String save(String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return "{'msg': 'spring5 mvc, save book info'}";
    }
    ...
}


(2) 使用postman发送get请求
http://localhost:8080/test3/book/save?name=javaAdv&price=120
    网页显示: {'msg': 'spring5 mvc, save book info'}
    控制台显示: 
        book name: javaAdv
        book price: 120


(3) 使用postman发送get请求
选择 post，输入 http://localhost:8080/test3/book/save
接着是消息体，选择body；
表单信息选择 x-www-form-urlencoded
    name springMVC adv
    price 220
上传文件选择 form-data
单击send
    网页显示: 
    控制台显示: 
        book name: springMVC adv
        book price: 220





3. 怎么发送中文不乱吗？

(1) 发送的name改为 'springMVC 高级教程'
控制器改为在网页+控制台同时输出，结果都是乱码。

@Controller
@RequestMapping("/book")
public class BookController {

    @RequestMapping("/save")
    @ResponseBody
    public String save(String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return String.format("{'book': '%s', 'price': %d}", name, price);
    }


(2) 之前是修改Servlet的请求编码（？），相当于过滤器
这里也是，需要在Servlet初始化类中新增方法:

$ tail ServeletInitConfig.java
...
public class ServeletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
...
    //应对中文乱码：get和post参数
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter=new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        //return super.getServletFilters();
        return new Filter[]{filter};  //多个过滤器还可以继续往后写
    }
...

再测测试，发现控制台正常了，网页还是中文乱码。 //todo







4. 如果请求参数名字和方法参数不一致怎么办？
(1)比如url参数名是 bookname，方法中接收的是 name，怎么办？
使用注解 @RequestParam("bookname") 转换：

    @RequestMapping("/save")
    @ResponseBody
    public String save(@RequestParam("bookname") String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return String.format("{'book': '%s', 'price': %d}", name, price);
    }

访问: http://localhost:8080/test3/book/save?price=120&bookname=java adv
控制台: 
    book name: java adv
    book price: 120

(2) @RequestParam 有两个参数
required 是否必须参数
defaultValue 参数的默认值





5. 传递 pojo 参数，自动构建实体类

新增实体类 
$ cat Book.java
package com.mio.first.domain;

public class Book {
    private String name;
    private int price;

    public void setName(String name) {
        this.name = name;
    }
    public void setPrice(int price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return String.format("Book[name:%s, price:%d]", name, price);
    }
}


控制器接收Book book参数:
    @RequestMapping("/save")
    @ResponseBody
    public String save(Book book){
        System.out.println(book);
        return String.format("{'book': '%s'}", book);
    }


浏览器请求: http://localhost:8080/test3/book/save?name=%E9%AB%98%E7%BA%A7&price=12
    浏览器显示: {'book': 'Book[name:??, price:12]'}
    控制台显示: Book[name:高级, price:12]




6. 含有复杂属性的对象: pojo 对象嵌套

比如，每个书的作者，可能有更多信息。

$ cat Author.java
package com.mio.first.domain;

public class Author {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return String.format("Author[name: %s, age: %d]", name, age);
    }
}


Book.java 中添加新属性，及set方法，修改toString()
    private Author author;

    public void setAuthor(Author author) {
        this.author = author;
    }

    @Override
    public String toString() {
        return String.format("Book[name:%s, price:%d, author: %s]", name, price, author);
    }


控制器不变:
    @RequestMapping("/save")
    @ResponseBody
    public String save(Book book){
        System.out.println(book);
        return String.format("{'book': '%s'}", book);
    }


浏览器访问，注意参数的写法：
    name=JavaAdv, price=80;
    author.name2=Tom, author.age=30

    http://localhost:8080/test3/book/save?price=120&name=java adv
        控制台: Book[name:java adv, price:120, author: null]

    http://localhost:8080/test3/book/save?price=120&name=javaAdv&author.name=Bill&author.age=32
        控制台: Book[name:javaAdv, price:120, author: Author[name: Bill, age: 32]]




7.接收数组
使用复选框表单，每个复选框同名，传递的就是数组。

控制器:
    @RequestMapping("/array")
    @ResponseBody
    public String getArray(String[] likes){
        System.out.println(Arrays.toString(likes));
        return String.format("{'likes': '%s'}", Arrays.toString(likes));
    }

测试: http://localhost:8080/test3/book/array?likes=java&likes=Cpp&likes=R
显示:
    控制台 [java, Cpp, R]
    网页 {'likes': '[java, Cpp, R]'}





8. 接收集合框架

控制器:
    //接收集合
    @RequestMapping("/list")
    @ResponseBody
    public String getList(List<String> likes){
        System.out.println(likes);
        return String.format("{'likes': '%s'}", likes);
    }

测试: http://localhost:8080/test3/book/list?likes=java&likes=Cpp&likes=R
报错: java.lang.IllegalStateException: No primary or single unique constructor found for interface java.util.List

分析: 把参数(List<String> likes)当做了pojo对象，类比 User user，需要构造器创建空对象，然后设置属性。这不是我们需要的。
    我们需要把接收的参数直接放到集合中。
    可以在参数前加注解 @RequestParam


控制器v2:
    //接收集合
    @RequestMapping("/list")
    @ResponseBody
    public String getList(@RequestParam List<String> likes){
        System.out.println(likes);
        return String.format("{'likes': '%s'}", likes);
    }

再次测试，结果正常，和array一样。





========================================
|-- 传递 json 数据
----------------------------------------

基本步骤:
    1 pom.xml 中加 jackson 坐标
    2 postman 中发送json数据的方法：get和post都可以，选raw-最后的text下拉框选json，输入json数据
        注意：转到headers下，发现 Content-Type 已经修改为 application/json 了。
    3 在配置类上 开启自动转换json数据的支持: @EnableWebMvc，该注解十分强大，以后还会遇到
    4 控制器参数中，添加注解 @RequestBody，把请求体中的数据放到形参中。在一个处理器方法中只能使用一次。



控制器不变

    //接收集合
    @RequestMapping("/list")
    @ResponseBody
    public String getList(@RequestParam List<String> likes){
        System.out.println(likes);
        return String.format("{'likes': '%s'}", likes);
    }


1. 在 pom.xml 中加入 jackson 坐标

        <!-- jackson -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.14.2</version>
        </dependency>
右侧，刷新pom。



2. postman 发送json数据
新建，底下数据体body中的raw，勾选最后的Text下拉框中的json。
get或post提交都可以。
输入: ["game", "music", "travel"]



3. 在配置文件中告诉 spring 这是 mvc模式: 开启json转对象的功能
$ cat SpringMvcConfig.java
package com.mio.first.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration //配置类，代替配置文件
@ComponentScan("com.mio.first") //扫描路径
@EnableWebMvc //开启mvc模式，可以处理json  <===== 加上这一行
public class SpringMvcConfig {
}



4. 尝试请求
请求 http://localhost:8080/test3/book/list
报错: Required request parameter 'likes' for method parameter type List is not present

修改参数的注解为 @RequestBody，因为信息在消息体中：
    //接收json
    @RequestMapping("/list")
    @ResponseBody
    public String getList(@RequestBody List<String> likes){
        System.out.println(likes);
        return String.format("{'likes': '%s'}", likes);
    }

测试: 内容见步骤2
接收: [game, music, travel]


(2) 使用命令行提交
$ curl --location 'http://localhost:8080/test3/book/list' --header 'Content-Type: application/json' --data '["Bill", "Gates"]'
控制台输出: [Bill, Gates]



(3) 怎么从网页提交json数据呢？ //todo
表单或者ajax。

(3A) 使用form不成功，原因可能是：表单无法生成无名的数组json。

<meta charset="utf-8" />
<html><head><title>test</title></head><body>
    <form action="http://localhost:8080/test3/book/list" method="POST" name="myForm" enctype='application/json'>         
        <p>
            <label for="first_name">First Name:</label>
            <input type="text" name="first_name" id="fname">
        </p>
        <p>
            <label for="last_name">Last Name:</label>
            <input type="text" name="last_name" id="lname">
        </p>
        <input value="Submit" type="submit">
    </form>
</body></html>


(3B) 使用ajax由于同源策略，一直失败

$ cat ajax.html #放到class根目录下resources/下
<meta charset="utf-8" />
<button onclick="submitform()">ajax提交</button>
<script type="text/javascript">
    function submitform(){
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "http://localhost:8080/test3/book/list", true);

        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                console.log("success: ", xhr.responseText)
            }else{
                console.log("error: ", xhr.responseText)
            }
        }

        xhr.setRequestHeader('Content-Type', 'application/json');
        var postData = ["games", "films"];
        xhr.send(JSON.stringify(postData));
        return false;
    }
</script>



在另一个控制器中加载该文件：
//    private String msg="<h2>hello, ajax from file</h2>";
    private String msg;

    @RequestMapping("/ajax")
    @ResponseBody
    public String ajax() {
        System.out.println("show ajax ...");
        String path=this.getClass().getResource("/").getPath();
        System.out.println("路径一为："+ path);

        // read from file;
        try {
            FileReader reader = new FileReader(path+"ajax.html");
            BufferedReader bufferedReader=new BufferedReader(reader);
            StringBuffer sb=new StringBuffer();
            String s="";
            while( (s=bufferedReader.readLine() )!=null ){
                sb.append(s+"\n");
            }
            bufferedReader.close();
            reader.close();
            msg=sb.toString();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return this.msg;
    }

浏览器访问: http://localhost:8080/test3/user/ajax
点击按钮，控制台显示: [games, films]
说明传递成功。




5. 传递 json，接收pojo对象

控制器，注意数据在body中，参数要加注解 @RequestBody
    //参数是json，接收为对象
    @RequestMapping("/save")
    @ResponseBody
    public String save(@RequestBody Book book){ //参数前加注解
        System.out.println(book);
        return String.format("{'book': '%s'}", book);
    }

访问：http://localhost:8080/test3/book/save
    body, raw 最后的text下拉框选json:
    {
        "name": "js book",
        "price": 25
    }
    控制台输出: Book[name:js book, price:25, author: null]

    再加上作者信息:
    {
        "name": "js book",
        "price": 25,
        "author":{
            "name": "wangcai",
            "age": 30
        }
    }
    控制台输出: Book[name:js book, price:25, author: Author[name: wangcai, age: 30]]




6. 集合中一次获取多个对象

控制器
    //参数是json，包含多个对象，接收到集合框架中
    @RequestMapping("/save7")
    @ResponseBody
    public String save7(@RequestBody List<Book> list){ //参数前加注解
        System.out.println(list);
        return String.format("{'books': '%s'}", list);
    }

请求参数： get http://localhost:8080/test3/book/save7
    body, raw 最后的text下拉框选json:
    [
        {"name":"java", "price":80},
        {"name":"js", "price":20},
        {"name":"vue", "price":50}
    ]
    控制台输出: [Book[name:java, price:80, author: null], Book[name:js, price:20, author: null], Book[name:vue, price:50, author: null]]




7.问题： @RequestBody 和 @RequestParam 的区别？
区别： 
    @RequestParam 用于接收url地址传参，表单传参(application/x-www-form-urlencoded)
    @RequestBody 用于接收json数据(application/json)
应用:
    后期开发中，发送json格式数据为主， @Requestbody应用较广
    如果发送非json格式数据，选用 @RequestParam 接收请求数据。




========================================
|-- 日期类型参数传递： @DateTimeFormat 注解
----------------------------------------
1. 日期类型基于不同的系统有不同的格式
2088-08-28
2088/08/28
08/28/2088 月日年


2. 实战
(1) 格式1: 2088/08/28
控制器
    //传入日期
    @RequestMapping("/dataParam")
    @ResponseBody
    public String dataParam(Date date){
        System.out.println("date: "+date);
        return "{'module': 'date param'}";
    }


postman 发送 get http://localhost:8080/test3/book/dataParam?date=2088/08/28
控制台: date: Sat Aug 28 00:00:00 CST 2088



(2) 格式2: 2088-08-28
尝试新格式 http://localhost:8080/test3/book/dataParam?date=2088-08-28
报错：Failed to convert from type [java.lang.String] to type [java.util.Date] for value '2088-08-28';

控制器： 需要设置日期格式，使用注解
    //传入日期 2088-08-28
    @RequestMapping("/dataParam2")
    @ResponseBody
    public String dataParam2(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){
        System.out.println("date: "+date);
        return "{'module': 'date param'}";
    }

postman 发送 get http://localhost:8080/test3/book/dataParam2?date=2088-08-28
控制台: date: Sat Aug 28 00:00:00 CST 2088




(3) 格式3: 2088-08-28 9:30:50

控制器: 修改注解
    //传入日期+时间 2088/08/28 9:30:50
    @RequestMapping("/dataParam3")
    @ResponseBody
    public String dataParam3(@DateTimeFormat(pattern = "yyyy/MM/dd HH:mm:ss") Date date){
        System.out.println("date: "+date);
        return "{'module': 'date param'}";
    }

postman 发送 get http://localhost:8080/test3/book/dataParam3?date=2088/08/28 9:30:50
控制台: date: Sat Aug 28 09:30:50 CST 2088





3. Converter 接口：实现以上转换的底层结构

全文搜索 shift双击，选择文件，输入 converter，注意是spring包的。
查接口的实现类: ctrl+H
    好多实现类！

$ cat Converter.java
package org.springframework.core.convert.converter;

public interface Converter<S, T> {

    @Nullable
    T convert(S source);
...
}

作用:
    请求参数年龄数据： String->Integer
    日期格式转换: String -> Date

注意：有些转换默认没有开启，当你感觉不对的时候，试试开启转换
@EnableWebMVC 功能之一：根据类型匹配对应的类型转换器。





=>总结：
    @DateTimeFormat
    类型转换器




========================================
|-- *** IDEA 新建的maven项目，引入springmvc 依赖后，在哪里放jsp文件？
----------------------------------------

问题: IDEA中新建maven项目，但没有webapp文件怎么办？


1. 新建项目

(1) 一般maven项目

new - Project，左侧选 New Project
    name: springmvc_04_res
    Location: G:\java_code\LearnSpring5
    Lang: java
    Build system: Maven
    Jdk: 17



(2) maven archetype 项目
new - project，左侧选 Maven Archetype
    name: springmvc_04_response
    Location: G:\java_code\LearnSpring5
    jdk: 17
    Catalog: Maven Central 等待加载原型列表，这具有不确定性，万一网络不好，可能加载一直失败。
    Archetype: 
        org.apache.maven.archetypes:maven-archetype-webapp 1.4 src/main/webapp/ 没有java目录
        org.apache.maven.archetypes:maven-archetype-j2ee-simple 1.4 试试这个目录结构不喜欢
        选择新窗口打开。



(3) 修订目录结构
IDEA 左侧选择项目，F4键，右侧
    直接右击，新建 target/目录，和src并列。 顶部 mark as Excluded
    点开 src/main/ 右击添加java/目录。 顶部 mark as 自动就是 Sources。

修改文件:
$ cat src/main/webapp/index.jsp
<html>
<body>
<h2>Hello World! from test4</h2>
</body>
</html>


还有一个xml文件，没啥内容
$ cat src\main\webapp\WEB-INF\web.xml
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
</web-app>



(4) 配置tomcat
点运行，跳出配置窗口：
    Tomcat server: 本地9.0.73
    Deployment dir: G:/java_code/LearnSpring5/springmvc_04_response/src/main/webapp
    Use classpath of module: springmvc_04_response
    Context path: /test4  可以随便填，就是一级url分类 http://localhost:8080/test4
    Server port: 8080, Admin port: 8005
    点apply，run。

浏览器查看: http://localhost:8080/test4/
    显示: Hello World! from test4






2. 开始引入spring mvc框架
安全的调用方式，是把jsp放到 src/main/webapp/WEB-INF/下，只能通过控制器调用，防止被随便调用。

(1) 在 pom.xml 中添加依赖

<dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>

    <!-- servlet 依赖 -->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
    </dependency>

    <!-- spring mvc 依赖 -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.3.26</version>
    </dependency>

  </dependencies>


(2) 创建SpringMVC配置类
如果想使用默认值，则方法体可以省略。

$ cat SpringMvcConfig.java
package com.mio.first.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration //配置类，代替配置文件
@ComponentScan("com.mio.first") //扫描路径
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {

    //自定义配置
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
    }

    //定义视图的路径
    @Bean
    public ViewResolver viewResolver(){
        InternalResourceViewResolver resolver=new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}



(3) 创建实体类：url和方法
$ cat UserController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {

    @RequestMapping("/save2")
    @ResponseBody
    public String save2(String name) {
        System.out.println("user save ..."+name);
        return String.format("{name:%s}", name);
    }
    @RequestMapping("/save")
    public String save() {
        System.out.println("user save ...");
        return "index";
    }
}



(4) 创建Tomcat启动配置类
$ cat ServeletInitConfig.java
package com.mio.first.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class ServeletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}



(5) 创建新jsp文件
$ cat WEB-INF/views/index.jsp
<h1>hello, from views/index.jsp</h1>


(6) 测试

1) get http://localhost:8080/test4/
显示的是 src\main\webapp\index.jsp

2) get http://localhost:8080/test4/save
显示的是 src\main\webapp\WEB-INF\views\index.jsp


3) get http://localhost:8080/test4/save2?name=旺财2
控制台显示 user save ...旺财2


说明：新建项目成功访问了jsp。









========================================
|-- 响应
----------------------------------------

1. 概述
响应页面
响应数据
    文本数据
    json数据

























========================================
IDEA 配置与快捷键
----------------------------------------

1. IDEA 快捷键

- 移动当前行: shift+alt+上下箭头
- 复制当前行: ctrl+D
- 生成Get/Set方法: alt+insert;
- 查看父类的方法列表，方便覆盖: 在子类中 ctrl+o
- 显示一个注解类中所有属性列表-对应参数名: alt+7

- 全文搜索 shift双击，选择文件，输入 converter，注意是spring包的
- 查接口的实现类: ctrl+H




2. IDEA 配置
(1) 新项目maven配置
菜单 File -new project setup - setting for new project;
Build - build tools - maven, 
    Maven home path: 本机安装的3.9.1
    User settings file: D:\ProgramFiles\apache-maven-3.9.1\conf\settings.xml
    Local repository: D:\ProgramFiles\myMavenRepo
    点击apply
左侧maven底下的 Runner:
    VM Options: -DarchetypeCatalog=internal
    JRE: 本机jdk17


(2) 新建项目
Name: springmvc-04-response
Location: G:\java_code\LearnSpring5
Java - Maven - JDK17








3.意外应对
找到占用端口的进程号，杀掉该进程。

> netstat -aon | findstr "8080"  #来查看那个PID占用的8080端口，最后一列就是pid
 TCP    127.0.0.1:8080        0.0.0.0:0              LISTENING       10072

> taskkill /pid 10072 /f  #其中 /f 表示强制关闭该进程


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
*** 相关技术 ***
----------------------------------------


learn Spring6-webMVC
====================

子模块1 spring6-mvc-start
    v0.0.1 第一个案例 


========================================
lombok依赖包介绍 //todo
----------------------------------------
https://blog.csdn.net/qq_37748331/article/details/115246321


========================================
websocket 客户端
----------------------------------------
https://www.liaoxuefeng.com/wiki/1022910821149312/1103327377678688




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

