Spring5 MVC
    因为spring6 mvc 一直没运行成功，学的基于spring5的mvc

IDE:
    使用官方的 spring tool suit 4.0
    尝试IDEA 社区版
        卸载git2.15,安装git2.40: https://git-scm.com/download/win


SSH已经过时了
    Struts2 已被 Spring MVC/ Spring Boot 所取代，
        struts1是古代，struts2是近代，spring mvc是现代
        Struts2 漏洞太多 (国内大厂都中过招)
        SpringMVC 更兼容Spring(2013年开始)
            Spring Boot 大行其道，零 XML 配置，开箱即用
        除了老项目，还有谁会在新项目上用 Struts2 的？
            建议不用学 struts ，直接学 spring mvc
    Hibernate 也逐渐被 MyBatis/ Spring Data JPA 所取代

现在流行:
    SSM = Spring + Spring MVC/ Spring Boot + MyBatis




https://itbaima.net/#/document
https://itbaima.net/#/curriculum



========================================
Spring MVC 该怎么学？
----------------------------------------

https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc
主要内容:
    MVC: 请求和响应
    REST
    WebSocket
    Other: SSM 整合
    拦截器


目标:
    获取请求参数，响应json数据
    REST风格进行开发
    前后端通信协议的实现
    SSM整合技术


1.SpringMVC的几大组件：
1）DispatcherServlet 根据请求的不同，将请求分发到不同的Controller处理器

2）Dispatcher 具体处理请求，返回逻辑视图

3）Handler Mapping 

3）ModelAndView 返回的逻辑视图，注意，是逻辑视图，并不是真正的视图比如JSP页面，而是通过通过视图解析器VierResoler解气逻辑视图，返回真正的要发送给前端的视图

4）ViewResolver View 视图解析类



2. 教程
详解SpringMVC: https://zhuanlan.zhihu.com/p/487488437





3.Spring6 MVC 的变化
(1). 依赖的servlet命名空间改变。
原来是javax，现在是 jakarta。
    <dependency>
      <groupId>jakarta.servlet</groupId>
      <artifactId>jakarta.servlet-api</artifactId>
      <version>6.0.0</version>
    </dependency>

(2). 支持的jdk变化
原来是 jdk1.8，现在是jdk17

(3). tomcat 版本号变化
spring6支持 tomcat10.0






========================================
Spring MVC 入门案例
----------------------------------------
1. 三层架构的演进

(1) 开始：请求 - Servlet 处理和响应

(2) 把Servlet分成三份
    Web 接收操作
    service 处理业务逻辑
    dao 数据持久化
这样一个servlet只能处理一个请求。

(3) 继续拆分成MVC
请求 -> controller ->service ->dao 
    dao和service 返回的数据叫模型 Model
    模型整合后拼接界面，叫视图 View


(4) 最后把视图抛给浏览器处理拼接：异步调用模式
后端: controller ->service ->dao，只返回json数据。
前端: 接收json并用js处理页面。
前后端交互：json

这就是 Spring MVC 模型。

Spring MVC 是一种基于MMC模型的轻量级web框架。




2. 步骤
(1) Servlet 开发web程序的流程
    1) 创建web工程：maven结构
    2) 设置tomcat服务器，加载web工程（tomcat插件）
    3) 导入坐标（Servelt）
    4) 定义处理请求的功能：UserService
    5) 设置请求的映射：配置映射关系

(2) Spring MVC技术开发web程序的流程
    1) 创建web工程：maven结构
    2) 设置tomcat服务器，加载web工程：tomcat插件
    3) 导入坐标：spring MVC + servlet
    4) 定义处理请求的功能类：UserController
    5) 设置请求映射：配置映射关系
    6) 将Spring MVC设定加载到Tomcat容器中。






3. 创建空白文件 with Eclipse
(0) File - new - Dynamic Web Project (跳过)
Project name: spring6-MVC-web
不勾选 Use default location
Location: G:\learngit\spring6-mvc

Target runtime: Tomcat v9.0
Dynamic web module version: 4.0

勾选 Generate web.xml deployment descripter

左侧右击项目，build path，选择 本机的 jdk-17

删掉该项目。


(1) 创建maven 父项目
File - new - other, 输入 maven，选择 maven project
勾选 Create a simple project
不勾选 Use default Workspace location
Location: G:\learngit\spring6-mvc


Group Id: com.mio
Artifact Id: spring-mvc
打包方式: pom
Finish;


(2) 在父项目 pom.xml 中配置依赖
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mio</groupId>
  <artifactId>spring-mvc</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>
  <modules>
    <module>spring6-mvc-first</module>
  </modules>
  
  <dependencies>
    <!-- Servlet API-->
    <dependency>
      <groupId>jakarta.servlet</groupId>
      <artifactId>jakarta.servlet-api</artifactId>
      <version>6.0.0</version>
      <scope>provided</scope>
      <!-- 这有啥影响？-->
    </dependency>
          
    <!-- spring web MVC -->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>6.0.8</version>
    </dependency>
    
    <!-- junit 5-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.9.2</version>
    </dependency>
    
  </dependencies>
  
  <!-- 配置tomcat插件-->
  <build>
    <plugins>
      <plugin>
        <groupId>org.opoo.maven</groupId>
        <artifactId>tomcat9-maven-plugin</artifactId>
        <version>3.0.1</version>
        <configuration>
          <!-- 设定端口 -->
          <port>8081</port>
          <!-- 路径 -->
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>


(3) 创建子模块 spring6-mvc-start
https://blog.csdn.net/m0_73533108/article/details/126949474

击外部项目 spring6-mvc，new- Maven Module
    不勾选 skip archetype selection
    Module name: spring6-mvc-first
    父项目: spring6-mvc

选择一个模式：
    选择 org.apache.maven.archetypes / maven-archetype-webapp，其他保持默认即可

Parameter:
    group id: com.mio
    artifact id: spring6-mvc-first
    version:
    packaging: org.spring6.mvc.first
Finish

会下载一些东西。
最后回车。

删除 index.jsp 和 web.xml 文件。










4. 创建类文件

(1) 创建配置类，扫描包
$ cat SpringMvcConfig.java
package com.mio.first.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration //配置类，代替配置文件
@ComponentScan("com.mio.first") //扫描路径
public class SpringMvcConfig {

}




(2) 创建实体类，响应请求
$ cat UserController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class UserController {
    
    @RequestMapping("/save")
    public void save() {
        System.out.println("user save ...");
    }
}



(3) 创建容器类，注册配置文件
$ cat ServeletInitConfig.java
package com.mio.first.config;

import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;

public class ServeletInitConfig extends AbstractDispatcherServletInitializer{

    //加载的配置对象
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext context=
                new AnnotationConfigWebApplicationContext();
        //注册 配置类
        context.register(SpringMvcConfig.class);
        return context;
    }

    //设置spring 管理的范围，其余归tomcat处理
    @Override
    protected String[] getServletMappings() {
        return new String[] {"/"}; //所有请求都归Spring处理
    }

    //加载Spring的配置对象上下文，可以忽略
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}




(4A) 运行在tomcat中
右击子模块，run as, mvn build ...
Goals: tomcat9:run
勾选 slip test
确定。

运行失败。。。无法找到对应的路径。






==> 使用 spring tool suite 4.0 创建基于maven的web工程
也找不到怎么启动。







========================================
|-- 使用 IDEA 创建基于maven的web工程: 基于 spring5
----------------------------------------
1. 配置工具 
(1)配置maven
File -settings
Build-Bild Tools-Maven
    Maven home path: 选择安装的 D:...maven-3.9.1
    这两个会自动更新
    User settings file: C:\Users\admin\.m2\settings.xml 这个貌似不对
        勾选后面的 Override，改为: D:\ProgramFiles\apache-maven-3.9.1\conf\settings.xml
    Local repository: D:\ProgramFiles\myMavenRepo




2. 新建工程
new - project
name: spring-mvc3
Location: G:\java_code\test3
Lang: Java
Build sys: Maven
JDK: 17
勾选 add sample code

adv settings:
    groupId: com.mio
    artifactId: spring-mvc3

保存，右上角Maven面板展开，点刷新。
展开，可见已经加载的项目。



3. 在pom.xml中配置依赖
$ cat pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mio</groupId>
    <artifactId>spring-mvc3</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>


    <dependencies>
        <!-- servlet 依赖 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- spring mvc 依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.26</version>
        </dependency>
    </dependencies>

    <!--编译依赖，端口8081，根路径/ -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>common-tomcat-maven-plugin</artifactId>
                <version>2.2</version>
                <configuration>
                    <port>8081</port>
                    <path>/</path>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>



4. 其他类文件见上。



5. 运行
(1) 尝试1：失败
菜单 Run-Edit Configurations
    左侧:add new: maven
    右边: 
        name: 随便写
        Run: tomcat7:run
        失败，只是编译并退出。


(2) 使用插件 配置tomcat
https://blog.csdn.net/bsegebr/article/details/126384293

菜单File-settings
    Plugins: 搜索 Smart Tomcat，安装。
    点底部OK，关闭窗口。
右上角运行前下拉框，点第一个编辑
    左上角+，选择Smart Tomcat;
    右边配置：
        Tomcacat server, 右边 Configure 选择安装的 Tomcat9版本。
            确定后，下拉框选择刚设置的Tomcat。
        Doployment dir: D:\ProgramFiles\apache-tomcat-9.0.73\webapps\
        User Classpath of module: spring-mvc3
        Context path: test1
        Server port: 8080, Admin port:8005
        点ok。

可以启动，并输入url: http://localhost:8080/test1/save
    解释: 
        Context path 就是整个项目的地址。
        后面的路径是方法上设置的路径。
        说明配置文件中国的端口号8081没生效，还是这个Smart tomcat中配置的端口号。
    这时，页面是报错的，只有控制台有内容输出: user save...
    点右上角运行后的方块，暂停运行。


(3) 修改实体类
$ cat UserController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save...");
        return "{'msg': 'spring5 mvc'}";
    }
}

再次启动Tomcat9，输入url: http://localhost:8080/test1/save
    网页上看到 {'msg': 'spring5 mvc'}
    控制台看到 user save...

说明调用成功。

感觉比Eclipse使用体验好多了！


(4) 尝试修改端口
右上角：
    停止服务器。
    下拉框第一行，修改端口号为 8083
    启动: 确实已经变成 http://localhost:8083/test1






6. 入门案例总结
(1)一次性工作:
    创建工程、设置服务器，加载工程
    导入坐标
    创建web容器启动类（设置配置类，扫描包路径，加载Controller控制器bean）

(2)多次工作:
    定义处理请求的控制器类
    定义处理请求的控制器方法，并配置映射路径(@RequestMapping)与返回json数据(@ResponseBody)

一个项目，就是写url映射，写对应的方法。






7.入门案例工作流程分析
初始化流程
请求流程

(1)tomcat启动，执行容器初始化: ServeletInitConfig 类
  (2)该类执行createServletApplicationContext()，创建WebApplicationContext对象
    (3)该方法加载 SpringMvcConfig 类：代替xml配置文件。 
      (4)该配置方法中执行 @ComponentScan 加载对应的bean
        (5)于是 UserController 加载，每个 @RequestMapping 的名称对应一个具体的方法。
        (6)getServletMappings()方法规定，哪些请求通过 Spring mvc

具体加载到web容器的哪里呢？只有一个地方： 
Web容器:
  ServletContext
    WebApplicationContext
      UserController 类
        //save -> save()


一个请求过程:
    - 发送 http://localhost/save
    - web 容器发现所有请求都经过 spring mvc，经请求交给它处理
    - 解析请求路径 /save
    - 由 /save 匹配执行对应的方法 save()
    - 执行 save()
    - 检测到有 @ResponseBody 直接把save()返回值作为响应体返回。





8. 文件结构
com
 |-mio
   |-config
   |-controller
   |-service
   |-dao

Spring mvc 相关的bean: 表现层 bean
Spring 控制的bean:
    业务 bean: service
    功能 bean: DataSource 等

(1) 因为功能不同，怎么避免 Spring 错误的加载到 SpringMVC 的bean?
加载 Spring 控制的bean的时候排除掉 SpringMVC 控制的bean。
    - SpringMVC 加载bean对应的包均在 com.mio.controller 包中
    - Spring相关的bean加载:
        * 方式1: 扫描 com.mio，排除掉 controller 包。比如，使用注解排除
        * 方式2: 只扫描 com.mio 下的 service、dao包等。
        * 方式3: 不区分 spring和springMVC，都加载。







9. Servlet 初始化类的简化写法
$ cat ServeletInitConfig.java
package com.mio.first.config;

import org.springframework.web.filter.CharacterEncodingFilter;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import javax.servlet.Filter;

public class ServeletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

/*    //应对中文乱码：get和post参数
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter=new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        //return super.getServletFilters();
        return new Filter[]{filter};  //多个过滤器还可以继续往后写
    }*/
}















========================================
|-- postMan 简介： 接口测试工具
----------------------------------------
1. postman是一款功能强大的网页调试与发送网页HTTP请求的chrome插件
作用：用于接口调试
特征：
    简单
    实用
    美观
    大方

异步调用的好工具。



2. 安装
(1) https://www.postman.com/

下载，免安装；
注册账号: 
    如果无法注册，可以去网站上注册。
    postman, poster469@163; dawneve/nk16!
    身份: James Wang, Student; 邀请好友: https://app.getpostman.com/join-team?invite_code=04be117e45ef46585cabc4795fcdee6e
然后app登录，跳转网页认证，回到app。



3. 使用

(1) 先创建工作空间，有云备份的作用。

点击左侧 workspace，
右上角 Create Workspace，
    name: springMVC5
    确定。

新界面
    左上角，可以切换工作空间。

(2) 发送请求
右侧 requests 右侧的加号点击，
新页面，选择请求类型，比如 GET，输入 http://localhost:8081/test1/save 回车
这就相当于浏览器的请求，可以看到底下的页面返回值: {'msg': 'spring5 mvc'}

保存该请求: 右上角 save 点击，起名字，创建收藏该请求的集合，确定。
    这时，左侧多一个保存条目。


(3) 若干天后
点击左侧记录，直接点击send，就可以测试了。






========================================
请求与响应: 各种请求与参数、json响应
----------------------------------------
请求要点:
    请求前缀
    请求类型
    请求参数类型




1. 路径前缀
@RequestMapping 注解可以加到 类上和方法上，类前的是url的前缀。

$ cat BookController.java
package com.mio.first.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("/book")
public class BookController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("book save...");
        return "{'msg': 'spring5 mvc, Book'}";
    }
}

比如，上面的路径就是 /book/save






2. 怎么区分get和post请求

(1) 后台代码不变
@Controller
@RequestMapping("/book")
public class BookController {

    @RequestMapping("/save")
    @ResponseBody
    public String save(String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return "{'msg': 'spring5 mvc, save book info'}";
    }
    ...
}


(2) 使用postman发送get请求
http://localhost:8080/test3/book/save?name=javaAdv&price=120
    网页显示: {'msg': 'spring5 mvc, save book info'}
    控制台显示: 
        book name: javaAdv
        book price: 120

(3) 使用postman发送get请求
选择 post，输入 http://localhost:8080/test3/book/save
接着是消息体，选择body；
表单信息选择 x-www-form-urlencoded
    name springMVC adv
    price 220
上传文件选择 form-data
单击send
    网页显示: 
    控制台显示: 
        book name: springMVC adv
        book price: 220




3. 怎么发送中文不乱吗？

(1) 发送的name改为 'springMVC 高级教程'
控制器改为在网页+控制台同时输出，结果都是乱码。

@Controller
@RequestMapping("/book")
public class BookController {

    @RequestMapping("/save")
    @ResponseBody
    public String save(String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return String.format("{'book': '%s', 'price': %d}", name, price);
    }


(2) 之前是修改Servlet的请求编码（？），相当于过滤器
这里也是，需要在Servlet初始化类中新增方法:

$ tail ServeletInitConfig.java
...
public class ServeletInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
...
    //应对中文乱码：get和post参数
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter=new CharacterEncodingFilter();
        filter.setEncoding("UTF-8");
        //return super.getServletFilters();
        return new Filter[]{filter};  //多个过滤器还可以继续往后写
    }
...

再测测试，发现控制台正常了，网页还是中文乱码。 //todo






4. 如果请求参数名字和方法参数不一致怎么办？
比如url参数名是 bookname，方法中接收的是 name，怎么办？
使用注解 @RequestParam("bookname") 转换：

    @RequestMapping("/save")
    @ResponseBody
    public String save(@RequestParam("bookname") String name, int price){
        System.out.println("book name: "+name);
        System.out.println("book price: "+price);
        return String.format("{'book': '%s', 'price': %d}", name, price);
    }

访问: http://localhost:8080/test3/book/save?price=120&bookname=java adv
控制台: 
    book name: java adv
    book price: 120






5. 传递 pojo 参数，自动构建实体类

新增实体类 
$ cat Book.java
package com.mio.first.domain;

public class Book {
    private String name;
    private int price;

    public void setName(String name) {
        this.name = name;
    }
    public void setPrice(int price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return String.format("Book[name:%s, price:%d]", name, price);
    }
}


控制器接收Book book参数:
    @RequestMapping("/save")
    @ResponseBody
    public String save(Book book){
        System.out.println(book);
        return String.format("{'book': '%s'}", book);
    }


浏览器请求: http://localhost:8080/test3/book/save?name=%E9%AB%98%E7%BA%A7&price=12
    浏览器显示: {'book': 'Book[name:??, price:12]'}
    控制台显示: Book[name:高级, price:12]




6. 含有复杂属性的对象

比如，每个书的作者，可能有更多信息。

$ cat Author.java
package com.mio.first.domain;

public class Author {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return String.format("Author[name: %s, age: %d]", name, age);
    }
}


Book.java 中添加新属性，及set方法，修改toString()
    private Author author;

    public void setAuthor(Author author) {
        this.author = author;
    }

    @Override
    public String toString() {
        return String.format("Book[name:%s, price:%d, author: %s]", name, price, author);
    }


控制器不变:
    @RequestMapping("/save")
    @ResponseBody
    public String save(Book book){
        System.out.println(book);
        return String.format("{'book': '%s'}", book);
    }


浏览器访问，注意参数的写法：
    name=JavaAdv, price=80;
    author.name2=Tom, author.age=30

    http://localhost:8080/test3/book/save?price=120&name=java adv
        控制台: Book[name:java adv, price:120, author: null]

    http://localhost:8080/test3/book/save?price=120&name=javaAdv&author.name=Bill&author.age=32
        控制台: Book[name:javaAdv, price:120, author: Author[name: Bill, age: 32]]








========================================
IDEA 快捷键
----------------------------------------

1.快捷键

- 复制当前行: ctrl+D
- 生成Get/Set方法: alt+insert;
- 查看父类的方法列表，方便覆盖: 在子类中 ctrl+o





2.意外应对
找到占用端口的进程号，杀掉该进程。

> netstat -aon | findstr "8080"  #来查看那个PID占用的8080端口，最后一列就是pid
 TCP    127.0.0.1:8080        0.0.0.0:0              LISTENING       10072

> taskkill /pid 10072 /f  #其中 /f 表示强制关闭该进程


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
*** 相关技术 ***
----------------------------------------


learn Spring6-webMVC
====================

子模块1 spring6-mvc-start
    v0.0.1 第一个案例 


========================================
lombok依赖包介绍 //todo
----------------------------------------
https://blog.csdn.net/qq_37748331/article/details/115246321


========================================
websocket 客户端
----------------------------------------
https://www.liaoxuefeng.com/wiki/1022910821149312/1103327377678688




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

