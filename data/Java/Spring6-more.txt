Spring 6 视频笔记

狭义定义: Core	核心部分 - 本文主要关注的点
IoC Container, 
Events, 
Resources, 
i18n, 
Validation, 
Data Binding, 
Type Conversion, 
SpEL, 
AOP, 
AOT.




========================================
Spring 主要知识点
----------------------------------------
1. 能否跳过 spring 和 spring MVC 直接学习 Spring Boot？
https://www.zhihu.com/question/527283820/answer/2518307760

结论: 如果没有Spring基础的话，严重不建议学习Spring Boot。


Spring主要就是IOC和AOP两大特性
	IOC用来管理和存储对象，在Spring中这些对象被称为Bean
		比如Bean的生命周期，
		Spring三级缓存，
		Aware接口的使用，
		几种生命周期回调方式等等，
		这都是属于学过Spring应该掌握的知识，
		当然， 从源码层面DEBUG看过的会更好，但是，至少功能上应该要不陌生。
	AOP在Spring中的体现就是，
		利用底层的动态代理技术【Cglib，JDKProxy】
		以及部分AspectJ的注解来完成的对于对象的动态无侵入式增强。

然后再说上手Spring Boot。
	Spring Boot出现的主要原因是因为以前用Spring去整合Web项目的时候，配置太复杂了
	Spring Boot把这些场景抽象为了Maven依赖：叫做starter，场景启动器。
		你想用Web开发场景？可以，你就导入spring-boot-starter-web。
		想用模板引擎？你就导入spring-boot-starter-thymeleaf。
		想用缓存？可以，你就导入spring-boot-starter-data-redis等等

		一旦你导入某一个场景启动器【starter】，Spring Boot就会开启自动化配置，把相关场景需要的对象自动化配置好并加入Spring的IOC中，然后项目中我就可以自动注入这些对象了，那不就相当于这个场景就生效了么。

		你还可以封装自己的starter，完成你自己想要的自动化配置功能。
		但是一切，都离不开Spring底层的IOC容器和强大的AOP功能。


至于SpringMVC，这玩意儿只是Spring家族，Spring FrameWork在Web层里面提供的一种解决方案。
	SpringMVC是MVC在C【Controller】这一层上的一种实现框架

	所谓的跳过SpringMVC，也只是跳过一些源码方面的讲解，
	但是至少，ResponseBody，Validated，RequestMapping，RequestParam，
	还有request，session获取方式，参数获取方式，
	如何接收并且校验对象，如何接收表单数据等等，
	还有json序列化方式，
	Model/ModelMap对象的使用，
	springMVC接收请求处理的那几步，比如HandlerMapping，HandlerAdapter，ViewResolver的死记硬背等等，这些总要会吧。

	会了这些基本的，入手Spring Boot没啥太大问题，细枝末节啥的后面慢慢补就成。


所以建议题主，学习技术切不可急于求成，底层基础很重要，
	Spring实在不行可以去看看硅谷雷神的Spring注解驱动开发，那里讲了很多Spring的原理和底层。
		本人之前看过一部分，受益颇多。
		如果Java基础不牢固，很可能无法坚持看完，因为难度去确实比较大。





========================================
Spring 6 大纲与进度记录(最低 jdk17)
----------------------------------------
1. 视频进度
https://www.bilibili.com/video/BV1kR4y1b7Qc/?p=2

官方文档: https://spring.io/projects/spring-framework
	https://spring.io/projects/spring-framework#learn
	https://docs.spring.io/spring-framework/docs/current/reference/html/

(1) 划分
广义：使用 spring的都是 spring 框架
狭义：spring framework

核心: IoC 和 AOP

(2) 特点
非侵入式
控制反转 IoC
面向切面 AOP
容器
组件化: 多个组件通过spring组成复杂应用
一站式


(3) 模块组成
Overview	
History, Design Philosophy, Feedback, Getting Started.

Core	核心部分 - 本文主要关注的点
IoC Container, Events, Resources, i18n, Validation, Data Binding, Type Conversion, SpEL, AOP, AOT.

Testing	 测试
Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient.

Data Access	数据操作(JDBC)
Transactions, DAO Support, JDBC, R2DBC, O/R Mapping, XML Marshalling.

Web Servlet	
Spring MVC, WebSocket, SockJS, STOMP Messaging.

Web Reactive	
Spring WebFlux, WebClient, WebSocket, RSocket.

Integration	
REST Clients, JMS, JCA, JMX, Email, Tasks, Scheduling, Caching, Observability.

Languages	
Kotlin, Groovy, Dynamic Languages.

Appendix	
Spring properties.

Wiki	
What’s New, Upgrade Notes, Supported Versions, additional cross-version information.


(4) 环境
jdk17+

Eclipse: Version: 2022-12 (4.26.0)
Spring: 6.0.7
Apache Maven 3.9.1 #>mvn -v (maven 3.6+)





========================================
入门案例及实现步骤 (maven项目的文件结构、 测试文件的位置和写法)
----------------------------------------
1.大纲
(1) 先创建一个聚合工程，创建子模块
Spring6
	|-- spring-first
	|-- spring-2
(2) spring 开发步骤

1) 引入 Spring 相关依赖
2) 创建类，定义属性和方法
3) 按照 spring 要求创建配置文件(xml格式) 
4) 在spring 配置文件配置相关信息
5) 测试




2. 创建项目的具体操作
(1) 创建聚合工程
菜单 文件-new-maven project,

勾选 skip archetype selection
	archetype [ˈɑːkitaɪp]n. 原型；典型
不勾选 default Workspace location:
	Location: G:\learngit\spring6 一个新文件夹

下一步
	Group id: com.mio
	artifact id: spring6
	version: 0.0.1-SNAPSHOT 默认值
	Packaging: pom
finish。


(2) 创建子模块
菜单File-new-other-搜索 maven，选择 Maven Module
	勾选 skip archetype selection
	Module name: spring-first
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: spring-first
	version:
	packaging: jar
Finish


// 发现环境是 java1.5?
右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17




3. 写代码的具体操作
(1)修改子模块的 pom.xml 文件，添加后如下
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.mio</groupId>
    <artifactId>spring6</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>spring-first</artifactId>
  
  <properties>
	  <maven.compiler.source>17</maven.compiler.source>
	  <maven.compiler.target>17</maven.compiler.target>
  </properties>
  
  <dependencies>
	  <!-- 引入Spring context依赖，表示将Spring的基础依赖引入了 -->
	  <dependency>
		  <groupId>org.springframework</groupId>
		  <artifactId>spring-context</artifactId>
		  <version>6.0.7</version>
	  </dependency>
	  
	  <!-- JUnit -->
	  <dependency>
		  <groupId>org.junit.jupiter</groupId>
		  <artifactId>junit-jupiter-api</artifactId>
		  <version>5.6.3</version>
	  </dependency>
  </dependencies>
</project>

保存后会自动刷新，子项目中的 Maven Dependencies 下已经引入10个jar包。



(2) 创建类，定义属性和方法
在子模块中创建类：右击子模块-new-class
	package: com.mio.spring6
	Name: User
$ cat User.java
package com.mio.spring6;

public class User {
	public void add() {
		System.out.println("add ....");
	}
}

(3) 按照 spring 要求创建配置文件(xml格式) 
尝试给eclipse安装 Spring suit4 插件，失败。。。

创建xml配置文件
	位置在 src/main/java 下的 resources/
	名字随意，比如 bean.xml
内容如下:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>


(4) 使用 bena 标签在xml中创建user对象
bean:
	id 属性：唯一标识
	class 属性：要创建对象所在类的全路径(包名称+类名称)

<bean id="user" class="com.mio.spring6.User"></bean>


(5) 测试类，在User同目录下
$ cat UserTest.java
package com.mio.spring6;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {

	@Test
	public void testUserObject() {
		//1.加载spring配置文件，对象创建
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//2.获取创建对象
		User user=(User) context.getBean("user");
		System.out.println(user);
		//3.使用对象调用方法
		user.add();
	}
}



(6) 测试
// 右击 无法 run as test??!! //todo

尝试1: 凑合方法
只能创建main方法：
	public static void main(String[] args) {
		new UserTest().testUserObject();
	}
输出:
com.mio.spring6.User@55a1c291
add ....



尝试2: 更换测试类
注释掉 子模块中的
	  <!-- JUnit 
	  <dependency>
		  <groupId>org.junit.jupiter</groupId>
		  <artifactId>junit-jupiter-engine</artifactId>
		  <version>5.6.3</version>
	  </dependency>
	  -->
重新添加
      <!-- JUnit  这个有用 
		  <scope>test</scope>
      -->
      <dependency>
		  <groupId>junit</groupId>
		  <artifactId>junit</artifactId>
		  <version>4.11</version>
	  </dependency>
同时把测试类移动到 src/test/java/下

package com.mio.spring6;

import org.junit.Test;
//import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {

	@Test
	public void testUserObject() {
		//1.加载spring配置文件，对象创建
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//2.获取创建对象
		User user=(User) context.getBean("user");
		System.out.println(user);
		//3.使用对象调用方法
		user.add();
	}
}

支持选中测试方法，右击 run as JUnit Test

或者右击 子模块 名字，右击 run as Junit Test，运行所有测试方法。



总结:
1. JUnit 两种依赖有啥关系？
2. 注意测试文件的位置
子模块/
  |-src/
     |-main/java/
         |- com.mio.spring6.User.java
     |-test/
         |- com.mio.spring6.UserTest.java





========================================
|-- 分析以上程序
----------------------------------------
1. 创建对象
(1) 是否调用了无参构造器？
$ cat User.java
package com.mio.spring6;

public class User {
	public User() {
		System.out.println("0: User 无参构造器");
	}
	
	public void add() {
		System.out.println("add ....");
	}
}

运行测试后，输出:
	0: User 无参构造器
	com.mio.spring6.User@28eaa59a
	add ....
说明: 确实输出了 无参构造器。


(2) 创建对象没有new? 如何使用反射创建对象？

步骤
	- 加载 bean.xml 配置文件
	- 解析xml文件
	- 获取属性值：id，class
	- 使用反射创建对象

代码:
	//反射创建对象
	@Test
	public void testUserObject2() throws Exception {
		//1.加载xml文件，获取信息：id, class 略
		//2.获取类对象
		Class clazz=Class.forName("com.mio.spring6.User");
		//3.创建对象
		//User user=clazz.newInstance(); //jdk17已过时
		User user=(User) clazz.getDeclaredConstructor().newInstance();
		//4.执行方法
		user.add();
		System.out.println("from: testUserObject2");
	}

输出:
	0: User 无参构造器
	add ....
	from: testUserObject2



(3) 创建的对象在哪里？
//todo: eclipse下怎么看maven项目中spring的源码?

Spring是一个bean 容器:
DefaulListableBeanFactory.java
	private final Map<String, BeanDefinition> beanDefinitionMap=...
	键值对，字符串-Bean定义，也就是bean的描述信息。







========================================
|-- 添加 Log4j2 日志记录组件
----------------------------------------
1. 日志常用设置 
(1)日志信息的优先级
从低到高：TRACE< DEBUG < INFO < WARN < ERROR < FATAL
	trace 追踪，相当于程序的执行，最低的日志级别
	debug 调试，一般将其设置为最低的日志级别
	info: 信息，输出重要信息，使用较多
	warn 警告
	error 错误
	fatal 严重错误
级别高的自动屏蔽级别低的。

(2) 日志输出目的地
控制台
文件

(3) 日志格式
时间格式

(4) 过程
引入依赖 pom.xml
写配置文件，固定名字：
测试
	输出到哪里？
	格式？
	输出哪些部分？





2. 实例
(1) 在pom.xml引入2个依赖
	  <!-- log4j2的2个依赖-->
	  <dependency>
		  <groupId>org.apache.logging.log4j</groupId>
		  <artifactId>log4j-core</artifactId>
		  <version>2.20.0</version>
	  </dependency>
      
      <dependency>
		  <groupId>org.apache.logging.log4j</groupId>
		  <artifactId>log4j-slf4j-impl</artifactId>
		  <version>2.20.0</version>
	  </dependency>

(2) 创建配置文件
文件名固定，必须放类的根目录下的 resources/下。
$ cat log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<loggers>
		<root level="DEBUG">
			<!-- 定义三种输出方式，具体定义见下文  -->
			<appender-ref ref="spring6log" />
			<appender-ref ref="RollingFile" />
			<appender-ref ref="log" />
		</root>
	</loggers>

	
	<!-- 更详细的设置: https://www.cnblogs.com/LLL0617/p/16864480.html -->
	<appenders>
		<!-- 输出日志信息到控制台 -->
		<console name="spring6log" target="SYSTEM OUT">
			<!-- 控制日志输出的格式 -->
			<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n" />
		</console>
		
		
		<!-- 输出到文件，每次log都自动清空，由append属性控制 -->
		<File name="log" fileName="G:/learngit/spring6/dustbin/test.log" append="false">
			<PatternLayout pattern="%d{HH:mm:ss SSS} %-5level %class{35} %L %M - %msg%xEx%n" />
		</File>
		
		
	    <RollingFile name="RollingFile" fileName="G:/learngit/spring6/dustbin/app.log" 
	    	filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{35} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="50MB" />
            <!-- 设置同类型日志,同一文件夹下可以存放的数量,如果不设置此属性则默认存放7个文件 -->
            <DefaultRolloverStrategy max="20" />
        </RollingFile>
	</appenders>

</configuration>


(3) 运行上一节的测试函数
1) 观察控制台输出，多了前三行
2023-04-02 17:37:43 441 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
2023-04-02 17:37:43 761 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 17:37:43 819 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
0: User 无参构造器
org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad, started on Sun Apr 02 17:37:43 CST 2023
testUserObject: com.mio.spring6.User@666b83a4
add ....



2)文件 test.log

17:37:43 441 DEBUG org.springframework.context.support.AbstractApplicationContext 630 prepareRefresh - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
17:37:43 761 DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader 393 doLoadBeanDefinitions - Loaded 1 bean definitions from class path resource [bean.xml]
17:37:43 819 DEBUG org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 225 getSingleton - Creating shared instance of singleton bean 'user'


3) 文件 app.log
2023-04-02 at 17:37:43 CST DEBUG org.springframework.context.support.AbstractApplicationContext 630 prepareRefresh - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
2023-04-02 at 17:37:43 CST DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader 393 doLoadBeanDefinitions - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 at 17:37:43 CST DEBUG org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 225 getSingleton - Creating shared instance of singleton bean 'user'





3. 手动输出日志信息
(1) 在测试类中添加
public class UserTest {
	//1.创建 logger 对象
	private Logger logger=LoggerFactory.getLogger(UserTest.class);
	
	@Test
	public void testUserObject() {
		//...
		
		//2.手动写日志
		logger.info("## 执行了 testUserObject()");
		//...
	}
}

执行后，控制台多了一行
2023-04-02 17:46:32 081 [main] INFO com.mio.spring6.UserTest - ## 执行了 testUserObject()






========================================
IoC: 控制反转 (inversion of control)
----------------------------------------
1. 什么是IoC？

创建对象的过程被反转了。是一种思想。

(1)使用IoC容器来管理
	所有Java对象的实例和初始化，
	控制对象与对象之间的依赖关系

	IoC容器管理的Java对象叫 bean，它与new创建的对象没有任何区别。

(2)bean定义信息
xml -> BeanDefinition
抽象 -> BeanDefinitionReader;
IoC容器: bean 定义信息 获取 
	实例化 实例: BeanFactory工厂 + 反射
	初始化 -> 最终对象

(3) 依赖注入：是控制反转的实现方式

两种实现：
	set 注入
	构造注入

Bean 管理:
	bean 对象的创建
	bean 对象中属性的赋值

(4) BeanFactory 是spring框架内部使用的接口，不提供给开发人员

我们使用的是 ApplicationContext 接口，是 BeanFactory 的子接口。
其重要实现类包括:
BeanFactory 接口
	|- ApplicationContext 接口
	  |- ConfigurableApplication 接口
	  	|- FilSystemXmlApplicationContext 类
	  	|- ClassPathXmlApplicationContext 类


//todo eclipse 查看接口继承和实现图?
https://www.likecs.com/show-203369151.html
A: F4：Open Type Hierarchy --（在新弹出窗口）-> show the Supertype Hierarchy（则会有接口显示）

Q: 如何显示一个类的所有的继承和实现的接口?
显示一个类的所有父类和所有子类: Ctrl+T
类文件的outline：默认会显示。







========================================
|-- 基于 xml 的IoC (JUnit 不报错也不输出，怎么办？)
----------------------------------------
准备工作：
- 把之前 子模块 pom.xml 中的依赖，移动到父工程 pom.xml 中。
- 观察发现，子模块的 Maven Dependencies 是正常的。
- 执行之前的 test，一切正常。

目的：
	获取bean 的三种方式
	依赖注入的2种方式：set和构造器
	其他特殊类型的注入
	bean 的作用域：默认单例，怎么多例？
	生命周期？
	xml自动配置


1. 新建子模块 spring6-ioc-xml
(1)方法参考 spring-first
(2)引入 spring-first 模块配置文件：bean.xml, log4j2.xml
$ cat bean.xml
	<bean id="user" class="com.mio.spring6.iocxml.User"></bean>

(3) 新建 User 类
$ cat User.java
package com.mio.spring6.iocxml;

public class User {
	private String name;
	private Integer age;
	
	public void run() {
		System.out.println("run ...");
	}
}


(4) 新建测试类，获取bean的三种方式
//todo 结果 JUnit 不运行，也不报错，怎么办？
原来是自己用了log4j，但是没有配置文件，所以没有输出任何信息。 //不是我的问题，删了也不行。
迂回措施：给测试类加main方法。

$ cat UserTest.java
package com.mio.spring6.iocxml;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {
	public static void main(String[] args) {
		ApplicationContext context=new
				ClassPathXmlApplicationContext("bean.xml");
		System.out.println(context);
		//1.根据id获取bean
		User user1=(User) context.getBean("user");
		System.out.println("1.根据id获取bean: "+user1);
		
		//2.根据类型获取bean
		User user2=(User)context.getBean(User.class);
		System.out.println("2.根据类型获取bean: "+user2);
		
		//3.根据id和类型
		User user3=(User)context.getBean("user", User.class);
		System.out.println("3.根据id和类型获取bean: "+user3);
	}
	
	@Test
	public void test001() {
		System.out.println("test001(3)");
	}
}

输出:
2023-04-02 21:43:55 345 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@28b46423
2023-04-02 21:43:55 538 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 21:43:55 585 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
org.springframework.context.support.ClassPathXmlApplicationContext@28b46423, started on Sun Apr 02 21:43:55 CST 2023
1.根据id获取bean: com.mio.spring6.iocxml.User@3f07b12c
2.根据类型获取bean: com.mio.spring6.iocxml.User@3f07b12c
3.根据id和类型获取bean: com.mio.spring6.iocxml.User@3f07b12c




(5) 细节问题：如果bean再加一条，仅仅是id不同，这时能使用类型获取到吗？
$ cat bean.xml
<bean id="user2" class="com.mio.spring6.iocxml.User"></bean>

测试: //2.根据类型获取bean
	User user2=(User)context.getBean(User.class);

报错: expected single matching bean but found 2: user,user2
	期望是单实例，但是找到2个匹配的。
解决：这时，只能依靠id或者，id+类型获取。



(6) 扩展问题: 一个接口的多个实现类，能否获取bean？
UserDao dao=new UserDaoImpl();

1) 新建包 bean，内部建接口 UserDao，及实现 UserDaoImpl
$ cat UserDao.java
package com.mio.spring6.iocxml.bean;
public interface UserDao {
	public void run();
}

$ cat UserDaoImpl.java
package com.mio.spring6.iocxml.bean;
public class UserDaoImpl implements UserDao {
	@Override
	public void run() {
		System.out.println("UserDaoImpl.run()");
	}
}



2) 配置文件 bean.xml
<bean id="userDaoImpl" class="com.mio.spring6.iocxml.bean.UserDaoImpl"></bean>


3) bean/下写测试类
$ cat TestUserDao.java
package com.mio.spring6.iocxml.bean;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestUserDao {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//根据 接口类型 获取 接口实现类对应的bean
		UserDao userDao=context.getBean(UserDao.class);
		System.out.println(userDao);
		userDao.run();
	}
}

输出:
	com.mio.spring6.iocxml.bean.UserDaoImpl@784b990c
	UserDaoImpl.run()
结论: 如果接口只有一个实现，则可以 根据接口类型，获取实现类的bean。


4) 如果多个实现类，则不能根据 接口类型 获取bean。 因为不唯一。
报错： expected single matching bean but found 2: userDaoImpl,personDaoImpl
解决：使用id。










========================================
|-- 依赖注入: 两种实现方式； 特殊值的注入、特殊类型的注入
----------------------------------------
1. 类的属性，创建对象过程中，向属性设置值

- 基于set
- 基于构造器

(1) 新建包 di，其中新建 Book 类
原生写法:
$ cat Book.java
package com.mio.spring6.iocxml.di;

public class Book {
	private String bname;
	private String author;
	//生成set方法
	public String getBname() {
		return bname;
	}
	public void setBname(String bname) {
		this.bname = bname;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	//构造器
	public Book() {}
	public Book(String bname, String author) {
		this.bname = bname;
		this.author = author;
	}
	
	@Override
	public String toString() {
		return String.format("Book[bname=%s, auther=%s]", bname, author);
	}

	public static void main(String[] args) {
		//原生做法:set注入
		Book book=new Book();
		book.setBname("Spring6");
		book.setAuthor("张三");
		System.out.println(book);
		
		//原生做法：构造器注入
		Book book2=new Book("java", "李四");
		System.out.println(book2);
	}
}





(2) 使用Spring的 set 方法注入
步骤：
	创建类，定义属性，生成其set方法，
	spring的xml配置文件：属性、值
	测试

使用上述Book类。

xml文件和重新创建: 类根目录下 
$ cat resources/bean-book-di.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 依赖注入1：set注入，name就是属性的小写 -->
	<bean id="book1" class="com.mio.spring6.iocxml.di.Book">
		<property name="bname" value="js"></property>
		<property name="author" value="王二"></property>
	</bean>
</beans>

测试类，为了方便，放同名类的文件夹内。
$ cat TestBook.java 
package com.mio.spring6.iocxml.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestBook {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-book-di.xml");
		Book book1=context.getBean("book1", Book.class);
		System.out.println(book1);
	}
}

输出: Book[bname=js, auther=王二]






(3) 构造器注入
步骤：
	- 创建类，定义属性，生成有参数构造方法
	- 配置xml
	- 测试

使用上述 Book 类。

xml的配置:
	<!-- 依赖注入2：构造器注入 -->
	<bean id="book2" class="com.mio.spring6.iocxml.di.Book">
		<constructor-arg name="bname" value="c++"></constructor-arg>
		<constructor-arg name="author" value="麻子"></constructor-arg>
	</bean>

测试：
	ApplicationContext context=
			new ClassPathXmlApplicationContext("bean-book-di.xml");
	//2.构造器注入
	Book book2= context.getBean("book2", Book.class);
	System.out.println(book2);

输出: Book[bname=c++, auther=麻子]







2. 特殊值的注入
字面量 int a=10; 这里字母a是变量，而"a"就表示其字符本身，就是字面量。
	Spring会把 value 属性的值看做字面量。
	<property name="name" value="times">
null值
	<property name="name">
		<null />
	</property>
xml 实体：比如值是<>，会报错
	和html实体类似，
	使用 &gt; 表示 >
	使用 &lt; 表示 <
CDATA节: 什么意思？就是告诉xml不要解析，这里面的都是纯文本。<![CDATA[ 这里写啥都可以 ]]
	<property name="bname">
		<value><![CDATA[a < b]]></value>
	</property>




========================================
|-- 特殊类型的注入: 对象类型、 数组类型、集合类型、
----------------------------------------
1. 对象类型的注入: 3种方式
	外部 bean 方式
	内部 bean方式
	级联赋值方式

部门1 --- m 员工
(1)新建包，里面建立2个类 Department, Employer; 
$ cat Department.java
package com.mio.spring6.iocxml.injectobj;
public class Department {
	private String dname;
	
	public void info() {
		System.out.println("Department: "+dname);
	}
}

$ cat Employer.java
package com.mio.spring6.iocxml.injectobj;
public class Employer {
	//该员工属于哪个部门
	private Department dept;
	
	private String ename;
	private int age;
	
	public void work() {
		System.out.println(ename + " Employer work... "+ "age: "+age);
		dept.info();
	}
}
注意：2个类都必须有setter/getter，本文为了简洁，省略。

(2) 配置文件
类根目录下/resources/bean-inject-obj.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 注入对象的三种方式	-->
	<!-- 方式1：外部 bean 方式 
		1 创建2个对象
		2 在emp的bean标签中，使用 property 引入dept的bean: 
			name=类的属性名，ref=待注入的bean的id
	-->
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="财务部"></property>
	</bean>
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="张三"></property>
		<property name="age" value="20"></property>
		<!-- 注入对象类型属性 
			private Department dept;
			name 就是类的属性名字; ref指代上文出现过的bean的id
		-->
		<property name="dept" ref="dept2"></property>
	</bean>
</beans>

(3) 测试
$ cat TestInjectObj.java
package com.mio.spring6.iocxml.injectobj;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestInjectObj {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1", Employer.class);
		//调用员工方法
		worker1.work();
	}
}

输出:
	张三 Employer work... age: 20
	Department: 财务部



(4) 方式2: 
配置文件: 
	<!-- 方式2：内部 bean 方式 	-->
	<bean id="emp1b" class="com.mio.spring6.iocxml.injectobj.Employer">
		<property name="ename" value="李四"></property>
		<property name="age" value="50"></property>
		<!-- 注入对象类型属性 
			private Department dept;
			name 就是类的属性名字; 需要的bean直接嵌套写
		-->
		<property name="dept">
			<bean id="dept2b" class="com.mio.spring6.iocxml.injectobj.Department">
				<property name="dname" value="人事部"></property>
			</bean>
		</property>
	</bean>

测试:
	private static void demo2() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1b", Employer.class);
		//调用员工方法
		worker1.work();	
	}
输出:
	李四 Employer work... age: 50
	Department: 人事部



(5) 第三种方式
配置文件
	<!-- 方式3：级联赋值 -->
	<bean id="dept2c" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="研发部"></property>
	</bean>
	<bean id="emp1c" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="王二"></property>
		<property name="age" value="40"></property>
		<!-- 注入对象类型属性: 在方式1的基础上，对要注入对象的属性值 dept.dname，重新赋值 -->
		<property name="dept" ref="dept2c"></property>
		<property name="dept.dname" value="广告部"></property>
	</bean>

测试：
	private static void demo3() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1c", Employer.class);
		//调用员工方法
		worker1.work();			
	}
输出：
	王二 Employer work... age: 40
	Department: 广告部








2. 注入数组
(1) 上文员工添加爱好属性，添加对应的getter/setter
	private String[] hobbies;
	public String[] getHobbies() {
		return hobbies;
	}

	public void setHobbies(String[] hobbies) {
		this.hobbies = hobbies;
	}

修改其work方法，输出hobbies：
	public void work() {
		System.out.println(ename + " Employer work... "+ "age: "+age);
		dept.info();
		System.out.println(Arrays.toString(hobbies));
	}

(2)新建配置文件 bean-di-array.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入数组类型 -->
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="财务部"></property>
	</bean>
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="张三"></property>
		<property name="age" value="22"></property>
		<!-- 注入对象类型属性 -->
		<property name="dept" ref="dept2"></property>
		<!-- 注入数组 -->
		<property name="hobbies">
			<array>
				<value>吃饭</value>
				<value>睡觉</value>
				<value>打游戏</value>
			</array>
		</property>
	</bean>
</beans>

(3) 测试
	private static void demo4() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-array.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1", Employer.class);
		//调用员工方法
		worker1.work();			
	}
输出:
	张三 Employer work... age: 22
	Department: 财务部
	[吃饭, 睡觉, 打游戏]








3. 注入集合
订正：今天发现员工是 employee，雇主是 employer。
	改正一下代码(类名，xml)，以上笔记就不改了。

(1) 在部门类中添加属性
	//一个部门有很多员工
	private List<Employee> empList;
生成setter/getter方法。

修改输出方法：
	public void info() {
		System.out.println("Department: "+dname);
		for(Employee emp: empList) {
			System.out.println("\t"+emp.getEname());
		}
	}

(2) 创建配置文件 bean-di-list.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入 List 类型 -->
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employee">
		<property name="ename" value="张三1"></property>
		<property name="age" value="21"></property>
	</bean>
	<bean id="emp2" class="com.mio.spring6.iocxml.injectobj.Employee">
		<property name="ename" value="张三2"></property>
		<property name="age" value="22"></property>
	</bean>
    
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="维修部"></property>
		<!-- 注入集合类型 -->
		<property name="empList">
			<list>
				<ref bean="emp1"></ref>
				<ref bean="emp2"></ref>
			</list>
		</property>
	</bean>
</beans>
解释:
	如果 List<String> 则需要使用 <list> <value>xx</value> </list>
	上文是对象，则list标签内使用 ref 标签。


(3) 测试
	private static void demo5() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-list.xml");
		//获取对象
		Department dept=context.getBean("dept2", Department.class);
		//调用方法
		dept.info();
	}
输出：
Department: 维修部
	张三1
	张三2


========================================
|-- 使用xml注入 Map 类型
----------------------------------------

1. 新建包，新建类 Student, Teacher
一个学生每门课不同的老师。

$ cat Student.java
package com.mio.spring6.iocxml.injectmap;
public class Student {
	private String sid;
	private String sname;
	//创建map属性
	private Map<String, Teacher> teacherMap;
	
	//方便输出
	public void run() {
		System.out.println("Stu: "+sid+", "+sname);
		System.out.println(teacherMap);
	}
}


$ cat Teacher.java
package com.mio.spring6.iocxml.injectmap;
public class Teacher {
	private String tid;
	private String tname;

	@Override
	public String toString() {
		return String.format("Teacher[id:%s, name:%s]", tid, tname);
	}
}
生成set/get。


(2) 配置文件 bean-di-map.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入 Map 类型 -->
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入Map类型 -->
		<property name="teacherMap">
			<map>
				<entry>
					<key>
						<value>语文</value>
					</key>
					<ref bean="teacher1"></ref>
				</entry>
				
				<entry>
					<key>
						<value>英语</value>
					</key>
					<ref bean="teacher2"></ref>
				</entry>
			</map>
		</property>
	</bean>
</beans>

(3) 测试
package com.mio.spring6.iocxml.injectmap;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestStu {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-map.xml");
		Student stu=context.getBean("student", Student.class);
		stu.run();		
	}
}

输出:
	Stu: 12345, 大宝
	{语文=Teacher[id:21, name:张三老师], 英语=Teacher[id:22, name:李四老师]}










========================================
|-- List 和 Map 注入的另一种写法： 引用集合bean (需修改xml的约束条件)
----------------------------------------
换一种写法。

1. 新增课程类 Lesson，一个学生可以选多门课
$ cat Lesson.java
package com.mio.spring6.iocxml.injectmap;
public class Lesson {
	private String lname;
	@Override
	public String toString() {
		return "Lesson [lname=" + lname + "]";
	}
}
生成get/set方法。

修改学生类，添加新属性 lessonList，修改输出
$ cat Student.java
package com.mio.spring6.iocxml.injectmap;

import java.util.List;
import java.util.Map;

public class Student {
	private String sid;
	private String sname;
	//创建map属性
	private Map<String, Teacher> teacherMap;
	private List<Lesson> lessonList;
	
	//方便输出
	public void run() {
		System.out.println("Stu: "+sid+", "+sname);
		System.out.println(teacherMap);
		System.out.println(lessonList);
	}
}


2. 新建配置文件
注意，使用util标签，需要引入其约束:
	https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html
	添加一行 xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation=""中添加
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd

$ cat bean-di-ref.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd
        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 引用注入集合类型
    1 创建3个对象
    2 注入普通类型属性
    3 使用 util:类型 定义
    4 在学生bean引入 util:类型定义，完成list，map类型属性的注入
    -->
    <bean id="lesson1" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java高级课程"></property>
	</bean>
	<bean id="lesson2" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java框架课程"></property>
	</bean>
	
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
    
    <util:list id="lessonList_a1">
    	<ref bean="lesson1"></ref>
    	<ref bean="lesson2"></ref>
    </util:list>
    
    
    <util:map id="teacherMap_b2">
    	<entry>
    		<key>
    			<value>化学</value>
    		</key>
    		<ref bean="teacher1"></ref>
    	</entry>
    	
    	<entry>
    		<key>
    			<value>物理</value>
    		</key>
    		<ref bean="teacher2"></ref>
    	</entry>
    </util:map>
    
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入List和Map类型的属性 -->
		<property name="lessonList" ref="lessonList_a1"></property>
		<property name="teacherMap" ref="teacherMap_b2"></property>
	</bean>
</beans>



3. 测试
	private static void demo2() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-ref.xml");
		Student stu=context.getBean("student", Student.class);
		stu.run();			
	}
输出：
	Stu: 12345, 大宝
	{化学=Teacher[id:21, name:张三老师], 物理=Teacher[id:22, name:李四老师]}
	[Lesson [lname=Java高级课程], Lesson [lname=Java框架课程]]





========================================
|-- p 命名空间
----------------------------------------
1. xml 的命名空间是为了防止同名冲突:
<beans xmlns="">
<beans xmlns="" xmlns:p="">
真实写法: xmlns:p="http://www.springframework.org/schema/p"


(1) 新建xml文件
$ cat bean-di-p.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd
        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- p 命名空间注入 -->
    <bean id="student2" class="com.mio.spring6.iocxml.injectmap.Student" 
    p:sid="1002" p:sname="Jim" 
    p:lessonList-ref="lessonList_a1" 
    p:teacherMap-ref="teacherMap_b2">
	</bean>
	   
    <!-- 引用注入集合类型
    1 创建3个对象
    2 注入普通类型属性
    3 使用 util:类型 定义
    4 在学生bean引入 util:类型定义，完成list，map类型属性的注入->最后一步不同
    -->
    <bean id="lesson1" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java高级课程"></property>
	</bean>
	<bean id="lesson2" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java框架课程"></property>
	</bean>
	
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
    
    <util:list id="lessonList_a1">
    	<ref bean="lesson1"></ref>
    	<ref bean="lesson2"></ref>
    </util:list>
    
    
    <util:map id="teacherMap_b2">
    	<entry>
    		<key>
    			<value>化学</value>
    		</key>
    		<ref bean="teacher1"></ref>
    	</entry>
    	
    	<entry>
    		<key>
    			<value>物理</value>
    		</key>
    		<ref bean="teacher2"></ref>
    	</entry>
    </util:map>
    
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入List和Map类型的属性 -->
		<property name="lessonList" ref="lessonList_a1"></property>
		<property name="teacherMap" ref="teacherMap_b2"></property>
	</bean>
</beans>


测试：
	private static void demo3() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-p.xml");
		Student stu=context.getBean("student2", Student.class);
		stu.run();
	}
输出：
	Stu: 1002, Jim
	{化学=Teacher[id:21, name:张三老师], 物理=Teacher[id:22, name:李四老师]}
	[Lesson [lname=Java高级课程], Lesson [lname=Java框架课程]]




========================================
|-- 引入外部属性文件
----------------------------------------
如果一个xml中bean太多，不方便维护。
一般放到数据库中，需要时引入。

1. 







========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------
