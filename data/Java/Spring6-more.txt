Spring 6 视频笔记

狭义定义: Core	核心部分 - 本文主要关注的点
IoC Container, 
Events, 
Resources, 
i18n, 
Validation, 
Data Binding, 
Type Conversion, 
SpEL, 
AOP, 
AOT.


其他人的总结:
	https://blog.csdn.net/MS_SONG/article/details/126242159




========================================
Spring 主要知识点
----------------------------------------
1. 能否跳过 spring 和 spring MVC 直接学习 Spring Boot？
https://www.zhihu.com/question/527283820/answer/2518307760

结论: 如果没有Spring基础的话，严重不建议学习Spring Boot。


Spring主要就是IOC和AOP两大特性
	IOC用来管理和存储对象，在Spring中这些对象被称为Bean
		比如Bean的生命周期，
		Spring三级缓存，
		Aware接口的使用，
		几种生命周期回调方式等等，
		这都是属于学过Spring应该掌握的知识，
		当然， 从源码层面DEBUG看过的会更好，但是，至少功能上应该要不陌生。
	AOP在Spring中的体现就是，
		利用底层的动态代理技术【Cglib，JDKProxy】
		以及部分AspectJ的注解来完成的对于对象的动态无侵入式增强。

然后再说上手Spring Boot。
	Spring Boot出现的主要原因是因为以前用Spring去整合Web项目的时候，配置太复杂了
	Spring Boot把这些场景抽象为了Maven依赖：叫做starter，场景启动器。
		你想用Web开发场景？可以，你就导入spring-boot-starter-web。
		想用模板引擎？你就导入spring-boot-starter-thymeleaf。
		想用缓存？可以，你就导入spring-boot-starter-data-redis等等

		一旦你导入某一个场景启动器【starter】，Spring Boot就会开启自动化配置，把相关场景需要的对象自动化配置好并加入Spring的IOC中，然后项目中我就可以自动注入这些对象了，那不就相当于这个场景就生效了么。

		你还可以封装自己的starter，完成你自己想要的自动化配置功能。
		但是一切，都离不开Spring底层的IOC容器和强大的AOP功能。


至于SpringMVC，这玩意儿只是Spring家族，Spring FrameWork在Web层里面提供的一种解决方案。
	SpringMVC是MVC在C【Controller】这一层上的一种实现框架

	所谓的跳过SpringMVC，也只是跳过一些源码方面的讲解，
	但是至少，ResponseBody，Validated，RequestMapping，RequestParam，
	还有request，session获取方式，参数获取方式，
	如何接收并且校验对象，如何接收表单数据等等，
	还有json序列化方式，
	Model/ModelMap对象的使用，
	springMVC接收请求处理的那几步，比如HandlerMapping，HandlerAdapter，ViewResolver的死记硬背等等，这些总要会吧。

	会了这些基本的，入手Spring Boot没啥太大问题，细枝末节啥的后面慢慢补就成。


所以建议题主，学习技术切不可急于求成，底层基础很重要，
	Spring实在不行可以去看看硅谷雷神的Spring注解驱动开发，那里讲了很多Spring的原理和底层。
		本人之前看过一部分，受益颇多。
		如果Java基础不牢固，很可能无法坚持看完，因为难度去确实比较大。




2. 要点
spring 框架
	核心：AOP, IoC, 生命周期，资源管理
	web: SpringMVC, RestTemplate
	Data: JdbcTemplate, DAO, 事务, ORM
	企业级应用: JMS, Job, Cache

Spring Boot:
	启动过程: 原理，内嵌 Tomcat
	自动装配: 原理, Stater
	生产级特性: 配置文件，打包部署，Actuator，Spring Boot Admin

Spring Cloud: 一套微服务解决方案，一系列不同功能的微服务框架的集合。
	基本概念: 
		分布式架构
		微服务架构: Dubbo(RPC), gRPC, Service Mesh,  
		云原生架构
	服务消息总线: Spring Cloud Bus
	服务安全: Security
	服务网关: 
		Zuul
		Kong
		Gateway
	服务链路跟踪:
		Sleuth
		Zipkin
		Skywalking
	服务注册和发现:
		Eureka
		Zookeeper
		Consul
		Nacos
	负载均衡
		Feign
		Ribbon
	服务限流与熔断
		Sentinel
		Hystrix


(2) 分布式课程
MIT 6.824:Distributed Systems
	记得 lab 一定要做
MIT 6.828 ?




========================================
Spring 6 大纲与进度记录(最低 jdk17)
----------------------------------------
1. 视频进度
https://www.bilibili.com/video/BV1kR4y1b7Qc/?p=2

官方文档: https://spring.io/projects/spring-framework
	https://spring.io/projects/spring-framework#learn
	https://docs.spring.io/spring-framework/docs/current/reference/html/

(1) 划分
广义：使用 spring的都是 spring 框架
狭义：spring framework

核心: IoC 和 AOP

(2) 特点
非侵入式
控制反转 IoC
面向切面 AOP
容器
组件化: 多个组件通过spring组成复杂应用
一站式


(3) 模块组成
Overview	
History, Design Philosophy, Feedback, Getting Started.

Core	核心部分 - 本文主要关注的点
IoC Container, Events, Resources, i18n, Validation, Data Binding, Type Conversion, SpEL, AOP, AOT.

Testing	 测试
Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient.

Data Access	数据操作(JDBC)
Transactions, DAO Support, JDBC, R2DBC, O/R Mapping, XML Marshalling.

Web Servlet	
Spring MVC, WebSocket, SockJS, STOMP Messaging.

Web Reactive	
Spring WebFlux, WebClient, WebSocket, RSocket.

Integration	
REST Clients, JMS, JCA, JMX, Email, Tasks, Scheduling, Caching, Observability.

Languages	
Kotlin, Groovy, Dynamic Languages.

Appendix	
Spring properties.

Wiki	
What’s New, Upgrade Notes, Supported Versions, additional cross-version information.


(4) 环境
jdk17+

Eclipse: Version: 2022-12 (4.26.0)
Spring: 6.0.7
Apache Maven 3.9.1 #>mvn -v (maven 3.6+)





========================================
入门案例及实现步骤 (maven项目的文件结构、 测试文件的位置和写法)
----------------------------------------
1.大纲
(1) 先创建一个聚合工程，创建子模块
Spring6
	|-- spring-first
	|-- spring-2
(2) spring 开发步骤

1) 引入 Spring 相关依赖
2) 创建类，定义属性和方法
3) 按照 spring 要求创建配置文件(xml格式) 
4) 在spring 配置文件配置相关信息
5) 测试




2. 创建项目的具体操作
(1) 创建聚合工程
菜单 文件-new-maven project,

勾选 skip archetype selection
	archetype [ˈɑːkitaɪp]n. 原型；典型
不勾选 default Workspace location:
	Location: G:\learngit\spring6 一个新文件夹

下一步
	Group id: com.mio
	artifact id: spring6
	version: 0.0.1-SNAPSHOT 默认值
	Packaging: pom
finish。


(2) 创建子模块
菜单File-new-other-搜索 maven，选择 Maven Module
	勾选 skip archetype selection
	Module name: spring-first
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: spring-first
	version:
	packaging: jar
Finish


// 发现环境是 java1.5?
右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17




3. 写代码的具体操作
(1)修改子模块的 pom.xml 文件，添加后如下
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.mio</groupId>
    <artifactId>spring6</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>spring-first</artifactId>
  
  <properties>
	  <maven.compiler.source>17</maven.compiler.source>
	  <maven.compiler.target>17</maven.compiler.target>
  </properties>
  
  <dependencies>
	  <!-- 引入Spring context依赖，表示将Spring的基础依赖引入了 -->
	  <dependency>
		  <groupId>org.springframework</groupId>
		  <artifactId>spring-context</artifactId>
		  <version>6.0.7</version>
	  </dependency>
	  
	  <!-- JUnit -->
	  <dependency>
		  <groupId>org.junit.jupiter</groupId>
		  <artifactId>junit-jupiter-api</artifactId>
		  <version>5.6.3</version>
	  </dependency>
  </dependencies>
</project>

保存后会自动刷新，子项目中的 Maven Dependencies 下已经引入10个jar包。



(2) 创建类，定义属性和方法
在子模块中创建类：右击子模块-new-class
	package: com.mio.spring6
	Name: User
$ cat User.java
package com.mio.spring6;

public class User {
	public void add() {
		System.out.println("add ....");
	}
}

(3) 按照 spring 要求创建配置文件(xml格式) 
尝试给eclipse安装 Spring suit4 插件，失败。。。

创建xml配置文件
	位置在 src/main/java 下的 resources/
	名字随意，比如 bean.xml
内容如下:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>


(4) 使用 bena 标签在xml中创建user对象
bean:
	id 属性：唯一标识
	class 属性：要创建对象所在类的全路径(包名称+类名称)

<bean id="user" class="com.mio.spring6.User"></bean>


(5) 测试类，在User同目录下
$ cat UserTest.java
package com.mio.spring6;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {

	@Test
	public void testUserObject() {
		//1.加载spring配置文件，对象创建
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//2.获取创建对象
		User user=(User) context.getBean("user");
		System.out.println(user);
		//3.使用对象调用方法
		user.add();
	}
}



(6) 测试
// 右击 无法 run as test??!! //todo

尝试1: 凑合方法
只能创建main方法：
	public static void main(String[] args) {
		new UserTest().testUserObject();
	}
输出:
com.mio.spring6.User@55a1c291
add ....



尝试2: 更换测试类
注释掉 子模块中的
	  <!-- JUnit 
	  <dependency>
		  <groupId>org.junit.jupiter</groupId>
		  <artifactId>junit-jupiter-engine</artifactId>
		  <version>5.6.3</version>
	  </dependency>
	  -->
重新添加
      <!-- JUnit  这个有用 
		  <scope>test</scope>
      -->
      <dependency>
		  <groupId>junit</groupId>
		  <artifactId>junit</artifactId>
		  <version>4.11</version>
	  </dependency>
同时把测试类移动到 src/test/java/下

package com.mio.spring6;

import org.junit.Test;
//import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {

	@Test
	public void testUserObject() {
		//1.加载spring配置文件，对象创建
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//2.获取创建对象
		User user=(User) context.getBean("user");
		System.out.println(user);
		//3.使用对象调用方法
		user.add();
	}
}

支持选中测试方法，右击 run as JUnit Test

或者右击 子模块 名字，右击 run as Junit Test，运行所有测试方法。



总结:
1. JUnit 两种依赖有啥关系？
2. 注意测试文件的位置
子模块/
  |-src/
     |-main/java/
         |- com.mio.spring6.User.java
     |-test/
         |- com.mio.spring6.UserTest.java





========================================
|-- 分析以上程序
----------------------------------------
1. 创建对象
(1) 是否调用了无参构造器？
$ cat User.java
package com.mio.spring6;

public class User {
	public User() {
		System.out.println("0: User 无参构造器");
	}
	
	public void add() {
		System.out.println("add ....");
	}
}

运行测试后，输出:
	0: User 无参构造器
	com.mio.spring6.User@28eaa59a
	add ....
说明: 确实输出了 无参构造器。


(2) 创建对象没有new? 如何使用反射创建对象？

步骤
	- 加载 bean.xml 配置文件
	- 解析xml文件
	- 获取属性值：id，class
	- 使用反射创建对象

代码:
	//反射创建对象
	@Test
	public void testUserObject2() throws Exception {
		//1.加载xml文件，获取信息：id, class 略
		//2.获取类对象
		Class clazz=Class.forName("com.mio.spring6.User");
		//3.创建对象
		//User user=clazz.newInstance(); //jdk17已过时
		User user=(User) clazz.getDeclaredConstructor().newInstance();
		//4.执行方法
		user.add();
		System.out.println("from: testUserObject2");
	}

输出:
	0: User 无参构造器
	add ....
	from: testUserObject2



(3) 创建的对象在哪里？
//todo: eclipse下怎么看maven项目中spring的源码?

Spring是一个bean 容器:
DefaulListableBeanFactory.java
	private final Map<String, BeanDefinition> beanDefinitionMap=...
	键值对，字符串-Bean定义，也就是bean的描述信息。







========================================
|-- 添加 Log4j2 日志记录组件
----------------------------------------
1. 日志常用设置 
(1)日志信息的优先级
从低到高：TRACE< DEBUG < INFO < WARN < ERROR < FATAL
	trace 追踪，相当于程序的执行，最低的日志级别
	debug 调试，一般将其设置为最低的日志级别
	info: 信息，输出重要信息，使用较多
	warn 警告
	error 错误
	fatal 严重错误
级别高的自动屏蔽级别低的。

(2) 日志输出目的地
控制台
文件

(3) 日志格式
时间格式

(4) 过程
引入依赖 pom.xml
写配置文件，固定名字：
测试
	输出到哪里？
	格式？
	输出哪些部分？





2. 实例
(1) 在pom.xml引入2个依赖
	  <!-- log4j2的2个依赖-->
	  <dependency>
		  <groupId>org.apache.logging.log4j</groupId>
		  <artifactId>log4j-core</artifactId>
		  <version>2.20.0</version>
	  </dependency>
      
      <dependency>
		  <groupId>org.apache.logging.log4j</groupId>
		  <artifactId>log4j-slf4j-impl</artifactId>
		  <version>2.20.0</version>
	  </dependency>

(2) 创建配置文件
文件名固定，必须放类的根目录下的 resources/下。
$ cat log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<loggers>
		<root level="DEBUG">
			<!-- 定义三种输出方式，具体定义见下文  -->
			<appender-ref ref="spring6log" />
			<appender-ref ref="RollingFile" />
			<appender-ref ref="log" />
		</root>
	</loggers>

	
	<!-- 更详细的设置: https://www.cnblogs.com/LLL0617/p/16864480.html -->
	<appenders>
		<!-- 输出日志信息到控制台 -->
		<console name="spring6log" target="SYSTEM OUT">
			<!-- 控制日志输出的格式 -->
			<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n" />
		</console>
		
		
		<!-- 输出到文件，每次log都自动清空，由append属性控制 -->
		<File name="log" fileName="G:/learngit/spring6/dustbin/test.log" append="false">
			<PatternLayout pattern="%d{HH:mm:ss SSS} %-5level %class{35} %L %M - %msg%xEx%n" />
		</File>
		
		
	    <RollingFile name="RollingFile" fileName="G:/learngit/spring6/dustbin/app.log" 
	    	filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{35} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="50MB" />
            <!-- 设置同类型日志,同一文件夹下可以存放的数量,如果不设置此属性则默认存放7个文件 -->
            <DefaultRolloverStrategy max="20" />
        </RollingFile>
	</appenders>

</configuration>


(3) 运行上一节的测试函数
1) 观察控制台输出，多了前三行
2023-04-02 17:37:43 441 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
2023-04-02 17:37:43 761 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 17:37:43 819 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
0: User 无参构造器
org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad, started on Sun Apr 02 17:37:43 CST 2023
testUserObject: com.mio.spring6.User@666b83a4
add ....



2)文件 test.log

17:37:43 441 DEBUG org.springframework.context.support.AbstractApplicationContext 630 prepareRefresh - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
17:37:43 761 DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader 393 doLoadBeanDefinitions - Loaded 1 bean definitions from class path resource [bean.xml]
17:37:43 819 DEBUG org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 225 getSingleton - Creating shared instance of singleton bean 'user'


3) 文件 app.log
2023-04-02 at 17:37:43 CST DEBUG org.springframework.context.support.AbstractApplicationContext 630 prepareRefresh - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3f57bcad
2023-04-02 at 17:37:43 CST DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader 393 doLoadBeanDefinitions - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 at 17:37:43 CST DEBUG org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 225 getSingleton - Creating shared instance of singleton bean 'user'





3. 手动输出日志信息
(1) 在测试类中添加
public class UserTest {
	//1.创建 logger 对象
	private Logger logger=LoggerFactory.getLogger(UserTest.class);
	
	@Test
	public void testUserObject() {
		//...
		
		//2.手动写日志
		logger.info("## 执行了 testUserObject()");
		//...
	}
}

执行后，控制台多了一行
2023-04-02 17:46:32 081 [main] INFO com.mio.spring6.UserTest - ## 执行了 testUserObject()






========================================
IoC: 控制反转 (inversion of control)
----------------------------------------
1. 什么是IoC？

创建对象的过程被反转了。是一种思想。

(1)使用IoC容器来管理
	所有Java对象的实例和初始化，
	控制对象与对象之间的依赖关系

	IoC容器管理的Java对象叫 bean，它与new创建的对象没有任何区别。

(2)bean定义信息
xml -> BeanDefinition
抽象 -> BeanDefinitionReader;
IoC容器: bean 定义信息 获取 
	实例化 实例: BeanFactory工厂 + 反射
	初始化 -> 最终对象

(3) 依赖注入：是控制反转的实现方式

两种实现：
	set 注入
	构造注入

Bean 管理:
	bean 对象的创建
	bean 对象中属性的赋值

(4) BeanFactory 是spring框架内部使用的接口，不提供给开发人员

我们使用的是 ApplicationContext 接口，是 BeanFactory 的子接口。
其重要实现类包括:
BeanFactory 接口
	|- ApplicationContext 接口
	  |- ConfigurableApplication 接口
	  	|- FilSystemXmlApplicationContext 类
	  	|- ClassPathXmlApplicationContext 类


//todo eclipse 查看接口继承和实现图?
https://www.likecs.com/show-203369151.html
A: F4：Open Type Hierarchy --（在新弹出窗口）-> show the Supertype Hierarchy（则会有接口显示）

Q: 如何显示一个类的所有的继承和实现的接口?
显示一个类的所有父类和所有子类: Ctrl+T
类文件的outline：默认会显示。







========================================
|-- 基于 xml 的IoC (JUnit 不报错也不输出，怎么办？)
----------------------------------------
准备工作：
- 把之前 子模块 pom.xml 中的依赖，移动到父工程 pom.xml 中。
- 观察发现，子模块的 Maven Dependencies 是正常的。
- 执行之前的 test，一切正常。

目的：
	获取bean 的三种方式
	依赖注入的2种方式：set和构造器
	其他特殊类型的注入
	bean 的作用域：默认单例，怎么多例？
	生命周期？
	xml自动配置


1. 新建子模块 spring6-ioc-xml
(1)方法参考 spring-first
(2)引入 spring-first 模块配置文件：bean.xml, log4j2.xml
$ cat bean.xml
	<bean id="user" class="com.mio.spring6.iocxml.User"></bean>

(3) 新建 User 类
$ cat User.java
package com.mio.spring6.iocxml;

public class User {
	private String name;
	private Integer age;
	
	public void run() {
		System.out.println("run ...");
	}
}


(4) 新建测试类，获取bean的三种方式
//todo 结果 JUnit 不运行，也不报错，怎么办？
原来是自己用了log4j，但是没有配置文件，所以没有输出任何信息。 //不是我的问题，删了也不行。
迂回措施：给测试类加main方法。

$ cat UserTest.java
package com.mio.spring6.iocxml;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {
	public static void main(String[] args) {
		ApplicationContext context=new
				ClassPathXmlApplicationContext("bean.xml");
		System.out.println(context);
		//1.根据id获取bean
		User user1=(User) context.getBean("user");
		System.out.println("1.根据id获取bean: "+user1);
		
		//2.根据类型获取bean
		User user2=(User)context.getBean(User.class);
		System.out.println("2.根据类型获取bean: "+user2);
		
		//3.根据id和类型
		User user3=(User)context.getBean("user", User.class);
		System.out.println("3.根据id和类型获取bean: "+user3);
	}
	
	@Test
	public void test001() {
		System.out.println("test001(3)");
	}
}

输出:
2023-04-02 21:43:55 345 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@28b46423
2023-04-02 21:43:55 538 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 1 bean definitions from class path resource [bean.xml]
2023-04-02 21:43:55 585 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
org.springframework.context.support.ClassPathXmlApplicationContext@28b46423, started on Sun Apr 02 21:43:55 CST 2023
1.根据id获取bean: com.mio.spring6.iocxml.User@3f07b12c
2.根据类型获取bean: com.mio.spring6.iocxml.User@3f07b12c
3.根据id和类型获取bean: com.mio.spring6.iocxml.User@3f07b12c




(5) 细节问题：如果bean再加一条，仅仅是id不同，这时能使用类型获取到吗？
$ cat bean.xml
<bean id="user2" class="com.mio.spring6.iocxml.User"></bean>

测试: //2.根据类型获取bean
	User user2=(User)context.getBean(User.class);

报错: expected single matching bean but found 2: user,user2
	期望是单实例，但是找到2个匹配的。
解决：这时，只能依靠id或者，id+类型获取。



(6) 扩展问题: 一个接口的多个实现类，能否获取bean？
UserDao dao=new UserDaoImpl();

1) 新建包 bean，内部建接口 UserDao，及实现 UserDaoImpl
$ cat UserDao.java
package com.mio.spring6.iocxml.bean;
public interface UserDao {
	public void run();
}

$ cat UserDaoImpl.java
package com.mio.spring6.iocxml.bean;
public class UserDaoImpl implements UserDao {
	@Override
	public void run() {
		System.out.println("UserDaoImpl.run()");
	}
}



2) 配置文件 bean.xml
<bean id="userDaoImpl" class="com.mio.spring6.iocxml.bean.UserDaoImpl"></bean>


3) bean/下写测试类
$ cat TestUserDao.java
package com.mio.spring6.iocxml.bean;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestUserDao {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean.xml");
		//根据 接口类型 获取 接口实现类对应的bean
		UserDao userDao=context.getBean(UserDao.class);
		System.out.println(userDao);
		userDao.run();
	}
}

输出:
	com.mio.spring6.iocxml.bean.UserDaoImpl@784b990c
	UserDaoImpl.run()
结论: 如果接口只有一个实现，则可以 根据接口类型，获取实现类的bean。


4) 如果多个实现类，则不能根据 接口类型 获取bean。 因为不唯一。
报错： expected single matching bean but found 2: userDaoImpl,personDaoImpl
解决：使用id。










========================================
|-- 依赖注入: 两种实现方式； 特殊值的注入、特殊类型的注入
----------------------------------------
1. 类的属性，创建对象过程中，向属性设置值

- 基于set
- 基于构造器

(1) 新建包 di，其中新建 Book 类
原生写法:
$ cat Book.java
package com.mio.spring6.iocxml.di;

public class Book {
	private String bname;
	private String author;
	//生成set方法
	public String getBname() {
		return bname;
	}
	public void setBname(String bname) {
		this.bname = bname;
	}
	public String getAuthor() {
		return author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
	//构造器
	public Book() {}
	public Book(String bname, String author) {
		this.bname = bname;
		this.author = author;
	}
	
	@Override
	public String toString() {
		return String.format("Book[bname=%s, auther=%s]", bname, author);
	}

	public static void main(String[] args) {
		//原生做法:set注入
		Book book=new Book();
		book.setBname("Spring6");
		book.setAuthor("张三");
		System.out.println(book);
		
		//原生做法：构造器注入
		Book book2=new Book("java", "李四");
		System.out.println(book2);
	}
}





(2) 使用Spring的 set 方法注入
步骤：
	创建类，定义属性，生成其set方法，
	spring的xml配置文件：属性、值
	测试

使用上述Book类。

xml文件和重新创建: 类根目录下 
$ cat resources/bean-book-di.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 依赖注入1：set注入，name就是属性的小写 -->
	<bean id="book1" class="com.mio.spring6.iocxml.di.Book">
		<property name="bname" value="js"></property>
		<property name="author" value="王二"></property>
	</bean>
</beans>

测试类，为了方便，放同名类的文件夹内。
$ cat TestBook.java 
package com.mio.spring6.iocxml.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestBook {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-book-di.xml");
		Book book1=context.getBean("book1", Book.class);
		System.out.println(book1);
	}
}

输出: Book[bname=js, auther=王二]






(3) 构造器注入
步骤：
	- 创建类，定义属性，生成有参数构造方法
	- 配置xml
	- 测试

使用上述 Book 类。

xml的配置:
	<!-- 依赖注入2：构造器注入 -->
	<bean id="book2" class="com.mio.spring6.iocxml.di.Book">
		<constructor-arg name="bname" value="c++"></constructor-arg>
		<constructor-arg name="author" value="麻子"></constructor-arg>
	</bean>

测试：
	ApplicationContext context=
			new ClassPathXmlApplicationContext("bean-book-di.xml");
	//2.构造器注入
	Book book2= context.getBean("book2", Book.class);
	System.out.println(book2);

输出: Book[bname=c++, auther=麻子]







2. 特殊值的注入
字面量 int a=10; 这里字母a是变量，而"a"就表示其字符本身，就是字面量。
	Spring会把 value 属性的值看做字面量。
	<property name="name" value="times">
null值
	<property name="name">
		<null />
	</property>
xml 实体：比如值是<>，会报错
	和html实体类似，
	使用 &gt; 表示 >
	使用 &lt; 表示 <
CDATA节: 什么意思？就是告诉xml不要解析，这里面的都是纯文本。<![CDATA[ 这里写啥都可以 ]]
	<property name="bname">
		<value><![CDATA[a < b]]></value>
	</property>




========================================
|-- 特殊类型的注入: 对象类型、 数组类型、集合类型、
----------------------------------------
1. 对象类型的注入: 3种方式
	外部 bean 方式
	内部 bean方式
	级联赋值方式

部门1 --- m 员工
(1)新建包，里面建立2个类 Department, Employer; 
$ cat Department.java
package com.mio.spring6.iocxml.injectobj;
public class Department {
	private String dname;
	
	public void info() {
		System.out.println("Department: "+dname);
	}
}

$ cat Employer.java
package com.mio.spring6.iocxml.injectobj;
public class Employer {
	//该员工属于哪个部门
	private Department dept;
	
	private String ename;
	private int age;
	
	public void work() {
		System.out.println(ename + " Employer work... "+ "age: "+age);
		dept.info();
	}
}
注意：2个类都必须有setter/getter，本文为了简洁，省略。

(2) 配置文件
类根目录下/resources/bean-inject-obj.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 注入对象的三种方式	-->
	<!-- 方式1：外部 bean 方式 
		1 创建2个对象
		2 在emp的bean标签中，使用 property 引入dept的bean: 
			name=类的属性名，ref=待注入的bean的id
	-->
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="财务部"></property>
	</bean>
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="张三"></property>
		<property name="age" value="20"></property>
		<!-- 注入对象类型属性 
			private Department dept;
			name 就是类的属性名字; ref指代上文出现过的bean的id
		-->
		<property name="dept" ref="dept2"></property>
	</bean>
</beans>

(3) 测试
$ cat TestInjectObj.java
package com.mio.spring6.iocxml.injectobj;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestInjectObj {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1", Employer.class);
		//调用员工方法
		worker1.work();
	}
}

输出:
	张三 Employer work... age: 20
	Department: 财务部



(4) 方式2: 
配置文件: 
	<!-- 方式2：内部 bean 方式 	-->
	<bean id="emp1b" class="com.mio.spring6.iocxml.injectobj.Employer">
		<property name="ename" value="李四"></property>
		<property name="age" value="50"></property>
		<!-- 注入对象类型属性 
			private Department dept;
			name 就是类的属性名字; 需要的bean直接嵌套写
		-->
		<property name="dept">
			<bean id="dept2b" class="com.mio.spring6.iocxml.injectobj.Department">
				<property name="dname" value="人事部"></property>
			</bean>
		</property>
	</bean>

测试:
	private static void demo2() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1b", Employer.class);
		//调用员工方法
		worker1.work();	
	}
输出:
	李四 Employer work... age: 50
	Department: 人事部



(5) 第三种方式
配置文件
	<!-- 方式3：级联赋值 -->
	<bean id="dept2c" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="研发部"></property>
	</bean>
	<bean id="emp1c" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="王二"></property>
		<property name="age" value="40"></property>
		<!-- 注入对象类型属性: 在方式1的基础上，对要注入对象的属性值 dept.dname，重新赋值 -->
		<property name="dept" ref="dept2c"></property>
		<property name="dept.dname" value="广告部"></property>
	</bean>

测试：
	private static void demo3() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-inject-obj.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1c", Employer.class);
		//调用员工方法
		worker1.work();			
	}
输出：
	王二 Employer work... age: 40
	Department: 广告部








2. 注入数组
(1) 上文员工添加爱好属性，添加对应的getter/setter
	private String[] hobbies;
	public String[] getHobbies() {
		return hobbies;
	}

	public void setHobbies(String[] hobbies) {
		this.hobbies = hobbies;
	}

修改其work方法，输出hobbies：
	public void work() {
		System.out.println(ename + " Employer work... "+ "age: "+age);
		dept.info();
		System.out.println(Arrays.toString(hobbies));
	}

(2)新建配置文件 bean-di-array.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入数组类型 -->
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="财务部"></property>
	</bean>
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employer">
		<!-- 注入普通属性 -->
		<property name="ename" value="张三"></property>
		<property name="age" value="22"></property>
		<!-- 注入对象类型属性 -->
		<property name="dept" ref="dept2"></property>
		<!-- 注入数组 -->
		<property name="hobbies">
			<array>
				<value>吃饭</value>
				<value>睡觉</value>
				<value>打游戏</value>
			</array>
		</property>
	</bean>
</beans>

(3) 测试
	private static void demo4() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-array.xml");
		//获取员工对象
		Employer worker1=context.getBean("emp1", Employer.class);
		//调用员工方法
		worker1.work();			
	}
输出:
	张三 Employer work... age: 22
	Department: 财务部
	[吃饭, 睡觉, 打游戏]








3. 注入集合
订正：今天发现员工是 employee，雇主是 employer。
	改正一下代码(类名，xml)，以上笔记就不改了。

(1) 在部门类中添加属性
	//一个部门有很多员工
	private List<Employee> empList;
生成setter/getter方法。

修改输出方法：
	public void info() {
		System.out.println("Department: "+dname);
		for(Employee emp: empList) {
			System.out.println("\t"+emp.getEname());
		}
	}

(2) 创建配置文件 bean-di-list.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入 List 类型 -->
	<bean id="emp1" class="com.mio.spring6.iocxml.injectobj.Employee">
		<property name="ename" value="张三1"></property>
		<property name="age" value="21"></property>
	</bean>
	<bean id="emp2" class="com.mio.spring6.iocxml.injectobj.Employee">
		<property name="ename" value="张三2"></property>
		<property name="age" value="22"></property>
	</bean>
    
	<bean id="dept2" class="com.mio.spring6.iocxml.injectobj.Department">
		<property name="dname" value="维修部"></property>
		<!-- 注入集合类型 -->
		<property name="empList">
			<list>
				<ref bean="emp1"></ref>
				<ref bean="emp2"></ref>
			</list>
		</property>
	</bean>
</beans>
解释:
	如果 List<String> 则需要使用 <list> <value>xx</value> </list>
	上文是对象，则list标签内使用 ref 标签。


(3) 测试
	private static void demo5() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-list.xml");
		//获取对象
		Department dept=context.getBean("dept2", Department.class);
		//调用方法
		dept.info();
	}
输出：
Department: 维修部
	张三1
	张三2


========================================
|-- 使用xml注入 Map 类型
----------------------------------------

1. 新建包，新建类 Student, Teacher
一个学生每门课不同的老师。

$ cat Student.java
package com.mio.spring6.iocxml.injectmap;
public class Student {
	private String sid;
	private String sname;
	//创建map属性
	private Map<String, Teacher> teacherMap;
	
	//方便输出
	public void run() {
		System.out.println("Stu: "+sid+", "+sname);
		System.out.println(teacherMap);
	}
}


$ cat Teacher.java
package com.mio.spring6.iocxml.injectmap;
public class Teacher {
	private String tid;
	private String tname;

	@Override
	public String toString() {
		return String.format("Teacher[id:%s, name:%s]", tid, tname);
	}
}
生成set/get。


(2) 配置文件 bean-di-map.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 注入 Map 类型 -->
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入Map类型 -->
		<property name="teacherMap">
			<map>
				<entry>
					<key>
						<value>语文</value>
					</key>
					<ref bean="teacher1"></ref>
				</entry>
				
				<entry>
					<key>
						<value>英语</value>
					</key>
					<ref bean="teacher2"></ref>
				</entry>
			</map>
		</property>
	</bean>
</beans>

(3) 测试
package com.mio.spring6.iocxml.injectmap;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestStu {
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-map.xml");
		Student stu=context.getBean("student", Student.class);
		stu.run();		
	}
}

输出:
	Stu: 12345, 大宝
	{语文=Teacher[id:21, name:张三老师], 英语=Teacher[id:22, name:李四老师]}










========================================
|-- List 和 Map 注入的另一种写法： 引用集合bean (需修改xml的约束条件)
----------------------------------------
换一种写法。

1. 新增课程类 Lesson，一个学生可以选多门课
$ cat Lesson.java
package com.mio.spring6.iocxml.injectmap;
public class Lesson {
	private String lname;
	@Override
	public String toString() {
		return "Lesson [lname=" + lname + "]";
	}
}
生成get/set方法。

修改学生类，添加新属性 lessonList，修改输出
$ cat Student.java
package com.mio.spring6.iocxml.injectmap;

import java.util.List;
import java.util.Map;

public class Student {
	private String sid;
	private String sname;
	//创建map属性
	private Map<String, Teacher> teacherMap;
	private List<Lesson> lessonList;
	
	//方便输出
	public void run() {
		System.out.println("Stu: "+sid+", "+sname);
		System.out.println(teacherMap);
		System.out.println(lessonList);
	}
}


2. 新建配置文件
注意，使用util标签，需要引入其约束:
	https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html
	添加一行 xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation=""中添加
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd

$ cat bean-di-ref.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd
        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- 引用注入集合类型
    1 创建3个对象
    2 注入普通类型属性
    3 使用 util:类型 定义
    4 在学生bean引入 util:类型定义，完成list，map类型属性的注入
    -->
    <bean id="lesson1" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java高级课程"></property>
	</bean>
	<bean id="lesson2" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java框架课程"></property>
	</bean>
	
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
    
    <util:list id="lessonList_a1">
    	<ref bean="lesson1"></ref>
    	<ref bean="lesson2"></ref>
    </util:list>
    
    
    <util:map id="teacherMap_b2">
    	<entry>
    		<key>
    			<value>化学</value>
    		</key>
    		<ref bean="teacher1"></ref>
    	</entry>
    	
    	<entry>
    		<key>
    			<value>物理</value>
    		</key>
    		<ref bean="teacher2"></ref>
    	</entry>
    </util:map>
    
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入List和Map类型的属性 -->
		<property name="lessonList" ref="lessonList_a1"></property>
		<property name="teacherMap" ref="teacherMap_b2"></property>
	</bean>
</beans>



3. 测试
	private static void demo2() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-ref.xml");
		Student stu=context.getBean("student", Student.class);
		stu.run();			
	}
输出：
	Stu: 12345, 大宝
	{化学=Teacher[id:21, name:张三老师], 物理=Teacher[id:22, name:李四老师]}
	[Lesson [lname=Java高级课程], Lesson [lname=Java框架课程]]





========================================
|-- p 命名空间
----------------------------------------
1. xml 的命名空间是为了防止同名冲突:
<beans xmlns="">
<beans xmlns="" xmlns:p="">
真实写法: xmlns:p="http://www.springframework.org/schema/p"


(1) 新建xml文件
$ cat bean-di-p.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd
        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- p 命名空间注入 -->
    <bean id="student2" class="com.mio.spring6.iocxml.injectmap.Student" 
    p:sid="1002" p:sname="Jim" 
    p:lessonList-ref="lessonList_a1" 
    p:teacherMap-ref="teacherMap_b2">
	</bean>
	   
    <!-- 引用注入集合类型
    1 创建3个对象
    2 注入普通类型属性
    3 使用 util:类型 定义
    4 在学生bean引入 util:类型定义，完成list，map类型属性的注入->最后一步不同
    -->
    <bean id="lesson1" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java高级课程"></property>
	</bean>
	<bean id="lesson2" class="com.mio.spring6.iocxml.injectmap.Lesson">
		<property name="lname" value="Java框架课程"></property>
	</bean>
	
	<bean id="teacher1" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="21"></property>
		<property name="tname" value="张三老师"></property>
	</bean>
	<bean id="teacher2" class="com.mio.spring6.iocxml.injectmap.Teacher">
		<property name="tid" value="22"></property>
		<property name="tname" value="李四老师"></property>
	</bean>
    
    
    <util:list id="lessonList_a1">
    	<ref bean="lesson1"></ref>
    	<ref bean="lesson2"></ref>
    </util:list>
    
    
    <util:map id="teacherMap_b2">
    	<entry>
    		<key>
    			<value>化学</value>
    		</key>
    		<ref bean="teacher1"></ref>
    	</entry>
    	
    	<entry>
    		<key>
    			<value>物理</value>
    		</key>
    		<ref bean="teacher2"></ref>
    	</entry>
    </util:map>
    
    
	<bean id="student" class="com.mio.spring6.iocxml.injectmap.Student">
		<property name="sid" value="12345"></property>
		<property name="sname" value="大宝"></property>
		<!-- 注入List和Map类型的属性 -->
		<property name="lessonList" ref="lessonList_a1"></property>
		<property name="teacherMap" ref="teacherMap_b2"></property>
	</bean>
</beans>


测试：
	private static void demo3() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-di-p.xml");
		Student stu=context.getBean("student2", Student.class);
		stu.run();
	}
输出：
	Stu: 1002, Jim
	{化学=Teacher[id:21, name:张三老师], 物理=Teacher[id:22, name:李四老师]}
	[Lesson [lname=Java高级课程], Lesson [lname=Java框架课程]]




========================================
|-- 引入外部属性文件(常用)
----------------------------------------
如果一个xml中bean太多，不方便维护。
一般放到数据库中，需要时引入。

1. 步骤
(1) 引入数据库相关依赖
(2) 创建外部属性文件，properties格式
定义数据信息：用户名、密码、地址等
(3) 创建 spring 配置文件，引入 context 命名空间
引入属性文件，使用表达式完成注入



2.操作
(1) 在子项目的 pom.xml 文件中引入
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.mio</groupId>
    <artifactId>spring6</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>spring6-ioc-xml</artifactId>
  
  <dependencies>
	  <!-- 引入mysql的依赖 -->
	  <dependency>
		  <groupId>mysql</groupId>
		  <artifactId>mysql-connector-java</artifactId>
		  <version>8.0.32</version>
	  </dependency>
	  
	  <!-- 引入线程池 -->
	  <dependency>
		  <groupId>com.alibaba</groupId>
		  <artifactId>druid</artifactId>
		  <version>1.2.16</version>
	  </dependency>
	  
  </dependencies>
</project>



(2)在class根目录/resources/下创建properties文件
这是 mysql 的配置文件。后缀固定，文件名随意。
$ cat jdbc-config.properties
jdbc.user=root
jdbc.password=
jdbc.url=jdbc:mysql://localhost:3306/spring?serverTimezone=UTC
jdbc.driver=com.mysql.cj.jdbc.Driver




(3)在class根目录/resources/下创建xml文件
这是 spring 的配置文件。 
注意要修改前几行的约束条件：
	新增一行： xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation 中新增两行:
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd

$ cat bean-jdbc.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 引入外部依赖文件 -->
	<context:property-placeholder location="classpath:jdbc-config.properties"></context:property-placeholder>
	
	<!-- 完成数据库信息注入 -->
	<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
		<property name="url" value="${jdbc.url}"></property>
		<property name="username" value="${jdbc.user}"></property>
		<property name="password" value="${jdbc.password}"></property>
		<property name="driverClassName" value="${jdbc.driver}"></property>
	</bean>

</beans>

注意: 分3步
	- 修改xml约束条件
	- 引入外部依赖 properties 文件
	- 使用外部文件的值完成注入: value="${jdbc.url}"



(4) 新建包jdbc，新建类 
	public static void demo1() {
		DruidDataSource dataSource=new DruidDataSource();
		dataSource.setUrl("jdbc:mysql://localhost:3306/spring?serverTimezone=UTC");
		dataSource.setUsername("root");
		dataSource.setPassword("");
		dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
		System.out.println(dataSource.getUrl());
	}

	private static void demo2() {
		ApplicationContext context=new ClassPathXmlApplicationContext("bean-jdbc.xml");
		DruidDataSource dataSource=context.getBean(DruidDataSource.class);
		System.out.println(dataSource.getUrl());
	}

输出:
	jdbc:mysql://localhost:3306/spring?serverTimezone=UTC

优点：如果mysql配置发生变动，只需要修改 properties 文件，其他地方不需要改动。








========================================
|-- bean 作用域: scope 属性，单实例、多实例（还有2个不常用的属性值）
----------------------------------------
1. 取值范围
默认是 单实例 scope="singleton"，IoC容器初始化
还可以是 多实例 scopre="prototype"，请求时初始化

(2). 如果在 WebApplicationContext 环境下还会有另外几个作用域(但不常用)
取值 scope="request"，在一个请求返回内有效。
取值 scope="session"，在一个会话范围内有效。




2. 示例

(1) 创建scope包，其中新建类 Orders
$ cat Orders.java
package com.mio.spring6.iocxml.scope;
public class Orders {}

(2) 新建配置文件 bean-scope.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    xsi:schemaLocation="        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- 使用 scope 设置：单实例(默认) singleton 、多实例 prototype -->
	<bean id="orders" class="com.mio.spring6.iocxml.scope.Orders" 
		scope="prototype">
	</bean>
</beans>

(3) 测试
	private static void demo1() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-scope.xml");
		Orders orders=context.getBean("orders", Orders.class);
		System.out.println(orders);
		//再次获取: 单实例 地址一致; 多实例 地址不一致;
		Orders orders2=context.getBean("orders", Orders.class);
		System.out.println(orders2);		
	}
输出:
singleton: IoC容器初始化时创建
	com.mio.spring6.iocxml.scope.Orders@1951b871
	com.mio.spring6.iocxml.scope.Orders@1951b871
prototype: 请求该bean时创建
	com.mio.spring6.iocxml.scope.Orders@7096b474
	com.mio.spring6.iocxml.scope.Orders@3e14c16d




========================================
|-- bean 的生命周期：创建对象、设置属性值、后处理1、初始化方法、后处理2、销毁方法
----------------------------------------
1. bean 的生命周期
(1) bean 对象的创建(调用无参构造器)
(2) 给 bean 对象设置相关属性
(3) bean 后置处理器(初始化前)
(4) bean 对象初始化
(5) bean 后置处理器(初始化后)

(6) bean 对象创建完成，可以使用了

(7) bean 对象销毁(配置指定销毁的方法)
(8) IoC 容器关闭


2. 示例
(1)创建包 lifecycle, 创建类
$ cat User.java
package com.mio.spring6.iocxml.lifecycle;

public class User {
	private String name;
	
	//无参构造
	public User() {
		System.out.println("1 调用无参构造，创建对象");
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		System.out.println("2 给bean对象设置属性值");
		this.name = name;
	}
	
	//初始化方法
	public void initMethod() {
		System.out.println("4 bean对象初始化，会调用指定的初始化方法");
	}
	
	//销毁方法
	public void destroy() {
		System.out.println("7 bean 对象销毁，会调用指定的销毁方法");
	}
}

(2) 创建配置文件
$ cat bean-lifecycle.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    xsi:schemaLocation="        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- bean 生命周期 -->
	<bean id="user" class="com.mio.spring6.iocxml.lifecycle.User" 
		init-method="initMethod" destroy-method="destroy">
		<property name="name" value="Tom"></property>
	</bean>
</beans>

(3) 测试
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context=
				new ClassPathXmlApplicationContext("bean-lifecycle.xml");
		User user=context.getBean("user", User.class);
		System.out.println("6 bean 创建完成，可以使用");
		System.out.println(user);
		
		context.close();//销毁 bean 对象，注意：ClassPathXmlApplicationContext 对象才用close方法
	}
输出:
	前面省略3条消息。
	1 调用无参构造，创建对象
	2 给bean对象设置属性值
	4 bean对象初始化，会调用指定的初始化方法
	6 bean 创建完成，可以使用
	com.mio.spring6.iocxml.lifecycle.User@478ee483
	2023-04-07 21:13:59 794 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@1787bc24, started on Fri Apr 07 21:13:59 CST 2023
	7 bean 对象销毁，会调用指定的销毁方法





(4) 后置处理器，是一个类，需要继承接口
$ cat MyBeanPost.java
package com.mio.spring6.iocxml.lifecycle;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanPost implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("3>> bean 后置处理器(Before初始化 执行)");
		return bean;
	}
	
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("5>> bean 后置处理器(After初始化 执行)");
		return bean;
	}
}

(5) 配置文件中新增
	<!-- bean 的后置处理器要放入IoC容器才能生效 -->
	<bean id="myBeanPost" class="com.mio.spring6.iocxml.lifecycle.MyBeanPost"></bean>

这是对所有的IoC容器中所有的bean都生效的！

(6)测试
	public static void main(String[] args) {
		ClassPathXmlApplicationContext context=
				new ClassPathXmlApplicationContext("bean-lifecycle.xml");
		User user=context.getBean("user", User.class);
		System.out.println("6 bean 创建完成，可以使用");
		System.out.println("\tUser name: " + user.getName());
		
		context.close();//销毁 bean 对象，注意：ClassPathXmlApplicationContext 对象才用close方法
	}

输出:
	1 调用无参构造，创建对象
	2 给bean对象设置属性值
	3>> bean 后置处理器(Before初始化 执行)
	4 bean对象初始化，会调用指定的初始化方法
	5>> bean 后置处理器(After初始化 执行)
	6 bean 创建完成，可以使用
		User name: Tom
	2023-04-07 21:23:49 195 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Closing org.springframework.context.support.ClassPathXmlApplicationContext@1787bc24, started on Fri Apr 07 21:23:48 CST 2023
	7 bean 对象销毁，会调用指定的销毁方法





========================================
|-- FactoryBean 是一种封装机制，由类内 getObject() 方法的返回值决定返回的对象(常用语整合第三方框架)
----------------------------------------
1. 示例
(1) 创建包 factorybean, 新建类
$ cat User.java
package com.mio.spring6.iocxml.factorybean;
public class User {}

$ cat MyFactoryBean.java
package com.mio.spring6.iocxml.factorybean;

import org.springframework.beans.factory.FactoryBean;

//在配置文件中配置 MyFactoryBean，返回的确实其中返回的对象
public class MyFactoryBean implements FactoryBean<User> {

	@Override
	public User getObject() throws Exception {
		return new User();
	}

	@Override
	public Class<?> getObjectType() {
		return User.class;
	}
}


(3) 配置文件
$ cat bean-factorybean.xml
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- FactoryBean 示例 -->
	<bean id="user" class="com.mio.spring6.iocxml.factorybean.MyFactoryBean">
	</bean>

</beans>

(4) 测试
	public static void main(String[] args) {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-factorybean.xml");
//		User user=context.getBean("user", MyFactoryBean.class);
		User user=(User) context.getBean("user");
		System.out.println(user);
	}
输出: com.mio.spring6.iocxml.factorybean.User@7c098bb3
说明，输出的确实是 bean 配置文件中的MyFactoryBean对象的返回的类型User的实例。










========================================
|-- 基于 xml 自动装配： bean 属性 autowire="byType"
----------------------------------------
1.定义
根据指定的策略，在IoC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值。

(2) 模拟过程
controller -> service接口和实现列 -> dao接口和实现类。
希望：
	在 controller 中注入 service
	在 service 中输入 dao

(3) 实现方法
在 controller 类中声明 service 类型属性，定义其set方法。
在 service 类中声明 dao 类型属性，定义其set方法。




3. 示例
(1) 新建包 auto, 文件结构如下
$ ls -R
.:
controller/  dao/  service/  TestController.java

./controller:
UserController.java

./dao:
UserDao.java  UserDaoImpl.java

./service:
UserService.java  UserServiceImpl.java


(2) 接口和实现类
## controller
$ cat controller/UserController.java
package com.mio.spring6.iocxml.auto.controller;

import com.mio.spring6.iocxml.auto.service.UserService;
//import com.mio.spring6.iocxml.auto.service.UserServiceImpl;

public class UserController {
	private UserService userService;

	public void setUserService(UserService userService) {
		this.userService = userService;
	}
	
	public void addUser() {
		System.out.println("controller 方法执行了");
		//调动 service
//		UserService userService=new UserServiceImpl();
		userService.addUserService();
	}
}


## service 先定义接口，再定义实现
$ cat service/UserService.java
package com.mio.spring6.iocxml.auto.service;

public interface UserService {
	public void addUserService();
}


$ cat service/UserServiceImpl.java
package com.mio.spring6.iocxml.auto.service;

import com.mio.spring6.iocxml.auto.dao.UserDao;
//import com.mio.spring6.iocxml.auto.dao.UserDaoImpl;

public class UserServiceImpl implements UserService {
	private UserDao userDao;
	public void setUserDao(UserDao userDao) {
		this.userDao = userDao;
	}

	@Override
	public void addUserService() {
		System.out.println("UserService 方法执行了");
		//调dao
//		UserDao userDao=new UserDaoImpl();
		userDao.addUserDao();
	}
}



## dao 先定义接口，再定义实现
$ cat dao/UserDao.java
package com.mio.spring6.iocxml.auto.dao;
public interface UserDao {
	public void addUserDao();
}

$ cat dao/UserDaoImpl.java
package com.mio.spring6.iocxml.auto.dao;
public class UserDaoImpl implements UserDao {
	@Override
	public void addUserDao() {
		System.out.println("userDao方法执行了");
	}
}



(3) 创建配置文件
$ cat bean-auto.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- bean 自动装配 
	1 先创建三个对象，要用其实现类
	2 添加bean属性 autowire="byType"，还有一个值 "byName"
	-->
	<bean id="userController" class="com.mio.spring6.iocxml.auto.controller.UserController" 
		autowire="byType">
		<!--  这种写法可以，但是需要一条一条写
		<property name="userService" ref="userService"></property>
		-->
	</bean>
	<bean id="userService" class="com.mio.spring6.iocxml.auto.service.UserServiceImpl"
		autowire="byType"></bean>
	<bean id="userDao" class="com.mio.spring6.iocxml.auto.dao.UserDaoImpl"></bean>
</beans>

注意: 
	若在IoC容器中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null；
	若在ioC容器中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionexception



(4) 测试
	private static void demo1() {
		//传统写法
		UserController controller=new UserController();
		controller.addUser();		
	}
	private static void demo2() {
		//使用xml自动装配
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-auto.xml");
		UserController userController=context.getBean(UserController.class);
		userController.addUser();
	}
demo2的输出:
	controller 方法执行了
	UserService 方法执行了
	userDao方法执行了


(5) 使用名称装配
新建配置文件
$ cat bean-auto2.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="        
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- bean 自动装配 
	1 先创建三个对象，要用其实现类
	2 添加bean属性 autowire="byType"，还有一个值 "byName"
	-->
	<bean id="userController" class="com.mio.spring6.iocxml.auto.controller.UserController" autowire="byName">
	</bean>
	<bean id="userService" class="com.mio.spring6.iocxml.auto.service.UserServiceImpl"
		autowire="byName"></bean>
	<bean id="userDao" class="com.mio.spring6.iocxml.auto.dao.UserDaoImpl"></bean>
	
</beans>

测试后输出同上文。
差别：使用 autowire="byName" 装配时，要求 bean的id 和 类中声明的属性 同名！













========================================
**** 基于 注解 管理 bean ****
----------------------------------------
https://www.bilibili.com/video/BV1kR4y1b7Qc/?p=38

1. 注解，是代码中的一种特殊标记
从Jdk1.5开始。
	不改变代码的方式，增加功能。
	都是@符号开始，后面是注解名字，还可能有()内的参数
Spring 2.5开始全面支持注解。

(2) Spring 通过注解实现自动装配的步骤
1) 引入依赖
2) 开启组件扫描
3) 使用注解定义bean
4) 依赖注入




2.创建子模块
(1) 右击外部项目 spring6，new- Maven Module
	勾选 skip archetype selection
	Module name: spring-first
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: spring6-ioc-annotation
	version:
	packaging: jar
Finish

右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17



3. 准备文件
(1) 子模块配置文件 pom.xml 不用修改
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.mio</groupId>
    <artifactId>spring6</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>spring6-ioc-annotation</artifactId>
</project>

主要靠父工程的依赖。


(2) 在类根目录下新建配置文件
$ cat bean-ioc-anno.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>

把之前 log4j2 配置文件复制过来:
$ cat log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<loggers>
		<root level="DEBUG">
			<!-- 定义三种输出方式，具体定义见下文  -->
			<appender-ref ref="spring6log" />
			<appender-ref ref="RollingFile" />
			<appender-ref ref="log" />
		</root>
	</loggers>

	
	<!-- 更详细的设置: https://www.cnblogs.com/LLL0617/p/16864480.html -->
	<appenders>
		<!-- 输出日志信息到控制台 -->
		<console name="spring6log" target="SYSTEM OUT">
			<!-- 控制日志输出的格式 -->
			<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss SSS} [%t] %-3level %logger{1024} - %msg%n" />
		</console>
		
		
		<!-- 输出到文件，每次log都自动清空，由append属性控制 -->
		<File name="log" fileName="G:/learngit/spring6/dustbin/test.log" append="false">
			<PatternLayout pattern="%d{HH:mm:ss SSS} %-5level %class{35} %L %M - %msg%xEx%n" />
		</File>
		
		
	    <RollingFile name="RollingFile" fileName="G:/learngit/spring6/dustbin/app.log" 
	    	filePattern="log/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz">
            <PatternLayout pattern="%d{yyyy-MM-dd 'at' HH:mm:ss z} %-5level %class{35} %L %M - %msg%xEx%n"/>
            <SizeBasedTriggeringPolicy size="50MB" />
            <!-- 设置同类型日志,同一文件夹下可以存放的数量,如果不设置此属性则默认存放7个文件 -->
            <DefaultRolloverStrategy max="20" />
        </RollingFile>
	</appenders>

</configuration>


========================================
|-- 基于注解创建 bean: @Component
----------------------------------------
4.开始写代码
创建新包 com.mio.spring6.iocannotation

(1) 引入依赖
已经在父工程中引入过。

(2) 开启组件扫描
Spring 默认是不支持注解装配bean
	需要在Spring 的xml 中配置 context:component-scan元素，开启Spring beans 的自动扫描功能。
开启后，Spring会默认扫描指定的包及其子包下的所有类，
	如果类使用了 @Component 注解，就将该类装配到容器中。

$ cat bean-ioc-anno.xml #新增命名空间3行，新增扫描方式3种
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
    	http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
    
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--1 开启组件扫描功能 -->
	<context:component-scan base-package="com.mio.spring6"></context:component-scan>
</beans>

此外，还有其他2种扫描方式，本次测试暂时不用：
	<!--2 排除扫描 某个类 -->
	<context:component-scan base-package="com.mio.spring6.iocannotation">
		<!-- type="annotation", 根据注解排除 expression 中设定的类		
			 type="assignable", 根据类型排除 expression 中设定的类 -->		
		<context:exclude-filter type="annotation" 
			expression="com.mio.spring6.iocannotation.controller.UserController"/>
		<context:exclude-filter type="assignable" 
			expression="com.mio.spring6.iocannotation.controller.UserController"/>
	</context:component-scan>
	
	<!--3 只扫描某个类 -->
	<context:component-scan base-package="com.mio.spring6.iocannotation">
		<!-- type="annotation" 根据注解包含 
		     type="assignable" 根据类型包含 -->		
		<context:include-filter type="annotation" 
			expression="com.mio.spring6.iocannotation.controller.UserController"/>
		<context:include-filter type="assignable" 
			expression="com.mio.spring6.iocannotation.controller.UserController"/>
	</context:component-scan>


(3) 使用注解定义bean
Spring提供了多个注解，可以直接加到class上，将他们定义为 Spring bean。
@Component  泛化的bean注解，仅表示这个类是一个组件(bean)，可用于应用的任何层次，如Service层、Dao层等。
@Repository  用于将数据访问层(Dao层)的类标记为bean。功能同上。
@Service  将业务层(Service层)的类标记为bean。
@Controller  将控制层(Controller层)的类标记为bean。

这4个是一样的，只是使用习惯不同。

新建子包 bean，建立User类
$ cat User.java
package com.mio.spring6.iocannotation.bean;

import org.springframework.stereotype.Component;

//等价于 <bean id="user" class="...本类名"></bean>
// 其中参数value可以省略，默认是类型首字母小写
@Component(value="user2") 
public class User {
}

测试：
package com.mio.spring6.iocannotation.bean;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestUser {
	@Test
	public void test002() {
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-ioc-anno.xml");
		User user=context.getBean("user2", User.class);
		System.out.println(user);
	}
}

输出:
	com.mio.spring6.iocannotation.bean.User@315ba14a
解释: 确实扫描了指定的包及其子包，并获取了对象。
	@Component(value="user2") 中的value就是 <bean id="user" class=""> 的id.
	context.getBean("user2") 获取对象时，也是使用该id名。

更多测试：换成其他3个注解，效果不变。
	//@Component
	//@Controller
	//@Service
	@Repository
	public class User {}



========================================
|-- 基于注解的注入: @Autowired
----------------------------------------
演示各种注入方法。
	属性注入
	set注入
	构造方法注入
	形参上注入
	只有一个构造函数，无注解
	@Autowired注解和@Qualifier注解结合


1. 使用 @Autowired 默认是按照 类型装配(byType)

(1) 查看该注解的定义

@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {

	/**
	 * Declares whether the annotated dependency is required.
	 * <p>Defaults to {@code true}.
	 */
	boolean required() default true;

}
解释：
@Target 表示该注解能用在什么地方？
	构造器，方法，参数，属性，注解类型
其中定义了一个参数required，默认是true:  boolean required() default true;
	如果注入的bean不存在，则报错。






2. 创建环境
(1)创建包 autowired，其中创建3个子包和5个文件
|-controller
	|-UserController
|-service
	|-UserService 接口
	|-UserServiceImpl 实现类
|-dao
	|-UserDao 接口
	|-UserDaoImpl 实现类

目前都是空架子，根据需要补充内容。


(2) 完成注入的步骤
1) bean对象创建
	在三个实现类上加上对应的注解: @Controller, @Service, @Repository
2) 定义相关属性，在属性上添加注解
	在Controller中声明 service 类的对象，顶上加上 @Autowired 注解
	在Service实现类中声明dao对象，顶上加上 @Autowired 注解

控制器
$ cat UserController.java
package com.mio.spring6.iocannotation.autowired.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.mio.spring6.iocannotation.autowired.service.UserService;

@Controller
public class UserController {
	//注入 service
	//方式1：属性注入
	@Autowired  //根据类型找到对应对象，完成注入
	private UserService userService;
	
	public void add() {
		System.out.println("controller...");
		userService.add();
	}
}

业务逻辑
$ cat UserService.java
package com.mio.spring6.iocannotation.autowired.service;

public interface UserService {
	public void add();
}


$ cat UserServiceImpl.java
package com.mio.spring6.iocannotation.autowired.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.mio.spring6.iocannotation.autowired.dao.UserDao;

@Service
public class UserServiceImpl implements UserService {
	//方式1：属性注入
	@Autowired  //根据类型找到对应对象，完成注入
	private UserDao userDao;

	@Override
	public void add() {
		System.out.println("service.add() ...");
		userDao.add();
	}
}

数据访问
$ cat UserDao.java
package com.mio.spring6.iocannotation.autowired.dao;

public interface UserDao {
	public void add();
}

$ cat UserDaoImpl.java
package com.mio.spring6.iocannotation.autowired.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao {
	@Override
	public void add() {
		System.out.println("dao.add() ...");
	}
}

配置文件
$ cat bean-ioc-anno2.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
    	http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
    
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--1 开启组件扫描功能 -->
	<context:component-scan base-package="com.mio.spring6.iocannotation.autowired"></context:component-scan>
</beans>


测试: 
package com.mio.spring6.iocannotation.autowired;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mio.spring6.iocannotation.autowired.controller.UserController;

public class TestUser {
	@Test
	public void test2() {
		ApplicationContext context=new 
				ClassPathXmlApplicationContext("bean-ioc-anno-autowired.xml");
		UserController userController = context.getBean(UserController.class);
		userController.add();
	}
}

输出:省略8行日志。
	controller...
	service.add() ...
	dao.add() ...

总结：
	类上通过 @Controller 等注解，声明为bean
	类的成员属性上声明为 @Autowired ，自动注入属性，不需要set方法。
	配置文件中要开启组件扫描
	使用时，加载配置文件获取IoC容器，从容器获取对象，该对象已经完成组装。








3. 其他几种注入方法
(1) 方式1：属性注入
在属性上添加 @Autowired。示例见上文。

(2) @Autowired 的set注入
- 在 UserController 类中声明类属性变量，生成其set/get方法
- 在其set方法上添加注解 @Autowired

	//方式2：set注入: 定义set方法，并在set方法上添加@Autowired注解
	private UserService userService;
	@Autowired
	public void setUserService(UserService userService) {
		this.userService = userService;
	}

UserService 类中同样操作。测试和结果不变。


(3) 构造方法上注入
- 在 UserController 类中声明类类型变量，
- 生成使用该类变量的构造函数，并加上 @Autowired注解

	//方式3：构造方法上注入
	private UserService userService;
	@Autowired
	public UserController(UserService userService) {
		//super();
		this.userService = userService;
	}

UserService 类中同样操作。测试和结果不变。


(4) 方式4: 形参上注入
就是构造函数的形参上添加注解 @Autowired。

	private UserService userService;
	public UserController(@Autowired UserService userService) {
		super();
		this.userService = userService;
	}


(5) 方式5: 只有一个有参构造函数，注解可以省略
多个有参构造时，不能省略注解。
有一个有参和一个无参构造函数时，执行无参构造函数实例化。

	private UserService userService;
	public UserController(UserService userService) {
		//super();
		this.userService = userService;
	}



(6) 方式6: @Autowired + @Qualifier 注解联合；例子见 UserRedisDaoImpl

新建类
$ cat UserRedisDaoImpl.java
package com.mio.spring6.iocannotation.autowired.dao;
import org.springframework.stereotype.Repository;
@Repository
public class UserRedisDaoImpl implements UserDao {
	@Override
	public void add() {
		System.out.println("dao redis ...");
	}
}

测试报错: expected single matching bean but found 2: userDaoImpl,userRedisDaoImpl
	有两个 UserDao 的实现类都匹配，无法确定使用哪个，所以报错。
	这个冲突说明只靠类型不能确定，需要用@Qualifier指定其id信息。
		类的实例的默认名字，是类名首字母小写。可以在类前的 @Controller 等注解的value=中指定id名。

$ cat UserServiceImpl.java
package com.mio.spring6.iocannotation.autowired.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.mio.spring6.iocannotation.autowired.dao.UserDao;

@Service
public class UserServiceImpl implements UserService {
	
	//方式6: @Autowired + @Qualifier 注解联合；
	@Autowired
	@Qualifier(value="userRedisDaoImpl")
	private UserDao userDao;

	@Override
	public void add() {
		System.out.println("service.add() ...");
		userDao.add();
	}
}
测试输出:
	controller...
	service.add() ...
	dao redis ...



========================================
|-- 基于注解的注入: @Resource 注入 （jdk扩展包中的注解）
----------------------------------------
1. @Resource 注解也能完成注入，那么它和 @Autowired 注解有何区别呢？
(1) @Resource 是jdk扩展包中的，也就是说属于 jdk 的一部分，是标准，更通用。
	JSR-250 标准中制定的注解类型。JSR是Java规范提案。

而 @Autowired 是Spring 框架自己的。


(2) @Resource 默认根据名称装配byName
	没有指定名字的，默认使用属性名(name)找同id的bean完成注入。
	通过name找不到的，自动通过类型装配byType。

@Autowired 注解默认根据类型装配 byType
	如果想根据名称装配，需要配合 @Qualifier 注解一起使用。


(3) @Resource 注解用在属性上、set方法上

@Autowired 注解用在属性上、set方法上、构造方法上、构造方法的参数上。


(4) @Resource 注解属于jdk扩展包，不在jdk当中，需要引入依赖。
	jdk8自带，不需要引入依赖。
	高于jdk11或低于jdk8需要引入依赖:

	<!-- @Resource 注解的依赖 -->
  	<dependency>
	  <groupId>jakarta.annotation</groupId>
	  <artifactId>jakarta.annotation-api</artifactId>
	  <version>2.1.1</version>
	</dependency>

我们使用的jdk17，需要引入到 父工程的 pom.xml中。




(5) 根据名称进行注入
$ cat UserServiceImpl.java
@Service
public class UserServiceImpl implements UserService {
	//根据名称进行注入
	@Resource(name = "userRedisDaoImpl2")
	private UserDao userDao;
...

其中name是bean中的id:
$ cat UserRedisDaoImpl.java
@Repository(value="userRedisDaoImpl2")
public class UserRedisDaoImpl implements UserDao {
...


(6) 根据类型注入
$ UserController.java
...

@Controller
public class UserController {
	//注入 service
//	@Resource //先按照名称byName匹配，没有名称则使用属性名字；找不到再按照类型匹配byType
//	private UserService userService;

	//根据类型注入: 没有指定名字；属性名userService3同名的bean没找到；按类型装配
	@Resource
	private UserService userService3;
	
	public void add() {
		System.out.println("controller...");
		userService3.add();
	}
}







2. 使用 @Resource 实现一遍
(1) 把上文的文件复制到新的 resource 包中
|--controller
	|--UserController
|--service
	|--UserService 接口
	|--UserServiceImpl
|--dao
	|--UserDao 接口
	|--UserDaoImpl
	|--UserRedisDaoImpl
修改引用的包，都限定在本包。


控制器




(2) 新建配置文件
$ cat bean-ioc-anno-resource.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
    	http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
    
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--1 开启组件扫描功能 -->
	<context:component-scan base-package="com.mio.spring6.iocannotation.resource"></context:component-scan>
</beans>


(3) 测试
	@Test
	public void test2() {
		ApplicationContext context=new 
				ClassPathXmlApplicationContext("bean-ioc-anno-resource.xml");
		UserController userController = context.getBean(UserController.class);
		userController.add();
	}
输出:
	controller...6
	service.add() ...3
	dao redis ...


总结:
	@Resource(name="") 注解加到 属性声明上，默认根据名字装配
	没有指定名字的，按照属性名字name装配。
	如果属性名同名的bean找不到，则按类型装配。





========================================
|-- 全注解开发：用配置类替代 xml 配置文件
----------------------------------------
1. 就是不再写 xml 配置文件，使用配置类替代

(1) 再上一节的 autowired 包中新建包 config，新建类 SpringConfig
$ cat SpringConfig.java
package com.mio.spring6.iocannotation.autowired.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration //指定这是配置类
@ComponentScan("com.mio.spring6.iocannotation.autowired") //开启组件扫描
public class SpringConfig {
}

要点:
	类前加上 @Configuration 表示这是一个配置类
	@ComponentScan() 指定扫描的包。


(2) 测试
package com.mio.spring6.iocannotation.autowired;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.mio.spring6.iocannotation.autowired.config.SpringConfig;
import com.mio.spring6.iocannotation.autowired.controller.UserController;

public class TestUser {
	@Test
	public void test1() {
		//加载配置文件
		ApplicationContext context=
				new ClassPathXmlApplicationContext("bean-ioc-anno-autowired.xml");
		UserController userController = context.getBean(UserController.class);
		userController.add();
	}
	
	@Test
	public void test2() {
		//加载配置类
		ApplicationContext context=
				new AnnotationConfigApplicationContext(SpringConfig.class);
		UserController userController = context.getBean(UserController.class);
		userController.add();		
	}
}

测试结果:
	controller...6
	service.add() ...3
	dao redis ...

要点：测试时加载 配置类。





========================================
手写 IoC: Java 反射 + 注解 实现
----------------------------------------
1. 回顾反射重点内容

java反射机制是在运行状态中，
	对于任何一个类，都能知道这个类的所有属性和方法；
	对于任意一个对象，都能够调用它的任意方法和属性；
	这种动态获取信息以及动态调用对象方法的功能称为Java 语言的反射机制。
简单说，反射机制就是程序在运行时能够获取自身的信息。





========================================
|-- 回顾 Java 的反射
----------------------------------------
1. 创建子模块
(1) 右击外部项目 spring6，new- Maven Module
	勾选 skip archetype selection
	Module name: spring6-reflect
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: spring6-reflect
	version:
	packaging: jar
Finish

右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17



2.准备文件
(1) 新建类
$ cat Car.java
package com.mio.reflect;

public class Car {
	private String name;
	private int age;
	private String color;
	//构造方法
	private Car(String name, int age, String color) {
		super();
		this.name = name;
		this.age = age;
		this.color = color;
	}
	public Car(String name, String color) {
		this(name, 0, color);
	}
	public Car() {
		super();
	}
	
	//私有方法
	private void run() {
		System.out.println("私有方法-run()");
	}
	
	@Override
	public String toString() {
		return String.format("Car[name:%s, age:%d, color:%s]", name, age, color);
	}

	//... 省略get/set方法
}


(2) 测试
1)获取class对象的常见3种方式
	@Test
	public void test01() throws ClassNotFoundException {
		//1 类名.class
		Class<Car> clazz1=Car.class;
		System.out.println(clazz1);
		
		//2 对象.getClass()
		Car car=new Car();
		Class clazz2=car.getClass();
		System.out.println(clazz2);
		
		//3 Class.forName("类的全路径")
		Class clazz3=Class.forName("com.mio.reflect.Car");
		System.out.println(clazz3);
		//class com.mio.reflect.Car		
	}


2)获取构造方法
	@SuppressWarnings({ "unchecked", "rawtypes" })
	@Test
	public void test02() throws Exception {
		Class clazz3=Class.forName("com.mio.reflect.Car");
		//注意，有两个获取构造函数的方法，差别就是是否有s结尾
		//1.获取构造函数，并实例化
		Car car=(Car)clazz3.getDeclaredConstructor().newInstance();
		System.out.println(car+"\n");

		//2.获取构造函数arr
		//getConstructors() 和 getDeclaredConstructors() 的区别: 前者只能获取public构造
		Constructor[] constructors = clazz3.getDeclaredConstructors(); //所有构造，public+private
//		Constructor[] constructors = clazz3.getConstructors(); //只能获取public构造
		System.out.println("构造方法个数:"+constructors.length);
		//遍历输出
		for(Constructor c: constructors) {
			System.out.println("构造方法:"+c.getName() + ", 参数个数:" + c.getParameterCount());
		}
		System.out.println();
		//实例化
		Car car2 =(Car) constructors[1].newInstance();
		System.out.println("2 "+car2);
		
		//3.默认使用无参构造，怎么使用有参构造？
		Constructor c1=clazz3.getConstructor(String.class, String.class);
		Car car3=(Car) c1.newInstance("宝马", "黑色");
		System.out.println("3 "+car3);
		
		//4.怎么调用 private 构造函数?
		Constructor c2=clazz3.getDeclaredConstructor(String.class, int.class, String.class);
		c2.setAccessible(true); //设置这一步才能访问私有构造，否则报错
		Car car4=(Car) c2.newInstance("比亚迪", 5, "红色");
		System.out.println("4 "+car4);
	}
	
输出:
	Car[name:null, age:0, color:null]

	构造方法个数:3
	构造方法:com.mio.reflect.Car, 参数个数:3
	构造方法:com.mio.reflect.Car, 参数个数:0
	构造方法:com.mio.reflect.Car, 参数个数:2

	2 Car[name:null, age:0, color:null]
	3 Car[name:宝马, age:0, color:黑色]
	4 Car[name:比亚迪, age:5, color:红色]


3)获取属性
	@Test
	public void test03() throws Exception {
		//获取对象
		Class clazz=Car.class;
		Car car=(Car) clazz.getDeclaredConstructor().newInstance();
		//获取所有属性
//		Field[] fields = clazz.getFields(); //获取所有的public属性
		Field[] fields = clazz.getDeclaredFields(); //获取所有的public+private 属性
		for(Field field: fields) {
			//设置属性的只
			if(field.getName().equals("name") ) {
				//设置允许访问
				field.setAccessible(true);
				field.set(car, "五菱宏光");
			}
			System.out.println(field.getName() +", \ttype:"+ field.getType());
		}
		//输出对象
		System.out.println(car);
	}

输出:
	name, 	type:class java.lang.String
	age, 	type:int
	color, 	type:class java.lang.String
	Car[name:五菱宏光, age:0, color:null]


4)获取方法
	@Test
	public void test04() throws Exception {
		//获取对象
		Car car=new Car("奔驰", "白色");
		Class clazz=car.getClass();
		
		//1.获取 public 方法
		Method[] methods = clazz.getMethods();
		for(Method method: methods) {
			System.out.println(method.getName() + ": "+method.getParameterCount());
			//执行某个方法 toString
			if(method.getName().equals("toString")) {
				String invoke=(String) method.invoke(car);
				System.out.println(" > " + invoke);
			}
		}
		System.out.println();
		
		//2.获取 private 方法
		Method[] methodsAll = clazz.getDeclaredMethods();
		for(Method method: methodsAll) {
			System.out.println(method.getName() + ": "+method.getParameterCount());
			//执行私有方法: run
			if(method.getName().equals("run")) {
				//设置许可
				method.setAccessible(true);
				String invoke=(String) method.invoke(car);
				System.out.println(" > " + invoke);
			}
		}
	}








========================================
|-- 手写IoC实现步骤
----------------------------------------
1. 创建子模块
(1) 右击外部项目 spring6，new- Maven Module
	勾选 skip archetype selection
	Module name: mio-ioc
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: mio-ioc
	version:
	packaging: jar
Finish

右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17


(2) 创建测试类 service dao
com.mio
|-service/
	|-UserService 接口
		|-impl/
			|-UserServiceImpl 实现类
|-dao/
	|-UserDao 接口
		|-impl/
			|-UserDaoImpl 实现类

业务逻辑 接口和实现
$ cat UserService.java
package com.mio.service;

public interface UserService {
	public void add();
}

$ cat UserServiceImpl.java
package com.mio.service.impl;

import com.mio.dao.UserDao;
import com.mio.service.UserService;

import mio.com.anno.Bean;
import mio.com.anno.Di;

//添加自定义注解
@Bean
public class UserServiceImpl implements UserService {
	@Di
	private UserDao userDao;
	@Override
	public void add() {
		System.out.println("service ...");
	}
}


数据操作接口和实现:
$ cat UserDao.java
package com.mio.dao;
public interface UserDao {
	public void add();
}

$ cat UserDaoImpl.java
package com.mio.dao.impl;

import com.mio.dao.UserDao;
import mio.com.anno.Bean;
@Bean
public class UserDaoImpl implements UserDao {
	@Override
	public void add() {
		System.out.println("dao ...");
	}
}





(3) 创建2个注解
@Bean 创建对象
@Di 属性注入

com.mio
|-anno/
	|-Bean
	|-Di

添加元注解：
Bean用在类上:
	运行时生效 @Retention(RetentionPolicy.RUNTIME) 
	使用位置 @Target(ElementType.TYPE)
Di用在属性上
	运行时生效 @Retention(RetentionPolicy.RUNTIME) 
	作用对象 @Target(ElementType.FIELD)

$ cat Bean.java
package mio.com.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Bean {}


$ cat Di.java
package mio.com.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Di {}




(4) 创建bean容器接口 ApplicationContext
定义方法、返回对象
com.mio
|-bean/
	|-ApplicationContext 接口，定义方法 Object getBean(Class clazz);

$ cat ApplicationContext.java
package com.mio.bean;

public interface ApplicationContext {
	Object getBean(Class clazz);
}


(5) 实现bean容器
com.mio
|-bean/
	|-AnnotatonApplicationContext 实现类
- 返回对象
- 根据包规则加载bean
	* 比如包 com.mio
	* 扫描该包及其子包的所有类，看类上面是否有@Bean注解，如果有就使用反射实例化




2. eclipse导入maven项目 pom.xml 有红叉 //todo //done;
可以删除2个空格，保存，就好了。
再加上空格，保持git不变。




========================================
|-- AnnotatonApplicationContext 类的实现: 注解+反射 实例化对象 (重要)
----------------------------------------

$ cat AnnotationApplicationContext.java
package com.mio.bean;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

import mio.com.anno.Bean;

public class AnnotationApplicationContext implements ApplicationContext {
	//1.创建map集合，放bean对象
	private Map<Class, Object> beanFactory = new HashMap<>();
	private static String rootPath; //包的根目录 

	//2.返回对象
	@Override
	public Object getBean(Class clazz) {
		return beanFactory.get(clazz);
	}
	
	//3.创建有参数构造，传递包路径，设置包扫描规则
	//设置包扫描规则: 当前包及其子包，如果有 @ Bean注解，把这个类通过反射实例化
	public AnnotationApplicationContext(String basePackage) throws Exception {
		//com.mio
		try {
			//1.把.替换成\
			String pkgPath=basePackage.replaceAll("\\.", "\\\\");
			//System.out.println(pkgPath);
			//2.获取包绝对路径，支持多个路径
			Enumeration<URL> urls =
					Thread.currentThread().getContextClassLoader()
										  .getResources(pkgPath);
			//2.2遍历输出
			while(urls.hasMoreElements()) {
				URL url=urls.nextElement();
				//System.out.println(url);//有乱码: %5c字符
				//为了防止乱码
				String filePath=URLDecoder.decode(url.getFile(), "utf-8");
				//System.out.println(filePath);
				//获取包前面的路径部分，字符串截取
				rootPath=filePath.substring(0, filePath.length() - pkgPath.length());
				
				//3.扫描包，使用函数实现
				loadBean(new File(filePath));
			}
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	
	//扫描包的过程，实例化
	private void loadBean(File file) throws Exception {
		//1 判断当前内容是否是文件夹
		if(file.isDirectory()) {
			//2 如果是，获取文件夹内的所有内容
			File[] childrenFiles = file.listFiles();
			//3 如果文件夹为空，直接返回
			if(childrenFiles==null || childrenFiles.length==0) {
				return;
			}
			//4 如果文件夹不为空，遍历文件夹所有内容
			for(File child: childrenFiles) {
				//4.1 遍历每个File对象，继续判断，如果还是文件夹，递归
				if(child.isDirectory()) {
					loadBean(child);
				}else {
					//4.2 遍历得到File对象是文件，则继续
					//4.3 得到包路径 + 类名称部分：字符串截取
					String pathWithClass = child.getAbsolutePath()
								.substring(rootPath.length()-1);
					//4.4 判断当前文件类型是否是.class
					if(pathWithClass.endsWith(".class")) {
						//4.5 如果是 .class类型，把路径\替换成.，把.class去掉 
						// com.mio.service.UserServiceImpl.class
						String fullName=pathWithClass.substring(0, pathWithClass.length()-6);
						fullName=fullName.replaceAll("\\\\", "\\.");
						
						//4.6 判断类上是否有 @ Bean注解，如果有，则实例化
						//4.6.1 获取class
						Class<?> clazz=Class.forName(fullName);
						//4.6.2 不是接口，才实例化
						//if(clazz.toString().startsWith("class")) {
						if(!clazz.isInterface()) {
							//4.6.3 判断是否有注解
							Bean annotation = clazz.getAnnotation(Bean.class);
							//System.out.println( "\t"+ clazz.toString()+"\t"+annotation );
							if(annotation != null) {
								//4.6.4 实例化
								Object instance = clazz.getConstructor().newInstance();
								
								
								//4.7 实例化后的对象，放到map集合 beanFactory
								//有接口，则接口作为key；没有接口，则类名作为key
								//4.7.1 判断当前类是否有接口
								//System.out.println("\t" + instance+"\t"+clazz.getInterfaces()[0] );
								//System.out.println("\t" + instance+"|\t"+clazz );
								if( clazz.getInterfaces().length>0 ) {
									beanFactory.put(clazz.getInterfaces()[0], instance);
								}else {
									beanFactory.put(clazz, instance);
								}
							}
						}
					}
				}
			}
		}
	}

	//测试: 写代码时测试
	public static void main2(String[] args) throws Exception {
//		ApplicationContext context=
//				new AnnotationApplicationContext("com.mio.bean.xml");
		AnnotationApplicationContext app=
				new AnnotationApplicationContext("com.mio");
		System.out.println(app);
	}
}



(6) 测试
$ cat TestUser.java
package com.mio;

import org.junit.jupiter.api.Test;

import com.mio.bean.AnnotationApplicationContext;
import com.mio.bean.ApplicationContext;
import com.mio.service.UserService;

public class TestUser {
	@Test
	public void test01() throws Exception {
		ApplicationContext context=
				new AnnotationApplicationContext("com.mio");
		UserService userService = (UserService) context.getBean(UserService.class);
		userService.add();
		System.out.println(userService);
	}

}

输出:
	service ...
	com.mio.service.impl.UserServiceImpl@646007f4






========================================
|-- 实现注入功能: @Di 注解 的功能实现
----------------------------------------
0. 回顾方法

$ cat UserServiceImpl.java
package com.mio.service.impl;

import com.mio.dao.UserDao;
import com.mio.service.UserService;

import mio.com.anno.Bean;
import mio.com.anno.Di;

//添加自定义注解
@Bean
public class UserServiceImpl implements UserService {
	@Di
	private UserDao userDao;

	@Override
	public void add() {
		System.out.println("service ...");
		userDao.add(); //调用方法
	}

}

其中，私有属性 userDao 上有注解@Di。本文手写首先该属性值的注入。




1.有参构造函数中，添加方法

public class AnnotationApplicationContext implements ApplicationContext {
	public AnnotationApplicationContext(String basePackage) throws Exception {
	...
		//属性注入
		loadDi();
	}
	...
}



2. 在该类中实现该方法
	
	//实现属性注入
	private void loadDi() {
		//实例化的对象，都在 beanFactory 的Map结合中
		//1 遍历 beanFactory 的 map 集合
		Set<Entry<Class, Object>> entries = beanFactory.entrySet();
		for(Entry<Class, Object> entry: entries) {
			//2 获取 map 集合每个对象(value)
			Object obj = entry.getValue();
			
			//获取对象 Class
			Class<? extends Object> clazz = obj.getClass();
			//获取属性
			Field[] declaredFields = clazz.getDeclaredFields();
			//3 遍历每个属性数组，得到每个属性
			for(Field field: declaredFields) {
				//4 检查属性上是否有@ Di 注解
				Di annotation=field.getAnnotation(Di.class);
				if(annotation != null) {
					// 如果有私有属性，设置可设置
					field.setAccessible(true);
					//5 有注解的，设置对象（注入）
					try {
						//要注入的对象：2种获取方式
						//System.out.println("\t"+ this.getBean(field.getType() ) );
						//System.out.println("\t"+ beanFactory.get(field.getType()) );
						// 第二个参数是注入的对象
						field.set(obj, beanFactory.get(field.getType()));
					} catch (IllegalArgumentException | IllegalAccessException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}



3. 测试
	@Test
	public void test01() throws Exception {
		ApplicationContext context=
				new AnnotationApplicationContext("com.mio");
		UserService userService = (UserService) context.getBean(UserService.class);
		userService.add();
		System.out.println(userService);
	}

输出:
	service ...
	dao ...
	com.mio.service.impl.UserServiceImpl@545997b1


说明 属性注入成功。




========================================
**** AOP 面向切面编程 ****
----------------------------------------
示例代码框架。


1. 创建子模块
(1) 右击外部项目 spring6，new- Maven Module
	勾选 skip archetype selection
	Module name: spring6-aop
	父项目: spring6

Artifact:
	group id: com.mio
	artifact id: spring6-aop
	version:
	packaging: jar
Finish

右击子模块，build path - config - Library 
	把jre环境设置为 本地安装的 jdk17



2.文件结构
(1) 新建包，新建类
|-Calculator 接口
|-CalculatorImpl 基本实现类
|-CalculatorLogImpl 带日志的实现类

接口
$ cat Calculator.java
package com.mio.spring6.aop.example;

public interface Calculator {
	int add(int i, int j);
	int sub(int i, int j);
	int mul(int i, int j);
	int div(int i, int j);
}

基本实现
$ cat CalculatorImpl.java
package com.mio.spring6.aop.example;
//基本实现类
public class CalculatorImpl implements Calculator {

	@Override
	public int add(int i, int j) {
		int result=i+j;
		System.out.println("方法内结果 add result="+result);
		return result;
	}
...

带日志的实现
$ cat CalculatorLogImpl.java
package com.mio.spring6.aop.example;
//带日志功能的实现类
public class CalculatorLogImpl implements Calculator {

	@Override
	public int add(int i, int j) {
		System.out.println("[日志] add 方法开始了，参数是: "+i+", "+j);
		int result=i+j;
		System.out.println("方法内结果 add result="+result);
		System.out.println("[日志] add 方法结束了，参数是: "+i+", "+j);
		return result;
	}
...

分析: 以上问题的缺点是，日志和核心功能混合写了。日志代码是重复的。

目标: 把业务逻辑和日志的代码分开。
实现方法：代理模式。





========================================
|-- 代理模式：静态代理、动态代理
----------------------------------------
1. 代理模式的概念
目的：解耦。
代理：我们直接和代理交互。
目标：代理和目标直接交互。

代理相当于中介，
	我们和明星之间有经纪人
	租客和房东之间，有中介。



2. 静态代理
|-接口
	|-实现类
	|-代理类

(1) 新建类
$ cat CalculatorStaticProxy.java
package com.mio.spring6.aop.example;

public class CalculatorStaticProxy implements Calculator {
	//被代理对象
	private Calculator calculator;
	//通过构造传入该参数
	public CalculatorStaticProxy(Calculator calculator) {
//		super();
		this.calculator = calculator;
	}

	@Override
	public int add(int i, int j) {
		//输出日志1
		System.out.println("[日志] add 方法开始了，参数是: "+i+", "+j);
		
		//调用目标对象的方法实现核心业务
		int result=calculator.add(i, j);
		
		//输出日志2
		System.out.println("[日志] add 方法结束了，结果是: "+result);
		return result;
	}
...


(2) 测试

	@Test
	public void test03() {
		Calculator calc=new CalculatorImpl();
		Calculator calcProxy=new CalculatorStaticProxy(calc);
		calcProxy.add(200, 300);
	}

输出:
	[日志] add 方法开始了，参数是: 200, 300
	方法内结果 add result=500
	[日志] add 方法结束了，结果是: 500

优点：确实解耦了
缺点：日志还是重复操作，还是写到代码中。
	其他代理还需要新建 代理类，每个接口新建一个代理类。





3. 动态代理
Spring 就是动态代理。
所有的类只需要一个代理类。做到了真正的解耦。

警告：动态代理也要求目标对象实现一个接口，否则报错。
	怎么做无接口的类的动态代理呢？//todo
		不能！JDK的动态代理必须有接口。
		https://www.cnblogs.com/WeidLang/p/9857495.html


(1) 用到的技术
java lang 包的 Proxy 类。
Java8 API文档的示例代码:

Proxy 提供静态方法来创建动态代理类和示例，是所有动态代理类的父类。
Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. 
创建Foo接口的代理:
To create a proxy for some interface Foo: 

     InvocationHandler handler = new MyInvocationHandler(...);
     Class<?> proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);
     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).
                     newInstance(handler);

or more simply: 
     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                          new Class<?>[] { Foo.class },
                                          handler);
方法部分：提供三个参数
	class loader 类加载器
	接口
	召唤类
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 
Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler. 

召唤类中有一个方法 invoke，需要三个参数：
	代理类
	方法
	参数
Object invoke(Object proxy, Method method, Object[] args) 
Processes a method invocation on a proxy instance and returns the result. 



(2) 新建动态代理工厂类
类内部新建属性，通过构造传入目标对象，
	有个get方法返回该对象的代理。
		该方法中，动态创建代理类
		在执行目标方法的前后可以添加日志方法，也就是实现了日志的统一管理。

动态代理 写法值得反复学习，不过记不住也没事，高频使用，但是很少手写其实现。
$ cat ProxyFactory.java
package com.mio.spring6.aop.example;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

//动态代理
public class ProxyFactory {
	//目标对象
	private Object target;
	//通过构造传入目标对象
	public ProxyFactory(Object target) {
//		super();
		this.target = target;
	}

	//返回代理对象：同时在方法执行前后添加日志
	public Object getProxy() {
		/* Proxy.newProxyInstance() 的三个参数
		 * ClassLoader loader, 加载动态生成代理类的类加载器
		 * Class<?>[] interfaces, 目标对象实现的所有接口的class类型数组
		 * InvocationHandler h 代理对象调用目标对象方法的过程
		 * */
		ClassLoader classLoader=target.getClass().getClassLoader();
		Class<?>[] interfaces = target.getClass().getInterfaces();
		//参数3有多种写法，这里使用匿名类
		InvocationHandler invocationHandler = new InvocationHandler() {
			/* invoke()方法的三个参数
			 * Object proxy, 代理对象
			 * Method method, 需要重写目标对象的方法
			 * Object[] args 就是method方法的参数
			 * */
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				//方法调用前 日志
				System.out.println("[动态代理日志] "+method.getName()+" 方法开始了，参数是: "+Arrays.toString(args));
				
				//调用目标类的方法，这俩只是同名，并不一样。
				Object result = method.invoke(target, args);
				
				//方法调用后 日志
				System.out.println("[动态代理日志] "+method.getName()+" 方法结束了，结果是: "+result);
				
				return result;
			}
		};
		return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
	}
}



(3)测试
使用以上计算器测试，
使用自定义内部类测试。
 
	@Test
	public void test04() {
		//动态代理
		//1 创建目标对象
		Calculator calc=new CalculatorImpl();
		//2 通过动态代理 获取代理类
		ProxyFactory proxyFactory = new ProxyFactory(calc);
		Calculator proxy = (Calculator) proxyFactory.getProxy();
		//3 调用目标方法
		proxy.mul(5, 25);
		System.out.println();
		
		
		//注意: 动态代理 目标类要实现接口，否则无法创建动态代理
		//4 another test: 通过动态代理获取其代理 
//		Book book = new BookImpl("Java 宝典");
//		ProxyFactory proxyFactory2 = new ProxyFactory(book);
//		Book proxy2 = (Book) proxyFactory2.getProxy();
		
		//对方法中的 内部类 动态代理
		interface Book {
			public void run();
		}
		
		class BookImpl implements Book {
			private String name;
			public BookImpl(String name) {
				this.name=name;
			}
			public void run() {
				System.out.println("Book.run()..."+name);
			}
		}
		
		//System.out.println(proxy2);
		//简写为一行
		Book proxy2=(Book) new ProxyFactory(new BookImpl("Java 宝典3")).getProxy();
		proxy2.run();
	}


输出:
	[动态代理日志] mul 方法开始了，参数是: [5, 25]
	方法内结果 mul result=125
	[动态代理日志] mul 方法结束了，结果是: 125

	[动态代理日志] run 方法开始了，参数是: null
	Book.run()...Java 宝典3
	[动态代理日志] run 方法结束了，结果是: null











========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------
