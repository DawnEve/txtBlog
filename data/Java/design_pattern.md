# 23种设计模式 design_pattern

[Java设计模式：23种设计模式全面解析](http://c.biancheng.net/design_pattern/)、 [23种设计模式通俗理解](https://www.cnblogs.com/pnljs/p/3169292.html)

- 数据结构和算法，构成了程序的基础。
- 而设计模式，则是构建大型程序必备的知识储备。


设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。


这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。

当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：
- 对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；
- 但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。


关于本教程
本教程虽然命名为“Java设计模式”，但是设计模式并不是 Java 的专利，它同样适用于 C++、C#、JavaScript 等其它面向对象的编程语言。

Java 是典型的面向对象的编程语言，所以本教程以 Java 为基础来讲解这 23 种设计模式，如果你不了解 Java，请猛击[《Java教程》](http://c.biancheng.net/java/)学习。







## GoF 的 23 种设计模式的分类和功能
设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。

**1.根据目的来分**
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。
1. 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
2. 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
3. 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。


**2.根据作用范围来分**
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。
1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。


表1 GoF 的 23 种设计模式的分类表

|范围\目的	|创建型模式(5)	|结构型模式(7)	|行为型模式(11)|
| ------------- |:-------------:| -----:|
|类模式(4)	|工厂方法	|(类）适配器	|模板方法、解释器|
|对象模式(19)	|单例/原型/抽象工厂/建造者	|代理/ (对象)适配器/<br>桥接/装饰/外观/享元/组合	|策略/命令/职责链/状态/<br>观察者/中介者/迭代器/<br>访问者/备忘录|




**3.GoF的23种设计模式的功能**
前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
1. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
1. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
1. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
1. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
1. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
1. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
1. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
1. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
1. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
1. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
1. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
1. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
1. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
1. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
1. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
1. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
1. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
1. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
1. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
1. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
1. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式，希望读者认真学好它们。






## UML中的类图及类图之间的关系

统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。

UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。

本教程主要介绍软件设计模式中经常用到的类图，以及类之间的关系。另外，在实验部分将简单介绍 UML 建模工具的使用方法，当前业界使用最广泛的是 Rational Rose。使用 [Umlet](https://www.umlet.com/) 的人也很多，它是一个轻量级的开源 UML 建模工具，简单实用，常用于小型软件系统的开发与设计。


详情： http://c.biancheng.net/view/1319.html


**类、接口和类图**

1. 类 Class
类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。
在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。
- 类名（Name）是一个字符串，例如，Student。
- 属性（Attribute）是指类的特性，即类的成员变量。UML 格式表示：[可见性]属性名:类型[=默认值] 例如：-name:String
- 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 格式表示：[可见性]名称(参数列表)[:返回类型] 例如：+display():void。

“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。


2. 接口 Interface

接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。
在 UML 中，接口使用一个带有名称的小圆圈来进行表示。


3. 类图
类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。



**类之间的关系**
在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。

1. 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。
2. 关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。
3. 聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。
4. 组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。
5. 泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。
6. 实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。











## 面向对象设计的SOLID原则

在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。

众所周知，Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计，S.O.L.I.D是面向对象设计和编程(OOD&OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。
```
SRP	The Single Responsibility Principle 单一责任原则
OCP	The Open Closed Principle 开放封闭原则
LSP	The Liskov Substitution Principle	里氏替换原则
DIP	The Dependency Inversion Principle	依赖倒置原则
ISP	The Interface Segregation Principle	接口分离原则

SRP	单一职责原则	一个类有且只有一个更改的原因。
OCP	开闭原则	能够不更改类而扩展类的行为。
LSP	里氏替换原则	派生类可以替换基类被使用。
ISP	接口隔离原则	使用客户端特定的细粒度接口。
DIP	依赖反转原则	依赖抽象而不是具体实现。
```
我想SOLID原则是你的工具箱里很有价值的工具。在设计下一个功能或者应用时他们就应该在你的脑海中。而且，将这些原则应用在项目中。

除SOLID原则外还有很多其它的面向对象原则。如：
```
"组合替代继承":这是说"相对于继承，要更倾向于使用组合"；
"笛米特法则"：这是说"你的类对其它类知道的越少越好"；
"共同封闭原则"：这是说"相关类应该打包在一起"；
"稳定抽象原则"：这是说"类越稳定，越应该由抽象类组成";
```


[Steve Smith](http://stevesmithblog.com/)在5月份的微软TechED 2009上有个[SOLIDify Your ASP.NET MVC](http://stevesmithblog.com/blog/teched-2009-session-aftermath/)的讲座, [derick.bailey](http://www.lostechies.com/members/derick.bailey/default.aspx)的[SOLID Development Principles – In Motivational Pictures](http://www.lostechies.com/blogs/derickbailey/archive/2009/02/11/solid-development-principles-in-motivational-pictures.aspx)很好的解释了SOLID原则。




`单一责任原则（SRP）`
当需要修改某个类的时候原因有且只有一个（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 

我们通常都说“低耦合，高内聚”。在我看来，这里的"单一职责"就是我们通常所说的“高内聚”，即一个类只完成它应该完成的职责。

 

 
`开放封闭原则/开闭原则（OCP）`
软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。

曾经在网上看到过这样一句话“哪里变化，封装哪里”。这其实就是说，我们要将系统中可能变化的地方封装起来，即对修改封闭。同时，为了应对系统需求（功能）的扩展，需要抽象！

这里抽象是关键。《设计模式》中的state模式和strategy模式是这个原则的最好体现。

即"面向接口编程，不要面向实现编程"！




`里氏替换原则（LSP）`
当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。
“只有在确定是 is-a 的关系时才能使用继承”。

里氏替换原则(Liskov Substitution Principle,LSP)适用于继承层次结构，指出设计类时客户端依赖的父类可以被子类替代，而客户端无须了解这个变化。

为什么LSP如此重要？
	- 如果没有LSP，类继承就会混乱；如果子类作为一个参数传递给方法，将会出现未知行为；
	- 如果没有LSP，适用与基类的单元测试将不能成功用于测试子类； 




`依赖倒置原则（DIP）`
1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 
2. 抽象不应该依赖于细节，细节应该依赖于抽象 

其实又是“面向接口编程，不要面向实现编程”的内在要求。




`接口分离原则（ISP）`
“不能强迫用户去依赖那些他们不使用的接口”。换句话说，使用多个专门的接口比使用单一的总接口总要好。

也就是说，一个接口或者类应该拥有尽可能少的行为（那么，什么叫尽可能少？就是少到恰好能完成它自身的职责），这也是保证“软件系统模块的粒度尽可能少，以达到高度可重用的目的。

接口隔离原则(Interface Segregation Principle)指出客户不应该被强迫依赖于他们不使用的接口。当我们使用非内聚的接口时，ISP指导我们创建多个较小的内聚度高的接口。

如果一个接口包含了过多的方法，应该通过分离接口将其拆分。

接口分离原则确保实现的接口有它们共同的职责,它们是明确的,易理解的,可复用的.





又及，还有两个常被提到的原则：

`六、合成复用原则（CRP）`

合成复用原则（Composite Reuse Principle,CRP），即优先使用委托而不是继承来重用已用功能（代码）。循序这一原则通常也是避免触犯里氏替换原则所要求的。




`七、迪米特法则（LoD / LKP）`

迪米特法则（Law Of  Demeter）又称最小知识原则（Least Knowledge Principle, LKP）。意思是一个对象应当对其它对象有尽量好的了解，即应该保持对象间有尽量少的相互作用是，使得对象（类）具有好的独立性，可测试性，也就易于维护。

关于“迪米特法则”的其它表述还有：只与你的朋友们通信，不要与“陌生人”说话。

设计模式中的Facade模式和Mediator模式就是使用了这一原则，降低模块间的耦合。


这几条原则是非常基础而且重要的面向对象设计原则。正是由于这些原则的基础性，理解、融汇贯通这些原则需要不少的经验和知识的积累。


> 当然，这些原则并不是孤立存在的，而是紧密联系的，遵循一个原则的同时也就遵循了另外一个或多个原则；反之，违反了其中一个原则也很可能同时就违反了另外一个或多个原则。 设计模式是这些原则在一些特定场景的应用结果。因此，可以把设计模式看作"框架"，把OOD原则看作"规范"。 在学习设计模式的过程中，我们要经常性的反思，这个设计模式体现了面向对象设计原则中的哪个或哪一些原则。


特别是在重构实现模式，或重构趋向模式的过程中，我们更要结合SOLID原则思考代码在重构前后的区别，理解它的改进。我正在研读《重构与模式》一书，因此接下来我会结合例子记录自己的学习体会。

```
可靠性，健壮性，可扩展性，可重用性！这四点是软件四大支柱，所以写代码的时候一定要注意这几点。
- 可靠性：代表你写的代码是可靠的，不会出现Exception；
- 健壮性：代表你程序的容错机制不错；
- 可扩展性：代表，适当的业务修改是可以快速完成的，不需要大量修改；
- 可重用性：相信知道继承的同学都知道可重用性，对于相同的业务逻辑要进行封装，不要重复书写，这点和函数作用类似。。。
```


**refer**
- http://www.importnew.com/10656.html
- http://www.tuicool.com/articles/MRrmqyM
- http://www.cnblogs.com/lanxuezaipiao/archive/2013/06/09/3128665.html
- http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html
- 设计图 UML图 http://blog.csdn.net/e5max/article/details/8872182









## 创建型模式
特点和分类 http://c.biancheng.net/view/1335.html

创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。

创建型模式分为以下几种。
- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。




### 单例模式

http://c.biancheng.net/view/1338.html





