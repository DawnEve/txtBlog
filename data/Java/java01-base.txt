java SE入门到精通


All my code: https://github.com/DawnEve/learngit/tree/master/Java
https://www.runoob.com/java/number-pow.html
廖雪峰 Java 教程: https://www.liaoxuefeng.com/wiki/1252599548343744


一天精通: https://www.cnblogs.com/happyframework/p/3332243.html
Java 基础： https://github.com/ZhongFuCheng3y/athena


基本语法
面向对象 
集合
文件操作
多线程 
Lambda 表达式 & StreamAPI 
MySQL 数据库核心技术
JDBC 规范与实现

综合: EMS 管理系统/银行管理系统

目标: 夯实语法内功，熟悉各种核心类库，深入理解面向对象思想。










========================================
Java 基础(30天入门)：Java 11
----------------------------------------

1. java中常用的几个包介绍
包名	说明
java.lang	该包提供了Java编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread等，不使用该包就很难编写Java代码了。

java.util	该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。

java.io	该包通过文件系统、数据流和序列化提供系统的输入与输出。
java.net	该包提供实现网络应用与开发的类。
java.sql	该包提供了使用Java语言访问并处理存储在数据源（通常是一个关系型数据库）中的数据API。

java.awt
javax.swing
这两个包提供了GUI设计与开发的类。java.awt包提供了创建界面和绘制图形图像的所有类，而javax.swing包提供了一组“轻量级”的组件，尽量让这些组件在所有平台上的工作方式相同。

java.text	提供了与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。



(1) 知识层面 https://mikechen.cc/17129.html

1)基础:
	编程基础
	面向对象OOP
	Java集合
	注解
	异常处理
	输入/输出

2) 高级特性：
	IO流
	枚举和注解
	集合
	泛型
	常用类：字符串、日期、随机数
	
	多线程
	并发编程
	反射机制
	网络编程
	
	Lambda表达式和Stream API的使用
	Java9 & Java11

3) 数据结构和算法：有经验后再继续
	数据结构
	算法
	设计模式：经典的23种
	JVM: Java虚拟机，底层

4) Java 框架
	Spring
	Spring MVC
	Spring Boot
	Spring Cloud
	Mybatis
	Redis
	RoketMQ等

5) 开发工具
	web 调试工具
	集成开发工具 Eclipse
	版本控制工具 Git
	构建工具 Maven
	Java 调试工具

6) 架构技术
	微服务
	中间件
	分布式架构
	容器部署



(2) 把个人融入到集体的发展中
学习的百分比:
	工作中学到 70%
	向他人学习 20%
	自我学习 10%


(3) 学习方法
- 保证听得懂：一天保证三个小时，并提高效率，要思考。
- 要敲三遍，运行: 必须手动，脑子和手是不同步的；知识？技能？骑自行车。
	代码量上来，就熟练了。
	三分看，七分练
- 整理笔记，模仿好的编码习惯/工具：模仿到走





2. 基础 

基础资料 https://www.w3schools.com/java/java_switch.asp
官方基础资料 https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html
官方API: https://docs.oracle.com/javase/8/docs/api/

学习方法: 
	视频讲解 https://www.bilibili.com/video/BV1Kb411W75N/
	看教程 https://www.weixueyuan.net/view/6316.html
	写代码 把 learngit 中的 重写一遍，不漏掉注释


大纲
	共有: 关键字、数据类型、运算符、流程控制、数组
	OOP(重点): 类/对象，类的结构，三大特性（封装、继承、多态），接口，设计模式, 异常处理
	app开发: 集合,IO/NIO, 类库，多线程，反射，网络，JDBC->Oracle/MySql;
	新特性: 泛型，元注解，装箱-拆箱，枚举，可变参数，Lambda表达式，Stream API，Date/Time API
	三个项目: 家庭记账系统，客户信息管理系统，开发团队人员调度软件；
	附加项目：银行业务管理系统，单机考试管理系统



Java程序由package+class组成，package对应目录的相对路径，class对应文件




========================================
|-- Java历史、环境、hello world、注释、API文档
----------------------------------------
1. Dos 命令: 对应的 linux 命令
dir: ls
cd:
md: mkdir
echo: : echo age=12;name=xiaoming>a1.txt 
exit:
del: rm 删除文件
rd: rmdir 删除目录
	rd dirName1 只能删除空目录
	del dirName2 递归删除文件，然后再 rd dirName2

.. 上一级目录
. 本级目录

换盘符: 直接输入盘符 D: 回车。


2. Java 历史
常用的 1.6-1.8之间。

Java 是类C语言
	舍弃了 C的指针：
	自动 GC 垃圾回收：Java会出现内存泄漏和内存溢出问题吗？会。
	JVM：Java 虚拟机

特点
	OOP: 类/对象的概念，三大特征：封装、继承、多态
	健壮性：指针、垃圾回收 容易出问题，Java有优化
	跨平台: JVM 实现本身不是跨平台的


3. 环境
(1) Java
JDK =  JRE + 开发工具集(如 Javac 编译工具)
JRE = JVM + JavaSE 标准类库

https://www.oracle.com/cn/java/technologies/downloads/archive/
https://www.oracle.com/cn/java/technologies/javase/javase8u211-later-archive-downloads.html
https://www.oracle.com/cn/java/technologies/javase/javase8u211-later-archive-downloads.html#license-lightbox

安装时的目录：英文、不能有空格。

JDK8 有部分协议变了：
jdk/下的目录：
	bin/ 工具目录, java, javac, javadoc
	db/ 数据库 ...
	include/ *.h C库
	jre/ 运行环境
	lib/ *.jar包
	src.zip 开源代码


设置环境变量：cmd进入jdk的bin目录执行；想在任何地方执行，需要设置环境变量。
	admin 对当前用户有效；系统变量 对所有人有效（推荐）；设置哪个都行，要坚持一个。
	path: windows 执行命令时的搜索顺序，先在当前路径找，然后在path中找。
		JAVA_HOME=D:\xx\jdk8_x\
		path: %JAVA_HOME%\bin\
		这么搞是因为tomcat需要变量 JAVA_HOME
	测试: java, javac
	可以安装几个版本，使用时看配置的是什么就用的什么。


C:\Users\admin>java -version
java version "1.8.0_161"

需要显示后缀。


(2) IDE
https://www.eclipse.org/downloads/
https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2022-12/R/eclipse-inst-jre-win64.exe






4. Hello world 
(1) 编写源文件：记事本新建文件 Hello.java
public class Hello{
	public static void main(String[] args){
		System.out.print("hello, world!!!");
	}
}

(2) 编译文件 (javac xx.java)
我的电脑-找到桌面-地址栏输入 cmd 回车，自动在当前了路径（桌面）打开cmd工具。

> javac Hello.java
没有报错，就是编译成功。
查看桌面，发现多了 Hello.class 文件。


(3) 解释运行 字节码文件(java xx) 
D:\Desktop>java Hello
hello, world!!!


(4) 注意
Java是大小写敏感的！但是windows不区分大小写，所以大小写写错不报错。
	而linux 是区分大小写的。
文件找不到，可能路径错误，文件名错误。

一个文件可以有多个类。
	编译后一个类对应一个class文件，字节码文件和类名一样。
但是一个文件只有有一个public类
	这时文件名要和 public 类同名。

入口文件是 main，是固定的。







5. 注释
Java的三种注释
	单行注释 //
	多行注释 /*   */，多行注释 不能嵌套使用。
	文档注释(Java 特有) /**   */

(1) 文档注释实例
文件 Hello.java 内容，保持ansi格式，否则中文报错。
/**
文档注释实例for class
@author 张三的老板
*/
public class Hello{
	/**
	文档注释 for main 方法
	@author 张三
	@version v0.2	
	*/
	public static void main(String[] args){
		System.out.print("hello, world!!!");
	}
}

编译
D:\Desktop\hi>javadoc -d docs -author -version Hello.java
D:\Desktop\hi

打开其中的 \hi\docs\index.html 文件，可见
类的注释，在最顶部。
方法的注释，在 方法概要 表格中。




6. Java API 文档
https://docs.oracle.com/javase/8/docs/

教程
https://docs.oracle.com/javase/tutorial/
Getting Started — An introduction to Java technology and lessons on installing Java development software and using it to create a simple program.
Learning the Java Language — Lessons describing the essential concepts and features of the Java Programming Language.
Essential Java Classes — Lessons on exceptions, basic input/output, concurrency, regular expressions, and the platform environment.
Collections — Lessons on using and extending the Java Collections Framework.
Date-Time APIs — How to use the java.time pages to write date and time code.
Deployment — How to package applications and applets using JAR files, and deploy them using Java Web Start and Java Plug-in.
Preparation for Java Programming Language Certification — List of available training and tutorial resources.


下载
https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html
使用方法：点击右侧的 Java SE API，可以打开熟悉的帮助页面。
左侧找到 java.lang 包，类选择 String，右侧就可以看到帮助文档。





7. 常用的编辑器
文本编辑器
	记事本
	UltraEdit
	EditPlus

IDE:
	JBuilder 历史
	NetBeans 历史
	Eclipse: IBM 开发的，免费的
	myEclipse: 收费版，集成了插件
	IDEA: 最新的，很流行，设计更人性化，功能和 Eclipse 相同





ref: https://www.bilibili.com/video/BV1Kb411W75N/?p=18
2023.3.12 19,20, 21-26, 27 概述,28,29-30安装环境, 31-32设置环境变量。
	33-34 hello world; 35 EditPlus编辑器; 37 文档注释；39 Java API 文档
	41.编码风格，IDE。42考试; 43-44复习;




========================================
|-- Java 语言基础: 关键字/保留字/标识符、数据类型、运算符、流程控制
----------------------------------------
1. 关键字、保留字
类、流程控制、数据类型等。
异常处理

保留字：以后可能会用的: goto, const

注意：Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。

(2) 标识符规则，就是变量名、类名、方法名、接口名等，自己能起名字的地方
1) 规则：不遵守报错
26个字母大小写、数字、下划线、$符，不能有空格: class Dog_${}
开头不能是数字。
不能使用关键字，但是可以包含关键字: int static1=3;
严格区分大小写，长度无限制

2) 规范，就是习惯。不遵守影响别人阅读
包名：小写，多个单词小写 xxyy
类名: 单词首字母大写: XxYy, class Cat{}
变量名、方法名：单词首字母大写，第一个单词首字母小写: xxYy, myCat, charAt(); 
常量名：所有字母都大写、多单词时每个单词用下划线连接 XX_YY, MY_PI=3.14

要见名知意。
谨慎使用单字母变量。

变量名可以用中文，但是会被鄙视。

(3). 变量
变量的概念：
	内存中的一个存储区域；
	该区域有自己的名称（变量名）和类型（数据类型）；
	该区域的数据可以在同一类型范围内不断变化；

Java是强类型语言，声明变量时必须明确类型。 数据类型 变量名 = 初始化值；
1) 声明变量
int myAge=12;
类型 变量名=变量值;

2) 作用域内有效
局部代码块：{}范围的东西外面找不到！！




2. 数据类型
8种原子类型
小数类型的常量默认是double类型，声明float类型的常量需要使用F作为后缀。

	整数类型：byte、short、int和long。
	小数类型：float和double。
	字符类型：char。
	布尔类型：bool。
	除此之外的是interface、class和array。


基本数据类型 primitive type
	数值: 整数(byte, short, int, long), 浮点数(float, double)
	字符(char)
	布尔(boolean)
引用数据类型 reference type
	类 class: 字符串是一个String 类，是引用类型。
	接口 interface
	数组[]


(1) 整型
类型  占用存储空间   表示范围
byte 1字节=8bit位    -128~127: -2^7~2^7-1
short 2字节         -2^15 ~ 2^15-1
int 4字节         -2^31 ~ 2^31-1
long 8字节         -2^63 ~ 2^63-1

byte b1=128; //编译报错 错误: 不兼容的类型: 从int转换到byte可能会有损失
long L2=1234567895L; //long的结尾必须有一个大写或小写的L结尾，不加会怎样？


(2) 浮点数
单精度 float  4  -3.403E38~3.403E28 
双精度 double 8   -1.798E308~1.798E308

float 占4个字节，但是比long表达的范围大。缺点是小数点后的不精确。


float b3=12.5; //错误: 不兼容的类型: 从double转换到float可能会有损失
float b3=12.5f; //末尾要加F或f


(3) 字符类型 char 
一个字符占用2个字节。
声明时使用单引号。只能有一个字符。
char c1='c';

转义字符 \n 表示换行; \t 制表符(tab键); 
char c2='\n'; 

或者使用 unicode 值表示字符 '\uXXXX'
char c3='\u0123'; //表示问号，可能是无法输出。
char c3='\u0043'; //表示大写C

字符集 
基本的 ascii，只有中文。
后来放大的 unicode，最后的实现是 UTF-8

cmd 命令行默认是 gbk 格式。
如果保存的文件不是 gbk，则可能报错。
各字符集中的 ascii 部分是一致的，其余差异很大。


(4) 布尔型
判断时，循环中使用。
boolean b2=true;


(5) 七种数据类型的互相运算(除了 布尔 外的7种)
- 自动类型提升
    1) byte,short,char ->int->long->float->double: 逐步提升，两两运算的结果是容量大（类型范围，不是所占字节）的类型。
    char呢？ 一个字符是2个byte。测试发现用short接收报错“错误: 不兼容的类型: 从int转换到short可能会有损失”
		说明 需要使用 int 接收 char 类型。
    2) 特别地: byte,char,short三种做运算时，包括同种类型的运算，结果都是int类型。


- 强制类型转换
	1)就是自动类型提升的逆运算: 
		int i2= (int)15.9; //15 浮点数变整数就是截断小数部分，不是四舍五入。
	2)可能导致精度损失: 上文损失小数点，下例符号变了，变为另一个极值。
		byte b1=(byte)128; //-128


- 两个错误，编码习惯问题: 
	1) long 类型的要有后缀L或l，否则可能出错。（默认int范围不报错，超过int则报错）
		long t1=123; //右边默认是 int，赋值给long 相当于自动提升了。不报错。
		long t2=12345678912345678L; //如果不加L则报错：错误: 过大的整数
	整型默认是int。
	浮点数默认是 double，所以声明 float 必须加后缀 F或f，否则肯定报错。因为float比double小。
		float f1=12.5; //错误: 不兼容的类型: 从double转换到float可能会有损失
	3) 编码情况2
		byte b1=12;
		byte b2=b1+0; // 错误: 不兼容的类型: 从int转换到byte可能会有损失
		加上0也是提升为int。


ascii码表：1-256；
A65，a97；
大概是字母大小写，数字
System.out.print((char)('a' +1) ); //98出来了

只有int double可以相加而类型不变。


(6) 字符串
- char 不能为空，String可以。
	String s1="abc";
	String s2=""; //可以
	char s3=''; //错误: 空字符文字

- 字符串也可以包含unicode字符
	String a="\u0001"; System.out.print(a);


(7) 常量 final 修饰，命名通常大写 
	final double PI = 3.1415927;
	PI=3.5; //错误: 无法为最终变量PI分配值。final修饰的不能修改。

常量分类
1 整数
2 小数
3 布尔型
4 字符常量：单引号
5.字符串常量：双引号
6.空null：









3. 运算符
算术运算符：+、-、*、/ 和 %，两个整数相除，结果还是整数。
赋值运算符：=、+=、-=、*=、/=、%=、&=、|=、~=、^=、<<=、>>= 、 >>>=、++ 和 --。
比较运算符：==、!=、<、<=、> 和 >=。
逻辑运算符：&&、|| 和 !。
	短路运算：使用 A && B 时，如果A已经false，则跳过B的运算。

	逻辑运算符: 连接2个布尔表达式。
	 and  & 双&&则左假右边不运算； //todo 单个 & 能用吗？
	 or  |  双||则左真右边不运算；
	 not  !
	异或运算 ^ 两边同时为真或假，则为true；分别为真和假则为false；

位运算符：&、|、~、^、<<、>> 和 >>>。
	~	按位取反运算符翻转操作数的每一位，即0变成1，1变成0。
	^	如果相对应位值相同，则结果为0，否则为1
三元运算符: variable x = (expression) ? value if true : value if false

instanceof 运算符：检查该对象是否是一个特定类型（类类型或接口类型）。 obj instanceof ClassName;
	String name = "James";
	boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真

运算的优先级
	查表
	不放心就多加括号






4. 控制结构
条件：if...else if...else、switch-case-default和三元运算符（?:）。
		int week=6;
		switch(week){
			case 1:
			   //语句
			   break; //可选
			case 2:
			case 3: //可以多个连写
			   //语句
			   break; //可选
			//你可以有任意数量的case语句
			default : //可选
			   //语句
		}
循环：while、do-while、for和foreach。
	int[] arr={1,5,8};
	for(int x : arr ){
		System.out.println(x);
	}
break; 退出循环
continue; 跳过本次循环。

Labeled block。



(2) If和switch的区别
If 对具体的值进行判断；对区间判断；对运算结果是boolean类型的表达式进行判断；

switch：对具体的值进行判断；值的个数通常是固定的；
	对于几个具体值，建议使用switch语句，因为其都加载选项，效率相对较高；
	但是switch不经常使用


(3) 循环练习题
1)打印九九乘法表：
class For1
{
	public static void main(String[] args){
		for(int i=1; i<9; i++){
			for(int j=1; j<=i; j++){
				System.out.print(i+"*"+j+"="+i*j+"   ");
			}
			System.out.println();
		}
	}
}


2)打印菱形：
class For1
{
	public static void main(String[] args){
		for(int i=-10; i<10; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print(" ");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )-1; j++){
					System.out.print("*");
			}


			System.out.println();
		}
	}
}

class For1{
	public static void main(String[] args){
		for(int i=-10; i<11; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )+1; j++){
					System.out.print("-");
			}
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}

			System.out.println();
		}
	}
}



ref: https://www.bilibili.com/video/BV1Kb411W75N/?p=45
2023.3.12 45关键字, 命名规范; 48 变量; 49 先声明再使用; 50 变量类型
	51 整型变量; 52 浮点数; 53 字符类型 54 字符集; 55布尔型; 56 自动类型转换
2023.3.13 56 自动类型转换, 58 强制类型转换; 59 运算规则的特殊情况; 60 string 是引用类型。


========================================
>>> 多看书，多练习，多总结！ | 当前Java进度: https://www.bilibili.com/video/BV1Kb411W75N/?p=56
----------------------------------------
docs: https://docs.oracle.com/javase/8/docs/
file:///G:/books_on_coding/Java/java8_docs/api/index.html

https://www.weixueyuan.net/view/6316.html

快速入门 https://www.cnblogs.com/happyframework/p/3332243.html


老代码: G:\java_code\src\mio\DataTypeDemo




========================================
字符串: String 类, StringBuffer & StringBuilder 类
----------------------------------------
1. 创建方法
(1) 两种方法
String str = "Tom";
String str2=new String("Tom");

(2) 差异
String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：
String s1 = "Tom";              // String 直接创建
String s2 = "Tom";              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String("Tom");   // String 对象创建
String s5 = new String("Tom");   // String 对象创建

s1, s2, s3 对应的是同一份；s4和s5分别对应不同的。 //todo 怎么判断？
	System.err.println(s1.getBytes() + " "+ s1.hashCode()); //这个不行，bytes都不同，hash都相同。
	// 可能是这么比较的
	System.out.println(s1==s2); //true
	System.out.println(s1==s3); //true
	System.out.println(s1==s4);  //false
	System.out.println(s1==s5);  //false
	System.out.println(s4==s5);  //false
	System.out.println(s1.equals(s5));  //true
	System.out.println(s4.equals(s5));  //true

(3) == 和 equals 的区别?
String是拥有“值语义”的引用类型，字符串常量实现了“享元模式”，equals会按照内容进行比较，==按照地址比较。

public class Hi2 {
    public static void main(String[] args) {
        String x = "你好";
        String y = new String("你好");
        
        System.out.println(x.equals(y)); // true
        System.out.println(x == y); // false
    }
}


(4) String 类有 11 种构造方法
使用字符数组初始化字符串：
	char [] arr1= {'t', 'o', 'm'};
	String str=new String(arr1);

字符串不能修改，需要很多修改可使用 StringBuffer & StringBuilder 类。 
//todo 我测试的可以修改 str+="hi"; 可能是效率不高？


(5) 创建格式化字符串
	int age=20;
	String name="wangcai";
	//方法1.printf，类C函数；一次性输出
	System.out.printf( "1新人名字是%s,今年%d岁\n", name, age ); 
	// 方法2.String.format 静态方法，可复用，而不是一次性输出
	String fs=String.format("2新人名字是%s,今年%d岁", name, age);
	System.out.println(fs);

(6) 字符串的长度 str.length() 
(7) 连接字符串
	System.out.println(s1.concat(s2));//方法1
	System.out.println(s1+" "+s2); //方法2

(8) String 方法
https://www.runoob.com/java/java-string.html
https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html







2. 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类

为了高效的修改字符串Java引入了 StringBuffer。
(1) 常用用例
sb.append(newStr) //最后追加新字符串
sb.toString(); //转成字符串

public class Hi2 {
    public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("你");
		sb.append("好").append("！"); //可以连续写
		
		System.out.println(sb.toString());
	}
}

(2) 和 String 的差异
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

String 实现了 charsequence 接口 
AbstractStringBuilder 不仅实现了 charsequence 接口，还实现了 Appendable 接口 
	两个实现类: 
	StringBuilder: 不是线程安全的 （不能同步访问）；较快。
	StringBuffer: 

- 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。

- StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

- 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。


(3) 示例
public class StringBuilderDemo {
	public static void main(String[] args) {
		System.out.println("index/capacity/length/contents");
//		StringBuilder sb=new StringBuilder(10); //初始化长度，默认16
		StringBuffer sb=new StringBuffer(10); //要求线程安全，则必须用 StringBuffer 类
		check(sb,1);
		sb.append("hello,");
		check(sb,2);
		sb.append(" this is tom!"); //容量自动增长
		check(sb,3);
		// 可以在中间插入
		sb.insert(5, " there");
		check(sb,4);
		//删除一段
		sb.delete(5, 11); //长度缩回去了，容量不变
		check(sb,5);
	}

	static void check(StringBuffer sb, int index) {
		System.out.println(index+" "+sb.capacity()+ " "+ sb.length()+" \""+sb+"\"");
	}
}

输出:
index/capacity/length/contents
1 10 0 ""
2 10 6 "hello,"
3 22 19 "hello, this is tom!"
4 46 25 "hello there, this is tom!"
5 46 19 "hello, this is tom!"


(4) StringBuffer 方法
https://www.runoob.com/java/java-stringbuffer.html
append()
reverse()
delete, insert, replace, charAt(), indexOf(), lastIndexOf(), 





========================================
数组， 多维数组 和 Arrays 类
----------------------------------------
1.声明语法
DataType[] name; //常用写法
DataType name[]; //也可以，类C写法


2. 初始化语法
DataType[] name = new DataType[length]。 //然后逐个初始化 name[0]=xx;
DataType[] name = new DataType[] { element1, element2, ...elementn }。//不能同时提供长度和花括号列表
DataType[] name = { element1, element2, ...elementn }。

例:
Int[] arr=new int[5];
int[] arr=new int[]{3,5,1,7};
Int[] arr={3,5,1,7};



3.操作数组
(1) 通过下标，从0开始索引。
(2) 数组长度 arr.length;
(3) 针对数组的 for-each 循环
for(int x: arr){
	sum+=x;
}
(4) 数组作为函数的参数，是按地址传递的
	private static void demo1() {
		int arr[] = {1,3,5,7};
		printArr(arr); //[1, 3, 5, 7]
		chanage(arr, 1, 1000); //确实被修改了
		printArr(arr); //[1, 1000, 5, 7]
	}
	// 数组是按地址传递的。这个地址被修改了，原来的值也被修改了
	private static void chanage(int[] arr, int index, int value) {
		arr[index]=value;
	}

(5) 数组作为返回值
	// 如果不想修改原数组，需要复制后修改
	private static void demo2() {
		int arr[]= {1,2,3};
		int arr2[]=doubleArr(arr); //倍增数组，不改变原始数组
		printArr(arr); //[1, 2, 3]
		printArr(arr2); //[2, 4, 6]
	}
	// 返回数组的函数
	private static int[] doubleArr(int[] arr) {
		int len=arr.length;
		int[] arr2=new int[len]; //声明新数组
		for(int i=0; i<len; i++) {
			arr2[i]=arr[i]*2;
		}
		return arr2;
	}

(6) 数组的常见操作
- 求最值：最大最小；
- 排序: 冒泡法，选择排
- 查找（二分法）


思考题：
Q: 给定一个有序数组，放入一个元素，并保证这个数组有序，请问怎么确定此元素位置；
A: 二分法返回min即可；

而内置方法，返回的是-min-1；
Array.binarySearch(arr, 50);//查看50在arr中是否存在？不存在则返回其插入点；


(7) 星期转换实例
	//getWeek
	static String getWeek(int i){
		if(i>7 || i<1){
			return "wrong weeks";
		}

		String[] weeks={"", "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday", "Sunday"};
		return weeks[i];
	}




4.多维数组
只有不等长多维数组DataType[][]，没有DataType[xxx, xxx]。
每个低维的长度可以不同。这和C不同。

(1) 直接为每一维分配空间
int[][] a = new int[2][3]; //相当于2行3列。
每行是一个数组，每个数组都是长度为3的一维数组。

初始化后，二维数组中第一维表示此数组含有3个一维数组；
但是数组是引用型类型，在堆中初始化为null，所以如下的存储：

	arr[0][1]=12;//
	System.out.println(arr); // print the whole 2d-array
	System.out.println(arr[0]); //print the 1st array in the 2d-array;
	System.out.println(arr[0][1]);//element at 1row 2column 

输出如下：
[[I@811c88
[I@785d65
12


(2) 从最高维开始，分别为每一维分配空间
int [][] arr=new int[3][]; //最高纬是3
//接着为这三个位置分配空间，装一维数组（因为只剩下一个维度）
arr[0]=new int[2]; //第0行是长度2的一维数组
arr[1]=new int[3]; //第1行是长度5
arr[2]=new int[] {21,22,23,24}; //第2行是长度4

或
String[][] s = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good"); //逐个命名
...


(3) Arrays 类
java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。

先导入类 import java.util.Arrays;

给数组赋值：通过 fill 方法。
	int arr[] =new int[3];
	Arrays.fill(arr, 3); //每个元素都填充为固定值
对数组排序：通过 sort 方法,按升序。
	Arrays.sort(arr); //升序
比较数组：通过 equals 方法比较数组中元素值是否相等。
	int[] arr1= {1,2,3};
	int[] arr2= {1,2,3};
	System.out.println(Arrays.equals(arr1, arr2)); //true
查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。
	//二分法必须先排序
	private static void demo4() {
		int[] arr= {-5,10,1};
		// 1.先排序
		Arrays.sort(arr);
		for(int x: arr) System.out.print(x+" ");
		System.out.println();
		
		// 2.查找
		int index=Arrays.binarySearch(arr, 3);
		//小于0表示没有找到；>=0表示找到
		System.out.println(  (index<0?"Not Found":"Found at "+index)  );
	}

(4) Arrays 其他方法
https://www.runoob.com/java/java-array.html








========================================
日期时间 Date 类， Calendar类
----------------------------------------
1. 当前日期
(1) 有两个构造函数
import java.util.Date;

private static void demo1() {
	//构造函数1: 获取当前时间
	Date d1=new Date(); //Wed Mar 15 10:56:09 CST 2023
	System.out.println(d1); //Wed Mar 15 10:59:52 CST 2023
	
	//构造函数2: 可接收一个参数，从 1970 年 1 月 1 日起的毫秒数。
	//使用js >new Date().getTime() //1678849135858
	Date d2=new Date(1678849135858L);
	System.out.println(d2); //Wed Mar 15 10:58:55 CST 2023
}


(2) 日期比较: 先后
Java使用以下三种方法来比较两个日期：

使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。
	//获取时间的毫秒数
	System.out.println(d2.getTime()); //1678849135858

使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 d1.before(d2) 返回true/false。
使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。
	//判断两个日期的先后
	System.out.println(1+" "+d1.after(d2)); //true
	System.out.println(1+" "+d1.compareTo(d2)); //1


(3) 格式化显示：SimpleDateFormat 
import java.text.SimpleDateFormat;
import java.util.Date;
	// 日期的格式化 SimpleDateFormat
	private static void demo2() {
		Date d1=new Date();
		SimpleDateFormat ft=new SimpleDateFormat("yyyy/MM/dd hh:mm:ss");
		System.out.println("当前时间:"+ ft.format(d1)); //2023/03/15 11:16:29
	}

日期和时间的格式化编码:
其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。
注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；
	HH 是 24 小时制，而 hh 是 12 小时制。

	// HH是24小时，hh是12小时
	SimpleDateFormat ft2=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss E");
	System.out.println("当前时间:"+ ft2.format(d1)); //2023/03/15 11:16:29  星期三

更多格式简介: https://www.runoob.com/java/java-date-time.html


(4) 使用printf格式化日期
	System.out.printf("%tY-%tm-%td %tH:%tM:%tS %tZ", d1, d1, d1, d1, d1, d1, d1); //2023-03-15 11:23:14 CST
略
需要了再查。


(5) 解析字符串为时间
	//解析字符串为时间
	private static void demo4() {
		SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd"); 
		//String input=args.length==0 ? "2023-3-15" : args[0]; //main方法的参数 args
		String input="2023-3-15";
		System.out.println(input + " -> ");
		
		Date t;
		try {
			t=ft.parse(input); //解析
			System.out.println(t);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
输出:
2023-3-15 -> 
Wed Mar 15 00:00:00 CST 2023


(6) 休眠 sleep
	//休眠3秒
	private static void demo5() {
		System.out.println(new Date());
		try {
			Thread.sleep(1000*3);//休眠
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(new Date());
	}
输出:
Wed Mar 15 11:31:10 CST 2023
Wed Mar 15 11:31:13 CST 2023

(7) 测量时间
略



(10) 其他方法	

	//转为字符串
	System.out.println(d2.toString()); //Wed Mar 15 10:58:55 CST 2023





2. Calendar类
Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。
Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。

https://www.runoob.com/manual/jdk11api/java.base/java/util/Calendar.html







10. 详细介绍
https://www.runoob.com/java/java-date-time.html





========================================
正则表达式
----------------------------------------
Java 正则表达式和 Perl 的是最为相似的。


1. java.util.regex 包主要包括以下三个类：

Pattern 类：
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

PatternSyntaxException：
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。


(1) 匹配
Pattern.matches(pattern, content)简单查找：字符串content 中是符合 pattern，要完全匹配才是true
import java.util.regex.Matcher;
import java.util.regex.Pattern;

	private static void demo1() {
		String content="this is a book or bike";
		String regex=".*book.*";
		
		//方法1  直接匹配
		boolean isMatch=Pattern.matches(regex, content); 
		System.out.println(isMatch); //true
		
		//方法2 两步法
		Pattern pt=Pattern.compile(regex); //编译正则
		Matcher m=pt.matcher(content); //创建匹配对象
		
		System.out.println(m.matches()); //true
	}

(2) 捕获组，就是带圆括号的正则表达式
		String content="This order was placed for QT3000! OK?";
		String pattern="(\\D*)(\\d+)(.*)";
		// 创建 Pattern对象
		Pattern reg=Pattern.compile(pattern);
		// 创建 matcher 对象
		Matcher m = reg.matcher(content);
		
		System.out.println(m);
		System.out.println(m.groupCount()); //共3个捕获组

		if(m.find()) {
			System.out.println(" 0>"+m.group(0)); //原文
			//三个捕获组
			for(int i=0; i<m.groupCount(); i++) {
				System.out.printf(" %d> %s\n", i, m.group(i));
			}
//			System.out.println(" 1>"+m.group(1)); 

		}


(3) 正则表达式语法
在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。

在其他的语言中（如 Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。
也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。

https://www.runoob.com/java/java-regular-expressions.html


(4) Matcher 类的方法
索引方法: 索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：

	序号	方法及说明
	1	public int start()		返回以前匹配的初始索引。
	2	public int start(int group)		 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引
	3	public int end()		返回最后匹配字符之后的偏移量。
	4	public int end(int group)	返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。

start 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。

	// 查找出现次数进行计数的例子: 匹配局部
	private static void demo5() {
		String input="cat cat cat cattie cat";
		String regex = "\\bcat\\b"; //两边包着空格的cat
		
		//匹配
		Pattern pt = Pattern.compile(regex);
		Matcher mt = pt.matcher(input); // 获取 matcher 对象
		System.out.println(mt);
		
		//输出匹配
		int count = 0;
		while(mt.find()) {
			count++;
			System.out.print("Match number "+count);
			System.out.print(", start(): "+mt.start());
			System.out.print(", end(): "+mt.end());
			System.out.println(":" + input.substring(mt.start(), mt.end()));
		}
	}


(5) 查找方法
查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：

	序号	方法及说明
	1	public boolean lookingAt()		 尝试将从区域开头开始的输入序列与该模式匹配。
	2	public boolean find()		尝试查找与该模式匹配的输入序列的下一个子序列。
	3	public boolean find(int start）		重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。
	4	public boolean matches()		尝试将整个区域与模式匹配。

matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。
lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。

	//matches 和 lookingAt 方法 
	private static void demo6() {
		//matches 要求完全匹配； lookingAt 要求部分匹配，但是必须从开头算起
		String str="this is a book";
		String regex=".*is";
		
		Pattern pt=Pattern.compile(regex);
		Matcher m=pt.matcher(str);
		
		System.out.println(m.matches()); //完全匹配吗？false
		System.out.println(m.lookingAt()); //是否从开头匹配？ true
	}


(6) 替换方法
替换方法是替换输入字符串里文本的方法：

	序号	方法及说明
	1	public Matcher appendReplacement(StringBuffer sb, String replacement) 	实现非终端添加和替换步骤。
	2	public StringBuffer appendTail(StringBuffer sb)  	实现终端添加和替换步骤。
	3	public String replaceAll(String replacement)  	 替换模式与给定替换字符串相匹配的输入序列的每个子序列。
	4	public String replaceFirst(String replacement)  	 替换模式与给定替换字符串匹配的输入序列的第一个子序列。
	5	public static String quoteReplacement(String s)  	返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。

例1: 替换第一个 和 全部替换
import java.util.regex.Matcher;
import java.util.regex.Pattern;
	//replaceFirst 和 replaceAll 方法
	private static void demo1() {
		String str="this is a dog. It's a black dog.";
		String regex="dog";
		String newWord="cat";
		
		Pattern p=Pattern.compile(regex);
		Matcher m=p.matcher(str);
		
		//全部替换
		String str2=m.replaceAll(newWord);
		System.out.println(str2);

		//替换 第一个出现的
		String str3=m.replaceFirst(newWord);
		System.out.println(str3);
	}


例2: 保持原文不变的替换
	// appendReplacement 和 appendTail 方法
	private static void demo2() {
		String str="this is a dog. It's a black dog.";
		String regex="dog";
		String newWord="cat";
		
		Pattern p=Pattern.compile(regex); //编译正则
		Matcher m=p.matcher(str); //获取匹配对象
		
		StringBuffer sb = new StringBuffer();
		while(m.find()) {
			m.appendReplacement(sb, newWord); //把m中匹配的替换成 newWord后放到sb中
			System.out.println(" > "+sb);
		}
		m.appendTail(sb); //把尾部加到sb
		System.out.println(sb.toString());
		System.out.println(str); //原文不变
	}
输出:
 > this is a cat
 > this is a cat. It's a black cat
this is a cat. It's a black cat.
this is a dog. It's a black dog.




(7) 分割字符串
//方法1 调用字符串的 split 方法
String[] arr=str.split(regEx); 

//方法2 调用编译后的正则的 split 方法
import java.util.regex.Pattern;
String[] arr2=Pattern.compile(regEx).split(str);



(8) PatternSyntaxException 类的方法
PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。

PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。

序号	方法及说明
1	public String getDescription() 获取错误的描述。
2	public int getIndex()  获取错误的索引。
3	public String getPattern() 获取错误的正则表达式模式。
4	public String getMessage() 返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。







========================================
函数/方法(其他语言中的 函数 or 过程): 命令行参数、构造方法
----------------------------------------
1. 函数的定义
修饰符 返回类型 函数名（参数类型 形式参数1，参数类型2, 形参2，...）
{
	执行语句；
	Return 返回值；
}

没有返回值的函数：
返回值类型怎么体现？Void

栈的特点：先进后出；

例子：
class Func{
	public static void main(String[] args){
		int a=3;
		int b=4;
		int c;
		System.out.println( add(a,b) );

	}

	public static int add(int a, int b){
		return a+b;
	}
}




2. 方法的重载 overload：相同名字但参数不同的方法。

概念：同一各类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。
重载的特点：

class Fn1{
	/**
	overload of functions
	*/


	//int
	public static int add(int a, int b){
		return a+b;
	}

	//double
	public static double add(double a, double b){
		return a+b;
	}
	//more than 2
	public static int add(int a, int b, int c){
		return a+b+c;//or return add( add(a,b),c))
	}

	public static void main(String[] args){
		int a=3;
		int b=4;
		int c=100;
		System.out.println( add(a, b) );
		System.out.println( add(2.3,3.3) );
		System.out.println( add(a,b,34) );
		System.out.println( add(a,2.1111) );
	}
}


3. 变量的作用域


4. 命令行参数的使用

public class Hi2 {
	// 这个只能通过命令行测试
	// javac xx.java;  java xx this is a book
	public static void main(String[] args) {
		for(int i=0; i<args.length; i++) {
			System.out.println("args["+i+"]="+args[i]);
		}
	}
}

编译和运行: 
D:\Desktop\hi>javac Hi2.java
D:\Desktop\hi>java Hi2 this is a book .
args[0]=this
args[1]=is
args[2]=a
args[3]=book
args[4]=.







5. 可变参数
JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。

方法的可变参数的声明如下所示： typeName... parameterName
在方法声明中，在指定参数类型后加一个省略号(...) 。

一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。

public class VarArgsDemo {
	public static void main(String[] args) {
		printMax(1,5,9,3,7);
		printMax(new double[] {10,15,25});
	}

	private static void printMax(double... ds) {
		if(ds.length==0) {
			System.out.println("No argument passed");
			return;
		}
		
		double result=ds[0];
		for(int i=1; i<ds.length; i++) {
			if(ds[i] > result)
				result=ds[i];
		}
		System.out.println("max value is:"+result);	
	}
}

输出： 
max value is:9.0
max value is:25.0















========================================
OOP 概念 
----------------------------------------
类与对象，属性和方法，构造方法，OOP三大特性，权限修饰符的访问范围，
重载和重写，this，super，
抽象列，接口， 
枚举，内部列，final关键字，instanceof，
使用UML进行标准建模
类之间的关系

设计模式
异常，注解



1. 变量 
局部变量: 方法中。
	局部变量没有初始值，必须初始化后再使用。
成员变量（实例变量）：方法外、类内、无static。
类变量：方法外、类内、有static修饰。


(2) 内部类
嵌套到另一个类内部的类。
- 非静态内部类 （内部类）: 
	要先实例化外部类，再实例化内部类： OC oc=new OC(); OC.IC ic = oc.new IC();
	内部类加 private 后， 外部不可见 OC.IC 类型。
	内部类可以在方法内定义：局部内部类
- 静态内部类：
	带 static 修饰的内部类，无需实例化外部类即可访问它
	注意：静态内部类无法访问外部类的成员。


(3) 访问修饰符 4个
	default 同一个包内可见
	private 同一个类内可见。不能修饰类（外部类）。
	protected 对同一个包内的类，和所有子类可见。不能修饰类（外部类）。
	public 对所有类可见
	说明：
		接口中的变量隐式 public static final，接口中的方法默认 public
		main() 方法必须public，否则Java解释器不能运行该类。
		接口及接口的成员变量和成员方法不能声明为 protected。
	访问控制的继承
		父类声明为 public 的方法在子类中必须为public。
		父类声明为 protected 的方法在子类中 protected 或 public，不能是 private。
		父类声明为 private 的方法不能被子类继承。

(4) 非访问修饰符
static 修饰符，用来修饰类方法和类变量。
	局部变量不能被声明为 static 变量。

final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

abstract 修饰符，用来创建抽象类和抽象方法。
	一个类不能同时被 abstract 和 final 修饰。
	如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
	抽象方法：
		抽象方法不能被声明成 final 和 static。
		任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

synchronized 和 volatile 修饰符，主要用于线程的编程。
	synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

transient 修饰符
	序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。
	该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。
	实例
	public transient int limit = 55;   // 不会持久化
	public int b; // 持久化







========================================
|-- 继承
----------------------------------------
1. 继承需要符合的关系是：is-a，父类更通用，子类更具体。
(1)
class 父类 {
}
 
class 子类 extends 父类 {
}

Java 不支持多继承，但支持多重继承。

继承的表示:	父类<--子类<-- 孙类

继承的优点：减少重复代码。


(2) 继承的特性
- 子类拥有父类非 private 的属性、方法
- 子类可以拥有自己的属性和方法，也就是对父类扩充
- 子类可以实现父类的方法
- Java单继承，就是一个类只有有一个父类，不能是多个
- 提高了类的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）


(3) 继承关键字
extends 和 implements 这两个关键字来实现继承
所有的类都是继承于 java.lang.Object

1) extends关键字 实现类的继承
public class Animal{
	private String name;
	public Animal(String name){
		this.name=name;
	}
	public void eat(){
	}
}

public class Bird extends Animal{
}


2) implements 用于继承接口
接口可以多继承，接口之间用逗号隔开。

public interface CanFly{
	public void fly();
}

public interface CanEat{
	public void eat();
}

public class Bird implements CanFly, CanEat{
}




(4) super 与 this 关键字
super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
this关键字：指向自己的引用。


(5) final 关键字
使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，
	final class 类名 {//类体}
	注： final 定义的类，其中的属性、方法不是 final 的。

或者用于修饰方法，该方法不能被子类重写
	修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}






========================================
|-- 构造器/构造函数 constructor
----------------------------------------
1. 默认构造方法的访问修饰符和类的访问修饰符相同。

- 构造函数没有返回值。
- 构造函数和类同名。
- 构造函数可以重载，只要参数不同即可。

class Dog {
  int x;
 
  // 以下是构造函数
  Dog() {
    x = 10;
  }
  
   Dog(int x) {
    this.x = x;
  }
}



2. 继承时
- 子类不继承父类的构造器，他只能调用（隐式或显式）。
- 如果父类的构造器带有参数，则必须在子类的构造器中显式的通过 super 关键字调用父类的构造器并传参。
	- super调用父类构造器必须在子类构造器第一行
	- 如果不写super函数，默认调用父类的无参构造器
- 父类构造器没有参数，则系统会自动调用父类的无参构造器。




========================================
|-- 重写(Override)与重载(Overload)
----------------------------------------
1. Override 重写 函数体

覆盖父类同名方法的函数体，返回值和形参都不能改变。

子类只能抛出更小的异常: 
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。

在面向对象原则里，重写意味着可以重写任何现有方法。


(1) 重写后，运行的是特定对象的方法
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}

public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象

      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
   }
}

输出:
动物可以移动
狗可以跑和走


分析:
在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。
- 这是由于在编译阶段，只是检查参数的引用类型。
- 然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。
因此在上面的例子中，之所以能编译成功，
	是因为 Animal 类中存在 move 方法，
	然而运行时，运行的是特定对象的方法。


(2) 方法的重写规则
- 参数列表必须完全一致
- 返回类型：只能是父类返回值及其派生类
- 访问权限：降低限制，父类public，子类不能是 protected 
- 父类成员只能被子类重写
- final 方法不能被重写
- static 方法不能被重写，但是能够再次声明
- 同一个包中，子类可以重写父类的所有方法，除了 private 和 final 方法。
- 不在一个包中，子类只能重写父类声明为 public 和 protected 的非 final 方法。
	问题：是否同一个包，重写规则有啥区别？
- 重写抛出的异常只能是父类抛出的异常及其子类
- 构造函数不能被重写


(3) super 关键字
需要在子类中调用父类的被重写方法时，要使用 super 关键字







2. 重载(Overload)
同名函数，参数不同。
	区分：独一无二的参数列表
返回值可以相同，也可以不同。
	无法使用返回值区分重载函数。


最常见的是构造器的重载。












========================================
|-- 多态：同一个方法，传入不同的类做不同的处理
----------------------------------------
1.现实中，按下F1键
当前是word，就显示word的帮助
当前是win就是win的帮助。

同一个动作，对不同的对象有不同的结果。


2.多态的优点
	1. 消除类型之间的耦合关系
	2. 可替换性
	3. 可扩充性
	4. 接口性
	5. 灵活性
	6. 简化性

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。



3. 多态存在的三个必要条件
	继承
	重写 (override)
	父类引用指向子类对象：Parent p = new Child();

class Shape {
    void draw() {}
}
 
class Circle extends Shape {
    void draw() {
        System.out.println("Circle.draw()");
    }
}
 
class Square extends Shape {
    void draw() {
        System.out.println("Square.draw()");
    }
}
 
class Triangle extends Shape {
    void draw() {
        System.out.println("Triangle.draw()");
    }
}

调用:
	private static void demo1() {
		Shape s1=new Circle();  s1.draw();
		Shape s2=new Square();  s2.draw();
		Shape s3=new Triangle();  s3.draw();
	}
输出:
Circle.draw()
Square.draw()
Triangle.draw()



4. 虚函数
虚函数的存在是为了多态。

Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。

如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。



5. 重写 
当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

要想调用父类中被重写的方法，则必须使用关键字 super。



6.多态的实现方式
(1)方式一：重写
这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。


(2)方式二：接口
1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。

2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。


(3) 方式三：抽象类和抽象方法
详情请看 Java抽象类 章节。







========================================
|-- 抽象类 与 抽象方法
----------------------------------------
1. 抽象类
abstract 修饰类名
抽象类不能实例化，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。


2. 抽象方法
abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

public abstract double sendMail();

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。







========================================
|-- 封装 Encapsulation
----------------------------------------
1. 就是隐藏细节，只暴漏接口

适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

2. 封装的优点
	1. 良好的封装能够减少耦合。
	2. 类内部的结构可以自由修改。
	3. 可以对成员变量进行更精确的控制。
	4. 隐藏信息，实现细节。

3. 实现 
属性 private 修饰；
对每个值提供 public 方法访问: getAge(), setAge();
	使用 this 关键字解决实例变量和参数变量同名的问题。


package chapter3;

public class TestStu {
	public static void main(String[] args) {
		Student stu1=new Student("lilei");
		System.out.println(stu1.getName());
		stu1.setName("wangcai");
		System.out.println(stu1.getName());
	}
}

class Student{
	private String name="";

	public Student() {}
	public Student(String name) {
		this.name=name;
	}
	
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name=name;
	}
}






========================================
|-- 接口 Interface: 声明、实现、继承、标记接口
----------------------------------------
1. 什么是接口？
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

一个类通过继承接口的方式，从而来继承接口的抽象方法。


(2) 接口与类相似点：
一个接口可以有多个方法。
接口文件保存在 .java 结尾的文件中，文件名使用接口名。
接口的字节码文件保存在 .class 结尾的文件中。
接口相应的字节码文件必须在与包名称相匹配的目录结构中。


(3)接口与类的区别：
接口不能用于实例化对象。
接口没有构造方法。
接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
接口不能包含成员变量，除了 static 和 final 变量。
接口不是被类继承了，而是要被类实现。
接口支持多继承。


(4) 接口特性
接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。


(5) 抽象类和接口的区别
1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

注：JDK 1.8 以后，接口里可以有静态方法和方法体了。

注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。

注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。








2. 接口的声明
接口的声明语法格式如下：不必使用 abstract 修饰接口。

[可见度] interface 接口名称 [extends 其他的接口名] {
	// 声明变量
	public static final String name; // 只能是 public static final
	// 抽象方法
	public abstract void method1(); //接口方法前的 abstract 可以省略
	public void method2(); 
}


/* 文件名 : Animal.java */
interface Animal {
   public void eat();
   public void move();
}




3. 接口的实现
当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。

类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。

...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...

/* 文件名 : Mammal.java */
public class Mammal implements Animal{
   public void eat(){
      System.out.println("Mammal eats");
   }

   public void move(){
      System.out.println("Mammal moves");
   } 

   public int noOfLegs(){
      return 0;
   }

   public static void main(String args[]){
      Mammal m = new Mammal();
      m.eat();
      m.move();
   }
}

输出:
Mammal eats
Mammal moves


重写接口中声明的方法时，需要注意以下规则：
	类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
	类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
	如果实现接口的类是抽象类，那么就没必要实现该接口的方法。


在实现接口的时候，也要注意一些规则：
	一个类只能继承一个类，但是能实现多个接口。
	一个接口能继承另一个接口，这和类之间的继承比较相似。




4. 接口的继承
一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。

// 文件名: Sports.java
public interface Sports{
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}
 
// 文件名: Football.java
public interface Football extends Sports{
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}
 
// 文件名: Hockey.java
public interface Hockey extends Sports{
   public void homeGoalScored();
   public void visitingGoalScored();
   public void endOfPeriod(int period);
   public void overtimePeriod(int ot);
}

Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。

相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。




5.接口的多继承
在Java中，类的多继承是不合法，但接口允许多继承。

在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：

public interface Hockey extends Sports, Event
以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可以定义或是继承相同的方法




6.标记接口: 没有任何方法的接口被称为标记接口。

(1) 最常用的继承接口是没有包含任何方法的接口。
- 标记接口是没有任何方法和属性的接口
- 它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。
- 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。

例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：

	package java.util;
	public interface EventListener
	{}


(2)标记接口主要用于以下两种目的：
1) 建立一个公共的父接口：
正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。
例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。

2) 向一个类添加数据类型：
这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。







========================================
|-- 匿名类
----------------------------------------
1. 定义
匿名类没有类名，直接使用new实例化。
	匿名类通常继承一个父类或实现一个接口。

不能有名字，只能在new语句声明它们。

(1) 继承一个父类 的匿名类
className refer=new ClassName(){ }

class Person{
	public void say() {
		System.out.println("父类方法");
	}
}

	// 匿名类：继承一个父类
	private static void demo1() {
		//正常调用
		Person p1=new Person();
		p1.say();
		
		//创建匿名子列，改写方法后调用
		Person p2=new Person() {
			public void say() {
				System.out.println("重写父类方法");
			}
		};
		p2.say();
	}


(2) 实现接口 的匿名类
interface Flyable{
	void fly();
}

	// 匿名类：实现一个接口
	private static void demo2() {
		// 方法1
		Flyable f1=new Flyable() {
			public void fly() {
				System.out.println("匿名内部类-实现接口 Flyable");
			}
		};
		f1.fly();
		// 方法2：直接不要名字
		new Flyable() {
			public void fly() {
				System.out.println("匿名内部类2");
			}
		}.fly();
	}







========================================
枚举 enum
----------------------------------------
使用枚举可以减少bug。

0. 定义和使用
public class EnumDemo {
	enum FruitJuice{ SMALL, MEDIUM , LARGE }; //不能定义在方法中 why? 花括号内最后的分号可省略。
	
    public static void main(String[] args) {
		FruitJuice fj1=FruitJuice.SMALL;
		System.out.println(fj1); //SMALL
		System.out.println(fj1.equals(0)); //false
	}
}

注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。 //??后半句什么意思



1. Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。

Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。

例如定义一个颜色的枚举类。
	enum Color 
	{ 
		RED, GREEN, BLUE; 
	} 
	//枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色。

例: 
enum Color{ RED, GREEN, BLUE; }
public class Test{
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}

输出: 
RED


2. 内部类中使用枚举
	enum Color{ RED, GREEN, BLUE; }
	private static void demo1() {
		Color c1 = Color.RED;
        System.out.println(c1);
	}

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。

以上的枚举类 Color 转化在内部类实现：
class Color{
     public static final Color RED = new Color(); //todo 看不懂，这三个不是一样吗？
     public static final Color BLUE = new Color();
     public static final Color GREEN = new Color();
}



3.迭代枚举元素
	enum Color{ RED, GREEN, BLUE; }
	//迭代枚举元素
	private static void demo2() {
		for(Color val: Color.values()) {
			System.out.println(val);
		}
	}
输出:
RED
GREEN
BLUE


4. 在 switch 中使用枚举类
	//在 switch 中使用枚举类
	private static void demo3() {
		Color val=Color.BLUE;
		
		switch(val) {
		case RED:
			System.out.println("红色");
			break;
		case GREEN:
			System.out.println("绿色");
			break;
		case BLUE:
			System.out.println("蓝色");
			break;
		}
	}
输出: 蓝色





5. values(), ordinal() 和 valueOf() 方法

num 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。

values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：
	values() 返回枚举类中所有的值。
	ordinal() 方法可以找到每个枚举常量的索引，就像数组索引一样。
	valueOf() 方法返回指定字符串值的枚举常量。

例:
	private static void demo4() {
		// values() 返回枚举中的所有值
		Color[] arr=Color.values();
		
		//迭代枚举：val.ordinal() 获取 0-based 序号
		for(Color col: arr) {
			//查看索引
			int index=col.ordinal();
			System.out.println(col+" at index "+ index);
		}
		
		// valueOf() 由字符出值，返回枚举常量。不存在则报错 IllegalArgumentException
		System.out.println(Color.valueOf("RED"));
		try {
			System.out.println(Color.valueOf("WHITE"));
		}catch(IllegalArgumentException e) {
			System.out.println(">> exception now");
		}
	}
输出:
RED at index 0
GREEN at index 1
BLUE at index 2
RED
>> exception now





6. 枚举类成员
(1) 枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。
枚举既可以包含具体方法，也可以包含抽象方法。 

	// 枚举的方法
	enum Color2{
		RED, GREEN, BLUE;
		//构造函数
		private Color2() {
			System.out.println("Constructor called for: "+this.toString());
		}
		
		public void colorInfo() {
			System.out.println("Universal Color");
		}
	}
	private static void demo5() {
		Color2 c2=Color2.RED;
		System.out.println(c2);
		c2.colorInfo();
	}

输出:
Constructor called for: RED
Constructor called for: GREEN
Constructor called for: BLUE
RED
Universal Color

说明：每个值都调用过构造器。


(2) 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。

	enum Color3{
	    RED{
	        public String getColor(){//枚举对象实现抽象方法
	            return "红色";
	        }
	    },
	    GREEN{
	        public String getColor(){//枚举对象实现抽象方法
	            return "绿色";
	        }
	    },
	    BLUE{
	        public String getColor(){//枚举对象实现抽象方法
	            return "蓝色";
	        }
	    };
	    public abstract String getColor();//定义抽象方法 <===***###===
	}
	private static void demo6() {
        for (Color3 c:Color3.values()){
            System.out.print(c.getColor() + " | ");
        }
	}
输出：红色 | 绿色 | 蓝色 | 





========================================
包(package)，命令行编译Java
----------------------------------------
1. 目的
为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

(2) 写法: package pkg1[．pkg2[．pkg3…]];

例: 一个 Something.java 文件它的内容
package net.java.util;
public class Something{
   ...
}

那么它的路径应该是 net/java/util/Something.java 这样保存的。 
package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。


(3).包的作用
- 组织代码: 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
- 避免名字冲突：如同文件夹一样，包也采用了树形目录的存储方式。
	同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的。
	当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
- 限定访问权限，拥有包访问权限的类才能访问某个包中的类。


一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。

以下是一些 Java 中的包：
	java.lang-打包基础的类
	java.io-包含输入输出功能的函数


开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。

由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。




2. 创建包
(1) 包声明 package
- 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。
- 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。
- 通常使用小写的字母来命名避免与类、接口名字的冲突。


/* 文件名: Animal.java */
package animals;
 
interface Animal {
   public void eat();
   public void travel();
}


接下来，在同一个包中加入该接口的实现：

package animals;
/* 文件名 : MammalImp.java */
public class MammalImp implements Animal{
 
   public void eat(){
      System.out.println("Mammal eats");
   }

}


(2) import 关键字 引入包
- import 语句应位于 package 语句之后，所有类的定义之前
- 可以没有，也可以有多条
- 同一个包内，包名可以省略。
- import payroll.*; 支持通配符

import package1[.package2…].(classname|*);

import payroll.Employee;

如果没有引入，则必须使用全名 payroll.Employee



(3) package 的目录结构
类放在包中会有两种主要的结果：
	包名成为类名的一部分，正如我们前面讨论的一样。
	包名必须与相应的字节码所在的目录结构相吻合。

// 文件名 :  Car.java
package vehicle;
public class Car { }

目录结构: vehicle\Car.java

现在，正确的类名和路径将会是如下样子：
	类名 -> vehicle.Car
	路径名 -> vehicle\Car.java (在 windows 系统中)






3. 编译带包名的类
带包的Java文件的编译: https://www.runoob.com/w3cnote/java-compile-with-package.html

一个公司使用它互联网域名的颠倒形式来作为它的包名，如可以使用 com.biomooc 开头
	一个 com.biomooc.test的包，对应的文件有 com\biomooc\test\Person.java


(1) 文件名: Person.java
package com.biomooc.test;
public class Person {
	public void say(){
		System.out.println("Person.say()");
	}
}
class Animal {}

现在，我们用-d选项来编译这个文件，如下：
$ javac -d . Person.java

编译后的文件：
.\com\biomooc\test\Animal.class
.\com\biomooc\test\Person.class


(2) 在 Hi2.java中引入
package com.biomooc.test;
import com.biomooc.test.*;

public class Hi2{
    public static void main(String[] args){
        Person p1=new Person();
		p1.say();
    }
}


编译
	编译单个文件 $ javac -d . Hi2.java
	编译一个包 $ javac -d . *.java


运行
	只能运行有main入口文件的类名。
	注意，完整类名=包名+类名。
	$ java com.biomooc.test.Hi2
	输出: Person.say()


(3)使用绝对路径编译
	如果使用的-d不是当前目录，比如 -d /home/
	直接运行 java -cp /home/test test.Run，其中源文件在 test 文件夹中，包名为 test，启动文件为 Run.java。

编译：
> F:
F:\> javac -d D:\Desktop\hi\target D:\Desktop\hi\*.java
	解释：第一个 -d 表示保存编译后class文件的路径，要存在该文件夹
		后面要能找到的java文件
运行：
	F:\>java -cp D:\Desktop\hi\target com.biomooc.test.Hi2
	输出: Person.say()
	解释: -cp 就是classpath，不过只在当前命令有效。指定查找class文件的路径。
			也可以配置 ClassPath 路径，但影响全局。
		后面是类的完整名字：包名+类名
		只能运行带有main方法的类。


ref:
https://www.runoob.com/w3cnote/java-compile-with-package.html







========================================
|-- finalize() 方法
----------------------------------------
Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。

例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。

在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。

finalize() 一般格式是：
protected void finalize()
{
   // 在这里终结代码
}

关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。

当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。

package chapter3;

public class FinalizeMethod {
	public static void main(String[] args) {
		Dog2 d1=new Dog2(1);
		Dog2 d2=new Dog2(2);
		Dog2 d3=new Dog2(3);
		
		d2=d3=null;
		System.out.println("invoke gc");
		System.gc(); //调用垃圾收集器
	}
}

class Dog2{
	private int id;
	public Dog2(int id) {
		this.id=id;
		System.out.println("Dog Object "+id+ "is created.");
	}
	
	protected void finalize() throws Throwable {
		super.finalize();
		System.out.println(">> Dog Object "+id+" is disposed.");
	}
}

输出:
Dog Object 1is created.
Dog Object 2is created.
Dog Object 3is created.
invoke gc
>> Dog Object 3 is disposed.
>> Dog Object 2 is disposed.






========================================
常用类: Number, Math, Character 
----------------------------------------
1. 层次结构
Object 
	Boolean: boolean
	Character: char
	Number 
		Byte 包装的是 byte 
		Short: short 
		Integer: int 
		Long: long
		Float: float 
		Double: double

这种由编译器特别支持的包装称为装箱。




2. Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

(1) Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。
	System.out.println("cos(60)="+Math.cos(Math.PI/3));
	System.out.println("1的反正切值:"+Math.atan(1)/Math.PI);
	System.out.println("pi/2的角度值："+Math.toDegrees(Math.PI/2));
	System.out.println("60的弧度值："+Math.toRadians(60)/Math.PI);

(2) Number & Math 类方法
https://www.runoob.com/java/java-number.html

System.out.println("随机数："+Math.random()); //[0,1]随机数

Math 的 floor,round 和 ceil 方法实例比较




3. Character 字符，不是字符串。

(1)Character 类在对象中包装一个基本类型 char 的值

// 原始字符 'a' 装箱到 Character 对象 ch 中
Character ch = 'a';
 
// 原始字符 'x' 用 test 方法装箱
// 返回拆箱的值到 'c'
char c = test('x');

(2) 转义字符 '\t'

(3) Character 方法
序号	方法与描述
1	isLetter()  是否是一个字母
2	isDigit()  是否是一个数字字符
3	isWhitespace()  是否是一个空白字符
4	isUpperCase()  是否是大写字母
5	isLowerCase()  是否是小写字母

6	toUpperCase()  指定字母的大写形式
7	toLowerCase()  指定字母的小写形式
8	toString()  返回字符的字符串形式，字符串的长度仅为1









========================================
Java IO 流：相对于内存，读入内存叫输入(input)，写入硬盘叫输出(output)
----------------------------------------
输入流表示从一个源读取数据，输出流表示向一个目标写数据。



一、按数据来源（去向）分类：  
1、是文件： FileInputStream, FileOutputStream, FileReader, FileWriter  
2、是byte[]：ByteArrayInputStream, ByteArrayOutputStream  
3、是Char[]: CharArrayReader, CharArrayWriter  
4、是String: StringBufferInputStream, StringReader, StringWriter  
5、网络数据流：InputStream, OutputStream, Reader, Writer  


二、按是否格式化输出分：  
1、要格式化输出：PrintStream, PrintWriter  


三、按是否要缓冲分：  
1、要缓冲：BufferedInputStream, BufferedOutputStream, 
	BufferedReader, BufferedWriter  


四、按数据格式分：  
1、二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream及其所有带Stream结束的子类  
2、纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer及其所有带Reader, Writer的子类  



五、按输入输出分：  
1、输入：Reader, InputStream类型的子类  
2、输出：Writer, OutputStream类型的子类  


六、特殊需要：  
1、从Stream到Reader,Writer的转换类：InputStreamReader, OutputStreamWriter  
2、对象输入输出：ObjectInputStream, ObjectOutputStream  
3、进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter  
4、合并输入：SequenceInputStream  
5、更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader  


决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：  
第一，考虑最原始的数据格式是什么：是否为文本？  
第二，是输入还是输出?  
第三，是否需要转换流：InputStreamReader, OutputStreamWriter?  
第四，数据来源（去向）是什么：文件？内存？网络？  
第五，是否要缓冲：bufferedReader （特别注明：一定要注意的是readLine()是否有定义，有什么比read, write更特殊的输入或输出方法）  
第六，是否要格式化输出：print?  











总结二：  
  
首先是java的IO。这破东西可真费事，I/O类库常使用“流(stream)”这种抽象。
所谓“流”是一种能生成或接受数据的，代表数据的源和目标的对象。
流把I/O设备内部的具体操作给隐藏起来了。

正如JDK文档所显示的，Java的I/O类库分成输入和输出两大部分。
所有InputStream和Reader的派生类都有一个基本的，继承下来的，能读取单个或byte数组的read( )方法。

同理，所有OutputStream和Writer的派生类都有一个基本的，能写入单个或byte数组的write( )方法。

但通常情况下，你是不会去用这些方法的；它们是给其它类用的 —— 而后者会提供一些更实用的接口。

因此，你很少会碰到只用一个类就能创建一个流的情形，实际上你得把多个对象叠起来，并以此来获取所需的功能。
Java的流类库之所以会那么让人犯晕，最主要的原因就是“你必须为创建一个流而动用多个对象”。  



Java的IO类结构：  
	根接口是InputStream/OutputStream，
	充当数据源的IO类有 
		FileInputStream/FileOutputStream，
		ByteArrayInputStream  / ByteArrayOutputStream  等，
	充当装饰功能的IO类有
		BufferedInputStream  /   BufferedOutputStream，
		DataInputStream   /   DataOutputStream等，  
	它们都是继承装饰接口 FilterInputStream/FilterOutputStream。

	使用IO时，首先创建一个数据源IO，然后根据需要的功能创建装饰类IO，其构造函数的参数为已创建的数据源IO。
	
	
我们以创建一个具有缓冲的文件输入流为例，假定需要从磁盘读取文件“C:\log.txt”：
	// 创建一个FileInputStream:  
	FileInputStream fileInput = new FileInputStream("C:\\log.txt");  
	// 创建一个BufferedInputStream:  
	BufferedInputStream bufferedInput = new BufferedInputStream(fileInput);  
	// 现在得到的bufferedInput即是具有缓冲的文件输入流  
	
	或者进一步简写如下：  
	InputStream input = new BufferedInputStream(new FileInputStream("C:\\log.txt"));
	// 现在得到的input具有缓冲的文件输入流


java.io.Reader 和 java.io.InputStream 区别
	java.io.Reader 和 java.io.InputStream 组成了 Java 输入类。
	Reader 用于读入16位字符，也就是 Unicode 编码的字符；
	而 InputStream 用于读入 ASCII 字符和二进制数据。

在 Java 中，有不同类型的 Reader 输入流对应于不同的数据源：
    FileReader 用于从文件输入；
    CharArrayReader 用于从程序中的字符数组输入；
    StringReader 用于从程序中的字符串输入；
    PipedReader 用于读取从另一个线程中的 PipedWriter 写入管道的数据。  

相应的也有不同类型的 InputStream 输入流对应于不同的数据源：FileInputStream，ByteArrayInputStream，StringBufferInputStream，PipedInputStream。


另外，还有两种没有对应 Reader 类型的 InputStream 输入流：  
    Socket 用于套接字；  
    URLConnection 用于 URL 连接。  
这两个类使用 getInputStream() 来读取数据。  

相应的，java.io.Writer 和 java.io.OutputStream 也有类似的区别。 




========================================
|-- 控制台 输入与输出，及 Scanner
----------------------------------------
1. 读取控制台输入

BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。

(1) 实例: 用户输入字符，程序逐个输出，直到遇到q停止。

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Hi2 {
	public static void main(String[] args) throws IOException {
		demo1();
	}
	
	//从命令行 读取字符
	private static void demo1() throws IOException {
		// 把System.in 包装在一个 BufferedReader中创建一个字符流
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		System.out.println("输入字符，按下q键退出");
		char c;
		do {
			c=(char) br.read();
			System.out.println(c);
		}while(c!='q');
	}
}


(2) 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。

	//从命令行 读取字符串
	private static void demo2() throws IOException {
		//分两步写
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);
		
		String str;
		System.out.println("输入一行文字，输入一行\"end\"结束");
		do {
			str=br.readLine();
			System.out.println(str);
		}while(!str.equals("end"));
	}



(3) 使用 Java Scanner 类来获取控制台的输入
java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。
创建对象: Scanner s = new Scanner(System.in);

1) 字符与字符串
- 使用 hasNext 与 hasNextLine 判断是否还有输入的数据
- next() 与 nextLine() 方法获取输入的字符串


import java.util.Scanner;
	//接收一个字符出
	private static void demo1() {
		//1.创建
		Scanner scan = new Scanner(System.in);
		
		System.out.println("从键盘输入:");
		//2.判断是否有输入
		if(scan.hasNext()) {
			//3.读取
			String str=scan.next();
			System.out.println("输入的数据为: "+str);
		}
		//4.关闭
		scan.close();
	}


	//读取一行
	private static void demo2() {
		//1.创建
		Scanner scan = new Scanner(System.in);
		
		System.out.println("从键盘输入:");
		//2.判断是否有输入
		if(scan.hasNextLine()) {
			//3.读取
			String str=scan.nextLine();
			System.out.println("输入的数据为: "+str);
		}
		//4.关闭
		scan.close();
	}

next() 与 nextLine() 区别?
- next() 不能带有空格
- nextLine() Enter结束，可以获得空格。


2) 读入整数 nextInt(), hasNextInt()
	//读入整数
	private static void demo3() {
		Scanner scan = new Scanner(System.in);
		System.out.println("Please input an int or float:");
		int i=0;
		float f=0.0f;
		if(scan.hasNextInt()) {
			i=scan.nextInt();
			System.out.println("int:"+ i);
		}else if(scan.hasNextFloat()){
			f=scan.nextFloat();
			System.out.println("float:"+f);
		}else {
			System.out.println("Input Error: not int/float");
		}
		scan.close();
	}

3) 示例：输入多个数，求总和和平均值

	//输入多个数，求总和和平均值
	private static void demo4() {
		Scanner scan = new Scanner(System.in);
		System.out.println("输入数字并回车(输入非数字回车结束输入):");
		double sum=0;
		int m=0;
		
		while(scan.hasNextDouble()) {
			double x=scan.nextDouble();
			m++;
			sum+=x;
		}
		scan.close();
		
		System.out.println("total:"+ sum);
		System.out.println("average:"+ sum/m );
	}

输出:
输入数字并回车(输入非数字回车结束输入):
1 2 3 4 5
.
total:15.0
average:3.0

4) 也可以从文件读取内容
Scanner scanner=new Scanner(new File("src/dustbin/file1.txt"));

	// 从文件读
	private static void demo5() {
		try(Scanner scanner = new Scanner(new File("src/dustbin/file1.txt"))) {
			while(scanner.hasNextLine()){
				System.out.print( scanner.nextLine()+"\n" );
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		System.out.println("Done");		
	}




2. 输出到控制台
(1) write 方法 
注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。
	// 输出到控制台
	private static void demo3() {
		int b='A';
		System.out.write(b);
		System.out.write('\n');
	}






========================================
|-- 文件 及IO流层次
----------------------------------------
3. 读写文件 

一个流被定义为一个数据序列。
输入流用于从源读取数据，输出流用于向目标写数据。

(1)各种流的层次结构图: https://www.runoob.com/java/java-files-io.html
IO流
	字符流
		Reader 
			BufferdReader
			InputStreamReader, FileReader 
			StringReader 
			PipeReader 
			CharArrayReader 
			FilterReader, PushbackReader 
		Writer 
			BufferdWriter
			OutputStreamWriter, FileWriter;
			PriterWriter;
			StringWriter;
			PipedWriter;
			CharArrayWriter;
			FilterWriter;
	字节流
		InputStream 
			FileInputStream;
			FilterInputStream;
				BufferdInputStream;
				DataInputStream;
				PushbackInputStream;
			ObjectInputStream;
			PipedInputStream;
			SequenceInputStream;
			StringBufferedInputStream;
			ByteArrayInputStream;
		OutputStream 
			FileOutputStream;
			FilterOutputStream;
				BufferedOutputStream;
				DataOutputStream;
				PrintStream;
			ObjectOutputStream;
			PipedOutputStream;
			ByteArrayOutputStream;

两个重要的流是 FileInputStream 和 FileOutputStream。



(2) FileInputStream 从文件读入内存
用于读取文件，多种构造方法。

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

	// 多种构造方法
	private static void demo1() throws IOException {
		// 方法1: 文件名字符串.
		//注意：路径是相对于src的！
		//InputStream is=new FileInputStream("src/dustbin/file1.txt");
		
		// 方法2: 
		File f=new File("src/dustbin/file1.txt");
		InputStream is=new FileInputStream(f);
		
		// 打印到屏幕
		int a;
		while( (a=is.read())!=-1 ) {
			System.out.print((char)a);
		}
		is.close();
	}

创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。

序号	方法及描述
1	public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。
2	protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。
3	public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。
4	public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。
5	public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。


除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接：
	ByteArrayInputStream
	DataInputStream


(3) FileOutputStream 内存输出到文件
两个构造方法。
如果文件名不存在，则新建一个。如果有，则覆盖。

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

	// 写文件
	private static void demo2() throws IOException {
		// 方法1 打开文件
		OutputStream os=new FileOutputStream("src/dustbin/file2.txt");
		// 方法2
		File f=new File("src/dustbin/file2.txt");
		//OutputStream os=new FileOutputStream(f);
		
		//开始写入
		char[] arr= {'t', 'h', 'i', 's', ' ', 'i', 's', ' ','a', '.'};
		for(char x : arr) {
			os.write(x);
		}
		
		os.close();
		System.out.println("Done");
	}

创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。

序号	方法及描述
1	public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。
2	protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。
3	public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。
4	public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。

除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接：
	ByteArrayOutputStream
	DataOutputStream


(4) 综合例子: 写入二进制、读取二进制

	// 写入文件3，再读取并打印
	private static void demo3() throws IOException {
		//1. 写入文件
		byte bWrite[]= {11,21,3,40,5};
		OutputStream os=new FileOutputStream("src/dustbin/file3.txt");
		for(int i=0; i<bWrite.length; i++) {
			os.write(bWrite[i]); //write the byte
		}
		os.close();
		
		//2. 读取，并打印到屏幕
		InputStream is=new FileInputStream("src/dustbin/file3.txt");
		int size=is.available();
		System.out.println(size);
		
		for(int i=0; i<size; i++) {
			int x=is.read();
			System.out.println(x+" "+ (char)x); //数字正确读出，有些ascii不可打印
		}
		is.close();
	}


(5) 实例2: 可读写中文，解决乱码
	private static void demo4() throws IOException {
		//1. 写入文件，包含中文
		//打开文件
		File f=new File("src/dustbin/file4.txt");
		FileOutputStream fos=new FileOutputStream(f); //字节流
		
		//字节流转字符流，可指定编码
		OutputStreamWriter writer=new OutputStreamWriter(fos, "UTF-8");
		
		//输入
		writer.append("中文输入");
		writer.append("\r\n");//换行
		writer.append("English line");
		
		//关闭文件
		writer.close();//关闭写入流：缓冲区写入文件
		fos.close(); //关闭输出流
		
		//2. 读取文件
		FileInputStream fis=new FileInputStream(f); //字节流
		InputStreamReader reader=new InputStreamReader(fis, "UTF-8"); //转字符流，可指定编码
		
		StringBuffer sb=new StringBuffer(); //缓冲
		while(reader.ready()) {
			sb.append( (char)reader.read() ); //读取的是字节? 这不是字符流吗? //todo
		}
		
		System.out.println(sb.toString());
		reader.close();
		fis.close();
	}




========================================
|-- 目录与文件 的创建、列举、删除
----------------------------------------
4. 文件和I/O
还有一些关于文件和I/O的类，我们也需要知道：

	File Class(类)
	FileReader Class(类)
	FileWriter Class(类)

(1) 创建目录
import java.io.File;
	private static void demo1() {
		String dirname="src/dustbin/temp";
		File d=new File(dirname);
		if(!d.exists()) { //如果不存在，则新建目录
			d.mkdir();
			System.out.println("Created!");
		}
		System.out.println("done");
	}

Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。
以上路径写法在两个系统是通用的。


(2) 读取目录
一个目录其实就是一个 File 对象，它包含其他文件和文件夹。
isDirectory()  是否是目录
list() 方法 获取文件和文件夹列表

import java.io.File;
	// 读取目录，及其中的文件 和 文件夹
	private static void demo2() {
		String dirname="src/dustbin";
		File f1=new File(dirname);
		if(f1.isDirectory()) {
			System.out.println("目录:"+dirname);
			String s[]=f1.list();
			for(int i=0; i<s.length; i++) {
				File f=new File(dirname+"/"+s[i]);
				if(f.isDirectory())
					System.out.println("  "+s[i]+" 是一个目录");
				else
					System.out.println("  "+s[i]+" 是一个文件");
			}
		}else {
			System.out.println(dirname+"不是一个目录");
		}
		
	}

输出:
目录:src/dustbin
  file1.txt 是一个文件
  file2.txt 是一个文件
  file3.txt 是一个文件
  file4.txt 是一个文件
  temp 是一个目录


(3) 删除目录或文件
java.io.File.delete() 方法。
必须保证该目录下没有其他文件才能正确删除，否则将删除失败。

	// 删除文件或目录，目录必须空
	private static void demo3() {
		File folder=new File("src/dustbin/temp");
		if(folder.list().length==0) {
			folder.delete();
			System.out.println("delete now.");
		}else {
			System.out.println("Not empty");
			deleteR(folder);//如果不是空目录，则递归式删除该文件夹。
		}
	}
	// 删除文件夹，递归式
	private static void deleteR(File fd) {
		File[] files=fd.listFiles(); //只要文件
		if(files != null) {
			for(File f: files) {
				if(f.isDirectory()) {
					deleteR(f);
				}else {
					System.out.println(f+ "\t" +f.isDirectory());
					f.delete();
				}
			}
		}
		System.out.println(fd+ "\t" +fd.isDirectory());
		fd.delete();		
	}






 





========================================
|-- 各种流的总结: 字节流/字符流，文件/内存/管道，性能比较
----------------------------------------
1、Java技术支持两种数据类型的流  
InputStream和OutputStream：字节流。其它字节流都是InputStream或OutputStream的子类。  
Reader和 Writer：字符流。其它字符流都是Reader或Writer的子类。  


2、节点流  
Java 2 SDK中有三种基本类型的节点：文件(file)、内存(memory)、管道(pipe)。  


3、过程流  
过程流在其它流之上，完成排序、变换等操作。过程流也被称做过滤流。  
当你需要改变输入流的原始数据时，你可以将一个过滤输入流连接到一个原始的输入流上。  
用过滤流将原始数据变换成你需要的格式。    


4、基本字节流类  
(1)FileInputStream和FileOutputStream  
	这两个节点流用来操纵磁盘文件。这些类的构造函数允许你指定它们所连接的文件。
	要构造一个FileInputStream，所关联的文件必须存在而且是可读的。
	如果你要构造一个FileOutputStream而输出文件已经存在，则它将被覆盖。
FileInputStream infile = new FileInputStream("myfile.dat");
FileOutputStream outfile = new FileOutputStream("results.dat");

(2) BufferInputStream和BufferOutputStream
这些是过滤器流，它们可以提高I/O操作的效率。

(3) PipedInputStream和PipedOutputStream  
管道流用来在线程间进行通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。  
要使管道流有用，必须有一个输入方和一个输出方。  

(4) DataInputStream和DataOutputStream
这些过滤器通过流来读写Java基本类



5、 基本字符流类  
图阐述了Reader和Writer字符流的体系结构。

(1) InputStreamReader 和 OutputStreamWriter
用于字节流与字符流之间的转换接口。
当你构造一个InputStreamReader或OutputStreamWriter时，转换规则定义了16位Unicode和其它平台的特定表示之间的转换。
InputStreamReader从一个数据源读取字节，并自动将其转换成Unicode字符。
如果你特别声明，InputStreamReade会将字节流转换成其它种类的字符流。
OutputStreamWriter将字符的Unicode编码写到输出流，如果你的使用的不是Unicode字符，OutputStreamWriter会将你的字符编码转换成Unicode编码。


(2) BufferedReader和 BufferedWriter
因为在各种格式之间进行转换和其它I/O操作很类似，所以在处理大块数据时效率最高。
在InputStreamReader和OutputStreamWriter的结尾链接一个BufferedReader和BufferedWriter是一个好主意。
记住对BufferedWriter使用flush()方法。


(3) 使用其它字符转换
如果你需要从一个非本地(例如，从连接到一个不同类型的机器的网络连接读取)的字符编码读取输入，
你可以象下面这个程序那样，使用显式的字符编码构造ir=new InputStreamReader(System.in,  "8859_1");
注：如果你通过网络连接读取字符，就应该使用这种形式。
否则，你的程序会总是试图将所读取的字符当作本地表示来进行转换，而这并不总是正确的。ISO 8859-1是映射到ASCII的Latin-1编码模式。



6、 对象串行化  
java.io.Serializable接口支持将一个Java技术对象存放到一个流中。  
将一个对象存放到某种类型的永久存储器上称为"保持"。
  
如果一个对象可以被存放到磁盘或磁带上，或者可以发送到另外一台机器并存放到存储器或磁盘上，那么这个对象就被称为可保持的。  

java.io.Serializable接口没有任何方法，它只作为一个”标记”，用来表明实现了这个接口的类可以串行化。  

类中没有实现Serializable接口的对象不能被保持。  

// 文件实现追加：  

// 其中的FileWriter()中的第二个参数的含义是: 是否在文件中追加内容  
PrintWriter out = new PrintWriter(new FileWriter(logFileName, true), true);  


Java读写文件最常用的类是FileInputStream/FileOutputStream和FileReader/FileWriter。  
	其中FileInputStream和FileOutputStream是基于字节流的，常用于读写二进制文件。
	读写字符文件建议使用基于字符的FileReader和FileWriter，省去了字节与字符之间的转换。
	但这两个类的构造函数默认使用系统的编码方式，如果文件内容与系统编码方式不一致，可能会出现乱码。  
	在这种情况下，建议使用FileReader和FileWriter的父类：InputStreamReader/OutputStreamWriter，  
	它们也是基于字符的，但在构造函数中可以指定编码类型：InputStreamReader(InputStream in, Charset cs) 和OutputStreamWriter(OutputStream out, Charset cs)。


// 读写文件的编码：  
InputStreamReader ir = new InputStreamReader(new FileInputStream(fileName), "utf-8");
OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(fileName), "utf-8");


/** 
三种IO性能比较: 
在读写一个10k文件的时候，三种方式的耗时如下: 
InputStreamReader And OutputStreamWriter : 63ms (可以设置文件的编码，如果不用buffer) 
BufferedReader And BufferedWriter : 31ms  
BufferedInputStream And BufferedOutputStream : 16ms 
*/  


/** 
* Description: Test the java IO’s efficiency 
* Author: AllanCao 
* Date: 2007-02-18 
*/

import java.io.*;  


/** 
* using the InputStreamReader And OutputStreamWriter 
*/  
class EncoderRW {  
 public static String read(String fileName) throws IOException {  
  StringBuffer sb = new StringBuffer();  
  /*此处读文件时用了buffer，如果不用，性能损失一倍*/  
  BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), “utf-8″));  
  String s;  
  while((s = in.readLine()) != null) {  
    sb.append(s);  
    sb.append(”\n”);  
  }  
  in.close();  
  return sb.toString();  
 }  
 public void write(String fileName, String text) throws IOException {  
  OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(fileName),”utf-8″);  
  out.write(text);  
  out.flush();  
  out.close();  
 }  
}



/** 
* using the BufferedReader And BufferedWriter 
*/  
class WriterReader {  
 public String read(String fileName) throws IOException {  
  StringBuffer sb = new StringBuffer();  
  BufferedReader in = new BufferedReader(new FileReader(fileName));  
  String s;  
  while((s = in.readLine()) != null) {  
    sb.append(s);  
    sb.append(”\n”);  
  }  
  in.close();  
  return sb.toString();  
 }  
 public void write(String fileName, String text) throws IOException {  
  PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));  
  out.print(text);  
  out.close();  
 }  
}  



/** 
* using the BufferedInputStream And BufferedOutputStream 
*/  
class BufferedStream{  
 public byte[] read(String fileName) throws IOException {  
  BufferedInputStream remoteBIS = new BufferedInputStream(new FileInputStream(fileName));  
  ByteArrayOutputStream baos = new ByteArrayOutputStream(10240);  
  byte[] buf = new byte[1024];  
  int bytesRead = 0;  
  while(bytesRead >= 0)  
  {  
   baos.write(buf, 0, bytesRead);  
   bytesRead = remoteBIS.read(buf);  
  }  
  byte[] content = baos.toByteArray();  
  return content;  
 }  
 public void write(String fileName, byte[] content)  throws IOException {  
  BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileName));  
  out.write(content);  
  out.flush();  
  out.close();  
 }  
}  



public class TestIO  
{  
 public static void main(String[] args)throws IOException {  
  long currentTime = System.currentTimeMillis() ;  
  EncoderRW rw = new EncoderRW();  
  rw.write(”index.dat”,rw.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
  
  currentTime = System.currentTimeMillis() ;  
  WriterReader wr = new WriterReader();  
  wr.write(”index.dat”,wr.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
  
  currentTime = System.currentTimeMillis() ;  
  BufferedStream bf = new BufferedStream();  
  bf.write(”index.dat”,bf.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
 }  
}  



//读写文件 
	static void bufferedReaderDemo() throws IOException, InterruptedException{
		//读写文件
		FileReader fr=new FileReader("dustbin//bb.txt");
		FileWriter fw=new FileWriter("dustbin//bb_backup2.txt");
		//加缓冲区
		BufferedReader br=new BufferedReader(fr);
		BufferedWriter bw=new BufferedWriter(fw);
		
		//System.out.print(fr.getEncoding());//UTF8
		char[] cbuf=new char[64];
		int length=0;
		while((length=br.read(cbuf))>0){
			bw.write(cbuf,0,length);
//			fw.flush();//有了这句话是时刻刷新，从缓冲区向文件中保存
		}
		//关闭
		br.close();
		bw.close();
		fr.close();
		fw.close();
	}







========================================
异常 Exception: 异常捕获，或抛出异常
----------------------------------------
1. Java 的异常
异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。

异常发生的原因有很多，通常包含以下几大类：
	用户输入了非法数据。
	要打开的文件不存在。
	网络通信时连接中断，或者JVM内存溢出。

这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-

三种类型
	检查性异常：打开不存在的文件等。在编译时不能被简单地忽略。
	运行时异常：与检查性异常相反，运行时异常可以在编译时被忽略。
	错误：错误不是异常，而是脱离程序员控制的问题。
		错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。



2. Exception 类的层次
父类: java.lang.Exception 

Throwable 类
	Exception
		IOException
			FileNotFoundException
		RuntimeException
			NullPointerException
	Error
		IOError
		OutOfMemoryError


3.Java 内置异常类
https://www.runoob.com/java/java-exceptions.html



4. 异常方法
下面的列表是 Throwable 类的主要方法:

序号	方法及说明
1	public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。
2	public Throwable getCause() 返回一个 Throwable 对象代表异常原因。
3	public String toString() 返回此 Throwable 的简短描述。
4	public void printStackTrace() 将此 Throwable 及其回溯打印到标准错误流。。
5	public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。
6	public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。







========================================
|-- 捕获异常 try...catch...finally
----------------------------------------
5. 捕获异常
使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。

(1) try/catch
try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：

	try
	{
	   // 程序代码
	}catch(ExceptionName e1)
	{
	   //Catch 块
	}
	//最后还有一个可选的 finally{}。无论try是否捕获错误，finally语句一定会执行。通常用来关闭文件、记录日志等。


Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。

如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。

	// 捕获报错: 下表越界
	private static void demo1() {
		try {
			int a[]=new int[2];
			System.out.println("Access a[3]="+a[3]);
		}catch (ArrayIndexOutOfBoundsException  e) {
			System.out.println("Exception thrown: " + e);
		}
		System.out.println("out of the block");
	}


(2) 多重捕获块
try{
   // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}catch(异常类型3 异常的变量名3){
  // 程序代码
}

例子: 	// 多重捕获
	private static int demo3() {
		String fileName="src/dustbin/file10.txt";
		byte x;
		try {
			FileInputStream file = new FileInputStream(fileName);
			x=(byte) file.read();
		}catch (FileNotFoundException  e) {
			e.printStackTrace();
			return -1;
		}catch (IOException  e) {
			e.printStackTrace();
			return -1;
		}
		return x; //116 - t
	}


(3) finally关键字
try{
  // 程序代码
}catch(异常类型1 异常的变量名1){
  // 程序代码
}catch(异常类型2 异常的变量名2){
  // 程序代码
}finally{
  // 程序代码
}

无论是否发生异常，finally 代码块中的代码总会被执行。
在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。


注意: 
	catch 不能独立于 try 存在。
	在 try/catch 后面添加 finally 块并非强制性要求的。
	try 代码后不能既没 catch 块也没 finally 块。
	try, catch, finally 块之间不能添加任何代码。



(4) try-with-resource
JDK7 之后，Java 新增的 try-with-resource 语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 。
JDK7 之前所有被打开的系统资源，比如流、文件或者 Socket 连接等，都需要被开发者手动关闭，否则将会造成资源泄露。

	try (resource declaration) {
	  // 使用的资源
	} catch (ExceptionType e1) {
	  // 异常块
	}

以上的语法中 try 用于声明和实例化资源，catch 用于处理关闭资源时可能引发的所有异常。
例1: 注意：try-with-resource 语句关闭所有实现 AutoCloseable 接口的资源。

	// try-with-resource from JDK1.7
	private static void demo1() {
		String line, fileName="src/dustbin/file10.txt";
		try(BufferedReader br=new BufferedReader(new FileReader(fileName))){
			while( (line=br.readLine())!=null) {
				System.out.println("line=>"+line);
			}
		}catch (IOException e) {
			System.out.println("IOException in try block=>"+ e.getMessage());
		}
	}
输出: IOException in try block=>src\dustbin\file10.txt (系统找不到指定的文件。)
以上代码会自动关闭try中打开的资源。

例2: 不使用 try-with-resources 而改成 finally 来关闭资源，整体代码量多了很多，而且更复杂繁琐了：

	// 使用try...catch...finally则要繁琐很多，需要两次try catch
	private static void demo2() {
		String line, fileName="src/dustbin/file10.txt";
		
		BufferedReader br=null;
		try{
			System.out.println("> Enter try block");
			br=new BufferedReader(new FileReader(fileName));
			while( (line=br.readLine())!=null) {
				System.out.println("line=>"+line);
			}
		}catch (IOException e) {
			System.out.println("IOException in try block=>"+ e.getMessage());
		}finally {
			System.out.println("> Enter finally block");
			try {
				if(br != null) {
					br.close(); //关闭可能有异常，所以需要再次捕获
				}
			} catch (IOException e) {
				System.out.println("IOException in finally block=>" + e.getMessage());
			}
		}
	}


(5) try-with-resource 处理多个资源，使用;分割
	private static void demo3() {
		// 打开2个资源，Scanner作为输入，读取文件;
		// 写入 文件 PringWriter 
		try(Scanner scanner=new Scanner(new File("src/dustbin/file1.txt"));
				PrintWriter writer=new PrintWriter(new File("src/dustbin/fileP.txt"))
				){
			while(scanner.hasNext()) {
				String str=scanner.nextLine();
				System.out.println(str);
				writer.print( str+"\n" ); //如何保证换行？
			}
		}catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println("Done");
	}








========================================
|-- 抛出异常 throws/throw 关键字
----------------------------------------
3. 抛出异常 throws/throw 关键字

(1) throw 关键字用于在代码中抛出异常，
而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。

	// 抛出异常，代码中使用 throw
	private static void demo1(int i) {
		if(i<=0) {
			throw new IllegalArgumentException("Number must be positive!");
		}
	}


(2) throws 关键字用于在方法声明中指定该方法可能抛出的异常。
当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。

public class ThrowDemo {
	public static void main(String[] args) throws IOException {
		demo2();
	}

	// 方法声明种使用 throws 关键字
	private static void demo2() throws IOException {
		BufferedReader reader=new BufferedReader(new FileReader("src/dustbin/file1.txt"));
		String line=reader.readLine();
		while(line != null) {
			System.out.println(line);
			line=reader.readLine();
		}
		reader.close();		
	}
}

异常会传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。
文件读方法可能异常，
	所以该方法必须声明 throws 异常，
		引用该方法的main也必须声明 throws 异常。


(3) throws 多个异常，用逗号隔开
import java.io.*;
public class className
{
   public void withdraw(double amount) throws RemoteException,
                              InsufficientFundsException
   {
       // Method implementation
   }
   //Remainder of class definition
}



========================================
|-- 自定义异常，与通用异常
----------------------------------------
1. 在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。
	所有异常都必须是 Throwable 的子类。
	如果希望写一个检查性异常类，则需要继承 Exception 类。
	如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。

自定义异常类: 
class MyException extends Exception{
}


(1) 自定义异常类
/**
 * 自定义异常
 * @author admin
 *
 */
class MyException extends Exception{
	String msg="";

	private static final long serialVersionUID = 1L;
	public MyException(){}
	public MyException(String s){
		super(s);
		this.msg=s; 
		System.out.println("1. my own exception...happened");
	}
	
	//自定义异常可以自定义方法
	public void say(String word){
		System.out.println("2. 异常信息Say："+this.msg);
		System.out.println("3 "+word);
	}
}

(2) 在函数readArray中抛出该异常

	//使用自定义异常
	public static void readArray(int[] arr) throws MyException{
		try{
			System.out.println(arr[arr.length+1]);
		}catch(Exception e){
			//处理不了，就抛出给上层处理
			throw new MyException("遇到 数组下标越界 异常");
		}
	}

(3) 使用上述函数 readArray
	public static void main(String[] args){
		//抛出异常
		int[] a={1,2,3};
		try {
			readArray(a); //这里不得不处理了，否则就中断。
		} catch (MyException e) {
			//e.printStackTrace();
			e.say(e.toString());//异常的可调用方法
			System.out.println("4. 异常信息是： "+e.getMessage());
		}finally{
			System.out.println("5.--- end ---");
		}
	}

(4) 输出
1. my own exception...happened
2. 异常信息Say：遇到 数组下标越界 异常
3 chapter4.MyException: 遇到 数组下标越界 异常
4. 异常信息是： 遇到 数组下标越界 异常
5.--- end ---






2. 通用异常
在Java中定义了两种类型的异常和错误。

JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。

程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。















========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------

