MyBatis: 是一个数据持久层框架

javaEE
	表现层
	业务层
	持久层


前置知识： JDBC
	无论是什么的ORM框架（Object Relation Mapping）其实都是在JDBC上封装了一层，底层用的都是JDBC的代码。
	Mybatis作为一个ORM框架，在市面上非常受欢迎，只要有JDBC基础，学会用很简单。



竞争框架：
	手写SQL
	DBUtils
	我觉得 JdbcTemplate 非常好用
	Mybatis 
	Hibernate
	SpringData JPA
		SpringDataJPA 在自动化方面 几乎是吊打mybaits跟那些狗屁插件，甚至连一句SQL都不用写，DDL都可以省了，但是所有的表结构都是高度针对Java对象模型的，对OLAP并不友好
		大家穷尽智力，经过无数次尝试也没能写出对比Hibernate有稳定性能提升的SQL，最后都通过修改表设计、分区、分库分表、业务方妥协或者整体架构的变动来解决性能问题。

		我的经验告诉我，业务复杂到一定程度的时候，对比徒手写SQL和Hibernate自动生成SQL的效率是一种很愚蠢且没有意义的行为，因为决定效率的不是SQL本身，而是整个系统设计、实施的问题。
		如果你的数据库架构很烂，再高的SQL水平也写不出能好的性能。





========================================
MyBatis 简介
----------------------------------------
1. 简介 
(1)官网
https://github.com/mybatis

https://mybatis.org/mybatis-3/ 文档很好
https://mybatis.net.cn/

(2)什么是 MyBatis？
MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。


动态sql
缓存
Mapper代理
逆向工程：通过表的结构，生成我们自己的JavaBean以及对应的Mapper接口和Mapper映射文件。

Mybatis-plus又是程序员偷懒造出的轮子：这款插件说实话我没用过，看了一下官网，大致就是：简单的CRUD，我连XML都不需要了，API直接帮我们内置了对应的CRUD方法


jdbc 的缺点： MyBatis 怎么简化？
	硬编码：
		用户名、密码 -> 写到xml配置文件中，可维护性很强
		SQL语句  -> 抽取到 xml 中
	操作繁琐：
		手动设置参数  -> 后台封装
		手动解析封装结果 -> 后台封装

MyBatis 几乎免除了所有 JDBC 设置参数和解析结果的工作。




(3) 教程

官方教程：
https://mybatis.org/mybatis-3/getting-started.html

https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases
https://mybatis.net.cn/getting-started.html

https://blog.csdn.net/lsl5713/article/details/124451398





学习方法: 一两周就可以上手，后面在工作中不断地使用，同时把MyBatis官方文档完整的看上两三遍，定能完全掌握MyBatis。
	http://www.mybatis.cn/archives/789.html



2. mybatis 做了什么？
https://zhuanlan.zhihu.com/p/260090982

(1)mybatis-config.xml是Mybatis的核心配置文件，通过其中的配置可以生成SqlSessionFactory,也就是SqlSession工厂

(2)基于SqlSessionFactory可以生成SqlSession对象

(3)SqlSession是一个既可以发送SQL去执行，并返回结果，类似于JDBC中的Connection对象，也是Mybatis中至关重要的一个对象。

(4)Executor是SqlSession底层的对象，用于执行SQL语句

(5)MapperStatement对象也是SqlSession底层的对象，用于接收输入映射（SQL语句中的参数），以及做输出映射（即将SQL查询的结果映射成相应的结果）





3.使用步骤

(1) 使用传统方式JDBC访问数据库：
	1)使用JDBC访问数据库有大量重复代码（比如注册驱动、获取连接、获取传输器、释放资源等）；
	2)JDBC自身没有连接池，会频繁的创建连接和关闭连接，效率低；
	3)SQL是写死在程序中，一旦修改SQL，需要对类重新编译；
	4)对查询SQL执行后返回的ResultSet对象，需要手动处理，有时会特别麻烦；
	...


(2) 使用mybatis框架访问数据库：

	1)Mybatis对JDBC做了封装，可以简化JDBC代码；
	2)Mybatis自身支持连接池（也可以配置其他的连接池），因此可以提高程序的效率；
	3)Mybatis是将SQL配置在mapper文件中，修改SQL只是修改配置文件，类不需要重新编译。
	4)对查询SQL执行后返回的ResultSet对象，Mybatis会帮我们处理，转换成Java对象。
	...

总之，JDBC中所有的问题（代码繁琐、有太多重复代码、需要操作太多对象、释放资源、对结果的处理太麻烦等），在Mybatis框架中几乎都得到了解决！！





========================================
MyBatis 快速入门 (IDEA 社区版)
----------------------------------------
https://www.bilibili.com/video/BV1MT4y1k7wZ/?p=2

目录:
	Mapper 代理开发
	MyBatis 核心配置文件
	增删改查：基于xml配置文件
	增删改查：基于注解
	动态SQL


1. 创建项目

目标：查询user表中所有数据

步骤：
	1 创建user表，添加数据
	2 创建模块，导入坐标
	3 编写MyBatis核心配置文件 --> 替换连接信息，解决硬编码问题
	4 编写SQL映射文件 --> 统一管理sql语句，解决硬编码问题
	5 编码：
		1 定义pojo类
		2 加载核心配置文件，获取 SqlSessionFactory 对象
		3 获取 SqlSession 对象，执行SQL语句
		4 释放资源


(0) 找一个测试mysql服务

1) 使用Ubuntu上的，版本号：
$ mysql --version
mysql  Ver 8.0.32-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu))
查询默认用户名和密码
	$ sudo cat /etc/mysql/debian.cnf 
	上面，password后面的就是默认密码。
	Server version: 8.0.32-0ubuntu0.20.04.2 (Ubuntu)


用老版本吧，新版本改动太多，不太会。
2) 改用 ubuntu上的docker版，宿主机7070端口映射到容器的3306。
root@b919662117cc:/# mysql --version
mysql  Ver 14.14 Distrib 5.7.18, for Linux (x86_64) using  EditLine wrapper

登录
root@b919662117cc:/# mysql -h y.biomooc.com -P 7070 -u root -p
Enter password: 123456
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 5.7.18 MySQL Community Server (GPL)

切换数据库:
mysql> use mysql;
mysql> select Host, User, authentication_string from user;
+-----------+-----------+------------------ ------------------------+
| Host      | User      | authentication_string                     |
+-----------+-----------+------------------- -----------------------+
| localhost | root      | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
| localhost | mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| %         | root      | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
| %         | wp        | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
| %         | yanpd     | *A20A1D957DC042DF8559A2FD83641CE96742B4D7 |
+-----------+-----------+-------------------- ----------------------+

win10上使用xampp的mysql进行远程连接
> mysql -h y.biomooc.com -P 7070 -u root -p
密码 123456
连接成功。




(1) 创建user表，添加数据

create database mybatis;
use mybatis;
drop table if exists tb_user;

create table tb_user(
	id int primary key auto_increment,
	username varchar(20),
	password varchar(20),
	gender char(1),
	addr varchar(30)
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into tb_user values(1, "zhangsan", "123", "M", "北京");
insert into tb_user values(2, "Lily", "234", "F", "广州"), (3, "王五", "345", "M", "上海");


查询:
MySQL [mybatis]> select * from tb_user;
+----+----------+----------+--------+------+
| id | username | password | gender | addr |
+----+----------+----------+--------+------+
|  1 | zhangsan | 123      | M      | 北京 |
|  2 | Lily     | 234      | F      | 广州 |
|  3 | 王五     | 345      | M      | 上海 |
+----+----------+----------+--------+------+
3 rows in set (0.00 sec)





(2) 创建模块，导入坐标
IDEA 社区版
1) 创建父工程
菜单 File - new - project
	Name: MyBatis-demo
	Location: G:\java_code\LearnSpring5
	Java - Maven - jdk17
	adv:
		GroupId: com.mio
		ArtifactId: MyBatis-demo
	在当前窗口打开。


2) 在父工程中引入依赖
$ cat pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mio</groupId>
    <artifactId>MyBatis-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>


    <dependencies>
        <!-- mybatis 3 的依赖 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.13</version>
        </dependency>

        <!-- mysql 的依赖 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.49</version>
        </dependency>

        <!-- junit 的依赖 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>


        <!-- slf4j 日志api -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.5</version>
        </dependency>

        <!-- logback-classic 依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.6</version>
        </dependency>

        <!-- logback-core 依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
            <version>1.4.6</version>
        </dependency>

    </dependencies>
    
</project>



3) 创建子模块
右击项目 - new - New Module:
	Name: demo1
	Location: G:\java_code\LearnSpring5\MyBatis-demo(默认)
	Java - Maven - jdk17
	Parent: MyBatis-demo(默认)
	adv:(和父工程一致)
		com.mio
		demo1
	点击create



4) logback 还需要配置文件(接着都在子模块中操作)

内容一会补充
$ cat src/main/resources/logback.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--    console表示当前日志信息是可以输出到控制台的-->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>【%level】  %cyan(【%thread】) %boldGreen(%logger{15}) - %msg %n</pattern>
        </encoder>
    </appender>
    <logger name="com.Carter_x" level="DEBUG" additivity="false">
        <appender-ref ref="Console"/>
    </logger>
</configuration>




(3) 编写MyBatis核心配置文件 --> 替换连接信息，解决硬编码问题
https://mybatis.org/mybatis-3/getting-started.html

$ cat src/main/resources/mybatis-config.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <!-- mysql 连接信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://y.biomooc.com:7070/mybatis?useSSL=false"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>

            </dataSource>
        </environment>
    </environments>

    <mappers>
        <!-- SQL 映射文件 -->
        <mapper resource="UserMapper.xml"/>
    </mappers>
</configuration>








(4) 编写SQL映射文件 --> 统一管理sql语句，解决硬编码问题
$ cat resources/UserMapper.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mio.UserMapper">
    <select id="selectAll" resultType="com.mio.pojo.User">
        select * from tb_user;
    </select>
</mapper>




(5) 编码：
	0 定义pojo类

	1 加载核心配置文件，获取 SqlSessionFactory 对象
	2 获取 SqlSession 对象
	3 执行SQL语句
	4 释放资源


创建实体类
$ cat User.java
package com.mio.pojo;

public class User {
    private Integer id;
    private String username;
    private String password;
    private String gender;
    private String addr;

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", gender='" + gender + '\'' +
                ", addr='" + addr + '\'' +
                '}';
    }
    //...get/set略
}


测试类
$ cat TestUser.java
package com.mio.pojo;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

// MyBatis 快速入门
public class TestUser {
    public static void main(String[] args) throws IOException {
        //https://mybatis.org/mybatis-3/getting-started.html
        //1.加载核心配置文件，获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);

        //2.获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3.执行SQL语句
        List<User> users = sqlSession.selectList("com.mio.UserMapper.selectAll");
        System.out.println(users);

        //4.释放资源
        sqlSession.close();
    }
}

输出:
[
User{id='1', username='zhangsan', password='123', gender='M', addr='北京'}, 
User{id='2', username='Lily', password='234', gender='F', addr='广州'}, 
User{id='3', username='王五', password='345', gender='M', addr='上海'}]


终于成功输出！



小结：除了两句常用，其他都是一次性代码/操作。
        //2.获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3.执行SQL语句
        List<User> users = sqlSession.selectList("com.mio.UserMapper.selectAll"); //这里是SQL语句对应的 命名空间+名字





========================================
|-- 在IDEA中配置数据库 //todo
----------------------------------------

社区版貌似没有这个功能，先跳过：https://www.bilibili.com/video/BV1MT4y1k7wZ/?p=3
	现在就动辄崩溃，安装太多插件更容易崩溃了！

有更强的SQL语句提示。




========================================
|-- mapper 代理开发
----------------------------------------

1. 问题
这个找SQL语句的写法依旧存在硬编码："com.mio.UserMapper.selectAll"
	//3.执行SQL语句
    List<User> users = sqlSession.selectList("com.mio.UserMapper.selectAll"); //这里是SQL语句对应的 命名空间+名字

更好的方法是啥呢？
	Mapper 代理开发。


(2)官方示例 https://mybatis.org/mybatis-3/getting-started.html

	try (SqlSession session = sqlSessionFactory.openSession()) {
	  Blog blog = session.selectOne(
	    "org.mybatis.example.BlogMapper.selectBlog", 101);
	}

	更好的写法
	try (SqlSession session = sqlSessionFactory.openSession()) {
	  BlogMapper mapper = session.getMapper(BlogMapper.class);
	  Blog blog = mapper.selectBlog(101);
	}






2. 使用Mapper 代理开发的几个步骤

(0) 准备子模块 demo2
win文件夹中复制子模块 demo1，粘贴改名为 demo2。
	IDEA社区版中右击模块2，Open module settings, Name 改名为 demo2
	修改子模块 pom.xml文件: <artifactId>demo2</artifactId>
在父项目中配置上子模块名字
    <modules>
        <module>demo1</module>
        <module>demo2</module>
    </modules>
接着在demo2中操作。



(1) 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放到同一个目录下。

$ cat UserMapper.java
package com.mio.mapper;

public interface UserMapper {
}

怎么将mapper接口和映射文件放到同一个目录呢？
	- [x]要么将xml文件移动到 com.mio.mapper 下：不好！因为代码和配置文件混合了，不好维护。
	- [√]要么给xml放到一个同样的目录结构中：比如 resources/com/mio/mapper/xx.xml，最后编译完还是放到一个文件夹中。
		注意： 右击 resources/ 新建是目录，需要输入/而不是.
		使用右上角 maven 的Lifecycle:compile，编译后显示class文件夹，点开发现确实是一起的:
			demo2\target\classes\com\mio\mapper\UserMapper.class
			demo2\target\classes\com\mio\mapper\UserMapper.xml



(2) 设置SQL映射文件的namespace属性为Mapper接口全限定名。
$ cat resources/com/mio/mapper/UserMapper.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mio.mapper.UserMapper">         #<=========这一行使用接口的 全路径+接口名
    <select id="selectAll" resultType="com.mio.pojo.User">
        select * from tb_user;
    </select>
</mapper>


(3) 更新MyBatis的配置文件：
右击配置文件 UserMapper.xml，copy path，path from source root: com/mio/mapper/UserMapper.xml
粘贴到 resources/mybatis-config.xml 中:
    <mappers>
        <!-- SQL 映射文件 -->
        <mapper resource="com/mio/mapper/UserMapper.xml"/>
    </mappers>


进一步的优化：
	如果坚持满足三个条件：本文的(1)(2)(4)，则mybatis-config.xml中引入mapper的方法可简化为：
	<mappers>
        <!-- Mapper 代理方式 -->
        <package name="com.mio.mapper"/>
    </mappers>
    好处是，不管以后有多少mapper，都不用再添加了。



(4) 在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致。
$ cat UserMapper.java
package com.mio.mapper;

import com.mio.pojo.User;

import java.util.List;

public interface UserMapper {

    List<User> selectAll(); //返回值类型：一个用User，很多个用List<User>
}


(5) 编码测试
	通过 SqlSession 的 getMapper 方法获取 Mapper 接口的代理对象
	调用对应方法完成sql执行。

$ cat TestUser.java
package com.mio.pojo;

import com.mio.mapper.UserMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

// MyBatis 的代理开发
public class TestUser {
    public static void main(String[] args) throws IOException {
        //https://mybatis.org/mybatis-3/getting-started.html
        //1.加载核心配置文件，获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);

        //2. 获取 SqlSession 对象，用它来执行sql
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3.1 获取 UserMapper 接口的代理方法
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        //3.2 执行方法
        List<User> users = mapper.selectAll();
        System.out.println(users);

        //4. 释放资源
        sqlSession.close();

    }
}

输出：
[User{id='1', username='zhangsan', password='123', gender='M', addr='北京'}, 
User{id='2', username='Lily', password='234', gender='F', addr='广州'}, 
User{id='3', username='王五', password='345', gender='M', addr='上海'}]


流程分析:
	读取mybatis配置文件，获取 甩手掌柜 SqlSessionFactory 对象
	打开 session 会话。
	会话获取 mapper 代理对象，读取该接口同目录下xml文件
	调用接口中定义的方法：实质是xml中定义的sql语句的id

好处是：容易维护。



========================================
MyBatis 核心配置文件： mybatis-config.xml
----------------------------------------

看官网介绍： https://mybatis.org/mybatis-3/configuration.html
	中文: https://mybatis.org/mybatis-3/zh/configuration.html

configuration 配置（注意：配置时要按照这个先后顺序，顺序乱了会报错！）
	properties 属性
	settings 设置
	typeAliases 类型别名
	typeHandlers 类型处理器
	objectFactory 对象工厂
	plugins 插件
	environments 环境配置
		environment 环境变量
			transactionManager 事务管理器
			dataSource 数据源
	databaseIdProvider 数据库厂商标识
	mappers 映射器




1. mappers 已经讲过，有几种写法

<!-- Using classpath relative resources --> 相对class路径
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
</mappers>

<!-- Using url fully qualified paths --> 文件绝对路径
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
</mappers>

<!-- Using mapper interface classes --> 接口全名
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
</mappers>


最省劲的写法：
<!-- Register all interfaces in a package as mappers -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>






2. environments 环境
注意：可以配置多个，但是每个 SqlSessionFactory 实例只能选择一种环境。
	开发环境 dev 很小
	测试环境 test 中等
	生产环境 pro 巨大数据量

<!-- 配置数据库的连接环境，可配置多个environment，通过default属性切换某一个的id -->

	<environments default="development">  #<=== 修改这里，在环境id之间切换，就可以修改数据源
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <!-- mysql 连接信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://y.biomooc.com:7070/mybatis?useSSL=false"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>

            </dataSource>
        </environment>

	  <environment id="test">
	    <transactionManager type="JDBC">
	      <property name="..." value="..."/>
	    </transactionManager>
	    <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://y.biomooc.com:3306/mybatis?useSSL=false"/>
                <property name="username" value="tom"/>
                <property name="password" value="123456"/>
	    </dataSource>
	  </environment>
	</environments>

其中 transactionManager 事务会被spring接管，
数据库连接池 dataSource 也会被 spring 接管。






3. typeAliases 类型别名

(1) 文档
	<typeAliases>
	  <typeAlias alias="Author" type="domain.blog.Author"/>
	  <typeAlias alias="Blog" type="domain.blog.Blog"/>
	</typeAliases>
当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。


【推荐方法】 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：
	<typeAliases>
	  <package name="domain.blog"/>
	</typeAliases>


其他内置类的别名：
https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases


(2) 操作
mapper/下有很多冗余写法，比如 全类名：
	<mapper namespace="com.mio.mapper.UserMapper">
	    <select id="selectAll" resultType="com.mio.pojo.User">
	        select * from tb_user;
	    </select>
	</mapper>


如果在 mybatis-config.xml 设置了：
    <!-- 类型别名，方便xml中返回类型不用加这个前缀，变 com.mio.pojo.User 为 User； 该设置要放到mapper 前面，甚至最前面 -->
    <typeAliases>
        <package name="com.mio.pojo"/>
    </typeAliases>



则 mapper/ 就可以省略 com.mio.pojo.User 的包前缀，直接使用 User(不区分大小写，不过习惯上类名使用大写):
	<mapper namespace="com.mio.mapper.UserMapper">
	    <select id="selectAll" resultType="User">
	        select * from tb_user;
	    </select>
	</mapper>



4. 注意：这些配置是有先后顺序的！






========================================
完成增删改查：基于xml配置文件
----------------------------------------
https://www.bilibili.com/video/BV1MT4y1k7wZ/?p=6

1. 案例效果：品牌数据的增删改查

(1) 配置文件完成增删改查

查询
	查询所有数据
	查看详情
	条件查询
添加
修改
	修改全部字段
	修改动态字段
删除
	删除一个
	批量删除：多个






2. 环境准备
	数据库表 tb_brand
	实体类 Brand
	测试用例
	安装 MyBatisX插件


(1) 数据库表 tb_brand
注意：使用win客户端才能避免中文乱码，直接用Ubuntu的命令行会中文丢失。
G:\xampp\mysql\bin> mysql -h 192.168.2.120 -P 7070 -u tom -p
> use mybatis;

drop table if exists tb_brand;

create table tb_brand(
	id  int primary key auto_increment,
	brand_name varchar(20),
	company_name varchar(20),
	ordered int,
	description varchar(100),
	status int
) charset=utf8;

insert into tb_brand(brand_name, company_name, ordered, description, status)
values('三只松鼠', '三只松鼠股份有限公司', 5, '好吃的干果', 0),
	('化为', 'huawei技术有限公司', 100, '数字技术领域领头羊', 1),
	('小米', '小米科技有限公司', 50, 'are you ok?', 1);

select * from tb_brand;


登录docker，使用命令行登录mysql: 确实没有中文。
root@b919662117cc:/# mysql -u root -h localhost -p
> use mybatis;
> insert into tb_brand(brand_name, company_name, ordered, description, status)
values('百目网', '百目科技有限公司', 2, '你喜欢的慕课', 1);



(2) 实体类 Brand
$ cat Brand.java
package com.mio.pojo;

public class Brand {
    private Integer id;
    private String brandName;
    private String companyName;
    private Integer ordered;
    private String description;
    private Integer status;

    @Override
    public String toString() {
        return "Brand{" +
                "id=" + id +
                ", brandName='" + brandName + '\'' +
                ", companyName='" + companyName + '\'' +
                ", ordered=" + ordered +
                ", description='" + description + '\'' +
                ", status=" + status +
                '}';
    }
    //... 省略 get/set
}


(3) 测试用例
写到 src/test/java/下
$ cat MyBatisTest.java
package com.mio.test;

public class MyBatisTest {
}

后面再写内容。


(4) 安装 MyBatisX插件
这是一个为 效率 而生的插件。
问题：UserMapper.xml和UserMapper.java 映射文件 和 接口文件 要反复切换着查看，怎么避免呢？该插件能在xml中直接跳转到接口对应方法中。

安装方法：
	菜单File-settings, 左侧选择 plugins，右侧搜索 mybatisx，点击 install。

使用方法:
	1) 代码左边有跳转按钮，可以在java和xml之间跳转。
	2) 在xml中写方法签名: User selectById(int id); 鼠标悬浮，选择 Generate statement:
		跳转到 xml中，自动生成:  <select id="selectById" resultType="com.mio.pojo.User"></select>
	补充完整：
    <select id="selectById" resultType="User">
        select *
        from tb_user where id=#{id};
    </select>






3. 查询：所有数据

(1) 编写接口方法：Mapper 接口
	参数：无
	结果：List<Brand>

复制粘贴 UserMapper.java。
$ cat BrandMapper.java
package com.mio.mapper;

import com.mio.pojo.User;

import java.util.List;

public interface BrandMapper {

    List<Brand> selectAll();

    Brand selectById(int id);
}


(2) 编写SQL语句：SQL映射文件
复制粘贴 UserMapper.xml
$ cat BrandMapper.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mio.mapper.BrandMapper">
    <!-- statement 语句 -->
    <select id="selectAll" resultType="brand">
        select * from tb_brand;
    </select>
    <select id="selectById" resultType="brand">
        select *
        from tb_brand where id=#{id};
    </select>
</mapper>


(3) 执行方法，测试

$ cat MyBatisTest.java
package com.mio.test;

import com.mio.mapper.BrandMapper;
import com.mio.pojo.Brand;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

public class MyBatisTest {
    @Test
    public void testSelectAll() throws IOException {
        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 个人重点写的就是接口方法名，和对应xml中的sql语句。
        List<Brand> brands = mapper.selectAll();
        System.out.println(brands);

        Brand brand = mapper.selectById(2);
        System.out.println(brand);

        //5.释放资源
        sqlSession.close();
    }
}

输出:
[Brand{id=1, brandName='null', companyName='null', ordered=5, description='好吃的干果', status=0}, Brand{id=2, brandName='null', companyName='null', ordered=100, description='数字技术领域领头羊', status=1}, Brand{id=3, brandName='null', companyName='null', ordered=50, description='are you ok?', status=1}, Brand{id=4, brandName='null', companyName='null', ordered=2, description='', status=1}]

Brand{id=2, brandName='null', companyName='null', ordered=100, description='数字技术领域领头羊', status=1}


(4)总结：Mybatis 完成操作需要几步？
	三步：编写接口方法，编写sql，执行方法。





========================================
|-- 实体类 属性名 和 数据表 字段名不一致怎么办？ resultMap 标签
----------------------------------------

(5) 问题：输出结果为什么有null？
因为数据库字段名 brand_name，而java pojo的属性名是 brandName，不能一一对应上。无法自动封装。

怎么对应上？
	三个方案:
		sql中取别名: select name as stuName ...
		sql片段;
		方案3 最常用：resultMap。包括2个步骤：定义 resultMap标签, 使用 resultMap属性。具体见下文示例。


$ cat BrandMapper.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mio.mapper.BrandMapper">
    <!-- statement 语句 -->

    <!-- 数据库字段名 和 pojo 属性名不一致，数据不能自动封装
        * 方案1：使用别名，让别名和 pojo 属性名一致：每次查询都要写一次，重复
        * 方案2：使用sql片段，就是把重复的部分定义到一个标签内，下次引用。这可能导致一堆sql片段，不灵活
        * 方案3：resultMap，最常用的方案。
    <sql id="brand_column">
        id, brand_name as brandName, company_name as companyName, ordered, description, status
    </sql>

    <select id="selectAll" resultType="brand">
        select
            <include refid="brand_column"></include>
        from tb_brand;
    </select>
     -->

    <!-- 步骤：1.定义resultMap标签，2.在select查询标签中使用resultMap属性替换resultType
        id: 唯一标示
        type: 原来select标签的 resultType，支持别名
    -->
    <resultMap id="brandResultMap" type="brand">
        <!-- 完成映射 column 表的字段名，property 实体类的属性名
            id: 完成主键字段的映射
            result: 一般字段的映射
        -->
        <result column="brand_name" property="brandName"></result>
        <result column="company_name" property="companyName"></result>
    </resultMap>

    <select id="selectAll" resultMap="brandResultMap">
        select *
        from tb_brand;
    </select>


	<!-- <select id="selectById" resultType="brand"> -->
    <select id="selectById" resultMap="brandResultMap">
        select *
        from tb_brand where id=#{id};
    </select>
</mapper>


输出结果:
[Brand{id=1, brandName='三只松鼠', companyName='三只松鼠股份有限公司', ordered=5, description='好吃的干果', status=0}, Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}, Brand{id=3, brandName='小米', companyName='小米科技有限公司', ordered=50, description='are you ok?', status=1}, Brand{id=4, brandName='', companyName='', ordered=2, description='', status=1}]

Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}






========================================
|-- 按id查询：怎么在xml中sql传递参数？ 
----------------------------------------
按步骤，主要是写接口，然后写sql语句。
	这部分已经写过了，见上文。
	这里又重新写了一遍。
重点：怎么打印sql语句？



1. 写接口
src/main/java/目录下
$ cat BrandMapper.java 
package com.mio.mapper;
    Brand selectById(int id); //添加这一行


2. 写sql语句
src/main/resources/目录下，包路径同接口

定义 字段-属性映射 resultMap(selectAll已定义)，其id="brandResultMap" 是标识符;
使用该属性：resultMap="brandResultMap"
sql中使用 #{id} 接收接口中的参数 int id。

$ cat BrandMapper.xml
    <resultMap id="brandResultMap" type="brand">
        <!-- 完成映射 column 表的字段名，property 实体类的属性名
            id: 完成主键字段的映射
            result: 一般字段的映射
        -->
        <result column="brand_name" property="brandName"></result>
        <result column="company_name" property="companyName"></result>
    </resultMap>

    <select id="selectById" resultMap="brandResultMap">
        select *
        from tb_brand where id=#{id};
    </select>


3. 测试运行结果
测试代码，不一样的就这一行：
        Brand brand = mapper.selectById(2);
        System.out.println(brand);
结果：
	Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}




4. xml中的技术细节
(1) 参数占位符#{}和${}的区别？
参数占位符：
    1). #{} 替换为?，为了防止SQL注入【传参时用#{}】
    2). ${} 拼接参数，会存在SQL注入问题，不安全；速度会快一点
    使用场合：
        * 用户参数传递：使用 #{}，不要相信用户的输入
        * 程序员自己的参数，可以信任自己，用来替换不固定的表名或列名，可以使用 ${}
    测试：可以通过打印SQL语句日志来查看区别。


(2) 参数类型 <select parameterType="int"，可省略，一般不写

(3) xml中特殊字符的传参：id>10没问题，但是id<10就报错!
    1). 使用转义字符(就是实体entity): &lt; 代替<
    2). CDATA区: xml中输入CD，IDEA会提醒自动补齐:
        <![CDATA[
            这里写什么都可以，包括<
        ]]>

    <select id="selectById" resultMap="brandResultMap">
        select *
        from tb_brand where id
		<![CDATA[
            <=
        ]]>
        #{id};
    </select>








========================================
|-- 日志: 怎么打印sql语句？(用logbacke文件使mybatis打印sql语句)
----------------------------------------
日志的等级见：Java/Spring6-IoC.txt


1.怎么配置用 logback 文件使mybatis打印sql语句？

(1) pom.xml 中配置依赖

        <!-- slf4j 日志api -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.5</version>
        </dependency>

        <!-- logback-classic 依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.6</version>
        </dependency>

        <!-- logback-core 依赖 -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
            <version>1.4.6</version>
        </dependency>



(2) 在 resources/下新建配置文件 
$ cat logback.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--    console表示当前日志信息是可以输出到控制台的-->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--
            https://blog.csdn.net/qq_38701905/article/details/80739240

            %d{yyyy-MM-dd HH:mm:ss SSS}
            %-3level %logger{1024}
            %boldGreen(%logger{15})
            %class{35}
            -->
            <pattern>[%level] %blue(%d{HH:mm:ss.SSS}) %cyan([%thread]) %boldGreen(%logger{15}) - %msg %n</pattern>
        </encoder>
    </appender>

    <!-- name 是要扫描的包路径; level 是消息等级, TRACE < DEBUG < INFO < WARN < FATAL -->
    <logger name="com.mio.mapper" level="DEBUG" additivity="false">
        <appender-ref ref="Console"/>
    </logger>
</configuration>


(3) 测试
注解运行一个mybatis查询案例，控制台输出是带颜色的：

[DEBUG] 11:00:41.955 [main] c.m.m.B.selectById - ==>  Preparing: select * from tb_brand where id=?; 
[DEBUG] 11:00:41.956 [main] c.m.m.B.selectById - ==> Parameters: 2(Integer) 
[DEBUG] 11:00:41.958 [main] c.m.m.B.selectById - <==      Total: 1 
Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}

符合预期。






========================================
|-- 条条件查询：mybatis如何接收多个参数？ （mysql 的url要加 characterEncoding=utf8，否则模糊查询没结果）
----------------------------------------
内容：
	多条件查询
    多条件动态查询
    单条件动态查询


1. 多条件查询
(1)需求分析
    条件表达式？
        当前状态： status=?
        企业名称: company_name like ?
        品牌名称: brand_name like ?
    怎么连接？
        And 同时成立
        Or 至少一个成立

(2) 返回 List<>





2. 代码实现
(1) BrandMapper.java 中写接口方法

    //多条件查询 三种写法，任选一个
    /*
    //写法1：散装参数，分别列举三个参数，使用注解@Param("xml中的占位符")指定xml中哪个占位符接收该参数
    List<Brand> selectByCondition(@Param("status") int status,
                                  @Param("companyName") String companyName,
                                  @Param("brandName") String brandName);
    //写法2：xml中的占位符要和类中的属性名对应
    List<Brand> selectByCondition(Brand brand);
    */
    //写法3：xml中的占位符要和map中的key对应
    List<Brand> selectByCondition(Map map);
    /*
    */

(2) BrandMapper.xml 中写sql语句
    <!-- 多条件查询 -->
    <select id="selectByCondition" resultMap="brandResultMap">
        select *
        from tb_brand
        where
            status = #{status}
            and company_name like #{companyName}
            and brand_name like #{brandName}
    </select>


(3) 测试

    @Test
    public void testSelectByCondition() throws IOException {
        //接收的参数
        int status=1;
        String companyName="技术";
        String brandName="为";
        //处理参数
        companyName = "%"+companyName+"%";
        brandName = "%"+brandName+"%";


        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("写法3");

        /*
        // 写法1 散装参数
        List<Brand> brands = mapper.selectByCondition(status, companyName, brandName);

        // 写法2 封装对象
        Brand brand=new Brand();
        brand.setStatus(status);
        brand.setCompanyName(companyName);
        brand.setBrandName(brandName);
        List<Brand> brands = mapper.selectByCondition(brand);
        */

        // 写法3 集合对象
        Map map=new HashMap();
        map.put("status", status);
        map.put("companyName", companyName);
        map.put("brandName", brandName);
        List<Brand> brands = mapper.selectByCondition(map);


        System.out.println(brands);

        //5.释放资源
        sqlSession.close();
    }

输出: 没结果！！
为什么呢？搜了一下，有说mysql连接时要设置utf8，否则java和mysql交流不畅。

在 resources/mybatis-config.xml 中设置编码格式为utf8：
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <!-- mysql 连接信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <!-- 注意：1.不加utf8会导致模糊查询没返回结果; 2.本来该使用&，但是java中必须使用其实体 -->
                <property name="url" value="jdbc:mysql://y.biomooc.com:7070/mybatis?useSSL=false&amp;characterEncoding=utf8"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>

再次测试，输出正常:
[DEBUG] 10:22:45.788 [main] c.m.m.B.selectByCondition - ==>  Preparing: select * from tb_brand where status = ? and company_name like ? and brand_name like ? 
[DEBUG] 10:22:45.889 [main] c.m.m.B.selectByCondition - ==> Parameters: 1(Integer), %技术%(String), %为%(String) 
[DEBUG] 10:22:45.944 [main] c.m.m.B.selectByCondition - <==      Total: 1 
[Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}]



3. 小结
SQL语句设置多个参数有集中方式
    散装参数: 需要在接口形参上加注解 @Param("xml中参数占位符名称")；
    实体类封装参数: 保证SQL中的参数名和实体类属性名对应上；
    map集合: 保证SQL中的参数名和map集合的键的名称对应上；





========================================
|-- （动态条件查询 if, where 标签）多参数查询的问题：如果有些参数用户没有输入，会导致查询结果为空！
----------------------------------------
1. 如果三个框，用户只输入一个，则会造成查询失败。
因为sql语句是按照三个进行查询的。
怎么根据用户的输入灵活创建sql语句呢？

(1) MyBatis 对动态SQL有很强大的支持，在xml中使用如下标签：
    if
    choose(when, otherwise)
    trim(where, set)
    foreach

(2) 官网资料
https://mybatis.org/mybatis-3/dynamic-sql.html






2. 代码演示
接口不需要修改，只需要改动sql代码部分。

(1) 写法1：有问题
    <select id="selectByCondition" resultMap="brandResultMap">
        select *
        from tb_brand
        where
        <if test="status != null">
            status = #{status}
        </if>
        <!-- 注意：这里test使用的是java传过来的值，与mysql无关。所以变量名要使用java的 -->
        <if test="companyName !=null and companyName!='' ">
            and company_name like #{companyName}
        </if>
        <if test="brandName !=null and brandName!='' ">
            and brand_name like #{brandName}
        </if>
    </select>

如果没有设置 status，会导致 where and 直接连接而报错！


1) 解决方法1：加恒等式 where 1=1，在每个if开头都加上and。
    笨方法，但是至少可以运行。


2) 解决方案2: where标签替换where表达式，每个if开头都加and。mybatis会自动考虑这些and是否要保留。

    <!-- 动态条件查询
        * if 条件判断
            * test 逻辑表达式
        * 问题: 多个and时，第一个语句没有值导致sql后的where直接跟着第二个语句的and，会报错！
            * 方法1 where后加恒等式 1=1，然后多个if语句都加上and开头。
            * where 标签替换where关键字
     -->
    <select id="selectByCondition" resultMap="brandResultMap">
        select *
        from tb_brand
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <!-- 注意：这里test使用的是java传过来的值，与mysql无关。所以变量名要使用java的 -->
            <if test="companyName !=null and companyName!='' ">
                and company_name like #{companyName}
            </if>
            <if test="brandName !=null and brandName!='' ">
                and brand_name like #{brandName}
            </if>
        </where>
    </select>






========================================
|-- （动态条件查询 choose(when, otherwise) 标签）单参数动态查询: 下拉框选择一个，按这一列搜索
----------------------------------------
1. 问题: 从多个条件中选择一个
(1) 需求: 用户按照下拉框(公司名、品牌名、描述)选择一个，输入关键词，按选择的列查询。
用户具体选择哪个是不确定的，要根据用户选择生成sql语句。

choose ~ 类似 switch 
    when ~ 类似 case
    otherwise ~ 类似 default


(2) 官网示例
https://mybatis.org/mybatis-3/dynamic-sql.html

<select id="findActiveBlogLike" resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>



2. 代码实现
(1) 写接口
    //单条件动态查询
    List<Brand> selectByConditionSingle(Brand brand);


(2) 写sql
因为只要一个条件，所以不用写and。

    <!-- 单条件动态查询 -->
    <select id="selectByConditionSingle" resultMap="brandResultMap">
        select *
        from tb_brand
        where
        <choose> <!-- 类似 switch -->
            <when test="status!=null"> <!-- 类似 case -->
                status=#{status}
            </when>
            <when test="companyName !=null and companyName !=''">
                company_name like #{companyName}
            </when>
            <when test="brandName !=null and brandName !=''">
                brand_name like #{brandName}
            </when>
            <otherwise> <!-- 类似 default -->
                1=1
            </otherwise>
        </choose>
    </select>


(3) 测试

    @Test
    public void testSelectByConditionSingle() throws IOException {
        //接收的参数
        int status=1;
        String companyName="技术";
        String brandName="为";
        //处理参数
        companyName = "%"+companyName+"%";
        brandName = "%"+brandName+"%";


        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("单条件动态查询，只能有一个where语句，哪一个不确定");

        // 封装对象
        Brand brand=new Brand();
        //brand.setStatus(status);
        //brand.setCompanyName(companyName);
        brand.setBrandName(brandName);
        List<Brand> brands = mapper.selectByConditionSingle(brand);

        System.out.println(brands);

        //5.释放资源
        sqlSession.close();
    }

输出:
单条件动态查询，只能有一个where语句，哪一个不确定
[DEBUG] 11:10:31.774 [main] c.m.m.B.selectByConditionSingle - ==>  Preparing: select * from tb_brand where brand_name like ? 
[DEBUG] 11:10:31.834 [main] c.m.m.B.selectByConditionSingle - ==> Parameters: %为%(String) 
[DEBUG] 11:10:31.863 [main] c.m.m.B.selectByConditionSingle - <==      Total: 1 
[Brand{id=2, brandName='化为', companyName='huawei技术有限公司', ordered=100, description='数字技术领域领头羊', status=1}]

如果三个条件都提供了，则使用最先提供的，忽视其余的。



(4) 如果用户一个都不选怎么办？
为了不报错，可以加一个 default: otherwise 1=1 表示查了所有结果。

还可以使用 <where> 包裹 <choose>，省略最后一个 otherwise。



========================================
|-- 添加数据：mybatis 默认开启事务
----------------------------------------
1. 需求 
让用户填写id之外的所有字段。

返回 void ，通过是否有异常判断是否成功。


2. 过程
(1) 写接口
package com.mio.mapper;
public interface BrandMapper {
    //添加数据
    void add(Brand brand);
}

(2) 写sql 语句 
$ cat resources/com/mio/mapper/BrandMapper.xml
    <insert id="add">
        insert into tb_brand(brand_name, company_name, ordered, description, status)
        values(#{brandName}, #{companyName}, #{ordered}, #{description}, #{status});
    </insert>

(3) 写测试方法

$ cat src/test/java/com/mio/test/MyBatisTest.java 

    @Test
    public void testAdd() throws IOException {
        //接收的参数
        int status=1;
        String companyName="波导手机";
        String brandName="波导";
        String description="手机中的战斗机";
        int ordered=100;

        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("添加对象");

        // 封装对象
        Brand brand=new Brand();
        brand.setStatus(status);
        brand.setCompanyName(companyName);
        brand.setBrandName(brandName);
        brand.setDescription(description);
        brand.setOrdered(ordered);

        mapper.add(brand); //添加
        System.out.println(brand);

        //5.释放资源
        sqlSession.close();
    }

执行后，控制台日志也符合预期。
查数据库：但是，数据库中没有该条目！！
>mysql -h y.biomooc.com -P 7070 -u root -p
> select * from mybatis.tb_brand;


(4) 显示更多日志
配置 resources/logback.xml，使其显示更多日志
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--    console表示当前日志信息是可以输出到控制台的-->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--
            https://blog.csdn.net/qq_38701905/article/details/80739240

            %d{yyyy-MM-dd HH:mm:ss SSS}
            %-3level %logger{1024}
            %boldGreen(%logger{15})
            %class{35}
            -->
            <pattern>[%level] %blue(%d{HH:mm:ss.SSS}) %cyan([%thread]) %boldGreen(%logger{15}) - %msg %n</pattern>
        </encoder>
    </appender>

    <!-- name 是要扫描的包路径; level 是消息等级, TRACE < DEBUG < INFO < WARN < FATAL -->
    <root level="debug">
        <appender-ref ref="Console"/>
    </root>
    <!--
    <logger name="com.mio.mapper" level="DEBUG" additivity="false">
        <appender-ref ref="Console" />
    </logger>
    -->
</configuration>

再次执行，能看到确实有回滚操作：
[DEBUG] 17:34:29.967 [main] o.a.i.t.j.JdbcTransaction - Rolling back JDBC Connection [com.mysql.jdbc.JDBC4Connection@3e44f2a5] 


(5) 需要手动提交事务
在释放资源前，提交事务。

	//提交事务
	sqlSession.commit();

	//5.释放资源
	sqlSession.close();

看日志：[DEBUG] 17:39:28.565 [main] o.a.i.t.j.JdbcTransaction - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@3e44f2a5] 
看数据库，确实新增一行。


(5B) 或者创建 SqlSession 对象时，设置主动提交事务。
	//2. 获取 SqlSession 对象
    SqlSession sqlSession = sqlSessionFactory.openSession(true); 
	//加参数true表示自动提交事务，相当于关闭了事务。
	//默认是false，需要手动提交事务。




========================================
|-- 添加数据：主键返回(xml中写上 useGeneratedKeys="true" keyProperty="id")
----------------------------------------
1. 问题 
上述代码中无法获取id。
    System.out.println(brand.getId()); //获取id失败，这里是一个null
而有些时候我们是需要id的，怎么办呢？

(2) 修改xml中的语句，即可解决该问题。

在接口中新建方法  void add2(Brand brand);

在xml中写sql语句:
    <!-- 添加数据，并返回主键id
        useGeneratedKeys="true" 说名要获取自动获取的键
        keyProperty="id" 绑定要获取的属性名称
    -->
    <insert id="add2" useGeneratedKeys="true" keyProperty="id">
        insert into tb_brand(brand_name, company_name, ordered, description, status)
        values(#{brandName}, #{companyName}, #{ordered}, #{description}, #{status});
    </insert>


测试：
        mapper.add2(brand); //添加，并获取主键
        System.out.println(brand);
        System.out.println(brand.getId()); //获取主键id成功




========================================
|-- 修改数据: 修改全部字段、修改动态字段(if 标签)
----------------------------------------
1. 需求 
如果内容有变化，就要修改。
修改完，点确定，完成更新。

(1) 接口方法

参数：所有数据
返回值：void 可以通过异常判断是否成功。
	也可以返回int，就是影响的行数。

    //修改数据
    void update(Brand brand);

(2) 在xml中写sql语句
    <!-- 修改数据 -->
    <update id="update">
        update tb_brand
        set
            brand_name=#{brandName},
            company_name=#{companyName},
            ordered=#{ordered},
            description=#{description},
            status=#{status}
        where id=#{id}
    </update>

(3) 测试 

    @Test
    public void testUpdate() throws IOException {
        //接收的参数
        int status=1;
        String companyName="魅族手机";
        String brandName="魅族";
        String description="小而美";
        int ordered=10;
        int id=15;

        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true); //加参数true表示自动提交事务

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("修改对象");

        // 封装对象
        Brand brand=new Brand();
        brand.setStatus(status);
        brand.setCompanyName(companyName);
        brand.setBrandName(brandName);
        brand.setDescription(description);
        brand.setOrdered(ordered);
        brand.setId(id);

        int result = mapper.update(brand); //修改
        System.out.println(brand);
        System.out.println("result=" + result);

        //手动提交事务
        //sqlSession.commit();

        //5.释放资源
        sqlSession.close();
    }

输出：result=1 是影响的行数。




2. 动态修改
比如用户只修改密码一项，再按上述都写，就会导致除了密码之外的都被设置为空，这不是我们希望的效果。
怎么办呢？一个方法就是在xml中使用动态语句生成sql：提交哪个字段，才在sql中修改哪个字段。

(1) 添加接口
int updateDyn(Brand brand); //动态sql


(2) 添加sql语句

    <!-- 修改数据: 动态修改 -->
    <update id="updateDyn">
        update tb_brand
        <set> <!-- 使用set标签 代替 set 关键字，能自动处理异常：最后一个是逗号？set后是空？ -->
            <if test="brandName != null and brandName != '' ">
                brand_name=#{brandName},
            </if>
            <if test="companyName != null and companyName != '' ">
                company_name=#{companyName},
            </if>
            <if test="ordered != null "> <!-- int 类型，只需要判断是否是null -->
                ordered=#{ordered},
            </if>
            <if test="description != null and description != '' ">
                description=#{description},
            </if>
            <if test="status != null">
                status=#{status}
            </if>
        </set>
        where
            id=#{id}
    </update>


(3) 测试 

    @Test
    public void testUpdateDyn() throws IOException {
        //接收的参数
        int status=0;
        String companyName="金刚商店";
        String brandName="金刚";
        String description="村里最好的产品";
        int ordered=8;
        int id=16;

        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true); //加参数true表示自动提交事务

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("修改对象");

        // 封装对象
        Brand brand=new Brand();
        brand.setStatus(status);
//        brand.setCompanyName(companyName);
//        brand.setBrandName(brandName);
//        brand.setDescription(description);
        brand.setOrdered(ordered);
        brand.setId(id);

        int result = mapper.updateDyn(brand); //修改
        System.out.println(brand);
        System.out.println("result=" + result);

        //手动提交事务
        //sqlSession.commit();

        //5.释放资源
        sqlSession.close();
    }

查看日志，生成的sql语句是：
	Preparing: update tb_brand SET ordered=?, status=? where id=? 
	Parameters: 8(Integer), 0(Integer), 16(Integer)
查看数据表，确实仅那个修改的字段有变化。




========================================
|-- 删除：删除一个、批量删除(foreach 标签)
----------------------------------------
1. 需求：有些不需要的条目，可以按照id删除

(1) 写mapper接口
参数 id 
返回 void 

    //删除
    void deleteById(int id);
	
(2) 在xml中写sql语句 
    <!-- 删除 -->
    <delete id="deleteById">
        delete from tb_brand
        where id=#{id}
    </delete>

(3) 测试 

    @Test
    public void testDeleteById() throws IOException {
        //接收的参数
        int id=4;

        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true); //加参数true表示自动提交事务

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("修改对象");


        mapper.deleteById(id); //删除

        //手动提交事务
        //sqlSession.commit();

        //5.释放资源
        sqlSession.close();
    }

检查数据表，id=4的记录已经倍删除。






2. 批量删除
需求：复选框，选中的多个可以按id批量删除。

(1) 写接口
接收：id数组
返回：void

    void deleteByIds(@Param("ids") int[] ids);

(2) 在xml中写sql语句
问题：不确定要删除几个，写sql时占位符个数不确定。
	delete from tb_brand 
	where id in (?,?,?);
解决方法：mybatis 提供了 foreach 标签来遍历数组

    <!-- 批量删除 -->
    <delete id="deleteByIds">
        delete from tb_brand
        where id in
        <foreach collection="ids" item="id" separator="," open="(" close=")">
            #{id}
        </foreach>
    </delete>
解释：
	separator="," 是多个#{id}之间的分隔符号
	open和close则是指定循环外包裹符号。

尝试：接口中不写注释，则xml的foreach中要写 collection="array"。否则写ids会报错 Parameter 'ids' not found
	void deleteByIds(int[] ids);


(3) 测试 

    @Test
    public void testDeleteByIds() throws IOException {
        //接收的参数
        int[] ids={2, 15, 16};

        //1. 获取 SqlSessionFactory 对象
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory =
                new SqlSessionFactoryBuilder().build(inputStream);
        //2. 获取 SqlSession 对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true); //加参数true表示自动提交事务

        //3 获取Mapper接口的代理对象
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

        //4.执行对应的接口方法: 整合spring后，只有这一行了，其他都是流程化的，都可以框架实现。
        // 重点写的就是接口方法名，和对应xml中的sql语句。
        System.out.println("修改对象");


        mapper.deleteByIds(ids); //删除

        //手动提交事务
        //sqlSession.commit();

        //5.释放资源
        sqlSession.close();
    }


日志：Preparing: delete from tb_brand where id in ( ? , ? , ? )
	Updates: 3 
数据表确实少了3个。




========================================
MyBatis 参数传递：pojo类型，Map集合，Collection，List，Array等 //todo
----------------------------------------
1. 











https://www.bilibili.com/video/BV1MT4y1k7wZ/?p=12

========================================
IDEA 快捷键
----------------------------------------
1. 按照数据表创建pojo类
按列选取：alt+鼠标左键
	id int primary key auto_increment,
	username varchar(20),
	password varchar(20),
	gender char(1),
	addr varchar(30)

变量名后都加空格，然后按照某一列选取之后的字符删掉，并加上分号结尾。
前面按列加上 private String 
最后修改 id 的类型为 Integer。
格式化代码: ctrl+alt+shift+L

(2) alt+insert 创建getter/setter 方法
(3) 输入 toString 的前几个字母，选择提示的第二项，选择全部变量名覆盖该方法。

2. 快速注释xml文件: 选择若干行 shift+ctrl+/






========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------

