DOM 操作




========================================
js dom 获取
----------------------------------------
1. 

按 dom 的id查询:
> document.getElementById("book")


选择全部:
> document.querySelectorAll("div h2")
NodeList(2) [h2, h2]









========================================
js dom 插入
----------------------------------------
existingItem.appendChild(newItem);//在existingItem内部的最后添加元素newItem
document.getElementById("myList").insertBefore(newItem,existingItem);//在myList内部的existingItem前面添加newItem



1.使用数组信息，向文档中插入dom元素

<!--start 积累句型 小目录-->	
<div class=item id=juxing>
	<h2  class="title">20190608 <a>如何通过英语读报积累写作句型？</a></h2>
</div>
<!--end-->	

<script>
//只需要补充url和text，即可自动更新链接
var url_list1=[
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486402&idx=2&sn=79b61e7be76fbf4d7e9541ab47c8d670","(1)经济学人：老年盗窃团伙"],
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486404&idx=2&sn=100aae2456dce4b45fe807da65d419eb","(2)Atlantic: 权游配乐"],
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486411&idx=2&sn=a6e4cb50296856aac414bb4fccfae418","(3)NPR: 放大的疼痛"],
]

// 自动更新dom
for(var i in url_list1){
	var oDiv=document.getElementById("juxing") //找到父元素
	url_info=url_list1[i] //获取url信息
	
	//创建链接元素
	oA=document.createElement("A");
	oA.setAttribute("target","_blank");
	oA.setAttribute("href",url_info[0]);
	//向链接元素中添加文本
	oText=document.createTextNode(url_info[1]); //创建文本节点
	oA.appendChild(oText)
	//向父元素插入链接元素
	oDiv.appendChild(oA)
	oDiv.appendChild( document.createTextNode(" | ") )
	//console.log(oA) //test
}
</script>





2.innerHTML在body标签中插入隐藏html内容
//定义广告
function sapp(){
	window.onload = function () {
		var body = document.body;
		var div = document.createElement("div");
		div.id = "downdiv";
		div.innerHTML = '<div class="downcode" style="position:fixed;z-index:1000;top:200px;right:10px;overflow:hidden;background: #fff;"><p style="text-align:right;color:#b50723;margin: 3px;cursor: pointer;"><span onclick="hidedown();">关闭</span></p><img alt= "下载" src= "http://www.yueshuapp.com/app/2wm.png" style= "width:200px;height:200px;" /><p style="text-align:center;line-height:24px;">下载看书APP 告别广告,超快更新</p></div >';
		body.appendChild(div);
	}
}

//隐藏按钮
function hidedown() {
	document.getElementById("downdiv").style.display = "none";
}

//启动
sapp();

refer: https://m.mxguan.com/xxgg/apppc.js



========================================
|-- 删除dom节点
----------------------------------------
//保证传入的是node
function deleteNode(node){
	if(node.parentNode){
		console.log(i);
		node.parentNode.removeChild(node); 
	}
}
// 删除一个网页中的css表，因为aLink是动态数组，删除一个元素之后数组更新，最大角标对应的元素已经不存在，删除过程会报错。
// 倒序删除则没问题！
var aLink=document.getElementsByTagName('link');
for(var i=aLink.length-1; i>=0; i--){
		deleteNode(aLink[i]);
}
//测试站点：https://segmentfault.com/q/1010000002955089


========================================
|-- 动态加载js文件：创建dom并加载js、document.writeln
----------------------------------------
1.
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>





2.向现有文件中添加js脚本: document.writeln
使用 document.writeln()
document.writeln("<script src=\'https://m.mxguan.com/xxgg/apppc.js\'></script>");

refer: 
document.write() 和 document.writeln() 区别 https://www.cnblogs.com/colmeluna/p/3862642.html


========================================
|-- 原生js删除节点、替换节点、复制节点node.cloneNode(true)
----------------------------------------
1、removeChild() 用来删除父节点的一个子节点。 
parent.removeChild(childNode); 
如下：

<div id="box">
    <p id="p1">这是一个段落</p>
    <p id="p2">第二个段落</p>
</div>
<script>
    var box=document.getElementById("box");  //找到父元素
    var p1=document.getElementById("p1");    //找到子元素    
    box.removeChild(p1);  
    //也可以通过要删除的子节点的父节点删除子节点
    p1.parentNode.removeChild(p1);                  
</script>





2、replaceChild() 用新节点替换某个子节点。 
parent.replaceChild (newnode,oldnode ) ； 
如下：

<div id="box">
    <p id="p1">这是一个段落</p>
    <p id="p2">第二个段落</p>
    <div id="div1">这是div</div>
</div>
<script>
    var box=document.getElementById("box");  //找到父元素
    var p1=document.getElementById("p1");    //找到要替换的元素

    var p3=document.createElement('p');//创建要替换的元素
    p3.innerHTML="这是第三个段落";  //为创建的元素赋值
    box.replaceChild(p3,p1);  //替换节点
    p1.parentNode.replaceChild(p3,p1); //通过parentNode节点替换
</script>
注意：新节点可以是文档中某个已存在的节点，也可以创建新的节点。






3、cloneNode() 复制节点并返回复制的节点 
node.cloneNode(true|false) ; //默认是 false。 
参数设置为 true，克隆节点及其属性，以及后代；设置为 false，克隆节点本身 
如下：
<div id="main">
    <div id="box">
        <p id="p1">这是一个段落</p>
        <p id="p2">第二个段落</p>
    </div>
</div>
<script>
    var main=document.getElementById("main"); 
    var box=document.getElementById("box"); 

    var newNode=box.cloneNode(true);
    main.appendChild(newNode);
    console.log(main);
</script>



https://blog.csdn.net/LLL_liuhui/article/details/79978487


========================================
|-- js运动 - 完美运动框架 startMove.js(支持缓冲运动、链式运动、同时运动)
----------------------------------------
支持多物体运动，定时器和obj绑定；
支持链式运动，只需要传入匿名运动函数；
支持同时运动，只需要传入json运动目标；
支持像素变化和不透明度的变化，不支持颜色的变化。


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>完美运动框架</title>
<style>
*{
	padding: 0;
	margin: 0;
}
div{
	color: #fff;
	width: 200px;
	height: 100px;
	background-color: yellow;
	border: 4px solid #000;
	filter: alpha(opacity:30);
	opacity: 0.3;
}
</style>
</head>
<body>
	
	<div id="div1"></li>
</body>
<script>
window.onload = function(){
	var oDiv = document.getElementById('div1');
	oDiv.onmouseover = function(){
		
		startMove(oDiv,{width:400,height:125,opacity:100});
	}
	oDiv.onmouseout = function(){
		startMove(oDiv,{height:100,width:200,opacity:30});
	}
	
}
function getStyle(obj,attr){
	if (obj.currentStyle) {
		return obj.currentStyle[attr];
	}
	else{
		return getComputedStyle(obj,false)[attr];
	}
}

function startMove(obj,json,fn){
	var flag = true;
	clearInterval(obj.timer);
	obj.timer = setInterval(function(){
		for(var attr in json){
			// 1.取当前的值
			var iCur = 0;
			if(attr == 'opacity'){
				iCur = Math.round(parseFloat(getStyle(obj,attr))*100);
			}
			else{
				iCur = parseInt(getStyle(obj,attr));
			}
			// 2.算速度
			var iSpeed = (json[attr]-iCur)/8;
			iSpeed = iSpeed>0?Math.ceil(iSpeed):Math.floor(iSpeed);

			// 3.检测停止
			if(iCur != json[attr])
			{
				flag = false;
			}

			if (attr == 'opacity') {
				obj.style.filter = 'alpha(opacity:'+(iCur + iSpeed)+')';
				obj.style.opacity = (iCur+iSpeed)/100;
			}
			else
			{
				obj.style[attr] = iCur + iSpeed + 'px';
			}
			
		}

		if (flag) {
			clearInterval(obj.timer);
			if (fn) {
				fn();
			}
		}

	},30)
}
</script>
</html>



========================================
|-- 传说中新增table最快的方法(js的数组连接插入dom中)
----------------------------------------
1. 简短形式

<style type="text/css">
table{width: 100%; border-collapse: collapse; border-color:Red;}
table td{ border:1px red solid}
</style>

<div id="tableDiv"></div>
<script type="text/javascript">
var maxRow =30;
var maxCol = 8;
var strTbody = ["<table border='1' class='style2'><tbody>"];

for(var i = 0; i < maxRow; i++){
	strTbody.push("<tr>");
	for(var j = 0; j < maxCol; j++){
		strTbody.push("<td>test</td>");
	}
	strTbody.push("</tr>");
}
strTbody.push("</tbody></table>");

var obj = document.getElementById("tableDiv");
obj.innerHTML = strTbody.join("");
</script>





2.应用
另一种fib高效实现
https://www.cnblogs.com/rubylouvre/archive/2010/09/19/1830692.html#4319309

<!doctype html>
<html>
  <head>
    <title>缓存函数形式的fib</title>
    <style>
      table {
        border-collapse: collapse;
        width:100%;
      }
      table td {
        border: 1px solid firebrick;
      }

    </style>
    <script>

      var memoize = function(fn) {
        var cache = [];
        return function(i) {
          return (i in cache) ? cache[i] :
            (cache[i] = fn.call(arguments.callee, i));
        };
      }

      var fib = new memoize(function(i) {
        if (i == 0 || i == 1)
          return 1;
        return this(i-1) + this(i-2);
      });

      var draw = function(){
        
        var table = ["<table>"]
        function test(n) {
          var t = new Date;
          for (var i = 0; i < 1000; i++) {
            var res = fib(n);
          }
          t = new Date - t;
          table.push('<tr><td>',n,'</td><td>',res,'</td><td>',t,'</td><td>',(t/n).toFixed(2) ,'</td></tr>');
        }

        for (var i = 0; i < 79; i++) {
          test(i);
        }
        table.push('</table>');
        var div = document.createElement('div');
        div.innerHTML = table.join('');
        document.body.appendChild(div);
        
      }



    </script>
  </head>
  <body onload="draw();">

  </body>
</html>







========================================
css类名添加和删除
----------------------------------------
可以参考一下classList，提供了add、remove、toggle以及contains等方法方便操作className
https://segmentfault.com/q/1010000002955089


var classVal = document.getElementById("id").getAttribute("class");

//删除的话
classVal = classVal.replace("someClassName","");
document.getElementById("id").setAttribute("class",classVal );

//添加的话
classVal = classVal.concat(" someClassName");
document.getElementById("id").setAttribute("class",classVal );

//替换的话
classVal = classVal.replace("someClassName","otherClassName");
document.getElementById("id").setAttribute("class",classVal );
只是匹配个class名字，用不着正则应该。







========================================
|-- css 属性的操作
----------------------------------------
1. 任何属性的操作都有一个style前缀

var a1=document.getElementsByTagName("h4")[7]
a1.style.backgroundColor="red"  //在js中，css的属性名都是驼峰法：第一个字母小写，后面的单词首字母大写。
a1.style.color="white"









========================================
|-- js 16进制颜色转rgb，并判断敏感
----------------------------------------

<style>
#box1{border:1px solid #eee; height:200px; padding:20px;}
</style>
<div id=box1>This is a book</div>

<script>
//1.js将16进制颜色转换成RGB格式
//https://blog.csdn.net/u012255097/article/details/78772157
function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);   
    return result ? {       
        r: parseInt(result[1], 16),              
        g: parseInt(result[2], 16),       
        b: parseInt(result[3], 16)   
    } : null;
}

//2. 通过rgb值判断颜色深浅 https://blog.csdn.net/qq_36843675/article/details/79448051
//通过把 RGB 模式转换成 YUV 模式，而 Y 是明亮度（灰阶），因此只需要获得 Y 的值而判断他是否足够亮就可以了：
//越小颜色越深
var Y=function(obj){
	var Y=obj.r*0.299 + obj.g*0.578 + obj.b*0.114;
	return Y>192;
}

//3. 测试
var bg='#F6A2FF'
var oDiv=document.getElementById('box1');

oDiv.style.background=bg;
oDiv.style.color=Y( hexToRgb(bg) )?"black":"white";
</script>





========================================
JS 事件处理 addEvent(obj,ev,fn)
----------------------------------------
主要有五个部分:
- 事件流: 三个阶段
	事件捕获: 根元素先捕获，逐步传递给具体按钮。从外到内。
	到达目标：
	事件冒泡：具体元素，到根元素。从内到外。
- 使用事件处理程序
	事件： 用户或浏览器执行的某种行为，click, load 
	事件处理程序: onclick, onload 
- 事件对象 event 形参
	oBtn.onclick=function(event){
		console.log(event.type) //"click"
	}
	oBtn.addEventListener('click', (event)=>{
		console.log(event.type); //"click"
	}, false)
- 事件类型：大致有7种事件类型。
	用户界面事件(UIEvent): 涉及与 BOM 交互的通用浏览器事件
	焦点事件(FocusEvent): 在元素获得和失去焦点时触发
	鼠标事件(MouseEvent):使用鼠标在页面执行某些操作时触发
	滚轮事件(WheelEvent): 使用鼠标滚轮（或类似设备）时触发
	输入事件(InputEvent): 向文档中输入文本时触发
	键盘事件(KeyboardEvent): 使用键盘在页面上执行某些操作时触发。
	合成事件(CompositionEvent): 在使用某种IME(Input method editor，舒服发编辑器)输入字符时触发
- 事件委托：比较常用
	对每个子元素设置事件处理函数，会占用更多内存空间，
	使用事件委托，能解决该问题。
	见下文单独章节。




1.监听事件: 给obj增加事件的自定义函,兼容IE/chrome/ff
function addEvent(obj,ev,fn){
	if(obj.addEventListener){
		//ff:addEventListener
		obj.addEventListener(ev,fn,false);
	}else{
		//IE:attachEvent
		obj.attachEvent('on'+ev,fn);
	}
}

/* 示例
addEvent(oBtn,'click',function(){
	alert('you clicked me!');
});
*/



2.[代码实例片段]dom中插入监听：
<script type="text/javascript">
    //这是一段浏览跟踪函数，在节省字节上很下功夫。不知道截取的是否完整。
    var GoSquared={};
    GoSquared.acct = "GSN-138769-Y";
    (function(w){
        function gs(){ //该函数是立即执行函数内部，不会污染全局变量
            w._gstc_lt=+(new Date); //获取当前日期，比如 1453253776603
            var d=document;//为了节省字节
            var g = d.createElement("script"); //创建dom
                g.type = "text/javascript"; //为什么不用setAttribute？用.操作符确实节省字节，兼容性如何？
                g.async = true; 
                g.src = "../../../d1l6p2sc9645hc.cloudfront.net/tracker.js";
            var s = d.getElementsByTagName("script")[0]; //获取script标签，因为本段代码在script中添加的，至少会有一个标签。
            s.parentNode.insertBefore(g, s);//插入到dom中。第一个参数使用了s.parentNode
        }
        w.addEventListener?w.addEventListener("load",gs,false):w.attachEvent("onload",gs);//使用()?:处理兼容。比if方式节省字节
    })(window);//传入的是window，相当于是给window绑定事件。
</script>




========================================
|-- 键盘事件：按上下键翻页
----------------------------------------
查询键盘事件的 keyCode: http://keycode.info/


1.键盘事件

(1)是否按下shift键？
var range=5;
if(e.shiftKey==1){
	range=1
}





2.实例
<pre>
说明：按键盘← →方向键 或 PageUp PageDown键直接翻页
	/*
		PageUp	33
		PageDown	34
		left	37
		up	38
		right	39
		down	40
	*/
</pre>
<div id='div1' style='color:red;'></div>

<SCRIPT language=javascript>
/**
	事件处理函数
	PageUp	33
	PageDown	34
	
	left	37
	up	38
	right	39
	down	40
*/
document.onkeydown =function(evt){
	//获取键盘事件和数字
	var evt = evt ||window.event;
	var key=evt.which||evt.keyCode;
	
		console.log(key);//todo
	//上一页 下一页的判断
	if ([33,37,38].indexOf(key)!=-1){pre();}
	if ([34,39,40].indexOf(key)!=-1){next();}
};

//向前翻页
function pre(){
	var prevpage="#up";
	location = prevpage;
	document.getElementById('div1').innerHTML='上一页';
}

//向后翻页
function next(){
	var nextpage="#down";
	location = nextpage;
	document.getElementById('div1').innerHTML='下一页';
}
</SCRIPT>




3. 在页面生成一个方块，可以鼠标、键盘移动位置
方便核对大篇幅屏幕文字和手写文字时，记录视线位置。
/*
aim:看web(如长页面或pdf)听写时加一个框，提示视线位置
Version:
v0.1 可用，引入页面即可出现框，刷新消失。
v0.2 添加键盘移动功能，暴露接口，可以设置大小、颜色等

使用：
var s=document.createElement("script");s.src="http://ielts.biomooc.com/static/js/dragBar.js";document.body.append(s);
var s=document.createElement("script");s.src="http://ielts.dawneve.cc/static/js/dragBar.js";document.body.append(s);
可移动的元素一定是定位元素（非static定位的）
监听鼠标mousedown，mouseup 和 mousemove事件。
mousemove事件处理里获取 event 事件对象的 clientX 和 clientY属性, 通过style设置元素的 top 和 left
*/
var dragBar={
	fixLeftTop:function(_this,left,top){
		//会拖出去产生进度条，要防止需要写判断
		if(left<0){
			left=0;
		}else if(left >window.innerWidth-_this.offsetWidth){
			left = window.innerWidth-_this.offsetWidth;
		}
		if(top<0){
			top=0;
		}else if(top >window.innerHeight-_this.offsetHeight){
			top = window.innerHeight-_this.offsetHeight;
		}
		return [left,top]
	},
	dragFactory: function(obj){
		var IsMousedown, LEFT, TOP;
		var _this=this;
		obj.onmousedown=function(e) {
			IsMousedown = true;
			e = e||event;
			LEFT = e.clientX - obj.offsetLeft;
			TOP = e.clientY - obj.offsetTop;
			document.onmousemove = function(e) {
				var e = e||event;
				var left=e.clientX - LEFT,top=e.clientY - TOP;
				var rs=_this.fixLeftTop(obj,left,top)
				left=rs[0];
				top=rs[1]
				//重新设置高度
				if (IsMousedown) {
					obj.style.left = left + "px";
					obj.style.top = top + "px";
				}
				return false;
			}

			document.onmouseup=function(){
				IsMousedown=false;
			}
		}
	},
	moveFactory:function(obj){
		var _this=this;
		document.onkeydown=function(e){
			if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.key)<0){
				return false;
			}
			//记录开始位置
			var left=obj.offsetLeft,top=obj.offsetTop;
			//普通移动，一次5px，按下shift则精细调整微1px
			var range=5;
			if(e.shiftKey==1){
				range=1
			}
			if('ArrowUp'==e.key) top-=range;
			if('ArrowDown'==e.key) top+=range;
			if('ArrowLeft'==e.key) left-=range;
			if('ArrowRight'==e.key) left+=range;
			//不能移动出去
			var rs=_this.fixLeftTop(obj,left,top)
			left=rs[0];
			top=rs[1]
			
			//重新设置高度
			obj.style.left = left + "px";
			obj.style.top = top + "px";
			return false;
		}
	},
	init:function(){
		var oDiv=document.createElement('div');
		oDiv.setAttribute('style','	color:blue;	position:fixed;	display:block;	width:400px;	height:100px;	bottom:0;	cursor:move;	border:2px dashed #000;	background:rgba(0,0,0,0.4);z-index:9999;');
		oDiv.setAttribute('draggable',true);
		document.body.append(oDiv);
		//功能
		this.dragFactory(oDiv); //添加可拖动属性
		this.moveFactory(oDiv); //添加响应键盘移动功能		
		this.obj=oDiv;//暴露出去，方便该颜色、大小等
		console.log('dragBar.js script loaded! help> dragBar.help()')
	},
	help:function(){
		console.log('1.设置大小 > dragBar.obj.style.width="500px";  \n2.能鼠标拖动位置，或者键盘按键移动位置，按下shift和箭头一次移动1px，仅用箭头一次移动5px；');
	}
};
dragBar.init();









========================================
|-- JS阻止冒泡和取消默认事件(默认行为)
----------------------------------------

js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。
使用event.preventDefault()可以取消默认事件。
对于冒泡和捕获的优先顺序请看之前文章：JavaScript捕获和冒泡探讨 http://caibaojian.com/javascript-capture-bubble.html



实例: https://blog.csdn.net/caseywei/article/details/86071764
document.getElementById("box1").addEventListener("click",function(event){
	if(event.target == event.currentTarget){
		alert("您好，我是最外层div。");
		event.stopPropagation();
	}
});




1.防止冒泡和捕获
w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true


2.取消默认事件
w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;


3.return false
javascript的return false只会阻止默认行为，而是用jQuery的话则既阻止默认行为又防止对象冒泡。

下面这个使用原生js，只会阻止默认行为，不会停止冒泡
var a = document.getElementById("testB");
a.onclick = function(){
	return false;
};



4.总结使用方法

当需要停止冒泡行为时，可以使用
function stopBubble(e) { 
//如果提供了事件对象，则这是一个非IE浏览器 
if ( e && e.stopPropagation ) 
    //因此它支持W3C的stopPropagation()方法 
    e.stopPropagation(); 
else 
    //否则，我们需要使用IE的方式来取消事件冒泡 
    window.event.cancelBubble = true; 
}



当需要阻止默认行为时，可以使用
//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}




5. 事件注意点
event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等；
event对象只在事件发生的过程中才有效。


下面两句效果相同：
function a(e){
	var e = (e) ? e : ((window.event) ? window.event : null); 
	var e = e || window.event; // firefox下window.event为null, IE下event为null
}




http://caibaojian.com/javascript-stoppropagation-preventdefault.html






========================================
|-- js点击按钮显示再点击空白地方隐藏
----------------------------------------

http://zhidao.baidu.com/link?url=mLGTly6mxZyvbUl_vcmiBuhsVqVezpcBRGLJOi2n4Bvielzz7CutoTssV97UYTw8ChZGi4pMATX4_zKIX2W30wlix2DyIo8QIwCRDolEDHS

可以参考这个！

document.onclick = function(){
    //隐藏层代码
};
 
div.onclick = function(oEvent){
    //取消冒泡
    oEvent = oEvent || window.event;
    if(document.all){
        oEvent.cancelBubble = true;
    }else{
        oEvent.stopPropagation();
    }
};




========================================
|-- js原生拖动事件
----------------------------------------
1.拖拽位置
拖拽状态 = 0鼠标在元素上按下的时候{
    拖拽状态 = 1
    记录下鼠标的x和y坐标
    记录下元素的x和y坐标
   }
 鼠标在元素上移动的时候{
    如果拖拽状态是0就什么也不做。
    如果拖拽状态是1，那么
    元素y = 现在鼠标y - 原来鼠标y + 原来元素y
    元素x = 现在鼠标x - 原来鼠标x + 原来元素x
    }
 鼠标在任何时候放开的时候{
    拖拽状态 = 0
}
(1)不考虑兼容效果，没有特效
<div class="calculator" id="drag1">drag me-simple**********</div>
<style>
.calculator{
	color:blue;
	position:absolute;/*设置绝对定位，脱离文档流，便于拖拽*/  
	display:block;
	width:218px;
	height:280px;
	cursor:move;/*鼠标呈拖拽状*/
	border:1px solid #eee;
}
</style>

<script>
/*
可移动的元素一定是定位元素（非static定位的）
监听鼠标mousedown，mouseup 和 mousemove事件。
mousemove事件处理里获取 event 事件对象的 clientX 和 clientY属性, 通过style设置元素的 top 和 left
*/
window.onload = function() { 
	var IsMousedown, LEFT, TOP;
	var drag1=document.getElementById("drag1");
	drag1.onmousedown=function(e) {
		var _this=this;
		IsMousedown = true;
		e = e||event;
		LEFT = e.clientX - _this.offsetLeft;
		TOP = e.clientY - _this.offsetTop;
		document.onmousemove = function(e) {
			var e = e||event;
			var left=e.clientX - LEFT,top=e.clientY - TOP;
			//会拖出去产生进度条，要防止需要写判断
			if(left<0){
                left=0;
            }else if(left >window.innerWidth-_this.offsetWidth){
                left = window.innerWidth-_this.offsetWidth;
            }
            if(top<0){
                top=0;
            }else if(top >window.innerHeight-_this.offsetHeight){
                top = window.innerHeight-_this.offsetHeight;
            }
			//重新设置高度
			if (IsMousedown) {
				_this.style.left = left + "px";
				_this.style.top = top + "px";
			}
			return false;
		}

		document.onmouseup=function(){
			IsMousedown=false;
		}
	}
}
</script>





(2)拖动写法2 demo1.html
<div class="calculator" id="drag">drag me**********</div>  
<style>
.calculator{
	color:blue;
	position:absolute;/*设置绝对定位，脱离文档流，便于拖拽*/  
	display:block;
	width:218px;
	height:280px;
	cursor:move;/*鼠标呈拖拽状*/
	border:1px solid red;
}
</style>

<script>
window.onload = function() {  
    //拖拽功能(主要是触发三个事件：onmousedown\onmousemove\onmouseup)  
    var drag = document.getElementById('drag');  
  
    //点击某物体时，用drag对象即可；
	//move和up是全局区域，也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动)  
    drag.onmousedown = function(e) {  
        var e = e || window.event; //兼容ie浏览器  
        var diffX = e.clientX - drag.offsetLeft; //鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离  
        var diffY = e.clientY - drag.offsetTop;  
  
        /*低版本ie bug:物体被拖出浏览器可是窗口外部时，还会出现滚动条，  
            解决方法是采用ie浏览器独有的2个方法setCapture()\releaseCapture(),这两个方法，  
            可以让鼠标滑动到浏览器外部也可以捕获到事件，而我们的bug就是当鼠标移出浏览器的时候，  
            限制超过的功能就失效了。用这个方法，即可解决这个问题。注：这两个方法用于onmousedown和onmouseup中*/  
            if(typeof drag.setCapture!='undefined'){  
                drag.setCapture();  
            }
		//拖动
        document.onmousemove = function(e) {
            var e = e || window.event; //兼容ie浏览器  
            var left=e.clientX-diffX;  
            var top=e.clientY-diffY;  
  
            //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条  
            if(left<0){  
                left=0;  
            }else if(left >window.innerWidth-drag.offsetWidth){  
                left = window.innerWidth-drag.offsetWidth;  
            }  
            if(top<0){  
                top=0;  
            }else if(top >window.innerHeight-drag.offsetHeight){  
                top = window.innerHeight-drag.offsetHeight;  
            }  
  
            //移动时重新得到物体的距离，解决拖动时出现晃动的现象  
            drag.style.left = left+ 'px';  
            drag.style.top = top + 'px';
			//防止选中事件
			return false;
        };  
		//抬起鼠标
        document.onmouseup = function(e) { //当鼠标弹起来的时候不再移动  
            this.onmousemove = null;  
            this.onmouseup = null; //预防鼠标弹起来后还会循环（即预防鼠标放上去的时候还会移动）  
  
            //修复低版本ie bug  
            if(typeof drag.releaseCapture!='undefined'){  
                drag.releaseCapture();  
            }  
        };  
    };  
};
</script>




2. 很多obj需要拖动怎么办？写一个工厂模式的拖动
<div class="calculator" id="drag1">drag me-simple1**********</div>
<div class="calculator" id="drag2">drag me-simple2**********</div>
<div class="calculator" id="drag3">drag me-simple3**********</div>
<style>
.calculator{
	color:blue;
	position:absolute;/*设置绝对定位，脱离文档流，便于拖拽*/  
	display:block;
	width:300px;
	height:100px;
	cursor:move;/*鼠标呈拖拽状*/
	border:1px solid #eee;
}
</style>

<script>
/*
可移动的元素一定是定位元素（非static定位的）
监听鼠标mousedown，mouseup 和 mousemove事件。
mousemove事件处理里获取 event 事件对象的 clientX 和 clientY属性, 通过style设置元素的 top 和 left
*/
function dragFactory(drag1){
	var IsMousedown, LEFT, TOP;
	//var drag1=document.getElementById("drag1");
	drag1.onmousedown=function(e) {
		var _this=this;
		IsMousedown = true;
		e = e||event;
		LEFT = e.clientX - _this.offsetLeft;
		TOP = e.clientY - _this.offsetTop;
		document.onmousemove = function(e) {
			var e = e||event;
			var left=e.clientX - LEFT,top=e.clientY - TOP;
			//会拖出去产生进度条，要防止需要写判断
			if(left<0){
                left=0;
            }else if(left >window.innerWidth-_this.offsetWidth){
                left = window.innerWidth-_this.offsetWidth;
            }
            if(top<0){
                top=0;
            }else if(top >window.innerHeight-_this.offsetHeight){
                top = window.innerHeight-_this.offsetHeight;
            }
			//重新设置高度
			if (IsMousedown) {
				_this.style.left = left + "px";
				_this.style.top = top + "px";
			}
			return false;
		}

		document.onmouseup=function(){
			IsMousedown=false;
		}
	}
}
window.onload = function() { 
	var drag1=document.getElementById("drag1");
	dragFactory(drag1);
	//
	var drag2=document.getElementById("drag2");
	dragFactory(drag2);
	//
	var drag3=document.getElementById("drag3");
	dragFactory(drag3);
	//
}
</script>







ref:
深入理解javascript原生拖放(交换数据) https://www.cnblogs.com/xiaohuochai/p/5886618.html#anchor1
位置变化 https://blog.csdn.net/gongzhuxiaoxin/article/details/52894784
位置变化原理：https://blog.csdn.net/daydream13580130043/article/details/87970624
数据交换(html5)、位置变化总结：https://blog.csdn.net/weixin_41910848/article/details/82218243




========================================
|-- 主动触发一个事件，并传递参数
----------------------------------------
1. 触发一个事件 https://blog.csdn.net/liuxiao723846/article/details/80822052
function trigger(element,eventName="change"){
	if( document.createEvent ){
		var evObj = document.createEvent('HTMLEvents');
		evObj.initEvent( eventName, false, true);
		element.dispatchEvent(evObj);//chrome
	}else if( document.createEventObject ){
		element.fireEvent('on'+eventName);//IE
	}
}




2. 主动触发click事件，并传递鼠标位置参数
https://stackoverflow.com/questions/6157929/how-to-simulate-a-mouse-click-using-javascript

var evObj = document.createEvent('MouseEvents');
// 模拟第一次单击
var evObj = new MouseEvent("click", {
	isTrusted:true,
	view: window,
	bubbles: true,
	cancelable: true,
	screenX:456, screenY:157, 
	clientX:432, clientY:77
	/* whatever properties you want to give it */
});
ctx.canvas.dispatchEvent(evObj);//chrome

// 模拟第二次单击
evObj = new MouseEvent("click", {
	isTrusted:true,
	view: window,
	bubbles: true,
	cancelable: true,
	screenX:240, screenY:155, 
	clientX:216, clientY:75
	/* whatever properties you want to give it */
});
ctx.canvas.dispatchEvent(evObj);//chrome




3. 主动触发键盘事件
<input id="box" type="input" />
<input id="btn" type="button" value="button" />

<br>
<br>
<input id="show" type="input" />

<pre>
打开F12控制台，观察 console:

1. test1
按button，则触发自定义事件 build，在 上box 末尾添加字母b;

2. test2
上box输入字母，会触发 上box的 keydown事件。
下box输入字母，也会触发 上box的 keydown事件，但是上box内容不变，why? 
</pre>



<script>
// 1.获取元素
function $(obj){
	return document.getElementById(obj)
}
var box=$("box")
var elemBtn=$("btn")
var show=$("show")



// 2.上输入框 中输入文字时
box.onkeydown=function(e){
	console.log("[up box] keydown:", e)
}



// ####################
// 触发事件 标准格式
// ####################
// https://developer.mozilla.org/en-US/docs/Web/API/Document/createEvent#specifications
// Create the event. 自定义事件
var event = document.createEvent('Event');

// Define that the event name is 'build'.
event.initEvent('build', true, true); //事件名字是 build

// Listen for the event. //监听该事件
elemBtn.addEventListener('build', function (e) {
  // e.target matches elem
  console.log("build event:", e)
  box.value += "b"
}, false);

// 单击按钮时，触发自定义事件: 在输入框末尾添加字母
elemBtn.onclick=function(e){
	// Target can be any Element or other EventTarget.
	elemBtn.dispatchEvent(event); //主动触发这个事件
}




// 模拟一个键盘事件，在 下box输入，就像在上box输入一样。
show.addEventListener('keyup', function (e) {
	var key=e.key;
	var event2 = new KeyboardEvent("keydown", {
		isTrusted: true,
		altKey: false,
		key: key,
		code: "Key"+key.toUpperCase(),
		
		bubbles: true,
		cancelable: true,
	})
	//event2.initEvent('keydown', true, true); //事件名字是
	
	// e.target matches elem
	console.log("  [down box] keyup:", e)
	//document.dispatchEvent(event2) 
	
	box.focus() //给焦点也不行
	setTimeout(function(){ //1s后触发，还是无法在输入框中填充文字
		box.dispatchEvent(event2); //触发上box的 event2
		document.dispatchEvent(new KeyboardEvent('keypress', {'key': 'e'}));
	}, 1000)
	
}, false);

</script>










========================================
|-- 事件委托
----------------------------------------
1. 概念
- 每个函数都是对象，都占用内存空间，对象越多，性能越差。
- 为指定事件处理程序所需访问DOM的次数会先期造成整个页面交互的延迟。

2. 案例

<ul id="links">
	<li id="link1">Go there</li>
	<li id="link2">Do sth</li>
	<li id="link3">say hello</li>
</ul>

(1) 原始实现
let oA1=document.getElementById("link1");
let oA2=document.getElementById("link2");
let oA3=document.getElementById("link3");

oA1.addEventListener("click", (event)=>{
	location.href="http://www.a1.com";
})
oA2.addEventListener("click", (event)=>{
	document.title="a new title";
})
oA3.addEventListener("click", (event)=>{
	console.log("hello");
})


(2) 使用事件委托，只需要一个事件处理函数
根据事件冒泡，子节点点击后最终父节点都可以知道，所以只监听父节点即可。
把事件处理函数定义在其父对象上，event知道哪个子节点被触发了，据此设置行为。

let oUl=document.getElementById("links");

oUl.addEventListener('click', (event)=>{
	let target=event.target;
	switch(target.id){
		case "link1":
			ocation.href="http://www.a1.com";
			break;
		case "link2":
			document.title="a new title";
			break;
		case "link3":
			console.log("hello");
			break;
	}
})





========================================
剪贴板
----------------------------------------
1. 实现点击按钮，复制文本框中的的内容：支持 input 或 textarea
<textarea cols="20" rows="10" id="biao1">用户定义的代码区域</textarea>
<input type="button" onClick="copyUrl2()" value="点击复制代码" />

<script>
function copyUrl2() {
	var Url2=document.getElementById("biao1");
	
	Url2.select(); // 选择对象
	document.execCommand("Copy"); // 执行浏览器复制命令
	
	alert("已复制好，可贴粘。");
}
</script>


https://www.cnblogs.com/huijieoo/articles/5569990.html





========================================
|-- JavaScript复制内容到剪贴板: 新旧方法
----------------------------------------
1. 基本规则
(1) 早期实现，现在逐步废弃
如果是输入框，可以通过 select() 方法，选中输入框的文本，然后调用 copy 命令，将文本复制到剪切板

但是 select() 方法只对 input 和 textarea 有效，对disabled属性的的input没有效果，可以在在页面中添加一个表单，把它隐藏掉，不能display:none，不然也拿不到复制的内容


(2)按照最新的标准，有替代方法:
https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/writeText

	if( navigator.clipboard) {
		navigator.clipboard.writeText(text).then(function(){
			console.log("Async: copy to clipboard: Success")
		}, function(err){
			console.log("Async: could not copy text:", err)
		})
	}





2. 一个例子：选择文本并复制到剪切板:

<textarea style="width:80%; height: 150px;" id="textarea">
method1: 
如果是输入框，可以通过 select() 方法，选中输入框的文本，然后调用 copy 命令，将文本复制到剪切板

method2: 
但是 select() 方法只对 input 和 textarea 有效，对disabled属性的的input没有效果，可以在在页面中添加一个表单，把它隐藏掉，不能display:none，不然也拿不到复制的内容
</textarea>
<br />

<a href="http://www.baidu.com" id="oA">点击复制链接1</a> | 
<a href="http://pan.baidu.com" onclick="copyMe(this)">点击复制链接2</a>
<br />
<br />
然后尝试 ctrl+V 粘贴到记事本，查看效果。



<script>

// 目标: 文本复制到剪切板
// https://blog.csdn.net/weixin_46558787/article/details/126020300
// https://blog.csdn.net/IICOOM/article/details/124183673
function copy2clipboard(text){
	//1. 新的拷贝到剪切板方法，很简练；只是可能不支持。
	if( navigator.clipboard) {
		navigator.clipboard.writeText(text).then(function(){
			console.log("Async: copy to clipboard: Success")
		}, function(err){
			console.log("Async: could not copy text:", err)
		})
	}else{
	//2. 之前的拷贝到剪切板方法，很繁琐: 
	// input 或 textarea 控制才支持，需要先 select(), 再执行 Copy 命令
		//1. 临时控件
		var input=document.createElement("input");
		document.body.appendChild(input);
		//2. 拷贝到临时控件
		input.setAttribute('value', text);
		//input.value=text; 
		//3. 执行拷贝到剪切板
		input.select(); 
		document.execCommand("Copy");
		//4. 移除控件
		document.body.removeChild(input);
	}
}


// 获取对象
function $(id){
	return document.getElementById(id);
}

//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}

function stopBubble(e) { 
	//如果提供了事件对象，则这是一个非IE浏览器 
	if ( e && e.stopPropagation ) 
		//因此它支持W3C的stopPropagation()方法 
		e.stopPropagation(); 
	else 
		//否则，我们需要使用IE的方式来取消事件冒泡 
		window.event.cancelBubble = true; 
}

//阻止默认事件
$("textarea").onclick=function(){
	var e = e || window.event;
	stopBubble(e);
}
$("textarea").onselect=function(){
	document.execCommand("Copy");
	var selection=this.textContent.substring(this.selectionStart, this.selectionEnd);
	console.log("copy to clipboard now: " + selection)
}




// 绑定方法1: 需要嵌套到匿名函数，才能拿到调用对象，进而拿到其href
var oA = document.getElementById("oA");
oA.onclick = function(){
	copyMe(this);
};

// body 上的事件
document.body.onclick=function(){
	console.log("body-click")
}

//绑定方法2: 直接出入this参数，进而拿到其href
function copyMe(obj){
	//var e = (e) ? e : ((window.event) ? window.event : null); 
	var e = e || window.event; // firefox下window.event为null, IE下event为null
	stopDefault(e); //阻止默认行为: 比如a标签的 跳转
	stopBubble(e); //阻止冒泡，比如：默认把点击传递给外部对象 body，阻止后body事件就不会触发
	
	console.log(e, obj.href); //输出 e 和 调用对象的href属性
	
	// 开始复制到剪切板
	copy2clipboard(obj.href);	
	
	return false;
}
</script>










ref: https://www.iicoom.shop/posts/46







========================================
使用||设置默认值
----------------------------------------
//例1. 这一段是设置属性的，用||设置了一个{}默认值
(google_async_config = window.google_async_config || {})['ca-pub-1307862221338762'] = {"sra_enabled":false};



//例2. 先使用CDN的jQ，如果加载失败，使用本地jQ文件
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>
	window.jQuery||document.write('<script src="../assets/js/vendor/jquery-1.11.3.min.js"><\/script>');
</script>






========================================
url 获取与设置: location对象
----------------------------------------
获取和设置当前url，使用 location对象。


1. 获取当前完整url
console.log(location.href)


2. 改变当前url，也就自动刷新页面了
location.href="https://baidu.com"




========================================
|-- 使用js从当前url获取参数
----------------------------------------
1. 函数:
//获取url中的参数 https://www.cnblogs.com/vicky-li/p/9145026.html
function getUrlParam(name) {
	var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); //构造一个含有目标参数的正则表达式对象
	var r = window.location.search.substr(1).match(reg);  //匹配目标参数
	if (r != null) return unescape(r[2]); return null; //返回参数值
}




2.详解
(1)http://blog.dawneve.cc/index.php?k=javascript&id=1_2

window.location.search //"?k=javascript&id=1_2"
window.location.search.substr(1) //"k=javascript&id=1_2" 去掉第一个问号

name='id' //"id"
reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); 
//  /(^|&)id=([^&]*)(&|$)/  开头位置^或者第一个是&，接着跟一个字符串"id="，后面的捕获组默认贪婪匹配，直到碰到&或结尾$停止

rs="k=javascript&id=1_2".match(reg)
## 返回4元素的数组，只看下面前4个元素。0位置是整体匹配到的，接着是三个()捕获组的值。
## ["&id=1_2", "&", "1_2", "", index: 12, input: "k=javascript&id=1_2", groups: undefined]

rs[2] #1_2 是我们需要的id

unescape() 是防止出现汉字?



(2) 使用汉字测试:
百度搜索：蓝色
name='wd'
reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
## /(^|&)wd=([^&]*)(&|$)/

rs=window.location.search.substr(1).match(reg);  
## (4) ["wd=%E8%93%9D%E8%89%B2&", "", "%E8%93%9D%E8%89%B2", "&", index: 0, input: "wd=%E8%93%9D%E8%89%B2&rsv_spt=1&rsv_iqid=0xb3f0a89…b&rsv_sug3=6&rsv_sug2=0&inputT=2925&rsv_sug4=2925", groups: undefined]

rs[2] ##"%E8%93%9D%E8%89%B2"

unescape( rs[2] ) #更乱码了！可能仅仅是去掉引号之类的？

decodeURI(rs[2]) ##"蓝色"
decodeURIComponent(rs[2]) ##"蓝色"

小结: 是不是返回值应该加上 decodeURI 函数? 否则汉字不能正常获取。


========================================
|-- js改变URL地址栏但是不刷新页面
----------------------------------------
1.修改url并重新加载可以使用Location.assign(),Location.replace()方法。

2.如果修改url但不重新加载，可以使用html5后引入的History.pushState(),History.replaceState()。
pushState方法往历史记录中添加新记录，replaceState方法修改当前历史记录。有相同的参数，如下所示：

state:一个状态任意属性的对象，在浏览历史时，会触发事件并附上该对象。通常传入{}
title：这个历史的标题，貌似不对应html中的title元素。通常传入""
url：历史记录中的url，可以是绝对或相对地址，且必须是同源的。

//如果当前url为http://www.baidu.com/aaa
history.replaceState({},"","/bbb");
//现在为http://www.baidu.com/bbb


例子：
var url = window.location.href;
var valiable = "https://blog.csdn.net?word=23&n=2";
window.history.pushState({},0,valiable);


例子：
一般用来清空url传递的参数不刷新，这样可以少发送一次请求到后台
var url = window.location.href;
var valiable = url.split(“?”)[0];
window.history.pushState({},0,valiable);




ref:
history https://developer.mozilla.org/en-US/docs/Web/API/History_API
location https://www.w3schools.com/jsref/obj_location.asp




========================================
[经验谈] 多个事件有先后顺序，怎么设置？
----------------------------------------
1. js 无法设置先后顺序
即使都放到定时函数中，还是有一定概率失效。

但是一个监听器内是按照顺序从上到下执行的。


2. 如果事件有依赖，就把它们写到一个监听器中。

事件1 生成侧边栏目录dom
事件2 高亮目录中的当前dom元素

则好的方法是先定义2个函数，分别具体处理这些细节。
然后在 window 的 load 事件中，按先后顺序执行这几个函数。









========================================
异步与 AJAX
----------------------------------------
第二十九课：javascript异步处理 https://www.cnblogs.com/chaojidan/p/4182081.html#3760654
首先，我们来讲一下setTimeout和setInterval这两个API
接下来，我们来讲解下Deferred对象（jQuery中的ajax异步处理对象）的前身Mochikit Deferred。


1. 定时函数

如果是图片的异步加载，则这样可能更简洁:

html: 
<a target="_blank" href="http://stuff.mit.edu/doc/counter-howto.html" id='viewCounter'>
	<!-- 原本很慢，拖累网页加载 <img src="https://stuff.mit.edu/cgi/counter/txtBlog"> -->
</a>



js:

/** 异步 获取页面底部的计数器 */
addEvent(window, 'load', function(){
	var oA=document.getElementById("viewCounter");
	var url="https://stuff.mit.edu/cgi/counter/txtBlog"
	setTimeout(function(){
		var oImg=createElement("img", {src:url, alt:"浏览次数[异步获取]"})
		oA.append(oImg)
	}, 0)
})


// 用到的2个函数
//给obj增加事件的自定义函数：兼容IE/chrome/ff
function addEvent(obj,ev,fn){
	if(obj.addEventListener){
		//ff:addEventListener
		obj.addEventListener(ev,fn,false);
	}else{
		//IE:attachEvent
		obj.attachEvent('on'+ev,fn);
	}
}

/** 返回创建的dom元素
* 只有第一个参数是必须的。
* 其余2个参数可选。
*/
function createElement(tag, json, innerHTML){
	var json=json||{};
	var dom=document.createElement(tag);
	
	if(json!=undefined){
		for(var key in json){
			dom.setAttribute(key,json[key]);
		}
	}
	
	if(innerHTML!=undefined){
		dom.innerHTML=innerHTML;
	}
	return dom;
}








2. 手写 ajax 请求
https://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp

(1) 最简单的ajax实例：GET 方法
window.onload=function(){
	document.onclick=function(e){
		var xmlhttp=new XMLHttpRequest(); //1.获取对象
		//2.绑定回调函数
		xmlhttp.onreadystatechange=function(){
			if (xmlhttp.readyState==4 && xmlhttp.status==200){
				document.getElementById("text").innerHTML=xmlhttp.responseText;
			}
		}
		//3.设定访问的url
		xmlhttp.open("GET","2019/11/28.txt",true);
		//4.发送请求
		xmlhttp.send();
	}
}


(2) 最简单的ajax实例：POST
window.onload=function(){
	document.onclick=function(e){
		var xhr=new XMLHttpRequest(); //1.获取对象
		//2.绑定回调函数
		xhr.onreadystatechange=function(){
			if (xhr.readyState==4 && xhr.status==200){
				document.getElementById("text").innerHTML=xhr.responseText;
			}
		}
		//3.设定访问的url
		xhr.open("POST","2023/6/13.txt",true);
		xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
		//4.发送请求
		xhr.send("hello=123456");
	}
}

// 最后一个参数，向后台提交的数据是 "a=v1&b=v2" 的形式
// 把 json 转为 post 的data格式 a1=val1&a2=val2
function json2data(json){
    var str="";
    for(var ele in json){ 
        str+= ele +"=" + json[ele]+"&"
    }
    str=str.substring(0, str.length-1)
    return(str)
}



1) 可以在 onreadystatechange 前给一个进度条
    // 给Ajax设置文件上传的感知事件
    /*
    ajax.upload.onprogress = function(evt){
        var loaded = evt.loaded;
        var total = evt.total;
        //document.getElementById("progress").value =(loaded/total)*100;
        console.log( (loaded/total)*100 )
    }*/

2) 如果post上传文件，不能设置 "Content-Type"
var $postFile=function(url, fn, data=""){
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if(xhr.readyState==4 && xhr.status==200){
            fn(xhr.responseText);
        }
    }
    xhr.open('post', url, true);
    xhr.send(data); //file
}


3) 能发送数据或发送文件的
// ajax by post
//如果是文件，则 isFile=true
var $post=function(url, fn, data="", isFile=false){
    var xhr=new XMLHttpRequest();
    xhr.onreadystatechange=function(){
        if (xhr.readyState==4 && xhr.status==200){
            fn(xhr.responseText);
        }
    }
    xhr.open("POST", url, true);
    if(isFile==false){
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    xhr.send(data);
}

使用方法：
// 使用Ajax 提交结果
$("SNPForm").onsubmit=function(event){
    // 阻止浏览器的跳转
    event.preventDefault();

    // 收集表单信息
    var fd = new FormData(this);

    $post("/report/upload_file", function(data){
        console.log("a==3>>>", data)
    }, fd, true)
}


//todo 数据和文件一起发送怎么做？





3. 使用ajax实现 长轮询
怎么终止？设置某个实现条件，比如状态码为某某时停止长轮询。

<pre>
// F2:
oP=document.createElement("p");
oP.setAttribute('id', 'p');
document.body.append(oP);

<script>
var $={}
$['ajax']=function(obj){
	if(obj.type=="POST"){
		$post(obj.url, obj.success)
	}
}
var updater = {
	poll: function(url) {
		$.ajax({ url: url || this.url,
			type: "POST",
			dataType: "text",
			success: updater.onSuccess,
			error: updater.onError
		});
	},
	onSuccess: function(data, dataStatus){
		try {
			$("p").append(data);
			$("p").append( document.createElement("br"));
		} catch (e) {
			updater.onError(e);
			return;
		}
		var interval = window.setTimeout(updater.poll, 1000); //这里更新
	},
	onError: function(e) {
		console.log("Poll error;", e);
	}
};

updater.url="Handler1.ashx"
updater.poll();
</script>







========================================
Promise对象
----------------------------------------
https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544
http://es6.ruanyifeng.com/#docs/promise


详情见repo: https://github.com/dawnEve/jsLecture





========================================
Canvas 标签
----------------------------------------
更详细的canvas教程请看 js可视化-canvas-SVG 专题 。

有了canvas，flash就没啥用了。
鼠标粒子吸附效果： https://www.sojson.com/hexadecimal.html



1. 创建dom 
<canvas id="test-canvas" width="300" height="200"></canvas>
或
<canvas id="test-stock" width="300" height="200">
    <p>当前浏览器不支持Canvas，请使用chrome访问</p>
</canvas>



2. 检测是否支持： 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    console.log('你的浏览器支持Canvas!');
} else {
    console.log('你的浏览器不支持Canvas!');
}



3. 画图
(1) 熟悉坐标
getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。
var ctx = canvas.getContext('2d');

如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：
gl = canvas.getContext("webgl");

本节我们只专注于绘制2D图形。

Canvas的坐标系统：坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。



(2) 画一个笑脸
var canvas = document.getElementById('test-shape-canvas');
var ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色

// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);


(3) 绘制文本: 带阴影的文字
绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：
'use strict';
var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);







4. Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：

- 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
- 尽量使用整数坐标而不是浮点数；
- 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
- 背景图片如果不变可以直接用<img>标签并放到最底层。


例: 画股票交易k线图 https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576






========================================
Bom操作
----------------------------------------
浏览器相关操作：浏览器大小、尺寸、新建窗口、历史记录等。

常用的 Bom 对象(window的子对象)
document history location screen navigator frames




========================================
|-- 打开新窗口，并写入内容
----------------------------------------

//点击提交，打开新窗口，显示勾选单词列表
$("submit").onclick=function(){
	var master=[];
	for(var i=0;i<aInput.length;i++){
		//勾选的
		if(aInput[i].checked){
			master.push(aInput[i].name)
		}
	}
	
	//打开新窗口
	var newWindowObi=window.open('', "_blank");
	//console.log(this);
	newWindowObi.document.write("//保存到同级目录下的known.js中<br>//known=["+"<br>");
	for(var i=0;i<master.length;i++){
		newWindowObi.document.write("'"+master[i]+"',<br>");
	}
	newWindowObi.document.write("//]");
}







========================================
|-- js获取屏幕、浏览器的宽高：
----------------------------------------
好图 https://segmentfault.com/a/1190000016554851

当前浏览器的高度，该值会随着拖动浏览器而改变，document.documentElement.clientHeight //734

chrome中
offsetHeight = scrollHeight = body.offsetHeight+ body.margin;
clientHeight = window视窗可见高度;
如果body内容过短，则documentElement的offsetHeight和scrollHeight将比clientHeight小。

元素
offsetHeight = padding + border + height；
clientHeight = padding + height -水平滚动条的高度；
scrollHeight >= clientHeight；
offsetLeft = 元素border左上角到画布原点的距离 或 到offsetParent的border box顶部的距离。

https://blog.csdn.net/woxueliuyun/article/details/8638427


checked：
网页可见区域高度 document.documentElement.clientHeight 637  window视窗可见高度；
网页被卷去的高: document.documentElement.scrollHeight 25192  浏览器顶端距离网页顶端滚过的距离；
网页正文全文高: document.documentElement.offsetHeight 21174 
屏幕分辨率高：window.screen.height 1080


(1)scrollHeight: 就是container内部的总高度
这里内部元素就是large_block，large_block所撑开的高度(2000 + 40（上下padding） + 40（上下margin）) = 2080px，然后加上自身container上下各10px的padding,因此一共是2100px


(2)clientHeight: 就是container内部可见高度 + 自身padding。
内部可见高度为600 - 17(滚动条高度)
padding为上下各10，因此一共是600 - 17 + 20 = 603

(3)offsetHeight: 也是container自己本身的可见高度 + 自身padding + 自身border + 滚动条
与clientHeight不同的就是要加上自身border以及滚动条的高度，因此是603 + 20 + 17 = 640





网页可见区域高：document.body.clientHeight 21174
网页正文全文高：document.body.scrollHeight 21174
网页可见区域高（包括边线的高）：document.body.offsetHeight 21174
网页被卷去的高：document.body.scrollTop  0







<html>
<script>
function a(){
document.write(
"屏幕分辨率为："+screen.width+"*"+screen.height
+"<br />"+
"屏幕可用大小："+screen.availWidth+"*"+screen.availHeight
+"<br />"+
"网页可见区域宽："+document.body.clientWidth
+"<br />"+
"网页可见区域高："+document.body.clientHeight
+"<br />"+
"网页可见区域宽(包括边线的宽)："+document.body.offsetWidth 
+"<br />"+
"网页可见区域高(包括边线的宽)："+document.body.offsetHeight 
+"<br />"+
"网页正文全文宽："+document.body.scrollWidth
+"<br />"+
"网页正文全文高："+document.body.scrollHeight
+"<br />"+
"网页被卷去的高："+document.body.scrollTop
+"<br />"+
"网页被卷去的左："+document.body.scrollLeft
+"<br />"+
"网页正文部分上："+window.screenTop
+"<br />"+
"网页正文部分左："+window.screenLeft
+"<br />"+
"屏幕分辨率的高："+window.screen.height
+"<br />"+
"屏幕分辨率的宽："+window.screen.width
+"<br />"+
"屏幕可用工作区高度："+window.screen.availHeight
+"<br />"+
"屏幕可用工作区宽度："+window.screen.availWidth
);
}
</script>
<body onload="a()" >
</body>
</html>

//from http://www.cnblogs.com/lf6112/archive/2011/07/26/2117348.html


搞清clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop 
https://blog.csdn.net/qq_35430000/article/details/80277587



========================================
|-- JS操作cookies方法!
----------------------------------------
//写cookies
function setCookie(name,value,days){
	var Days = days||30;
	var exp = new Date();
	exp.setTime(exp.getTime() + Days*24*60*60*1000);
	document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString();
}
//读cookies
function getCookie(name){
	var arr,reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
	if(arr=document.cookie.match(reg))
		return unescape(arr[2]);
	else
		return null;
}

//读cookies 2
function getCookie2(name){
	var strcookie = document.cookie;//获取cookie字符串
	var arrcookie = strcookie.split("; ");//分割
	//遍历匹配
	for ( var i = 0; i < arrcookie.length; i++) {
		var arr = arrcookie[i].split("=");
		if (arr[0] == name){
			return arr[1];
		}
	}
	return "";
}

//删除cookies
function delCookie(name){
	var exp = new Date();
	exp.setTime(exp.getTime() - 1);
	var cval=getCookie(name);
	if(cval!=null)
		document.cookie= name + "="+cval+";expires="+exp.toGMTString();
}



附录：时代周刊的cookie 2019.8.20
(1)全部获取
> strcookie = document.cookie;
"ntv_fpc=a2b9cf3f-4927-4fbc-9797-6925c0809441; _fbp=fb.1.1566295853722.39518778; AMP_TOKEN=%24NOT_FOUND; _ga=GA1.2.79275737.1566295854; _gid=GA1.2.1305624424.1566295854; _parsely_session={%22sid%22:1%2C%22surl%22:%22https://time.com/%22%2C%22sref%22:%22%22%2C%22sts%22:1566295855745%2C%22slts%22:0}; _parsely_visitor={%22id%22:%22c851b013-5fdf-4bce-8903-2dd0af373887%22%2C%22session_count%22:1%2C%22last_session_ts%22:1566295855745}; jumpstart-plugin-test-roll=83.17047057898574; __gads=ID=f364685c982946fc:T=1566295857:S=ALNI_MYa94MyEIbWBiYtkzcL6jJEEjHKNA; ajs_user_id=null; ajs_group_id=null; ajs_anonymous_id=%2269b4de26-1e12-4f62-96e7-8fabab2c000a%22; OX_plg=pm; jumpnext-videos-played=5668933994001; __idcontext=eyJjb29raWVJRCI6IjNFTllCQ0dRQlBJUjNKR1pPR0dLQ0dVVU02V0RJRkxNTkxIS1U3U1k0RUFBPT09PSIsImRldmljZUlEIjoiM0VOWUJDR1FCTDVURFdHSEtISk1FWE1BSldVRjJKVEVJUzZMMjcyQzNZT1E9PT09IiwiaXYiOiJDUUlNQktOS05JVUtBQlFSWVU0UUJKS0VTUT09PT09PSIsInYiOjF9; GED_PLAYLIST_ACTIVITY=W3sidSI6Imdqa1ciLCJ0c2wiOjE1NjYyOTg3OTksIm52IjowLCJ1cHQiOjE1NjYyOTU4NTIsImx0IjoxNTY2Mjk4Nzk0fV0."


(2)数组格式
> arrcookie = strcookie.split("; ");
0: "ntv_fpc=a2b9cf3f-4927-4fbc-9797-6925c0809441"
1: "_fbp=fb.1.1566295853722.39518778"
2: "AMP_TOKEN=%24NOT_FOUND"
3: "_ga=GA1.2.79275737.1566295854"
4: "_gid=GA1.2.1305624424.1566295854"
5: "_parsely_session={%22sid%22:1%2C%22surl%22:%22https://time.com/%22%2C%22sref%22:%22%22%2C%22sts%22:1566295855745%2C%22slts%22:0}"
6: "_parsely_visitor={%22id%22:%22c851b013-5fdf-4bce-8903-2dd0af373887%22%2C%22session_count%22:1%2C%22last_session_ts%22:1566295855745}"
7: "jumpstart-plugin-test-roll=83.17047057898574"
8: "__gads=ID=f364685c982946fc:T=1566295857:S=ALNI_MYa94MyEIbWBiYtkzcL6jJEEjHKNA"
9: "ajs_user_id=null"
10: "ajs_group_id=null"
11: "ajs_anonymous_id=%2269b4de26-1e12-4f62-96e7-8fabab2c000a%22"
12: "OX_plg=pm"
13: "jumpnext-videos-played=5668933994001"
14: "__idcontext=eyJjb29raWVJRCI6IjNFTllCQ0dRQlBJUjNKR1pPR0dLQ0dVVU02V0RJRkxNTkxIS1U3U1k0RUFBPT09PSIsImRldmljZUlEIjoiM0VOWUJDR1FCTDVURFdHSEtISk1FWE1BSldVRjJKVEVJUzZMMjcyQzNZT1E9PT09IiwiaXYiOiJDUUlNQktOS05JVUtBQlFSWVU0UUJKS0VTUT09PT09PSIsInYiOjF9"
15: "GED_PLAYLIST_ACTIVITY=W3sidSI6Imdqa1ciLCJ0c2wiOjE1NjYyOTg3OTksIm52IjowLCJ1cHQiOjE1NjYyOTU4NTIsImx0IjoxNTY2Mjk4Nzk0fV0."
length: 16




========================================
监控鼠标滚轮的滚动，监控到哪个锚点了？
----------------------------------------
1.两种监听页面滚动的方法
(1).原生js通过window.onscroll监听
window.onscroll = function() {
  //为了保证兼容性，这里取两个值，哪个有值取哪一个
  //scrollTop就是触发滚轮事件时滚轮的高度
  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  console.log("滚动距离" + scrollTop);
}

(2).Jquery通过$(window).scroll()监听
$(window).scroll(function() {
  //为了保证兼容性，这里取两个值，哪个有值取哪一个
  //scrollTop就是触发滚轮事件时滚轮的高度
  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  console.log("滚动距离" + scrollTop);
})




2.每次滚轮事件，都做一次循环判断
jQ版
$(window).scroll(function(){
	//为页面添加页面滚动监听事件
	var wst =  $(window).scrollTop() //滚动条距离顶端值
	for (i=1; i<6; i++){             //加循环
		if($("#a"+i).offset().top<=wst){ //判断滚动条位置
			$('#nav a').removeClass("c"); //清除c类
			$("#a"+i+i).addClass("c");	//给当前导航加c类
		}
	}
})
$('#nav a').click(function(){
	$('#nav a').removeClass("c");
	$(this).addClass("c");
});



js版：
window.onscroll = function() {
	//为了保证兼容性，这里取两个值，哪个有值取哪一个
	//scrollTop就是触发滚轮事件时滚轮的高度
	var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
	//console.log("滚动距离" + scrollTop);
	//开始循环干活了
	//目录内容
	var oMenu=$('f_content');
	var aSpan=oMenu.getElementsByTagName("span");
	
	//正文内容
	var aA= document.querySelectorAll("a[name]");
	//对正文的锚点进行遍历
	for(var i=0;i<aA.length;i++){
		if(aA[i].offsetTop<scrollTop){
			//remove class cur, for 导航
			for(var j=0;j<aSpan.length;j++){
				aSpan[j].parentElement.parentElement.setAttribute("class","");
			}
			
			//add class cur, for 导航
			var oA=aSpan[i].parentElement.parentElement
			oA.setAttribute("class","cur")
		}
	}
}





refer:
鼠标滚动监听并且给锚点加class类 https://blog.csdn.net/sloafer/article/details/79446861
监听页面滚动及滚动到指定位置 https://www.jianshu.com/p/4bf613d8c927
原生JS实现随着鼠标滚动到元素位置触发对应css3动画，简单易用 https://blog.csdn.net/likeyou1207/article/details/80782935



========================================
|-- js 自动生成部分dom，刷新后锚点定位不准，会滚到目标位置的下面。
----------------------------------------
https://www.cnblogs.com/shixiaomiao/p/5208098.html

锚点定位的本质是： 修改容器的滚动高度； 也就说父容器无滚动，则锚点定位就会失效。



锚点的应用：
1.与overflow:hidden结合，实现：无js完全用css实现选项卡轮转切换效果 (这种效果，可以在js挂掉的时候救场，保持图片的滚动功能)
注：overflow：hidden就是隐藏超出的部分，不出现滚动条；


2. css3中的:target伪类 + 锚点
URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。
:target 选择器可用于选取当前活动的目标元素，改变样式；
如果页面足够高的话，会有样式的改变 同时伴随着 页面的滚动。
（伪类的：target的支持情况是：IE6-8是不支持的，其余都支持！未来css强大的征兆！）






3. js 准确定位url中的锚点

/* 使用的异步，使url中的锚点能在页面中(使用带name的a空标签)正确定位，而不是向下偏移。
* 测试：刷新和输入url都能准确定位，上面有js生成的长度不定的dom，依旧能准确定位。
* version 0.2 抽象成函数，在onload中调用; 要在js生成dom后调用;
*/
function locateURLAnchor(){
	var url = window.location.toString();//获取url
    var id = url.split("#")[1];//获取url#后的部分
	//如果链接含有锚点，则定位；否则啥也不做；
    if(id){
		//定位锚点所在的a标签，遍历获得该dom对象
        var aA=document.querySelectorAll("a[name]");
		for(var i=0;i<aA.length;i++){
			if(id==aA[i].name)
				break;
		}
		//console.log("id=",id,"; i=",i)
		if(i<aA.length){
			//aA[i].scrollIntoView(true)//放这里就不行
			//console.log("01 before setTimeout i=",i, aA[i].offsetTop)
			setTimeout(function(){
				//console.log("02 after setTimeout offsetTop", aA[i].offsetTop)
				//异步的代码总是最后才执行
				aA[i].scrollIntoView(true)//放这里就好使，可能会闪一下
			}, 0)
		}
    }
}


refer:
https://www.zhangxinxu.com/wordpress/2010/07/锚点跳转及jquery下相关操作与插件/




========================================
|-- html5: 视图滚动到某个dom节点 obj.scrollIntoView()
----------------------------------------
1.
document.querySelectorAll("h3")[1].scrollIntoView()






========================================
狂刷搜狗微信搜索的验证码：在F12控制台运行js代码
----------------------------------------
搜狗输入法动不动就说我是非法流量，让输入验证码，烦死了。
那我干脆就做一个所谓的非法流量，专门刷验证码，尽最大限度的加重其服务器压力。

//用途

//https://weixin.sogou.com/antispider/?from=http%3A%2F%2Fweixin.sogou.com%2Fweixin%3Ftype%3D2%26query%3D死狗
//F12，把以下代码写入console中，回车即可看到结果
var oDiv=document.createElement('div')
oDiv.id="sigou"
document.body.append(oDiv)

//add style
var style = document.createElement('style');
style.innerHTML ='#sigou{position:absolute; top:0;left:0; opacity:0.5;z-index:-200}#sigou img{width:80px;}';
document.head.append(style);

//
var arr2=[0,0,0]
function nothing(arr){
	console.log('==========================',arr)
	arr[0]++
	if(arr[0]>1000){
		arr[0]=0
		arr[1]++
		if(arr[1]>1000){
			arr[1]=0
			arr[2]++
		}
	}
	var oDiv=document.getElementById('sigou')
	oDiv.innerHTML=""
	var flag=1
	for(var i=0;i<500;i++){
		var signal=Math.round((Math.random()-0.5)*2)
		var time=new Date().getTime() + i%35*signal
		url2='https://weixin.sogou.com/antispider/util/seccode.php?tc='+time
		if(flag){
			flag*=0
			console.log(url2)
		}
		//a1=$.get(url2)
		img=document.createElement('img')
		img.src=url2
		oDiv.append(img)
	}
}
nothing(arr2)

//
var oTimer1
clearInterval(oTimer1)
oTimer1=setInterval(function(){
	nothing(arr2)
	document.title=arr2
},3000)




========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------

