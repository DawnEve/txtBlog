js105-canvas{竞争对手: flash;}


视频: https://www.imooc.com/video/3488

canvas手册: https://www.runoob.com/tags/ref-canvas.html

my demo: http://jslecture.biomooc.com/canvas_SVG/index.html



========================================
Canvas简介
----------------------------------------
有了canvas，flash就没啥用了。
鼠标粒子吸附效果： https://www.sojson.com/hexadecimal.html


1. 创建dom 
<canvas id="test-canvas" width="300" height="200"></canvas>
或
<canvas id="test-stock" width="300" height="200">
    <p>当前浏览器不支持Canvas，请使用chrome访问</p>
</canvas>



2. 检测是否支持： 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    console.log('你的浏览器支持Canvas!');
} else {
    console.log('你的浏览器不支持Canvas!');
}



3. 画图
(1) 熟悉坐标
getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。
var ctx = canvas.getContext('2d');

如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：
gl = canvas.getContext("webgl");

本节我们只专注于绘制2D图形。

Canvas的坐标系统：坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。



(2) 画一个笑脸
var canvas = document.getElementById('test-shape-canvas');
var ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色

// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);


(3) 绘制文本: 带阴影的文字
绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：
'use strict';
var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);







4. Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：

- 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
- 尽量使用整数坐标而不是浮点数；
- 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
- 背景图片如果不变可以直接用<img>标签并放到最底层。


例: 画股票交易k线图 https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576



========================================
|-- 使用canvas画直线和矩形,线条末端lineCap,画五角星 /矩形函数
----------------------------------------
1. 画一个矩形
<canvas id="test-canvas" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('test-canvas');
//检测浏览器是否支持
if (canvas.getContext) {
    //console.log('你的浏览器支持Canvas!');
} else {
    console.log('你的浏览器不支持Canvas!');
}

//用直线画一个矩形
//1.获取context对象
var ctx = canvas.getContext('2d');
//2.设置样式
ctx.lineWidth=10;
ctx.strokeStyle="#F00";
//3.画线
ctx.beginPath() //开始路径
ctx.moveTo(250,250)
ctx.lineTo(250,400)
ctx.lineTo(100,400)
ctx.lineTo(100,250)
ctx.lineTo(250,250)
//ctx.closePath(); //结束路径
ctx.stroke();
</script>


2. 填充封闭图形
ctx.fillStyle="yellow";
ctx.fill();

先描边再填充，描边线会被填充覆盖掉一半。
为了保持描边宽度，可以先fill再stroke。


3. 线条末端帽子 3种
<canvas id="test-canvas" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('test-canvas');
var ctx = canvas.getContext('2d');

//1.画左竖线
ctx.beginPath()
ctx.lineWidth=1;
ctx.moveTo(100, 10)
ctx.lineTo(100, 200)
//2.右竖线
ctx.moveTo(400, 10)
ctx.lineTo(400, 200)
//ctx.closePath();
ctx.stroke();

/*
butt	默认。向线条的每个末端添加平直的边缘。
round	向线条的每个末端添加圆形线帽。
square	向线条的每个末端添加正方形线帽。
*/
//style 1
ctx.beginPath()
ctx.lineWidth=20;
ctx.lineCap="butt" //线条末尾默认
ctx.strokeStyle="blue"
ctx.moveTo(100,30)
ctx.lineTo(400,30)
ctx.stroke();

//style 2
ctx.beginPath()
ctx.lineWidth=20;
ctx.lineCap="round" //线条末尾的形状
ctx.strokeStyle="green"
ctx.moveTo(100,80)
ctx.lineTo(400,80)
ctx.stroke();

//style 3
ctx.beginPath()
ctx.lineWidth=20;
ctx.lineCap="square" //线条末尾的形状
ctx.strokeStyle="red"
ctx.moveTo(100,130)
ctx.lineTo(400,130)
ctx.stroke();
</script>


4. 画五角星
<canvas id="test-canvas" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('test-canvas');
var ctx = canvas.getContext('2d');

ctx.beginPath()
ctx.lineWidth=10;
ctx.strokeStyle="red"
ctx.fillStyle="yellow"
//(250,250)为圆心,R=250,r=100;2*pi/5=72度
//第一个角,R 0度, r 36度
var R=200, r=80, delta=2*Math.PI/5;
var startAngle=-Math.PI/2+delta;
for(var i=0;i<5;i++){
	ctx.lineTo(250+R*Math.cos(startAngle+delta*i), 250+R*Math.sin(startAngle+delta*i) );
	ctx.lineTo(250+r*Math.cos(startAngle+delta/2+delta*i), 250+r*Math.sin(startAngle+delta/2+delta*i) );
}

ctx.closePath();
ctx.fill();
ctx.stroke();
</script>


5. 其他属性设置
(1)加上 ctx.lineJoin = 'round' 就会在线条连接处变成圆角效果

ctx.lineWidth=10; //宽线条才有效果
ctx.lineJoin="miter"; //尖角-默认
ctx.lineJoin="round"; //线条连接处是圆形的
ctx.lineJoin="bevel"; //斜劈

miterLimit默认是10，是限制miter时尖角的最大值，超过了就是bevel了。

(2)






二、画矩形函数: ctx.rect(x, y, width, height), fillRect(),strokeRect(),clearRect()
1.只画形状
ctx.rect(0,0,canvas.width,canvas.height);//画形状

2.画边框，填充
strokeRect() 和 fillRect();


3.实例

ctx.fillStyle="black";
ctx.fillRect(0,0,100,200) //第一个点x,y坐标，width,height;

rect <br>
<canvas id="test-canvas" width="800" height="600"></canvas>

<script>
var canvas = document.getElementById('test-canvas');
var ctx = canvas.getContext('2d');
//style
ctx.lineWidth=10;

//全黑背景
ctx.beginPath()
ctx.fillStyle="black";
ctx.fillRect(0,0,canvas.width,canvas.height) //x,y, width, height;
ctx.closePath();

//上方一排小方块
ctx.beginPath()
ctx.fillStyle="#fff";
ctx.lineWidth=2;
ctx.strokeStyle="yellow";
ctx.fillRect(10,10,50,50);
for(var i=0;i<13;i++){
	ctx.fillRect(10+i*60,10,50,50); //填充
	ctx.strokeRect(10+i*60,10,50,50); //描边
}
ctx.closePath();
</script>


4. 清空一个矩形区域内的像素
ctx.clearRect(x,y, width,height);

能清空一个像素？应该可以。




========================================
|-- 画虚线 cxt.setLineDash( [20,5] )
----------------------------------------
我们之前用moveTo, lineTo画的都是实线，canvas为我们提供了setLineDash()方法，它可以用来画虚线:

用法：cxt.setLineDash( 数组 )

参数中这个数组，是由实线和空白组合合成，如：
[ 20, 5 ]: 20px 实线，5px空白
[ 20, 5, 10, 5]: 20px实线，5px空白, 10px实线, 5px空白
重复拼凑组合而成的线型.


dash <br>
<canvas id="test-canvas" width="800" height="600"></canvas>

<script>
var canvas = document.getElementById('test-canvas'),
	ctx = canvas.getContext('2d');

//橙线: 一般虚线
ctx.beginPath();
ctx.lineWidth=10;
ctx.strokeStyle="orange";
ctx.setLineDash([15,10]);
ctx.moveTo(100,100);
ctx.lineTo(400,100);
ctx.stroke();

//蓝线: 长短线交替
ctx.beginPath();
ctx.lineWidth=5;
ctx.strokeStyle="blue";
ctx.setLineDash([20,5,5,5]); //实线 虚线 实线 虚线
ctx.moveTo(100,200);
ctx.lineTo(400,200);
ctx.stroke();

</script>






========================================
canvas 图形变换: 位移translate(x,y)、旋转rotate(deg)、缩放scale(sx,sy)
----------------------------------------
先绘制基本图形，再通过图形变换改造成需要的形状。


1. 图形变换 translate(x,y) 移动坐标系原点到x,y位置 
状态的保持，使用 save() 和 restore() 成对的使用，之间执行设置和绘图。

<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');
ctx.strokeStyle='black'

ctx.save() //保存图形状态
ctx.beginPath()
ctx.lineWidth=10; //恢复后是默认的1
ctx.fillStyle="blue";
ctx.translate(100,100); //变换基坐标到(x,y)位置
ctx.fillRect(0,0,100,200)
ctx.strokeRect(0,0,100,200)

ctx.restore();//恢复刚才在save时的设置状态

//ctx.translate(-100,-100); //陷阱: translate(x,y) 是叠加的，所以使用完后要反向再使用一次。
//另一种方式是保存状态save()，之后再恢复restore()

ctx.beginPath()
ctx.fillStyle="rgba(255,0,0,0.5)";
ctx.translate(100,100); //变换基坐标到(x,y)位置
ctx.fillRect(0,0,200,100)
ctx.strokeRect(0,0,200,100)
</script>



2. 旋转坐标轴 rotate(deg)
图形变换 rotate<br>
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');
ctx.strokeStyle='black'

ctx.save() //保存图形状态
ctx.beginPath()
ctx.lineWidth=5; //恢复后是默认的1
ctx.fillStyle="blue";

ctx.rotate(Math.PI/10) //围绕着原点旋转坐标系

ctx.fillRect(100,100,100,200)
ctx.strokeRect(100,100,100,200)

ctx.restore();//恢复刚才在save时的设置状态

//画竖线 如果不恢复，则绘制的是斜线；如果恢复，则绘制的是竖直线
ctx.strokeStyle="red";

ctx.moveTo(100,0)
ctx.lineTo(100,100)
ctx.stroke();
</script>


例2: rotate是旋转坐标轴，如果想让物体按照中心旋转，则需要先围绕着原点绘图，然后旋转坐标系即可。

图形变换 rotate _2<br>
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');
ctx.strokeStyle='black'

ctx.strokeRect(100,100,100,200) //原始位置

//###########恢复后
ctx.save() //保存图形状态
ctx.beginPath()
ctx.translate(150,200); //移动坐标原点

ctx.fillStyle="rgba(0,0,255,0.2)";
ctx.rotate(Math.PI/6) //围绕着原点旋转坐标系
ctx.fillRect(-50,-100,100,200) //图形要以原点为中心

ctx.fillStyle="rgba(255,255,0,0.3)";//黄色
ctx.rotate(Math.PI/6);
ctx.fillRect(-50,-100,100,200);

ctx.restore();//恢复刚才在save时的设置状态
//###########恢复后

ctx.fillStyle="rgba(255,0,0,0.2)";//红色
ctx.fillRect(100,100,100,200) //原始位置2
</script>



3. 缩放也是有副作用的，就是整体缩放了坐标系。
图形变换 scale _2<br>
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');
ctx.strokeStyle='black'

ctx.strokeRect(10,10,50,100) //矩形1

ctx.save()
ctx.scale(2,2)
ctx.strokeRect(10,10,50,100) //矩形2

ctx.scale(2,2)
ctx.strokeRect(10,10,50,100) //矩形3
ctx.restore();
//缩放的副作用: 是放大坐标系，所以放大了矩形的起始坐标、矩形的边框宽度、矩形的宽高等。

ctx.fillStyle="rgba(255,0,0,0.3)"
ctx.fillRect(10,10,50,100)
</script>



4. 对于星空代码的改造
作业: 重写星空代码，从软件工程的角度优化，提高复用性。
可以传入基本形状函数，传入随机次数。



5. 变换矩阵 
图形变换，翻看任何一本图形学课本都有描述。

二维图形变换矩阵是3x3的:
[a c e, 
b d f, 
0 0 1] 是三行三列矩阵，第一行是a c e;

a 水平缩放(1)
b 水平倾斜(0)

c 垂直倾斜(0)
d 垂直缩放(1)

e 水平位移(0)
f 垂直位移(0)

图形变换 transform()<br>
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

/**
二维图形变换矩阵是3x3的:
[a c e, 
b d f, 
0 0 1] 是三行三列矩阵，第一行是a c e;

a 水平缩放(1)
b 水平倾斜(0)

c 垂直倾斜(0)
d 垂直缩放(1)

e 水平位移(0)
f 垂直位移(0)
*/
var a=1,d=1; //缩放 x水平，y垂直 
var b=0.2,c=0; //倾斜 x水平，y垂直 
var e=0,f=0; //位移 x水平，y垂直 
draw(a,b,c,d,e,f)

function draw(a,b,c,d,e=0,f=0){
	ctx.fillStyle="rgb(255,255,255)"
	ctx.fillRect(0,0,canvas.width, canvas.height)
	//
	ctx.save()
	ctx.transform(a,b,c,d,e,f)
	ctx.fillStyle="rgba(0,0,0,0.2)"
	ctx.fillRect(100,100, 100, 200);
	ctx.restore();

	ctx.strokeRect(100,100,100,200);
}
// F12控制台输入，变参数看效果
//draw(0.5,0.2,0.6,0.5)

ctx.strokeStyle="rgba(255,0,0,0.8)"
ctx.transform(1,0,0,1,0,0)
ctx.transform(1,0.1,0,1,0,0)
ctx.transform(1,0,0.2,1,0,0) //transform是累积的

ctx.setTransform(1,0,0,1,0,0) //setTransform则覆盖掉前面设置的转换矩阵
ctx.strokeRect(300,100,100,200);
</script>









========================================
更多填充: 渐变色( fillStyle=color||gradient||pattern, pattern包括 img||canvas||video )
----------------------------------------

纯色上文用过: ctx.fillStyle="black";



1. 渐变色包括线性渐变和径向渐变
(1) 线性渐变 createLinearGradient(x1,y1,x2,y2);
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

//线性渐变
var grd1=ctx.createLinearGradient(10,10,100,100); //(x1,y1, x2,y2)起始位置
grd1.addColorStop(0,'black'); //2个参数，第一个位置0-1之间，第二个颜色
grd1.addColorStop(0.5,"white");
grd1.addColorStop(1,"red");

ctx.fillStyle=grd1;
ctx.fillRect(0,0,300,100); //渐变色的范围可以和形状不重合
//ctx.fillRect(0,0,180,180);


//线性渐变 横向x
var grd2=ctx.createLinearGradient(10,200,300,200); //y坐标不变，则沿着x变化
grd2.addColorStop(0,'blue');
grd2.addColorStop(0.5,"white");
grd2.addColorStop(1,"red");

ctx.fillStyle=grd2;
ctx.fillRect(0,150,300,100)

//线性渐变 纵向y 略
</script>





(2) 径向渐变 createRadialGradient(x1,y1,r1,x2,y2,r2)
<canvas id="canvas1" width="800" height="600" style="border:1px solid red;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
var ctx = canvas.getContext('2d');

//径向渐变
var grd1=ctx.createRadialGradient(150,100,0, 150,100, 200); //圆心位置、半径
grd1.addColorStop(0,"white");//2个参数，第一个位置0-1之间，第二个颜色
grd1.addColorStop(1,"red");

ctx.fillStyle=grd1;
//渐变色的范围可以和形状不重合
//ctx.fillRect(0,0,300,200); //整体效果
ctx.fillRect(0,0,300,100); //半圆
</script>








// helper function: return a new canvas containing an arc-gradient
//drawMultiRadiantCircle(100, 2, 2)
function drawMultiRadiantCircle(r, linewidth, radientColors) {
  var xc=r+linewidth/2;
  var yc=r+linewidth/2;
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  canvas.width=r*2+linewidth;
  canvas.height=r*2+linewidth;
  var partLength = (2 * Math.PI) / radientColors.length;
  var start = 0;
  var gradient = null;
  var startColor = null;
  var endColor = null;
  //
  for (var i = 0; i < radientColors.length; i++) {
    startColor = radientColors[i];
    endColor = radientColors[(i + 1) % radientColors.length];
    // x start / end of the next arc to draw
    var xStart = xc + Math.cos(start) * r;
    var xEnd = xc + Math.cos(start + partLength) * r;
    // y start / end of the next arc to draw
    var yStart = yc + Math.sin(start) * r;
    var yEnd = yc + Math.sin(start + partLength) * r;
    gradient = ctx.createLinearGradient(xStart, yStart, xEnd, yEnd);
    gradient.addColorStop(0, startColor);
    gradient.addColorStop(1.0, endColor);
    //
    ctx.beginPath();
    ctx.strokeStyle = gradient;
    ctx.arc(xc, yc, r, start, start + partLength);
    ctx.lineWidth = linewidth;
    ctx.stroke();
    ctx.closePath();
    start += partLength;
  }
  return(canvas);
}









2.pattern填充
(1)img填充 createPattern(img, 'repeat');
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<img id="lamp" src="../images/win7.png"><br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

//图形元素
//var img=document.getElementById("lamp");
//或者直接创建元素
var img=new Image(); img.src="../images/win7.png"

img.onload=function(){ //在图像加载完成后再使用img对象
	//参数1 图像对象
	//参数2 重复方式，共4种: no-repeat,repeat-x,repeat-y,repeat
	var pat=ctx.createPattern(img,"repeat");
	
	ctx.rect(0,0,canvas.width,canvas.height);//画形状
	console.log('first load')
	ctx.fillStyle=pat; 
	ctx.fill(); //填充
}
</script>



(2) canvas填充
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
图形变换 createPattern(canvas, 'repeat')<br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');
ctx.rect(0,0,canvas.width,canvas.height);//填充范围

//创建canvas元素
var canvas0=document.createElement('canvas');
var ctx0=canvas0.getContext('2d');
canvas0.width=15;
canvas0.height=15;
//绘制基本图形
ctx0.beginPath();
ctx0.moveTo(2,2)
ctx0.lineTo(13,2)
ctx0.lineTo(7,15)
ctx0.closePath();
ctx0.fillStyle="rgba(255,0,0,0.7)";
ctx0.fill();
//ctx0.fillRect(0,0,canvas0.width*0.8, canvas0.height*0.8)

//参数1 基本元素 小canvas
//参数2 重复方式，共4种: no-repeat,repeat-x,repeat-y,repeat
var pat=ctx.createPattern(canvas0,"repeat");
ctx.fillStyle=pat; 
ctx.fill(); //填充
</script>




(3) 视频填充 略。





3. 其实 strokeStyle也是类似的，不过要在描边足够宽的时候才能看清楚
ctx.lineWidth=10;




========================================
圆弧 ctx.arc(x,y,radius,startAngle,endAngle,?anticlockwise)(圆角矩形，2048棋盘)
----------------------------------------
arc(): 角度系统是顺时针的(右0，下90，左180，上270);
最后一个参数 是否逆时针 默认否


1.基本例子
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

//角度是顺时针的(右0，下90，左180，上270)

//row1: 默认是顺时针的。（最后一个参数 是否逆时针 默认否）
for(var i=0;i<13;i++){
	ctx.beginPath()
	ctx.arc(50*i,50,20,0,Math.PI/6*i)
	ctx.closePath();
	ctx.stroke();
}
//row2: 逆时针只是圆弧的方向。
for(var i=0;i<13;i++){
	ctx.beginPath()
	ctx.arc(50*i,100,20,0,Math.PI/6*i, true)
	//ctx.closePath();//收尾用直线连起来
	ctx.stroke();
}

ctx.fillStyle="yellow"
//row3: 圆弧顺时针 填充row1
for(var i=0;i<13;i++){
	ctx.beginPath()
	ctx.arc(50*i,150,20,0,Math.PI/6*i, false)
	ctx.fill();
}
ctx.fillStyle="blue"
//row4: 圆弧逆时针 填充row2
for(var i=0;i<13;i++){
	ctx.beginPath()
	ctx.arc(50*i,200,20,0,Math.PI/6*i, true)
	ctx.fill();
}
</script>




2.圆角矩形 进一步优化 并绘制2048游戏棋盘 
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');


//基本路径 圆角矩形
function pathRoundRect(ctx,width,height,radius){
	ctx.beginPath();//aim:中间绘制封闭图形
	//绘制4边，4个半圆弧
	ctx.arc(width-radius, height-radius,radius,0,Math.PI/2) //右下角
	ctx.lineTo(radius,height);//底
	ctx.arc(radius, height-radius,radius,Math.PI/2, Math.PI) //左下角
	ctx.lineTo(0,radius)//left
	ctx.arc(radius,radius,radius,Math.PI, Math.PI*3/2) //左上角
	ctx.lineTo(width-radius,0); //top
	ctx.arc(width-radius,radius,radius,Math.PI*3/2, Math.PI*2) //右上角
	ctx.closePath();	
}

//填充 圆角矩形
function fillRoundRect(ctx,x,y,width,height,radius, fillStyle){
	if(2*radius>width || 2*radius>height){
		return false;
	}
	ctx.save();//aim: 不改变原始环境
	ctx.translate(x,y);//移动原点到该点，则实际绘制只需要从(0,0)开始
	pathRoundRect(ctx,width,height,radius);
	ctx.fillStyle=fillStyle||"black"
	ctx.fill();
	ctx.restore();
}

//描边 圆角矩形
function strokeRoundRect(ctx,x,y,width,height,radius, lineWidth,strokeStyle){
	if(2*radius>width || 2*radius>height){
		return false;
	}
	ctx.save();//aim: 不改变原始环境
	ctx.translate(x,y);//移动原点到该点，则实际绘制只需要从(0,0)开始
	pathRoundRect(ctx,width,height,radius);
	ctx.lineWidth=lineWidth||1;
	ctx.strokeStyle=strokeStyle||"black"
	ctx.stroke();
	ctx.restore();
}


//绘制圆角矩形
fillRoundRect(ctx,10,20,50,20,10)
fillRoundRect(ctx,80,0,100,50,20, '#ff9600')
strokeRoundRect(ctx,200,10,100,20,5,  2,'red')


//绘制2048游戏的棋盘(4*4圆角矩形，每个100x100)
fillRoundRect(ctx, 60,60,500,500,10,"#bbada0")
for(var i=0;i<4; i++){
	for(var j=0;j<4; j++){
		fillRoundRect(ctx,80+i*120,80+j*120,100, 100,6,"#ccc0b3");
	}

}
</script>


作业: 可以使用canvas绘制游戏的UI等，尝试画象棋棋盘。



========================================
|-- 圆弧 arcTo(x1,y1, x2,y2, radius) 及 贝塞尔曲线(二次quadraticCurveTo()、三次bezierCurveTo)
----------------------------------------

1.圆弧 切线画圆弧 context.arcTo(x1,y1,x2,y2,radius)
//arcTo() 弧线和三个点确定的2直线相切；
//起点一定是指定起点，但不一定是弧线的起点；
//终点就是第二个切点，不一定指定的终点。


实例1:
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

function testArcTo(r=200){
	ctx.save()
	ctx.beginPath();
	ctx.strokeStyle="red"
	ctx.lineWidth=4;
	//需要先指定一个点，然后再arcTo()指定控制点，结束点，半径
	ctx.moveTo(100,50)
	ctx.arcTo(300,200,  100,400, r) //改变半径r，看效果
	ctx.stroke();
	ctx.restore();

	//画辅助线
	ctx.beginPath();
	ctx.moveTo(100,50); //point 1
	ctx.lineTo(300,200); //point 2
	ctx.lineTo(100,400); //point 3
	ctx.setLineDash([5,5]);
	ctx.stroke();
}

testArcTo(100) //100,200,300 分别查看红色弧线的效果
</script>




实例2: 月牙形状，并工程化优化代码
圆弧 切线画圆弧_3_moon context.arcTo(x1,y1,x2,y2,r);<br>
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

//tool: 计算2点之间的欧氏距离
function dist(x1,y1, x2,y2){
	return( Math.sqrt( (x1-x2)**2+(y1-y2)**2 ) )
}

//path 月亮: 指定半径，指定控制点距离中心的距离和半径的比例
function pathMoon(ctx,R,dr){
	var x0=0,y0=0; //起始点
	var xC=dr*R,yC=R;//控制点
	var x1=0,y1=2*R; //结束点
	//根据tan求圆弧半径
	var r=R*dist(x0,y0, xC,yC)/dist( (x0+x1)/2,(y0+y1)/2, xC,yC );
	
	ctx.beginPath();
	//半圆
	ctx.arc((x0+x1)/2, (y0+y1)/2, R, Math.PI/2, Math.PI*3/2, true)
	//圆弧
	ctx.moveTo(x0,y0);
	ctx.arcTo(xC,yC, x1,y1, r);
	
	ctx.closePath();
}

//画月亮: 位置，半径，控制点半径比，倾斜角度，填充颜色
//控制点和半径的比例越大，则月亮越弯
function drawMoon(ctx,x0,y0, R,dr, angle, fillColor){
	ctx.save()
	
	ctx.translate(x0,y0);//移动到位置
	ctx.rotate(angle); //旋转角度
	//画图形
	pathMoon(ctx, R,dr) 
	ctx.fillStyle=fillColor||"yellow"
	ctx.fill()
	
	ctx.restore()
}

//黑背景
ctx.fillStyle="black"
ctx.fillRect(0,0,canvas.width,canvas.height)

//画一个月亮
drawMoon(ctx, 200, 150, 80, 3, -Math.PI/6, 'red');//blood moon

//画多个月亮
var n=8,x0=300,y0=260, R=250;//月亮轨道圆心、半径，月亮个数
for(var i=0;i<n;i++){
	var angle=Math.PI*(1+i/n);
	drawMoon(ctx, x0+R*Math.cos(angle),y0+R*Math.sin(angle), 30,i/4, Math.PI/20*i, 'yellow')
		
	//drawMoon(ctx, 300+R*Math.cos(-angle),300+R*Math.sin(-angle),	30,-30*i/3, Math.PI/10, 'rgba(255,255,255,0.4)')
}
</script>






2. 贝塞尔曲线 
moveTo(x1,y1); quadraticCurveTo(xC,yC, x2,y2)	创建二次贝塞尔曲线
moveTo(x1,y1); bezierCurveTo(xC1,yC1, xC2,yC2, x2,y2)	创建三次方贝塞尔曲线


例1: quadraticCurveTo()和arcTo()类似，但是不用指定最后一个半径参数，而且曲线和收尾点是一致的。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
贝塞尔曲线 二次 context.quadraticCurveTo(x1,y1,x2,y2);<br>
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

function testQuadraticCurveTo(ctx, x0,y0, xC,yC, x1,y1){
	ctx.save()
	ctx.beginPath();
	ctx.strokeStyle="red"
	ctx.lineWidth=4;
	//需要先指定一个点，然后指定控制点，结束点
	ctx.moveTo(x0,y0)
	ctx.quadraticCurveTo(xC,yC,  x1,y1)
	ctx.stroke();
	ctx.restore();

	//画辅助线
	ctx.save()
	ctx.beginPath();
	ctx.moveTo(x0,y0); //point 1
	ctx.lineTo(xC,yC); //point 2
	ctx.lineTo(x1,y1); //point 3
	ctx.setLineDash([5,5]);
	ctx.stroke();
	ctx.restore();
}
//测试
testQuadraticCurveTo(ctx, 100,50,  300,200,  100,400);//指定三个点
testQuadraticCurveTo(ctx, 400,50,  400,300,  500,40);
</script>



例2: bezierCurveTo()
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
贝塞尔曲线 三次 context.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, xEnd,yEnd);<br>
<canvas id="canvas1"></canvas>
<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

function testBezierCurveTo(ctx, x0,y0, cp1x,cp1y, cp2x,cp2y, xEnd,yEnd){
	ctx.save()
	ctx.beginPath();
	ctx.strokeStyle="red"
	ctx.lineWidth=4;
	//需要先指定一个点，然后指定控制点，结束点
	ctx.moveTo(x0,y0)
	ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, xEnd,yEnd)
	
	ctx.stroke();
	ctx.restore();

	//画辅助线
	ctx.save()
	ctx.beginPath();
	ctx.moveTo(x0,y0); //0
	ctx.lineTo(cp1x,cp1y); //control 1
	ctx.moveTo(xEnd,yEnd); //0
	ctx.lineTo(cp2x,cp2y); //control 1
	ctx.setLineDash([5,5]);
	ctx.stroke();
	ctx.restore();
}
//测试
//testBezierCurveTo(ctx, 100,50,  300,200,  100,400, 400,300);//指定4个点
testBezierCurveTo(ctx, 100,50,  0,500,  250,500,  150,50);//花瓣
testBezierCurveTo(ctx, 400,50,  400,200,  500,40, 600,100);//左上角
</script>


作业: 使用花瓣路径，绘制花朵，可以指定花朵位置，旋转角度，花瓣个数，花瓣长度等。



========================================
文字渲染基础, 文本对齐
----------------------------------------

1. 常用属性
ctx.font="bold 40px Arial"; //文字样式
ctx.fillText(string, x,y);//文字和位置


(1) font属性默认 20px sans-serif
context.font= 最多可以设置5个值，和css中一致，分别是

1)font-style 
默认 normal， 斜体 italic, 倾斜字体 oblique;

2)font-variant 
默认 normal, small-caps 小号的大写字母显示小写字母

3)font-weight
lighter
normal 默认(400)
bold (700)
bolder
也可以使用数值 100,200,...,900.


4)font-size 字号
20px 默认 
2em
150%

还有几个字符串属性值xx-small, x-small, medium, large,x-large,xx-large;

5)font-family
设置多种字体备选
支持 @font-face ， css3可以向浏览器注入字体;
web安全字体:



(2)实例
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
文字渲染 fillText(string, x,y[, maxLen])<br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

ctx.font="bold 40px Arial";

ctx.save()
ctx.fillStyle="#058"
ctx.fillText("R1: fill text", 100,50); //填充后的文字
ctx.restore();


ctx.save()
ctx.lineWidth=2
ctx.strokeStyle="red"
ctx.strokeText('R2: stroke text', 20,100); //空心文字：描边后的文字
ctx.restore();

ctx.strokeText('R3: stroke text', 20,150, 100); //最后一个参数限定最长长度

//渐变色填充
//同理，也可以使用image图片填充，canvas对象来填充
var grd=ctx.createLinearGradient(0,0, 200,0)
grd.addColorStop(0, 'blue')
grd.addColorStop(0.5, 'white')
grd.addColorStop(1, 'red')
//
ctx.save()
ctx.fillStyle=grd;
ctx.font="italic bold 40px Arial";//斜体, 加粗
ctx.fillText('R4: stroke text', 20,200, 150);
ctx.restore()


ctx.save();
//小号大写字母 来显示小写
ctx.font="normal small-caps 40px Arial";//不加粗
ctx.fillText("R5: Small caps", 20,250)
ctx.restore();


</script>





2. 文本对齐
(1)文本横向对齐
context.textAligh=left|| center|| right

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
文字对齐 textAlign='left'<br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

//辅助线
ctx.moveTo(400,0)
ctx.lineTo(400,300)
ctx.stroke();

ctx.font="bold 40px Arial";
ctx.fillStyle="#058"

ctx.textAlign='left'
ctx.fillText("textAlign=left 默认", 400,50);

ctx.textAlign='center'
ctx.fillText("textAlign=center", 400,100);

ctx.textAlign='right'
ctx.fillText("textAlign=right", 400,150);
</script>


(2) 垂直对齐
context.textBaseline=top || middle|| bottom;
textBaseline 还有另外三个属性值: alphabetic(默认 拉丁语)/ideographic(汉语)/hanging(印度语);


(3) 获取文字宽度
var width=ctx.measureText(text).width;//获取文字宽度

局限性: 目前还只能获得width，不能获得其他属性。
获取前，要对文本的font属性进行设定。

作业: 既然可以获得文本宽度，就可以基于canvas做一个文本编辑器，肯定有很多细节需要处理。
字体测试系统?



========================================
阴影: 4个属性(shadowColor, shadowOffsetX,shadowOffsetY, shadowBlur)
----------------------------------------
1.常用的4个状态属性
设置好就绘制阴影了。(ctx: context)
ctx.shadowColor

ctx.shadowOffsetX
ctx.shadowOffsetY

ctx.shadowBlur


2.实例 
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
阴影 <br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

ctx.fillStyle="#F00"

ctx.shadowColor="#a00"
ctx.shadowOffsetX=30;
ctx.shadowOffsetY=10;
ctx.shadowBlur=5;
ctx.fillRect(20,20,200,100)

//函数设置阴影
function setShadow(ctx,color, X,Y, blur){
	ctx.shadowColor=color||"#eee"
	ctx.shadowOffsetX=X||0;
	ctx.shadowOffsetY=Y||0;
	ctx.shadowBlur=blur||4;
}

//带阴影的文字
ctx.save()
setShadow(ctx, "rgb(200,200,200,0.5)", 5,-5,5)

ctx.font="bold 40px Arial"
ctx.fillStyle="yellow"
ctx.fillText("CANVAS", 400,60)
ctx.restore()
</script>





========================================
两个全局属性: globalAlpha=1(Default), globalCompositeOperation="source-over"(Default)
----------------------------------------
1.全局透明度
修改后，整体透明度改变。
默认不透明。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
不透明度 globalAlpha <br>
<canvas id="canvas1"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

for(var i=0;i<200;i++){
	//获得随机颜色
	var R=Math.floor(Math.random()*255);
	var G=Math.floor(Math.random()*255);
	var B=Math.floor(Math.random()*255);
	ctx.fillStyle="rgb("+R+","+G+","+B+")";
	
	//设置不透明度
	ctx.globalAlpha=Math.random();
	ctx.globalAlpha=ctx.globalAlpha<0.4?0.4:ctx.globalAlpha;
	
	//开始画圆
	ctx.beginPath();
	var R=Math.random()*50;
	R=R<20?20:R;
	ctx.arc(Math.random()*canvas.width, Math.random()*canvas.height, R,
		0,2*Math.PI)
	ctx.fill();
}
</script>






2.globalCompositeOperation="source-over"

//遮挡顺序，共11个值
//ctx.globalCompositeOperation="source-over" //默认 后来居上
//ctx.globalCompositeOperation="destination-over" //原图形在上层

var arr=['source-over', 'source-atop', 'source-in', 'source-out',
	'destination-over', 'destination-atop', 'destination-in','destination-out',
	'lighter', 'copy', 'xor'];
//ctx.globalCompositeOperation=arr[0]



========================================
剪辑区域 ctx.clip() : 探照灯效果
----------------------------------------
clip() 方法从原始画布中剪切任意形状和尺寸。

提示：一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。


1. 例子
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
剪辑区域 ctx.clip()<br>
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

ctx.fillStyle='black';
ctx.fillRect(0,0,800,600);

//辅助线
ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2, canvas.height);
ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
ctx.stroke();

//
ctx.beginPath();
ctx.arc(400,300, 150, 0,Math.PI*2)
ctx.fillStyle='white';
ctx.fill();
ctx.clip();//只有该区域的部分才可以编辑

//文字
ctx.font="bold 150px Arial"
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.fillStyle='orange'
ctx.fillText('CANVAS', canvas.width/2, canvas.height/2);
</script>



2. 作业
制作探照灯效果。
动画效果，改变灯的形状，角度，大小等。




========================================
路径方向和剪纸效果: 非零环绕原则
----------------------------------------

1.非零环绕原则(拓扑学的定义)
复杂的、互相交叉的曲线收尾相连后，填充时怎么区分内外？

从某个区域，如果存在一条射线，和其相交的边的方向和(规定一个收尾相连曲线一个方向为正，则另一个方向为负)为非零，则该区域在内部。


镂空的圆环实例
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
路径方向和剪纸效果<br>
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=600;
var ctx = canvas.getContext('2d');

ctx.shadowColor="grey"
ctx.shadowOffsetX=10;
ctx.shadowOffsetY=10;
ctx.shadowBlur=5;

ctx.beginPath();
ctx.arc(300,300,100, 0, 2*Math.PI, false) //外圆 顺时针
ctx.arc(300,300,80, 0, 2*Math.PI, true) //内圆 逆时针
ctx.fill()
//内圆内的区域，根据非零环绕原则，
//从中发出一条射线，和相交2曲线(方向相反)的方向和为0，则为外部。

//尝试改变内圆第二个参数为false，则两个圆都是顺时针，内环内部也为内部，则为实心圆。
</script>




作业: 制作剪纸效果图，设置好阴影属性，然后画一个大的矩形(默认是顺时针)，然后在上面绘制几个逆时针图形，最后fill()，就出现剪影效果。








========================================
使用Canvas交互和 isPointInPath(x,y)
----------------------------------------
1.基本函数
isPointInPath(): 如果指定的点位于当前路径中，则返回 true，否则返回 false

//循环检查鼠标是否在小球内，是则修改颜色重绘
for(var i=0;i<balls.length;i++){
	var ball=balls[i];
	ctx.beginPath();
	ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
	//如果点击位置在小球内，则重绘该小球
	if(ctx.isPointInPath(x,y)){
		ctx.fillStyle="red";
		ctx.fill();
	}
}




2.实例 
交互 ctx.isPointInPath(x,y) 悬停改变小球颜色

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=800;
var ctx = canvas.getContext('2d');
var balls=[];

window.onload=function(){
	for(var i=0; i<10; i++){
		var oBall={
			x: Math.random()*canvas.width,
			y: Math.random()*canvas.height,
			r: Math.random()*50+20,
			color:'#058'
		}
		balls[i]=oBall;		
	}
	draw();
	canvas.addEventListener('mousemove', detect); //为实现动画
}

//绘制第一遍
function draw(x,y){
	for(var i=0; i<balls.length; i++){
		var ball=balls[i];
		ctx.beginPath();
		ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2 );
		
		if(x!=undefined && ctx.isPointInPath(x,y)){
			ball.color='red';
		}else{
			ball.color="#058";
		}
		ctx.fillStyle=ball.color;
		ctx.fill();
	}
}

//响应鼠标移动事件
function detect(event){
	//获取鼠标的canvas画布坐标，通过js方法 [经典语句]
	var x=event.clientX-canvas.getBoundingClientRect().left;//当前鼠标x位置，减去画布左侧的区域
	var y=event.clientY-canvas.getBoundingClientRect().top;
	
	draw(x,y);//重绘
}
</script>






========================================
在canvas上使用其他html控件
----------------------------------------
就是使用相对定位和绝对定位，确定html标签定位到canvas上，并绑定控制功能。
在按钮的单击事件中，改变全局变量的值，在canvas动画中，使用该全局变量决定是否刷新等操作。

<div id="canvasWrap">
	<canvas id="canvas1"></canvas>
	<div class="ctrls">
		<button> Begin</button>
		<button> End</button>
	</div>
</div>

<style>
#canvasWrap{
	position:relative;
}
#canvasWrap .ctrls{
	position:absolute;
	top:10px;
	left:10px;
	background:rgba(200,200,200,0.4);
	padding:10px;
}
</style>



========================================
扩展canvas的context方法: ctx.myMethod()
----------------------------------------

1. 给context新增方法
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
扩展canvas的context <br>
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=800;
var ctx = canvas.getContext('2d');

//对context的原型进行添加
CanvasRenderingContext2D.prototype.fillStar=function(r,R,x,y,rot){
	//内部使用this代替原来的context
	this.beginPath();
	for(var i=0;i<5;i++){
		this.lineTo(Math.cos( (18+i*72-rot)/180*Math.PI )*R+x,
			-Math.sin( (18+i*72-rot)/180*Math.PI )*R+y);
		this.lineTo(Math.cos( (54+i*72-rot)/180*Math.PI )*r+x,
			-Math.sin( (54+i*72-rot)/180*Math.PI )*r+y);
	}
	this.closePath();
	this.fill()
}

//测试
ctx.fillStyle="yellow";
ctx.fillStar(10,20, 100,100, 0);
ctx.fillStar(20,40, 200,100, 30);
</script>




2. 还有一些是依赖其他定位的，比如lineTo()要从之前的moveTo()函数指定的位置作为起点。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
扩展canvas的context _2 依赖其他函数的定位<br>
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=800;
var ctx = canvas.getContext('2d');

//改进为依赖 moveTo() 定位的绘图函数
var originalMoveTo=CanvasRenderingContext2D.prototype.moveTo;
CanvasRenderingContext2D.prototype.lastMoveToLoc={};
//重写moveTo()方法
CanvasRenderingContext2D.prototype.moveTo=function(x,y){
	originalMoveTo.apply(ctx, [x,y]);
	
	this.lastMoveToLoc.x=x;
	this.lastMoveToLoc.y=y;
}

//对context的原型进行添加 依赖moveTo()的绘图函数
CanvasRenderingContext2D.prototype.fillStar2=function(r,R,rot){
	//内部使用this代替原来的context
	var x=this.lastMoveToLoc.x;
	var y=this.lastMoveToLoc.y;
	
	this.beginPath();
	for(var i=0;i<5;i++){
		this.lineTo(Math.cos( (18+i*72-rot)/180*Math.PI )*R+x,
			-Math.sin( (18+i*72-rot)/180*Math.PI )*R+y);
		this.lineTo(Math.cos( (54+i*72-rot)/180*Math.PI )*r+x,
			-Math.sin( (54+i*72-rot)/180*Math.PI )*r+y);
	}
	this.closePath();
	this.fill()
}

//测试
ctx.fillStyle="yellow";
ctx.moveTo(100,100)
ctx.fillStar2(10,20, 0);

ctx.moveTo(200,200)
ctx.fillStar2(20,40, 30);
</script>


作业：
覆盖原函数不是一个好主意，因为稍微覆盖的有问题，原来依赖该函数的代码都会出问题。
可以延伸出一个自定义前缀的方法名系列，或者自定义context对象，建立自己的函数库、游戏引擎等。



========================================
canvas的官方标准 / 浏览器兼容性 / canvas图形库
----------------------------------------

一、历史原因，有2个官方标准维护canvas:
w3c 
http://www.w3.org/TR/2dcontext/

whatwg
https://html.spec.whatwg.org/ 这里其实是html5的所有文档。





二、canvas与浏览器兼容性
1. canvas标签内添加提示文字或图片。

2. 浏览器兼容性
js内使用if(context.ellipse) 来判断浏览器是否支持该方法
支持则返回函数对象，不支持则返回undefined，可以在else中加入alert()提醒。


3. 如果需要在IE678等运行canvas，可以加入兼容js代码
google: explorecanvas 
或者在github上找。

注意: 该js不是万能的。





三、cnavas 图形库
1.可以自己完善自己的图形库。

2.也有其他作者写的图形库。但是没有任何图形库是万能的。
1). canvasplus

2). artisan JS
artisanjs.com 

3). Rgragh 特定的统计图表图形库。





========================================
requestAnimationFrame() 函数代替setInterval(fn, time)
----------------------------------------
1. 基本框架: 
function update(){
	//需要更新的数据
	sun.update()
	tree.update();
	
	//重绘 
	stageClear();
	sun.draw();
	tree.draw();
	
	//重复该过程
	requestAnimationFrame(update)
}

//启动动画
update();




2. 实例: 一个小球自由落体并弹起，不计能量损失。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
requestAnimationFrame 更流畅的动画效果<br>
<canvas id="canvas1" style="border:1px solid black;"></canvas>

<script>
var canvas = document.getElementById('canvas1');
canvas.width=800;
canvas.height=400;
var ctx = canvas.getContext('2d');

//自由落体运动
var g=0.9;
var ratio=0.9;//垫子的位置
var ball={x:canvas.width/2,	y:20, r:15, vy:0}

//画底部垫子
ctx.fillRect(canvas.width/6*2.5, canvas.height*ratio, canvas.width/6, 20)

//画小球
function draw(){
	//清除画布
	ctx.clearRect(0,0,canvas.width,canvas.height*ratio);
	//画小球
	ctx.beginPath();
	ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
	ctx.fillStyle="orange";
	ctx.fill();
}

function update(){	
	var oldY=ball.y;
	//计算下一帧位置
	ball.vy+=g;	//更新速度 vt=v0+a;
	ball.y+=ball.vy;//更新位置 s=s0+v*t;
	
	//碰撞检测
	if(ball.y+ball.r>canvas.height*ratio){
		//ball.y-=ball.r; //位置矫正 不好，有可能还是出不来，有可能穿透
		ball.y=oldY; //取消当前帧的更新，这个处理更好
		ball.vy=-ball.vy;
	}
	
	//绘图
	draw();
	//该函数能根据电脑的屏幕刷新频率，自动更新动画
	requestAnimationFrame(update);
}
update();
</script>





========================================
实际问题: 双球碰撞后的速度处理 //todo
----------------------------------------
2D动画的碰撞检测 https://www.cnblogs.com/sevenyuan/p/7125642.html

质量不等的小球的非对心碰撞，怎么计算碰撞后的速度和运动方向？
https://www.cnblogs.com/dashnowords/p/10753005.html


1. google小球，鼠标悬浮排斥小球
https://www.html5canvastutorials.com/labs/html5-canvas-google-bouncing-balls/
解析 https://www.cnblogs.com/qs20199/p/4452271.html
怎么防止穿墙?


2. 堆积的小球，鼠标向上拖动可以扬起小球
http://whxaxes.github.io/canvas-test/src/Other-demo/shotBall.html
解析 https://www.cnblogs.com/axes/p/3513343.html
看代码，碰撞后的方向和速度怎么处理？

一些常量ballRadius =30, g = 9.8 , mocali = 0.5,balls = [],collarg = 0.8,pxpm = canvas.width/20; 意思很明显：ballradius是球半径，g是重力加速度，mocali是空气阻力引起的水平方向的减速度，balls是一个用于存放小球对象的数组，collarg是弹力系数。pxpm是像素与米之间的映射，把画布当成是20米宽的区域。

有空了看下怎么推导？
var rc = Math.sqrt(Math.pow(b1.x - b2.x , 2) + Math.pow(b1.y - b2.y , 2));
if(Math.ceil(rc) < (b1.radius + b2.radius)){
	//获得碰撞后速度的增量
	var ax = ((b1.vx - b2.vx)*Math.pow((b1.x - b2.x) , 2) + (b1.vy - b2.vy)*(b1.x - b2.x)*(b1.y - b2.y))/Math.pow(rc , 2)
	var ay = ((b1.vy - b2.vy)*Math.pow((b1.y - b2.y) , 2) + (b1.vx - b2.vx)*(b1.x - b2.x)+(b1.y - b2.y))/Math.pow(rc , 2)

	//给与小球新的速度
	b1.vx = (b1.vx-ax)*collarg;
	b1.vy = (b1.vy-ay)*collarg;
	b2.vx = (b2.vx+ax)*collarg;
	b2.vy = (b2.vy+ay)*collarg;

	//获取两球斜切位置并且强制扭转
	var clength = ((b1.radius+b2.radius)-rc)/2;
	var cx = clength * (b1.x-b2.x)/rc;
	var cy = clength * (b1.y-b2.y)/rc;
	b1.x = b1.x+cx;
	b1.y = b1.y+cy;
	b2.x = b2.x-cx;
	b2.y = b2.y-cy;
}


3. 桌球游戏
https://www.cnblogs.com/axes/p/3524928.html









========================================
如何使用canvas处理图像?(浏览器版本的photoshop
)canvas 图像处理(之前是图形，以下是图像): 缩放、添加水印、鼠标交互
----------------------------------------
大纲:
缩放图像
离屏canvas: 就是将第二个canvas中的内容加载到第一个canvas上;
canvas像素级处理: 各种图像算法做滤镜;


1. 载入图像，缩放图像
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
图像处理: 载入图像，图像缩放  drawImage(image, dx,dy, ?dw,?dh)<br>
<style>
#canvas1{
	display:block; margin:0 auto; border:1px solid #aaa;
}
</style>
<canvas id="canvas1"></canvas>

<script>
var canvas=document.getElementById('canvas1');
canvas.width=800;canvas.height=400;
var ctx=canvas.getContext('2d');
//ctx.strokeRect(0,0,canvas.width,canvas.height);

//载入图像
var img=new Image();
img.src="../images/win7.png";
//必须要在image的onload事件中载入图像，否则会载入失败
img.onload=function(){
	//col 1: 3个参数，第一个是image dom对象，接着是起点坐标(x,y)
	ctx.drawImage(img, 10, 10);
	//col 2: 还有2个参数，分别是显示宽、高，相当于缩放处理
	ctx.drawImage(img, 100,10, 200,200);
	ctx.drawImage(img, 100,250, img.width/2,img.height/2);//精确缩小50%
	//col 3: 使用9个参数，把原图(source)的某个区域内的区域加载到画布中(destination)
	//ctx.drawImage(img,  sx,sy,sw,sh, dx,dy,dw,dh)
	ctx.drawImage(img,  0,0,img.width/2,img.height/2, 320,10,100,100)
}
</script>






2. 给图像添加水印
基本思路: 就是要在在一个canvas中绘制图像，然后添加到另一个图像中。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
water mark 添加水印<br>
<style>
#canvas1{display:block; margin:0 auto; border:1px solid #aaa;}
</style>
<canvas id="canvas1"></canvas>

<script>
var canvas=document.getElementById('canvas1');
canvas.width=300;canvas.height=300;
var ctx=canvas.getContext('2d');

//载入图像
var img=new Image();
img.src="../images/win7.png";

//水印函数
function getWaterMark(text,width, fillStyle){
	var canvas2=document.createElement('canvas');
	canvas2.width=width; canvas2.height=20;
	var ctx2=canvas2.getContext('2d');
	//设置文字
	ctx2.textAligh='left'
	ctx2.textBaseline='top'
	ctx2.fillStyle=fillStyle || "rgba(255,0,0,0.7)";
	ctx2.font="Bold 20px Arial";
	//获取文字宽度
	var textWidth=ctx2.measureText(text).width;
	//canvas2.width=textWidth; //这句直接啥都没了?!
	ctx2.fillText(text, 0,0,width);
	
	//ctx2.strokeRect(0,0,canvas2.width,canvas2.height);//水印外边框
	//document.body.append(canvas2);//添加到dom中可见
	return( [canvas2, textWidth] );
}

//载入主图
img.onload=function(){
	//载入主图，填充整个画布
	ctx.drawImage(img, 0,0, canvas.width,canvas.height);
	
	//获取水印图像: 返回值维数组，第一个为canvas，第二个为文字宽度
	var arr=getWaterMark("water mark 2020", 150, 'rgba(255,255,255,0.5)');//白色文字
	//var arr=getWaterMark("water mark 2020", 150, 'rgba(0,0,0,0.4)');//灰色文字
	var waterMarkCanvas=arr[0];
	//添加水印到主图
	//ctx.drawImage(waterMarkCanvas, 0,canvas.height-waterMarkCanvas.height);//原始比例，左下角
	//ctx.drawImage(waterMarkCanvas, 0,canvas.height-waterMarkCanvas.height, waterMarkCanvas.width/2,waterMarkCanvas.height);//压缩长度
	ctx.drawImage(waterMarkCanvas, canvas.width-waterMarkCanvas.width,canvas.height-waterMarkCanvas.height);//右下角
	//ctx.drawImage(waterMarkCanvas, 0,0,arr[1],arr[0].height,  10,170,arr[1],arr[0].height);
}
</script>












========================================
|-- canvas和鼠标的交互案例: 单击图像或拖动时出现放大镜
----------------------------------------
1.该案例的主要难点是获取鼠标的坐标。
使用到的知识点: 圆弧的绘制，剪辑区域；


2. 案例代码：

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
放大镜(鼠标单击和拖动时 局部放大图片)<br>
<style>
#canvas1{display:block; margin:0 auto; border:1px solid #aaa;}
#offCanvas{display:none;}
</style>
<canvas id="canvas1"></canvas>
<canvas id="offCanvas"></canvas>

<script>
var canvas=document.getElementById('canvas1');
canvas.width=300;canvas.height=300;
var ctx=canvas.getContext('2d');
//ctx.strokeRect(0,0,canvas.width,canvas.height);

//放大镜canvas
var offCanvas=document.getElementById('offCanvas');
var offCtx=offCanvas.getContext('2d');
var scale=5; //放大倍数, 可设置

//载入图像
var img=new Image();
img.src="../images/win7.png";
imgH=img;//第二个是高清图

img.onload=function(){
	//载入图像，全画布显示
	ctx.drawImage(img, 0,0, canvas.width, canvas.height);
	
	//放大镜画布，载入高清图
	offCanvas.width=canvas.width*scale;
	offCanvas.height=canvas.height*scale;
	
	offCtx.drawImage(imgH, 0,0, offCanvas.width, offCanvas.height);
}


//获得相对于canvas的鼠标位置坐标，传入dom坐标
function windowToCanvas(x,y,canvas){
	var bbox=canvas.getBoundingClientRect();
	return {x:x-bbox.left, y:y-bbox.top};
}

var IsMouseDown=false;

//单击开始显示位置
canvas.onmousedown=function(e){
	e.preventDefault();//阻止默认事件
	IsMouseDown=true;
	//console.log(e.clientX,e.clientY);//这是dom文档坐标值
	var point=windowToCanvas(e.clientX,e.clientY, ctx.canvas);
	//console.log(point)
	
	drawCanvasWithMagnifier(true, point)
}

//鼠标移动时
canvas.onmousemove=function(e){
	e.preventDefault();
	//console.log('mouse mvoe');
	if(IsMouseDown==true){
		var point=windowToCanvas(e.clientX,e.clientY, ctx.canvas);
		drawCanvasWithMagnifier(true, point)
	}
}

canvas.onmouseup=function(e){
	e.preventDefault();
	IsMouseDown=false;
	//console.log('mouse up');
	drawCanvasWithMagnifier(false)
}

canvas.onmouseout=function(e){
	e.preventDefault();
	IsMouseDown=false;
	drawCanvasWithMagnifier(false)
}

//重绘带放大镜的画布
function drawCanvasWithMagnifier(isShowMagnifier, point){
	ctx.clearRect(0,0,canvas.width,canvas.height);
	ctx.drawImage(img, 0,0, canvas.width, canvas.height);
	//绘制放大镜
	if(isShowMagnifier){
		drawMagnifier(point);
	}
	
	//console.log(a,b)
}

function drawMagnifier(point){
	var r=canvas.height/4;//放大镜半径
	//放大镜画布的圆心坐标
	var L_cx=point.x*scale;
	var L_cy=point.y*scale;
	
	//source x,y
	var sx=L_cx-r, sy=L_cy-r;
	//destination x,y
	var dx=point.x-r, dy=point.y-r;
	
	//绘制圆形的剪辑区域
	ctx.save();
	ctx.beginPath();
	ctx.arc(point.x, point.y, r, 0, Math.PI*2);
	//绘制放大镜边框
	ctx.lineWidth=10;
	ctx.strokeStyle='#069';
	ctx.stroke();
	//然后建立剪辑区域
	ctx.clip();
	//接下来只能在圆形内编辑
	ctx.drawImage(offCanvas, sx,sy,2*r,2*r, dx,dy,2*r,2*r);
	ctx.restore();
}
</script>





========================================
|-- 像素级的图像处理基础: getImageData()和putImageData();
----------------------------------------
1. 像素级图像区域的获取和放置
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
像素级的图像处理: 获取和放置图像数据<br>
<style>
canvas{display:inline-block; border:1px solid #aaa; margin:10px 50px;}
.center{margin:10px auto; width:100px;}
</style>

<canvas id="canvas1"></canvas>
<canvas id="canvas2"></canvas>

<div class=center>
	<button id='filter'>filter</button>
</div>

<script>
var canvas1=document.getElementById('canvas1');
canvas1.width=300;canvas1.height=300;
var ctx1=canvas1.getContext('2d');

var canvas2=document.getElementById('canvas2');
canvas2.width=300;canvas2.height=300;
var ctx2=canvas2.getContext('2d');

//载入图片
var img=new Image();
img.src='../images/win7.png';
img.onload=function(){
	ctx1.drawImage(img, 0,0, canvas1.width, canvas1.height);
}

//单击时获取图片信息，并放置到右侧
document.getElementById("filter").onclick=function(){
	//1.获取 ctx1.getImageDate(x,y, width,height) 返回值为对象:包括键 width,height,data;
	var imageData=ctx1.getImageData(0,0, canvas1.width, canvas1.height);
	
	//2.修改imageData;
	//简单修改，也可以不修改
	imageData=filter1(imageData);
	
	//3.放置到右侧 ctx2.putImageData(imageData, dx,dy, dirtyX,dirtyY,dirtyW,dirtyH);
	//其中 dx,dy是要放入destination画布的位置，而dirtyX,dirtyY是source的位置
	//注意：放入的位置是x=dx+dirtyX, y=dy+dirtyY;
	//ctx2.putImageData(imageData, 0,0, 0,0,canvas2.width,canvas2.height);//放置原图
	//ctx2.putImageData(imageData, 50,50, 0,0,canvas2.width,canvas2.height); //右上角空一部分
	//ctx2.putImageData(imageData, 50,50, 20,20,canvas2.width,canvas2.height); //右上角空一部分
	ctx2.putImageData(imageData, 0,0, 50,50,canvas2.width-100,canvas2.height-100); //四边都留白
}

//滤镜1
function filter1(imageData){
	console.log('imageData=', imageData); //是一维数组，4位为一个像素，分别对应着rgba四个值;
	return(imageData);
}
</script>






========================================
|-- 像素级处理高级——简单的图像滤镜效果: 单个通道、灰度、黑白、反色、模糊、马赛克
----------------------------------------
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
图像滤镜 _2 更多滤镜(7个滤镜效果: 单个通道、灰度、黑白、反色、模糊、马赛克)<br>
<style>
canvas{display:inline-block; border:1px solid #aaa; margin:10px 50px;}
.center{margin:10px auto; width:1000px;}
</style>

<canvas id="canvas1"></canvas>
<canvas id="canvas2"></canvas>

<div class=center id=filters>
	<!-- 滤镜按钮 -->
	<button id='filter1'>filter1 原图</button>
	<button id='filter2'>filter2 获取单个通道</button>
	<button id='filter3'>filter3 灰度图</button>
	<button id='filter4'>filter4 黑白图</button>
	<button id='filter5'>filter5 反色</button>
	<br>
	<button id='filter6'>filter6 模糊Blur(耗时)</button>
	<button id='filter7'>filter7 马赛克Mosaic</button>
</div>

<script>
var canvas1=document.getElementById('canvas1');
canvas1.width=300;canvas1.height=300;
var ctx1=canvas1.getContext('2d');

var canvas2=document.getElementById('canvas2');
canvas2.width=300;canvas2.height=300;
var ctx2=canvas2.getContext('2d');

//载入图片
var img=new Image();
img.src='../images/github.png';
img.src='../images/win7_H.png';
img.onload=function(){
	ctx1.drawImage(img, 0,0);
	//ctx1.drawImage(img, 0,0, canvas1.width, canvas1.height);
}

//根据滤镜名字处理图像
function filterImage(filterName){
	//1.获取 ctx1.getImageDate(x,y, width,height) 返回值为对象:包括键 width,height,data;
	var imageData=ctx1.getImageData(0,0, canvas1.width, canvas1.height);
	
	//2.修改imageData;
	imageData=filterName(imageData);
	
	//3.放置到右侧 ctx2.putImageData(imageData, dx,dy, dirtyX,dirtyY,dirtyW,dirtyH);
	//其中 dx,dy是要放入destination画布的位置，而dirtyX,dirtyY是source的位置
	//注意：放入的位置是x=dx+dirtyX, y=dy+dirtyY;
	ctx2.putImageData(imageData, 0,0, 0,0,canvas2.width,canvas2.height);//放置原图
}


//绑定单击事件：单击则使用该滤镜处理图片，并显示到右侧
/*document.getElementById("filter1").onclick=function(){ filterImage(eval(this.id)); }
document.getElementById("filter2").onclick=function(){ filterImage(eval(this.id)); }*/

var aBtn=document.getElementById("filters").getElementsByTagName('button');
for(var i=0;i<aBtn.length;i++){
	var oBtn=aBtn[i];
	oBtn.onclick=function(){
		filterImage(eval(this.id)); 
	}
}


//定义滤镜1: 返回原图
function filter1(imageData){
	console.log('imageData=', imageData); //是一维数组，4位为一个像素，分别对应着rgba四个值;
	return(imageData);
}

//定义滤镜2: 获取单个通道
function filter2_2(imageData){
	console.log('imageData.data=', imageData); //是一维数组，4位为一个像素，分别对应着rgba四个值;
	//第i个像素的值是 r=pixelData[4*i+0]; g是+1,b是+2,a是+3; 
	//第x行第y列的像素编号是 i=x*width+y;
	var pixelData=imageData.data;
	for(var x=0;x<imageData.width;x++){
		for(var y=0;y<imageData.height;y++){
			//计算像素编号
			var i=x*imageData.width+y;
			//获取rgba值:var r=pixelData[4*i+0], g=pixelData[4*i+1], b=pixelData[4*i+2], a=pixelData[4*i+3];
			//简单修改，只保留1个通道，其他通道归零
			//pixelData[4*i+0]=0;//r
			pixelData[4*i+1]=0;//g
			pixelData[4*i+2]=0;//b
		}
	}
	return(imageData);
}
//使用如下抽象函数简写
//定义滤镜2: 获得单个通道
function filter2(imageData){
	function filterCore(r,g,b,a){
		return([0,g,0,a]);
	}
	return(filterBase(imageData, filterCore));
}


//定义滤镜函数抽象函数层
function filterBase(imageData, filterCore){
	var pixelData=imageData.data;
	for(var x=0;x<imageData.width;x++){
		for(var y=0;y<imageData.height;y++){
			//计算像素编号
			var i=x*imageData.width+y;
			//获取rgba值:
			var r=pixelData[4*i+0], g=pixelData[4*i+1], b=pixelData[4*i+2], a=pixelData[4*i+3];
			//处理 r,g,b,a并返回
			var arr=filterCore(r,g,b,a);
			//赋值
			pixelData[4*i+0]=arr[0];//r
			pixelData[4*i+1]=arr[1];//g
			pixelData[4*i+2]=arr[2];//b
			pixelData[4*i+3]=arr[3];//a			
		}
	}
	return(imageData);
}

//定义滤镜3:灰度图
function filter3(imageData){
	function filterCore(r,g,b,a){
		var grey=r*0.3 +g*0.59 +b*0.11;
		return([grey,grey,grey,a]);
	}
	return(filterBase(imageData, filterCore));
}

//定义滤镜4: 黑白滤镜
function filter4(imageData){
	function filterCore(r,g,b,a){
		var grey=r*0.3 +g*0.59 +b*0.11;
		grey=grey>150?255:0;//如果大于阈值，则为白色; (阈值越大则黑色越多)
		return([grey,grey,grey,a]);
	}
	return(filterBase(imageData, filterCore));
}

//定义滤镜5: 反色滤镜
function filter5(imageData){
	function filterCore(r,g,b,a){
		return([255-r,255-g,255-b,a]);
	}
	return(filterBase(imageData, filterCore));
}

//定义滤镜6: 模糊处理。原理: 把周围像素的平均值赋值给当前点;
function filter6(imageData,blurR){
	var data=imageData.data;
	//深度拷贝一份原始数据
	var nData=[];
	for(var i=0;i<data.length;i++){
		nData.push(data[i]);
	}
	//console.log(nData.length, data.length)
	//设置模糊半径，越大越模糊，但是也越慢
	var blurR=blurR || 5;//超过10会很慢，5模糊效果很好
	//var totalNumber=(2*blurR+1)**2+10;	//点的总数
	for(var x=0;x<imageData.width;x++){
		for(var y=0;y<imageData.height;y++){
			//获取该像素点位置
			var i=x*imageData.width+y;
			
			//获取该点上下左右点的rgb值的和
			var totalR=0,totalG=0,totalB=0;
			var totalNumber=0;
			for(var dx=-blurR;dx<=blurR;dx++){
				for(var dy=-blurR;dy<=blurR;dy++){
					//如果越界，则跳过
					if( x+dx<0 || x+dx>=imageData.width || y+dy<0 || y+dy>=imageData.height){
						continue;
					}
					//求和的点数
					totalNumber++;
					//获取该像素编号
					var di=(x+dx)*imageData.width+(y+dy);
					//获取该点的rgba值
					totalR+=data[4*di+0];
					totalG+=data[4*di+1];
					totalB+=data[4*di+2];
				}
			}
			
			//点的RGB值赋值给新数据
			nData[4*i+0]=totalR/totalNumber;
			nData[4*i+1]=totalG/totalNumber;
			nData[4*i+2]=totalB/totalNumber;
		}
	}
	//覆盖
	for(var i=0;i<imageData.data.length;i++){
		imageData.data[i]=nData[i];
	}
	return(imageData);
}


//定义滤镜7: 马赛克效果。原理: 把周围像素的平均值赋值给周围像素。类似模糊滤镜.
function filter7(imageData,blurR=15){
	var data=imageData.data;
	//设置马赛克方块宽度
	var blurR=blurR || 16;//马赛克效果多大效果好呢？
	for(var x=0;x<imageData.width;x+=blurR){
		for(var y=0;y<imageData.height;y+=blurR){
			
			//获取该点上下左右点的rgb值的和
			var totalR=0,totalG=0,totalB=0;
			var totalNumber=0;
			for(var dx=0;dx<=blurR;dx++){
				for(var dy=0;dy<=blurR;dy++){
					//如果越界，则跳过
					if( x+dx<0 || x+dx>=imageData.width || y+dy<0 || y+dy>=imageData.height){
						continue;
					}
					//求和的点数
					totalNumber++;
					//获取该像素编号
					var di=(x+dx)*imageData.width+(y+dy);
					//获取该点的rgba值
					totalR+=data[4*di+0];
					totalG+=data[4*di+1];
					totalB+=data[4*di+2];
				}
			}
			
			//计算平均RGB值
			var resultR=totalR/totalNumber;
			var resultG=totalG/totalNumber;
			var resultB=totalB/totalNumber;
			
			//覆盖: 赋值给原始采样点
			for(var dx=0;dx<=blurR;dx++){
				for(var dy=0;dy<=blurR;dy++){
					var di=(x+dx)*imageData.width+(y+dy);
					data[4*di+0]=resultR;
					data[4*di+1]=resultG;
					data[4*di+2]=resultB;
				}
			}
		}
	}
	return(imageData);
}
</script>




========================================
|-- 创建图像 ctx.createImageData(w,h): 一段感受到人类璀璨智慧的图像构建代码
----------------------------------------
https://www.zhihu.com/question/30262900

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
ctx.createImageData(w,h) 创建图像 一段感受到人类璀璨智慧的图像构建代码<br>
<style>
canvas{display:inline-block; margin:10px 50px;}
</style>

<canvas id="canvas1"></canvas>

<script>
var canvas=document.getElementById('canvas1');
const DIM=400;
canvas.width=DIM;canvas.height=DIM;
var ctx=canvas.getContext('2d');
//ctx.strokeRect(0,0,canvas.width, canvas.height);

//1.创建imageData
var imgData=ctx.createImageData(canvas.width, canvas.height);
//2.为其data赋值
/*
paint1(imgData)
paint2(imgData)
*/
paint3(imgData)

//3.填充画布
ctx.putImageData(imgData,0,0, 0,0, canvas.width, canvas.height);

//====== =======编写paint函数===== ========
//https://www.zhihu.com/question/30262900

//method1: 纯色
function paint1(imgData){
	for (var x=0;x<imgData.width;x++){
		for (var y=0;y<imgData.height;y++){
			var i=x*imgData.width+y;
			imgData.data[4*i+0]=55;
			imgData.data[4*i+1]=200;
			imgData.data[4*i+2]=2000;
			imgData.data[4*i+3]=255;
		}
	}
}

//method2: 放射色轮
function paint2(imgData){
	// 函数库
	var _sq=function(x){return Math.pow(x,2)}, cos=Math.cos, atan2=Math.atan2, acos=Math.acos;
	
	for (var i=0;i<imgData.height;i++){
		for (var j=0;j<imgData.width;j++){
			var p=i*imgData.width+j;//点的位置
			
			//神奇的代码，没看懂 https://www.zhihu.com/question/30262900
			var r=_sq(cos(atan2(j-DIM/2,i-DIM/2)/2))*255;
			var g=_sq(cos(atan2(j-DIM/2,i-DIM/2)/2-2*acos(-1)/3))*255;;
			var b=_sq(cos(atan2(j-DIM/2,i-DIM/2)/2+2*acos(-1)/3))*255;
			
			//填充
			imgData.data[4*p+0]=r;
			imgData.data[4*p+1]=g;
			imgData.data[4*p+2]=b;
			imgData.data[4*p+3]=255;
		}
	}
}


//method3: 涂抹的油画颜料，45度斜角
//done: 开始和大神的作品不一致，只有单色，无法实现多色涂抹。后来发现是随机数问题，分别运行即可解决。
function paint3(imgData){
	paint3ByChannelId(imgData, 0);
	paint3ByChannelId(imgData, 1);
	paint3ByChannelId(imgData, 2);
}
function paint3ByChannelId(imgData, channelId){
	var r=function(n){return Math.floor(Math.random()*n);}
	
	//初始化一个矩阵
	var c=[];
	for (var i=0;i<imgData.height;i++){
		c.push([])
		for (var j=0;j<imgData.width;j++){
			c[i][j]=0; //r(1);
		}
	}
	//神奇的代码，没看懂 https://www.zhihu.com/question/30262900 这三个函数实质上是一样的。改变99为999可以使涂抹线条更宽
	//非0则取自己，0则再测试是否不等于r(99):不等于则随机，等于则递归(i+r2, j+r2)
	var RD=function(i,j){return(!c[i][j]?c[i][j]=!r(99)?r(256):RD((i+r(2))%DIM,(j+r(2))%DIM):c[i][j])};
	var GR=function(i,j){return(!c[i][j]?c[i][j]=!r(99)?r(256):GR((i+r(2))%DIM,(j+r(2))%DIM):c[i][j])};
	var BL=function(i,j){return(!c[i][j]?c[i][j]=!r(99)?r(256):BL((i+r(2))%DIM,(j+r(2))%DIM):c[i][j])};
	//填充点
	for (var i=0;i<imgData.height;i++){
		for (var j=0;j<imgData.width;j++){
			var p=i*imgData.width+j;//点的位置		
			//填充
			imgData.data[4*p+channelId]=RD(i,j);
			//imgData.data[4*p+1]=GR(i,j);
			//imgData.data[4*p+2]=0 //BL(i,j);
			imgData.data[4*p+3]=255;
			
			c[i][j]=imgData.data[4*p+0]
		}
	}
}
</script>




========================================
综合练习：开发一个基于Canvas的网页绘图应用程序
----------------------------------------

1. 探索阶段：确定可行性和目标

(1)实现功能：
1)、能够绘制直线、样条曲线、圆、多边形等，并能够对所绘进行编辑；
2)、具有文件存储功能等

实现了部分类似Windows画图板的功能，包括铅笔、图章仿制、画直线、圆、矩形、橡皮擦、背景图、取色板、插入文字等功能，在实现过程中也利用了最新的CSS3技术


(2) 自由画笔的实现
https://blog.csdn.net/ydd321/article/details/47216009


(3) 笔刷等高级效果
https://blog.csdn.net/qq_40427180/article/details/85366472


(4) 手绘效果库
https://github.com/rough-stuff/rough
Roughjs是一个轻量级的JavaScript图形库（压缩后约9KB），可以让你在网页上绘制素描风格、手绘样式般的图形。Roughjs定义了绘制直线，曲线，圆弧，多边形，圆和椭圆的图元，同时它还支持绘制SVG路径。


(5) 更好用的图表系统
https://canvasjs.com/
https://canvasjs.com/javascript-charts/






2. 别人已经实现的功能

(1) 画板
http://yanhaijing.com/Painter/


(2) ms painter
https://www.canvaspaint.org/
 




========================================
p5.js 基于 canvas的库
----------------------------------------
例子: https://p5js.org/examples/





========================================
小游戏: canvas 版 flipbird
----------------------------------------
https://www.w3schools.com/graphics/game_score.asp





========================================
更多案例
----------------------------------------
1. 测量仪器、标尺: https://wwvalue.com/web-dev/pure-javascript-html5-canvas-gauge-canvgauge

2. 3D小车: https://bruno-simon.com/
上下左右键控制移动。




========================================
js 游戏引擎: HTML5 game framework 
----------------------------------------

1. info from https://www.zhihu.com/zvideo/1303117164316930048

(1) phaser
https://phaser.io/
https://phaserjs.com/

实例 https://phaser.io/examples


(2) create js
https://www.createjs.com/
分几个子包，可以控制声音的 sound.js

例子
	https://www.createjs.com/demos/easeljs/game
	https://www.createjs.com/demos/easeljs/curveto

(3) panda2 js (付费)
https://www.panda2.io/docs/api
https://www.panda2.io/plugins/  几个插件
API: https://www.panda2.io/docs/api


实例 https://www.panda2.io/games
	https://www.panda2.io/games/woriar
	https://www.panda2.io/games/kurupanda
	https://www.panda2.io/games/diamond

(4)cocos2d-html5
https://github.com/cocos2d/cocos2d-html5


(5) pixi js
https://www.pixijs.com/

https://gogomakeplay.com/games.html
	https://gogomakeplay.com/puckerball.html
	https://gogomakeplay.com/galaxoid.html




ref:
https://www.oschina.net/news/49017/free-javascript-game-engines

========================================
----------------------------------------





========================================
----------------------------------------


========================================
----------------------------------------





========================================
----------------------------------------


========================================
----------------------------------------





========================================
----------------------------------------


========================================
----------------------------------------

