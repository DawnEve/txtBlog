计算机组成原理
Principles of Computer Organization
(考研科目)

数据的表示与运算
存储器层次结构
指令系统
中央处理器
总线
输入输出系统



CSAPP 阅读笔记: Linux/  url: /index.php?k=Linux&id=1_8




========================================
简介与资料
----------------------------------------
1. 简介 

Principles of Computer Organization is about understanding the inner workings of computer systems from a conceptual standpoint, rather than from an engineering standpoint. Upon successful completion of this course, the computer will no longer seem a "black box" to you.



2. 资料
(1) 文字网页课程

网上课程主页
https://www.ontko.com/pub/rayo/cs63.html
https://www.biancheng.net/


pdf教程
https://www.cs.allegheny.edu/sites/amohan/teaching/cs200/cs200-syllabus.pdf


计算机组成与设计（第5版）- 学习指导与实验，纪禄平、罗克露、张建 编著，北京：电子工业出版社，2020



(2) 视频教程
https://www.icourse163.org/course/UESTC-1001543002
第1章  计算机系统概述
第2章  数据的表示、运算与校验
第3章  CPU子系统
第4章  存储子系统
第5章  总线与I/O子系统
第6章  I/O设备及其接口



========================================
数据的表示与运算
----------------------------------------



========================================
|-- 进制、原码/反码/补码详解及负数的位运算
----------------------------------------
1. 二进制、八进制、16进制、十进制的转换
0 1 2 3  4  5  6   7   8   9   10
1 2 4 8 16 32 64 128 256 512 1024

3位 二进制 => 1位 八进制
(111)2 => (7)8 

4位 二进制 => 1位 十六进制
(1111)2 => (F)16


10进制 to 2进制，短除法
2|152 余数
2| 76  0
2| 38  0
2| 19  0
2|  9  1
2|  4  1
2|  2  0
2|  1  0
把最后一个商和倒着写的余数连起来就是 (1001 1000)2=2**7 + 2**4 +2**3=128+16+8=152
前面有几位数，就乘以进制的几次方。




(2) 格式化输出n进制

#include<stdio.h>
int main(){
	int num=63;
	printf("10进制: %d\n", num);
	printf("16进制: 0x%X\n", num);
	printf("16进制: 0x%x\n", num);
	printf("8进制: 0%o\n", num);
	printf("2进制(没): %p\n", &num);

	// printf()8进制、16进制输出格式控制：
	printf("%04o\n",num); /*输出4位8进制的num*/
	printf("%02X\n",num); /*输出2位16进制的num*/
	return 0;
}

输出： 
10进制: 63
16进制: 0x3F
16进制: 0x3f
8进制: 077
2进制(没): 0x7ffee26ea064
0077
3F

使用gdb查看内存：
(gdb) p &num
$2 = (int *) 0x7fffffffe034
(gdb) x &num
0x7fffffffe034:	0x0000003f
(gdb) x/d &num  ## 十进制
0x7fffffffe034:	63


就是这个内存的位置，存放的16进制是 0x0000003f
int类型，8位16进制，合32位二进制，第一位是符号位，总共有 2**31






2.有符号数的原码、反码和补码

计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。


(1). 机器数和真值

## 机器数

一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。


## 真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1





(2) 原码, 反码, 补码的基础概念和计算方法.
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.
对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.


1) 原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001
[-1]原 = 1000 0001
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
[1111 1111 , 0111 1111] 即 [-127 , 127]

原码是人脑最容易理解和计算的表示方式.


2)反码
反码的表示方法是: 
- 正数的反码是其本身
- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.


3) 补码
补码的表示方法是:
- 正数的补码就是其本身
- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码再计算其数值.





3.负数的按位与运算：
按位与运算是按照数据的内部二进制形式进行运算的。若是两个负数，则是按二进制补码形式进行按位与。
所得结果若用有符号整型变量存储，则内部形式仍看作二进制补码。
如果用格式符%d输出，输出结果为十进制真值（不应该称为十进制原码）。

例如：
#include <stdio.h>
main(){
	short int a=-2,b=-3,c;
	a=-2;//a的补码  1111 1111 1111 1110
	b=-3;//b的补码  1111 1111 1111 1101
	c=a&b;//c的补码 1111 1111 1111 1100
	printf("%hd\n",c);//c的真值-4
}



分析：
-2
机器码  1000 0000 0000 0010
反码    1111 1111 1111 1101
补码    1111 1111 1111 1110

-3
机器码  1000 0000 0000 0011
反码    1111 1111 1111 1100
补码    1111 1111 1111 1101

c=a&b 按照补码计算
补码    1111 1111 1111 1100
反码    1111 1111 1111 1011
机器码  1000 0000 0000 0100
真值    -               4




========================================
|-- 位运算（&、|、^、~、>>、<<）
----------------------------------------
1. 运算规则

符号	描述	运算规则
&	与	两个位都为1时，结果才为1
|	或	两个位都为0时，结果才为0
^	异或	两个位相同为0，相异为1
~	取反	0变1，1变0
<<	左移	各二进位全部左移若干位，高位丢弃，低位补0
>>	右移	各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）






2. 案例

(1). 按位与 &。有0出0，没0出1.
0&0=0; 0&1=0; 1&0=0; 1&1=1 。
总结：两位同时为1，结果才为1，否则结果为0。

4&5 = 4

0100
0101
得
0100

例如：3&5 即 0000 0011& 0000 0101 = 0000 0001，因此 3&5 的值得1。
注意：负数按补码形式参加按位与运算。


与运算的用途：
1)清零
如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
- 取低字节 x & 0x0ff
- 取高字节 x & 0xff00

2)取一个数的指定位
比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。

- 取一个数的某些位 0124&073

3)判断奇偶
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。


#include <stdio.h>
int main(){
    int a,b, c;
    a=077;
    b=a&3;
    printf("%d & 3(decimal) 为 %d \n", a, b);
	
    c=b&7;
    printf("%d & 7(decimal) 为 %d \n", b, c);
    return 0;
}

输出:
63 & 3(decimal) 为 3 
3 & 7(decimal) 为 3 

解释：
63=(111111)2, 3=(11)2
前几位都消失了，只有后两位，& 运算后是 (11)2=3.
7=(111)2, 3=(11)2, 与得 (11)2=3；






(2) 按位或 |。有1出1，没1出0.
程序分析：0|0=0; 0|1=1; 1|0=1; 1|1=1 。
有一个为1结果就为1，全是0结果是0.

#include<stdio.h>
int main()
{
    int a,b;
    a=077;
    b=a|3;
    printf("b 的值为 %d \n",b);
    b|=7;
    printf("b 的值为 %d \n",b);
    return 0;
}

输出：
63 | 3(decimal) 为 63 
63 | 7(decimal) 为 63 
分析：
63=1+2+4+8+16+32=(111 111)2
3=(000 011)2
7=(000 111)2

由于63是全1，则和小的求或(有1出1)，结果都等于63。

或运算的用途：
1) 常用来对一个数据的某些位设置为1
比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。






(3) 按位异或 ^。
程序分析：0^0=0; 0^1=1; 1^0=1; 1^1=0。
相同出0，相异出1。

性质：
- 交换律 a^b=b^a;
- 结合律 (a^b)^c == a^(b^c)
- 对于任何数x，都有 x^x=0，x^0=x
- 自反性: a^b^b=a^0=a;


63 ^ 3(decimal) 为 60 
60 ^ 7(decimal) 为 59

分析：
(111111)2 ^ (11)2= (111100)2=60
(111100)2 ^ (111)2=(111011)2=32+16+8+2+1=59


异或运算的用途：
1)翻转指定位
比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

2)与0相 异或 值不变
例如：1010 1110 ^ 0000 0000 = 1010 1110

3)交换两个数
交换两个变量的值，不用中间变量
int a=3, b=4;
a'=a^b;
b'=b^a'=b^(a^b)=b^b^a=0^a=a;
a'=a'^b'=(a^b)^a=a^a^b=b;


#include<stdio.h>
void swap(int *a, int *b){
    if (*a != *b){
        *a ^= *b;
        *b ^= *a;
        *a ^= *b;
    }
}
int main(){
	int a=3, b=4;
	printf("a=%d, b=%d\n", a, b);
	swap(&a, &b);
	printf("a=%d, b=%d\n", a, b);
}

输出： 
a=3, b=4
a=4, b=3





(4) 按位取反~。单目运算符，在位运算中优先级最高。
程序分析：~0=1; ~1=0;

c语言测试过:
~1 = -2;
~2 = -3;
~3 = -4;
~-4= 3;
//我总结的：正整数取反后，绝对值+1，前面加负号。


分析
~(0000 0001)2=(1111 1110)2 补码 =(1111 1101)2 反码 = (1000 0010)2机器码=-2 真值
~012 = ~(000 001 010)2=(111 110 101)2补码=(111 110 100)2反码=(100 001 011)2机器码=-(2**3+2+1)=-11


#include <stdio.h>
int main()
{
    int a,b;
    a=234;
    b=~a;
    printf("a 的按位取反值为（十进制） %d \n",b);
	
    a=~a;
    printf("a 的按位取反值为（十六进制） %x (%d)\n",a,a);
    return 0;
}

输出： 
a 的按位取反值为（十进制） -235 
a 的按位取反值为（十六进制） ffffff15 (-235)

分析： 
~(0000 0000  1110 1010)2=(1111 1111  0001 0101)2补码=
	(1111 1111  0001 0100)2反码=
	(1000 0000  1110 1011)2机器码=-(1+2+8+32+64+128)=-235 真值


取反运算的用途：
1)使一个数的最低位为零
使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。




(5) 左移运算符（<<）
定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。


#include<stdio.h>
int main(){
	int a=2;
	int b=a<<2;
	int c=a<<9;
	printf("a=%d, 左移2位=%d, 左移9位=%d\n", a, b, c);
	return 0;
}

输出:
a=2, 左移2位=8, 左移9位=1024
2**1 ==>2**(1+2)=8
     ==>2**(1+9)=1024


(6) 右移运算符（>>）
定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。
例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。
操作数每右移一位，相当于该数除以2。



(7) 复合赋值运算符
位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：
&=        例：a&=b    相当于     a=a&b
|=        例：a|=b    相当于     a=a|b
>>=      例：a>>=b    相当于   a=a>>b
<<=      例：a<<=b    相当于   a=a<<b
^=        例：a^=b    相当于   a=a^b

运算规则：和前面讲的复合赋值运算符的运算规则相似。
不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以"与运算"为例说明如下：
我们知道在C语言中long型占4个字节，int型占2个字节(64位操作系统int占4位)，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，

1）如果整型数据为正数，左边补16个0。
2）如果整型数据为负数，左边补16个1。
3）如果整形数据为无符号数，左边也补16个0。
如：long a=123；int b=1；计算a& b。
如：long a=123；int b=-1；计算a& b。

如：long a=123；unsigned intb=1；计算a & b。








ref:
https://www.runoob.com/w3cnote/bit-operation.html





========================================
|-- 打印 int 和 float 的二进制表示
----------------------------------------

1. 源码

$ cat 17_print_binary.c 
#include<stdio.h>

//打印1byte = 8bits的二进制表示
void show_byte(const unsigned char * ptr, int enter) {
    unsigned char j=*ptr;
    for(int i=7; i>=0; i--){
        printf("%s", (*ptr & (1<<i))==0? "0":"1" );
    }
    printf(" ");
    if(enter) printf("\n");
}

// 打印int的二进制，是4个字节
void show_int(int *ptr, int enter){
    //假设是小端，先打印最后一个字节
    for(int i=3; i>=0; i--){
        /* 方法1 可以
        unsigned char *p=(unsigned char*) ptr + i;
        show_byte((unsigned char *)p, 0);
        */
        //方法2 也可以: 优先级是 强制转换 > 加号
        show_byte( (unsigned char *)ptr+i, 0);
    }
    if(enter) printf("\n");
}

//打印float的二进制，是4个字节
void show_float(float *ptr, int enter){
    //假设是小端，先打印最后一个字节
    for(int i=3; i>=0; i--){
        show_byte( (unsigned char *)ptr + i, 0);
    }
    if(enter) printf("\n");
}

int main(){
    // a char
    char s='A';
    show_byte( &s, 0);
    printf(" %c %d\n", s, s);
    
    // an int
    int a=-2;  //0x41;
    show_byte( (char *)&a, 0);
    printf(" %d\n", a);
    show_int(&a, 0);
    printf(" %d\n", a);

    // an float
    // https://blog.csdn.net/wangjunliang/article/details/127191707
    float f1=1.74, f2=0.87;
    show_float(&f1, 0); printf(" %f\n", f1);
    show_float(&f2, 0); printf(" %f\n", f2);

    return 0;
}


(2) 编译输出

$ gcc 17_print_binary.c 
$ ./a.out 
01000001  A 65
11111110  -2
11111111 11111111 11111111 11111110  -2
00111111 11011110 10111000 01010010  1.740000
00111111 01011110 10111000 01010010  0.870000




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------


