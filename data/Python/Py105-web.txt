Python105-web

(2019.3.4)目前主要是flask 1.0.2和jinja2。
Django 框架



========================================
web based tutorials
----------------------------------------
python3的Django 写的博客系统：
https://tendcode.com/article/python-shell/ 


flask写用户登录功能 https://qinqianshan.com/web/flask/



========================================
|-- python web包的比较: Django、tornado、flask、webpy
----------------------------------------

在Python的web开发框架中，目前使用量最高的有Django、Flask和Tornado， 经常会有人拿这几个对比，相信大家的初步印象应该是 Django大而全、Flask小而精、Tornado性能高。


Django是Python 中最全能的 web 开发框架，走大而全的方向。它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。不过Django提供的方便，也意味着Django内置的ORM跟框架内的其他模块耦合程度高，深度绑定了该框架，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的优秀特性。

Tornado全称Tornado Web Server，是一个用Python语言写成的Web服务器兼Web应用框架。Tornado走的是少而精的方向，注重的是性能优越，它最出名的是异步非阻塞的服务器方式。(Tornado框架和服务器一起组成一个WSGI的全栈替代品。单独在WSGI容器中使用tornado web框架或者tornaod http服务器，有一定的局限性，为了最大化的利用tornado的性能，推荐同时使用tornaod的web框架和HTTP服务器。)

Flask是一个使用 Python 编写的轻量级 Web 应用框架，也被称为 “microframework”，语法简单，部署很方便，整个框架自带了路径映射、模板引擎（Jinja2）、简单的数据库访问等web框架组件，支持WSGI协议（采用 Werkzeug）。Flask使用 BSD 授权。 Flask使用简单的核心，用 extension 增加其他功能，虽然没有默认使用的数据库、窗体验证工具，然而Flask保留了扩增的弹性，可以用Flask-extension加入ORM、窗体验证工具、文件上传、各种开放式身份验证技术这些功能。



从性能上看Tornado 比Django、Flask等主流 Web 服务器框架相比有着明显的区别：它是非阻塞式服务器，速度相当快。然而 Tornado 相比 Django 和Flask属于较为原始的框架，插件少，许多内容需要自己去处理。而Flask插件多，文档非常专业，有专门的公司团队维护，对于快速开发很有效率。由于WSGI协议的存在，可以结合 Tornado 的服务器异步特性、并发处理能力和Flask的文档和扩展能力为一体。虽然像Django，Flask框架都有自己实现的简单的WSGI服务器，但一般用于服务器调试，生产环境下建议用其他WSGI服务器，比如Nginx+uwsgi+Django方式。


Tornado关于使用平台的说明：
Tornado should run on any Unix-like platform, although for the best performance and scalability only Linux (with epoll) and BSD (with kqueue) are recommended for production deployment (even though Mac OS X is derived from BSD and supports kqueue, its networking performance is generally poor so it is recommended only for development use). Tornado will also run on Windows, although this configuration is not officially supported and is recommended only for development use.
Tornado应该运行在类Unix平台，在线上部署时为了最佳的性能和扩展性，仅推荐Linux和BSD（因为充分利用Linux的epoll工具和BSD的kqueue工具，是Tornado不依靠多进程/多线程而达到高性能的原因）。对于Mac OS X，虽然也是衍生自BSD并且支持kqueue，但是其网络性能通常不太给力，因此仅推荐用于开发。对于Windows，Tornado官方没有提供配置支持，但是也可以运行起来，不过仅推荐在开发中使用。







========================================
|-- python web编程：使用socket包
----------------------------------------
建议直接用命令行窗口运行py的server脚本，不要用jupyter，否则端口无法释放。

1.error:[Errno 98] Address already in use的解决
当你该端口被其他进程占用时，那就需要你修改为一个未使用的端口号重新运行。

如果是运行程序没有通过<Ctrl> C正常结束， 而是直接关闭Terminal或者其他非正常途径退出的时候： 
通过lsof -i:(port)，查看占用该端口号的进程，一般就是刚未正常退出的进程。例如
$ lsof -i :8000 # 这个命令针对我用的port 8000
##COMMAND   PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
##python3 16633 wangjl   56u  IPv4 38335892      0t0  TCP *:8000 (LISTEN)

然后kill掉该PID的进程，重新运行。
$ sudo kill -9 16633


如果是查看本机所有的进行的进程： 
ps aux　 #　用ps -A查看所有进程



2.



========================================
flask简介
----------------------------------------
flask: https://palletsprojects.com/p/flask/
文档： https://flask.palletsprojects.com/en/1.1.x/



《Flask Web开发：基于Python的Web应用开发实战》
http://blog.sina.com.cn/s/blog_c3b6050b0102x0l0.html

第一部分 Flask简介 
第1章 安装  
第2章 程序的基本结构 
第3章 模板  
第4章 web表单  
第5章 数据库 
第6章 电子邮件 
第7章 大型程序的结构 

第二部分 实例：社会化博客程序 
第8章 用户认证 
第9章 用户角色 
第10章 用户资料 
第11章 博客文章 
第12章 关注者 
第13章 用户评论 
第14章 程序编程接口 

第三部分 成功在望 
第15章 测试 
第16章 性能 
第17章 部署 
第18章 其他资源



Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. And before you ask: It's BSD licensed!


1.安装
pip install flask

2. 老版1.0例子
文件hello.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()

运行
>python hello.py

然后浏览器输入 http://127.0.0.1:5000/




###
3. 新版1.1例子
文件a2.py 
from flask import Flask, escape, request

app = Flask(__name__)

@app.route('/')
def hello():
    name = request.args.get("name", "World")
    return f'Hello, {escape(name)}!'
#
运行：
env FLASK_APP=hello.py flask run

访问浏览器 http://127.0.0.1:5000/?name=Flask~~
Hello, Flask~~!









========================================
|-- flask URL生成: url_for()函数
----------------------------------------

1.url_for() 函数。按照函数名，生成其对应的报时器中的url。

本质是根据函数名反向生成url，使用函数 url_for() 来针对一个特定的函数构建一个 URL。它能够接受函数名作为第一参数，以及一些关键字参数， 每一个关键字参数对应于 URL 规则的变量部分。

未知变量部分被插入到 URL 中作为查询参数。

url_for(方法的名) =app.route参数名
而url_for() 本身和app.route的参数是没关系的，只和方法的参数名相关。


@app.route('/')
def index():
	url=url_for('hello') #第一个参数是函数名，不是路由
	return '<meta http-equiv="refresh" content="0;url='+url+'">'
#

@app.route('/index.py')
def hello():
	pass();
#



2.例2

from flask import Flask,url_for
app = Flask(__name__)


@app.route('/')       #定义一个路由
def hello_world():    #定义一个视图函数
    return "<a href="+url_for('index',keyword="Main", id="1_2" ) +">goto</a>"
#<a href=/html/Main/1_2>goto</a>


@app.route('/html/<keyword>/<id>')
def index(keyword,id):
    return 'Hello kw=%s, id=%s!\n'%(keyword, id);

if __name__ == '__main__':
    app.run()



========================================
|-- flask 的调试，输出到控制台
----------------------------------------
1. 输出到网页
@app.route('/wjl')
def ixx():
	a=getConf("style",'txt');

	#txtStyle = cf.get(section, item)
	return a;
#


2. 输出到控制台 
with app.test_request_context():
	a=getConf("style",'txt');
	print(a) 
#




========================================
|-- python web编程：使用flask包写接口(路由、参数传递、获取) get post header 获取参数
----------------------------------------
WARNING: Do not use the development server in a production environment.
Use a production WSGI server instead.

Python实现简单的API接口
https://blog.csdn.net/u013040887/article/details/78895323/

教程：http://docs.jinkan.org/docs/flask/quickstart.html#static-files


1.基本例子
$ cat dFlask.py 
from flask import Flask
app = Flask(__name__)
@app.route('/')  
def hello_world():
    return "hello world"
if __name__=='__main__':
    app.run(host="192.168.2.120",port=8000)

运行该脚本后，就可以用浏览器访问了 192.168.2.120:8000





2.简单的get和post
(1)请求简介
1).get请求：
　　使用场景：
　　　　说白了就是从服务器获取数据，比如查询百度的时候就是这样的。
　　传参方式：
　　　　放在url中并且是通过 "  ?  " 的形式来指定Key和 Value的。
2).post请求：
　　使用场景：
　　　　对服务期产生影响，比如说登入的时候提交密码。
　　传参方式：
　　　　不通过url传参，通过"  foem_data  "的形式将信息发送至服务器。

(2)获取两种请求的参数
1.get请求：
　　flask.request.args获取，返回的是字典。
2.post请求;
　　flask.request.form获取，返回字典。
	注意：
		默认的视图函数只能发送get请求。如果要发送post请求时要再参数中写清楚。
		例如：@app.route('/login/',methods=['POST'])
3.从header获取信息：获取http的head信息，比如一些auth信息或者referer，useragent的信息等。
	request.headers.get("User-Agent")
#


例
$ cat dFlask2.py 
# -*- coding: utf-8 -*-
# Flask hello world
from flask import Flask, redirect, request
from flask import render_template
app = Flask(__name__)

@app.route('/send_msg', methods=['GET','POST']) #默认只接受get参数
def Messaging():
    if request.method =='POST':
        username = request.form.get('username', '默认值');
        return('post: username='+username);
    elif request.method =='GET':
        usr=request.args.get('username','默认值');
        return('get: usr = '+ usr)
    else:
        pass

@app.route('/send_msg2', methods=['POST'])
def do_send():
    return('post2')

@app.route('/send_msg2', methods=['GET'])
def show_form():
    return('get2')


@app.route('/')
def hello():
    return render_template('forms.html')


if __name__ == '__main__':
    ####默认监听127.0.0.1:5000   关闭调试模式
    app.run(host='192.168.2.120',port=8000,debug=True)
-
访问 
http://y.biomooc.com:8000/send_msg
http://y.biomooc.com:8000/send_msg2










3.路由解析：通过url动态传递参数
(1)#加不加最后的斜杠不一样
@app.route('/projects/')
def projects():
    return 'The project page' #访问时不带最后斜杠，会自动补齐斜杠

@app.route('/about')
def about():
    return 'The about page' #访问的时候加了斜杠，就会报错404
#



(2)从url传入的5类参数
#传入参数
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return 'User %s' % escape(username)
#http://blog2.163.com:8000/user/wjl
#User wjl


@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return 'Post %d' % post_id
# http://blog2.163.com:8000/post/123456
# Post 123456


@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # show the subpath after /path/
    return 'Subpath %s' % escape(subpath)
# http://blog2.163.com:8000/path/c/usr/bin/python3
# Subpath c/usr/bin/python3


Converter types:
	string:(default) accepts any text without a slash
	int:accepts positive integers
	float:accepts positive floating point values
	path:like string but also accepts slashes
	uuid:accepts UUID strings
#


(3) 从url获取get参数
@app.route('/hello2')
def hello2():
    name = request.args.get("name", "World2")
    return f'Hello, {escape(name)}!'
# http://blog2.163.com:8000/hello2?name=python3
# Hello, python3!

#






4.使用url_for函数构建URL
from flask import Flask, escape, url_for
app = Flask(__name__)

@app.route('/')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'

@app.route('/user/<username>')
def profile(username):
    return '{}\'s profile'.format(escape(username))
# http://blog2.163.com:8000/user/百度
# 百度's profile

with app.test_request_context():
    print(url_for('index')) #第一个参数是函数名，不是路由。必须定义过，否则报错。
    print(url_for('login'))
    print(url_for('login', next='/'))
    print(url_for('profile', username='John Doe'))
#/
#/login
#/login?next=%2F
#/user/John%20Doe #输出的路径是按照路由构建的，与函数名无关。

if __name__ == '__main__':
    app.run(host="blog2.163.com",port=8000)
#







3.怎么接收js的参数，处理后的数据再以json传递给js？





========================================
|-- flask中的g、add_url_rule、send_from_directory、static_url_path、static_folder的用法
----------------------------------------
https://www.cnblogs.com/shengulong/p/7106166.html








========================================
|-- 加载非static/下的图片
----------------------------------------
# 添加新静态文件的路径，这样就允许data/下的图片加载了
@app.route("/data/<path:filename>")
def downloader(filename):
    return send_from_directory("data",filename,as_attachment=False)
#



========================================
|-- flask配合表达实现文件上传，下载(todo)
----------------------------------------
#version1: 基本功能
#
import flask, os,sys,time
from flask import request, send_from_directory

interface_path = os.path.dirname(__file__)
sys.path.insert(0, interface_path)  #将当前文件的父目录加入临时系统变量

server = flask.Flask(__name__)

htmlForm="""
<meta http-equiv="content-type" content="text/html;charset=utf-8">
upload a file<br>
<form action="/upload" method="post" enctype="multipart/form-data">
	<input type="file" name="file" />
	<input type="submit" value="上传文件" />
</form>
"""

htmlBtn="""
<style>
a.btn{
    border: 1px solid red;
    padding: 2px 5px;
    text-decoration: none;
	margin:5px;
	
	background:white;
	color:red;
}
a.btn:hover{
    color: white;
	background: red;
}
</style>
<a class=btn target="_blank" href='/upload'>Upload File</a> 
<a class=btn target="_blank" href='http://y.biomooc.com/wangjl/docs/'>File List(Download File)</a> 
<br>
1. Files stay more than 2 days may be deleted! Please backup in time;<br>
2. Now you cannot delete the file yourself; If you want to delete a file, please ask the administrator for help.<br>
3. 
"""

@server.route('/')
def index():
    return htmlBtn;

# post方法：上传文件的
@server.route('/upload', methods=['POST','GET'])
def upload():
    if request.method=='GET':
        return(htmlForm);

    fname = request.files.get('file')  #获取上传的文件
    if fname:
        t = time.strftime('%Y%m%d%H%M%S')
        new_fname = r'./' +t+"_" + fname.filename #文件名加时间前缀，防止覆盖同名文件
        fname.save(new_fname)  #保存文件到指定路径
        #status= '{"code": "ok"}'
        return '<meta http-equiv="refresh" content="2;url=/">Upload success!';
    else:
        return '{"msg": "no file"}';

server.run(host="192.168.2.120",port=8000, debug=True)

使用方法：
$ python upload.py
访问浏览器 http://192.168.2.120:8000
即可看到2个按钮，点上传到/upload页面，选择文件，点上传即可完成上传。



refer:
https://www.cnblogs.com/jessicaxu/p/7891372.html





========================================
|-- 404页面
----------------------------------------

@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html')
#

需要在 templates 下新建page_not_found.html。内容自定义。




========================================
|-- 使用flask的jsonify返回json数据
----------------------------------------
1.py文件

from flask import Flask
from flask import jsonify 

app = Flask(__name__)

#json Controler
@app.route('/api/content/<date>')
def content(date):
    status=True
    
    #从Mysql获取当天数据
    content="some content from Mysql-"+date
    
    if content=="":
        status=False;
    #返回json
    return jsonify({'status':status,'date':date, 'content':content})

#启动程序
if __name__ == '__main__':
    print("==> pls browse http://127.0.0.1:5000/api/content/2019")
    app.run()

2.运行
python hello2.py 

在浏览器输入 http://127.0.0.1:5000/api/content/2019
即可看到json个数的数据：
{"content":"some content from Mysql-2019","date":"2019","status":true}




3.用jQuery获取json数据
(1)py文件
from flask import Flask,request
from flask import jsonify
from flask.templating import render_template

app = Flask(__name__)

#首页Controler
@app.route('/', methods=['GET'])
def home():
    return render_template("jQ_index.html");


#计算并返回
@app.route('/add', methods=['GET'])
def add_numbers():
    a=request.args.get('a',0,type=int) #获取表单参数
    b=request.args.get('b',0,type=int)
    return jsonify({'result': a+b});


#run app
if __name__ == '__main__':
    print("==> pls browse http://10.21.127.192:5000/")
    app.run(host="0.0.0.0", debug=True)


(2)jQ_index.html文件放在py同级的templates文件夹下
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Flask JQuery</title>

<!-- 插入jquery -->
<script src="{{url_for('static', filename='jquery-1.8.0.js')}}"></script>

<script type=text/javascript>
var $SCRIPT_ROOT = {{request.script_root|tojson|safe}};//这是？
</script>

<script type=text/javascript>
$(function() {
    function submit_form(e) {
        $.getJSON($SCRIPT_ROOT + '/add', 
		{
            a: $('input[name="a"]').val(),
            b: $('input[name="b"]').val(),
            now: new Date().getTime()
        },
        function(data,status) { /*status 参数可以省略*/
			console.log("status =",status)
            $('#result').text(data.result);
        });
    };
    // 绑定click事件
    $('#calculate').bind('click', submit_form);
});
</script>
</head>
<body>
<p>
    <input type=text size=5 name=a> +
    <input type=text size=5 name=b> =
    <span id=result>?</span>
</p>
<p><input type="button" id="calculate" value="计算"></p>
</body>
</html>

(3)jquery-1.8.0.js文件放到py同级的static文件夹下
(4)访问 http://10.21.127.192:5000/ 即可。



========================================
|-- python mysql 转义方法
----------------------------------------

python抓取的一些是数据放到mysql里去，但是有个问题，因为从外面抓取的数据有带'等其他的不规则的数据，如果你直接调用插入数据的方法会提示报错，这个时候就需要用到 python mysql 转义了。

通过help方法和dir的方法终于找到了，原来是：escape_string

如果你要用mysql转义字符串，那就可以看看下面的使用方法了：
content = MySQLdb.escape_string(content)


========================================
|-- 从url获取参数，从mysql获取数据，以json格式返回
----------------------------------------
1.hello3.py 
from flask import Flask
from flask import jsonify
import pymysql

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World! PLS browse: http://127.0.0.1:5000/about/32"

def getItem(id):
	#mysql 获取数据
	# 打开数据库连接
	#db = pymysql.connect(host='y.biomooc.com',port=7070,user='yanpd', password='789789', database='english')
	db = pymysql.connect(host='localhost',port=3306,user='root', password='', database='think')
	# 使用cursor()方法获取操作游标 
	cursor = db.cursor()
	# 执行sql语句
	sql = "select * from think_weibo where id="+id
	cursor.execute(sql)
	values = cursor.fetchall()
	# 关闭数据库连接
	db.close()
	#返回结果
	return values

#从url获取参数 http://127.0.0.1:5000/about/30
@app.route("/about/<id>")
def about(id):
	return jsonify(getItem(id));

if __name__ == '__main__':
    app.run()



2.运行该应用:
python hello3.py 

在浏览器输入 http://127.0.0.1:5000/about/30
即可看到json格式的、从mysql返回的数据。




========================================
|-- flask 允许跨域请求 cors ：用make_response 设置 'Access-Control-Allow-Origin' header
----------------------------------------
1. 实例1：跨域请求文本文件，相当于py是一个静态文件服务器

推荐方式
#CORS (Cross-Origin Resource Sharing)
def cors(arrOrStr):
    res=jsonify(arrOrStr)
    res.headers.add('Access-Control-Allow-Origin', '*')
    res.headers.add('Backend', 'wjl_dawnDict_server/0.3')
    res.headers.add('Email', 'jimmymall at 163 dot com')
    return res;
#


使用：需要提供跨域访问的地方，把返回值包裹一下即可：
return cors(arrayOrDict);




(1)py代码
# https://gist.github.com/LtGlahn/f0cad0530b4b4298fa8c
# https://www.pythonanywhere.com/forums/topic/2192/

#
#设置变量
import sys
env=sys.platform #"win32"测试环境;  "linux"生产环境
#print('env=',env)
if env=='linux':
    rootPath="/home/wangjl/web/docs/" #ubuntu
elif env=='win32':
    rootPath="F://Temp/" #windows

##############
# 支持跨域访问
# version: 0.2
##############
#路径名字不能是/static/,因为它是内部定义过的静态文件路径
@server.route('/file/<path:filePath>', methods=['get'])
def audio(filePath):
    #fpath = request.values.get('path', '') #获取文件路径
    #fname = request.values.get('filename', '')  #获取文件名
    fpathT = os.path.join(rootPath, filePath) #真实路径
    print(fpathT)
    if filePath.strip():
        if os.path.isfile(fpathT):
            blob=''
            try:
                with open( fpathT, 'rb') as file:
                    blob = file.read()
            except Exception as e:
                print(e)
                pass
            #
            res = make_response(blob) #重点：自定义响应
            res.mimetype='application/octet-stream'
            res.headers['Access-Control-Allow-Origin'] = '*' #允许跨域请求
            return res;
        else:
            return '{"msg2":"参数不正确"}path=%s, filename=%s;' %(fpathT, fname);
    else:
        return '{"msg1":"请输入参数"}'
#ajax test OK: http://127.0.0.1:8005/file/tmp.R


(2)测试：
<html>
<head>
<!--
  <script type="text/javascript" src="/html5/jquery-1.9.1.min.js"></script>
-->
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<style>
#show{border:1px solid red;}
</style>
<script type="text/javascript">
$(document).ready(function(){
  $("button").click(function(){
    $.get('http://127.0.0.1:8005/file/tmp.R',function(res){
      $('#show').html( res );
    })
  });
});
</script>
</head>

<body>
  <button>click</button>
  <pre id="show">xx</pre>
</body>

</html>



2. 实例2： 返回json数据
(1)app1.py
from flask import jsonify,make_response

#json Controler 不能跨域请求
import time
@app.route('/api/content/<date>')
def content(date):
    status=True
    #time.sleep(2)
    #从Mysql获取当天数据
    content="<h1>some content from Mysql-Docker "+date+'</h1>'
    
    if content=="":
        status=False
    #返回json
    return jsonify({'status':status,'date':date, 'content':content})

#json Controler 允许跨域请求
import time
@app.route('/api/content2/<date>')
def content2(date):
    status=True
    #time.sleep(2)
    #从Mysql获取当天数据
    content="<h1>some content2 from Mysql-Docker "+date+'</h1>'
    
    if content=="":
        status=False
    #构建自定义响应
    json_data=jsonify({'status':status,'date':date, 'content':content})
    res=make_response(json_data)
    #允许跨域
    res.headers['Access-Control-Allow-Origin']='*'
    #返回json
    return res


#启动程序
if __name__ == '__main__':
    print("==> pls browse http://127.0.0.1:5000/api/content/2019")
    app.run(debug=True)

(2)测试 ajax2.html
<html>
<head>
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<style>
#show{border:1px solid red;}
</style>
<script type="text/javascript">
$(document).ready(function(){
  $("#btn1").click(function(){
      $.get('http://127.0.0.1:5000/api/content/2019', function(res){
      $('#show').html( res );
    })
  });

  $("#btn2").click(function(){
    $.get('http://127.0.0.1:5000/api/content2/2019', function(res){
      console.log(res)
    })
  })
});
</script>
</head>

<body>
  <button id='btn1'>btn1</button>
  <button id='btn2'>btn2</button>
</body>
</html>

效果
点击btn1，控制台：
Access to XMLHttpRequest at 'http://127.0.0.1:5000/api/content/2019' from origin 'http://127.0.0.1' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
jquery.min.js:4 Cross-Origin Read Blocking (CORB) blocked cross-origin response http://127.0.0.1:5000/api/content/2019 with MIME type application/json. See https://www.chromestatus.com/feature/5629709824032768 for more details.


点击btn2，控制台：
{content: "<h1>some content2 from Mysql-Docker 2019</h1>", date: "2019", status: true}




3. 实例3：简化的返回json的方法
@app.route('/your/route/<params>', methods=['GET'])
def yourMethod(params):
    response = jsonify({'some': 'data'})
    response.headers.add('Access-Control-Allow-Origin', '*')
    return response
#测试也能通过





========================================
|-- blueprint 技术：能降低入口文件(app/__init__.py) 的长度
----------------------------------------
1.蓝图就是把一部分功能打包成一个python包。
# * 特别适合重复使用的模块，比如用户、权限等的打包。
# * 或者同一个系统内，使用两种不同的url策略。这样不同的url，加载同一个蓝图，节省了一个模块的开发。

文件结构
app.py 
static/
templates/
blueprints/ 里面放很多蓝图，相当于独立的包
  |-maintain/ 这是一个叫做maintain的蓝图
    |-static/
    |-templates/
	|-__init__.py

(1) 现在 blueprints/maintain/__init__.py 中添加代码
#
from flask import Blueprint

bp=Blueprint('maintain', __name__,
             template_folder='templates',
             static_folder='static')

@bp.route('/ping')
def ping():
    return "pong"





(2) 然后在入口文件 app.py 中引入该文件

from flask import Flask
from flask import request
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '<h1>Home 4</h1>'

# 导入蓝图。具体实现（控制器、模板等文件）可以在其他文件夹中。
from blueprints import maintain

#2选1，url_prefix 是可选参数，默认是空
app.register_blueprint(maintain.bp) #访问： xx:5000/ping
app.register_blueprint(maintain.bp, url_prefix="/maintain") #访问： xx:5000/maintain/ping

app.logger.info('Load blueprints/maintain')

if __name__ == '__main__':
    app.run(debug=True)

#

(3) 运行入口文件 app.py即可访问浏览器
xx:5000/ping 查看是否返回pong



refer:
https://www.bilibili.com/video/BV1j64y1M7sd

https://dormousehole.readthedocs.io/en/latest/
https://dormousehole.readthedocs.io/en/latest/tutorial/views.html








========================================
|-- 获得访问者IP地址
----------------------------------------
1.代码
(1) demo.py
from flask import Flask, render_template, request

# Initialize the Flask application
app = Flask(__name__)
# Default route, print user's IP
@app.route('/')
def index():
    ip = request.remote_addr
    return render_template('getIP.html', user_ip=ip)
if __name__ == '__main__':
    app.run(
        host="0.0.0.0",
        port=int("81")
    )


(2) 模板
$ cat getIP.html 
<p>You IP address is: {{user_ip}}</p>
<h3 class="text-muted">Code to retrieve the IP</h3>

(3) 测试
http://10.21.9.239:81/  You IP address is: 10.21.9.239
http://192.168.19.1:81/  You IP address is: 192.168.19.1








========================================
|-- 后台进程 执行耗时任务 ThreadPoolExecutor
----------------------------------------
# https://blog.csdn.net/caorya/article/details/118700537

$ cat flask_demo.py
import time
from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor()
#executor = ThreadPoolExecutor(10)里面的数字是线程池所能同时进行的最大数量

from flask import Flask
app = Flask(__name__)

def run(i):
    time.sleep(5)
    print("耗时任务执行结束"+i)


@app.route('/test/<number>')
def test(number):
    # 交给线程去处理耗时任务
    executor.submit(run, number)
    return "cheer!"+number


if __name__ == '__main__':
    app.run()

#> python flask_demo.py
# http://127.0.0.1:5000/test/4






========================================
jinja 模板技术简介
----------------------------------------
1. 简介
jinja: https://jinja.palletsprojects.com/en/3.1.x/
	https://palletsprojects.com/p/jinja/ 
https://blog.csdn.net/pick_ears/article/details/122084013

Template Designer Documentation: https://jinja.palletsprojects.com/en/3.1.x/templates/


Jinja is a fast, expressive, extensible templating engine. Special placeholders in the template allow writing code similar to Python syntax. Then the template is passed data to render the final document.


{% ... %} for Statements
{{ ... }} for Expressions to print to the template output
{# ... #} for Comments not included in the template output


https://palletsprojects.com/ 的所有项目: Click, Flask, Jinja



(1) 简单示例
$ cat t1.py
from flask import Flask,render_template
app = Flask(__name__)
@app.route('/')
def login():
    # 注意模板的路径，如果是在templates的demo文件夹下，这需要写成demo/index.html
    return render_template('t1_index.html')

if __name__ == '__main__':
    #app.run(debug=True)
    app.run(host="0.0.0.0", port=5000, debug=True)


模板文件:
$ cat templates/t1_index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <input id="kw" name="wd" class="s_ipt" value maxlength="255" autocomplete="off">
</body>
</html>


如果想改变模板文件的名称或位置: 
app = Flask(__name__, template_folder='templates2')




(2) 模板传参
$ cat t1.py 
from flask import Flask,render_template
app = Flask(__name__)

@app.route('/')
def login():
    uname="tom"
    userDict = {
        'uid': 20,
        'sex': "M"
    }
    return render_template('t2_index.html', username=uname, info=userDict)


if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)

模板:
$ cat templates/t2_index.html
<h1>{{username}}</h1>

<p>{{info.uid}}</p>
<p>{{info['sex']}}</p>


显示
<h1>tom</h1>

<p>20</p>
<p>M</p>







========================================
|-- 模板 filter 过滤器
----------------------------------------

(3) 过滤器
- 展开字典到模板: **dict
- Jinja2模板过滤器 相当于一个函数，将变量传入到过滤器中，然后过滤器根据自己的功能，再返回到响应的值，之后再讲结果渲染到页面中。
- 内置过滤器 https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters
- 自定义过滤器

$ cat t3.py 
from flask import Flask,render_template
from datetime import datetime
app = Flask(__name__)



@app.route('/')
def login():
    userDict = {
        'age': 20,
        'username':"Tom Bush",
        'city': 'Shenzhen',
        'sex': "M",
        'desc': "I love <b>C++</b>",
        'login_time': datetime(2022,11,7, 16,0,0),
        'book': {'C++':4, 'Java':1},
        'code': ['JS', 'C++', "Python"]
    }
    return render_template('t3_index.html', **userDict)


#Jinja2自定义过滤器
@app.template_filter("my_len")
def my_len2(arr):
    return len(arr)


# 自定义时间过滤器
@app.template_filter('handle_time')
# now_time 传递过来后就是time
def handle_time(time):
    # 小于1分钟，传入刚刚，大于一分小于1小时，xxx分钟之前，大于1小时小于24，xxx小时之前
    now = datetime.now()
    # 获取总秒数
    time_stamp = (now - time).total_seconds()
    if isinstance(time, datetime):
        if time_stamp<60:
            return '刚刚'
        elif 60<=time_stamp<=60*60:
            return '%d分钟之前'%int(time_stamp/60)
        elif 60*60<time_stamp<=60*60*24:
            return '%d小时之前'%int(time_stamp/(60*60))
    else:
        return time


if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)


模板 
$ cat templates/t3_index.html
<h1>{{username}}</h1>

<!--  过滤器 | 左边是待处理的参数，右侧是函数  -->
<p>age: {{age|abs}}</p>
<p>name: {{name | default("this man is lazy, nothing left.") }}</p>

<!-- 关闭转义功能 -->
<p>desc : {{desc | safe}}</p>


<!-- 关闭转义功能, method 2 -->
{% autoescape off %}
<p>desc2: {{desc}}</p>
{% endautoescape %}



<hr>
<!-- 数值换算 转为int类型 转为float类型 -->
{{age|int}}
{{age|float}}
<!--  变量转为字符串  -->
 {{age|string}}


<hr>
<!--  字符串  全部大写 全部小写-->
 {{city}}
 {{city|upper}}
 {{city|lower}}

<!--替换-->
{{city|replace(city,'坡县')}}


<hr>
<!--截取指定长度的字符串 例如微博显示一些数据后，再以...显示代表其余内容-->
<p>{{ desc|truncate(10) }}</p>

{{ "foo bar baz qux"|truncate(9) }} <br>
{{ "foo bar baz qux"|truncate(9, True) }} <br>
{{ "foo bar baz qux"|truncate(11) }} <br>
{{ "foo bar baz qux"|truncate(11, False, '...', 0) }} <br>



<hr>
自定义过滤器
<p>code: {{code|my_len}}</p>
<p>login: {{login_time|handle_time}}</p>




浏览器的显示: view-source:http://192.168.2.120:5000/
<h1>Tom Bush</h1>

<!--  过滤器 | 左边是待处理的参数，右侧是函数  -->
<p>age: 20</p>
<p>name: this man is lazy, nothing left.</p>

<!-- 关闭转义功能 -->
<p>desc : I love <b>C++</b></p>


<!-- 关闭转义功能, method 2 -->

<p>desc2: I love <b>C++</b></p>




<hr>
<!-- 数值换算 转为int类型 转为float类型 -->
20
20.0
<!--  变量转为字符串  -->
 20


<hr>
<!--  字符串  全部大写 全部小写-->
 Shenzhen
 SHENZHEN
 shenzhen

<!--替换-->
坡县


<hr>
<!--截取指定长度的字符串 例如微博显示一些数据后，再以...显示代表其余内容-->
<p>I love...</p>

foo... <br>
foo ba... <br>
foo bar baz qux <br>
foo bar... <br>



<hr>
自定义过滤器
<p>code: 3</p>
<p>login: 14分钟之前</p>






========================================
|-- 模板 控制语句
----------------------------------------

(4) 控制语句
所有的控制语句都是放在{%...%}中，并且有一个语句{% endxxx %}来进行结束，Jinja中常用的控制语句有if/for..in..

- if语句和python中的类似，可以使用>，<，<=，>=，==，!=来进行判断，也可以通过and，or，not，()来进行逻辑合并操作
- for循环可以遍历任何一个序列包括列表、字典、元组。并且可以进行反向遍历 如果序列没有值，也可以进入到else中。

$ cat t4.py 
from flask import Flask,render_template
from datetime import datetime
app = Flask(__name__)


@app.route('/')
def login():
    userDict = {
        'age': 20,
        'username':"Tom Bush",
        'city': 'Shenzhen',
        'sex': "M",
        'desc': "I love <b>C++</b>",
        'login_time': datetime(2022,11,7, 16,0,0),
        'book': {'C++':4, 'Java':1},
        'code': ['JS', 'C++', "Python"]
    }
    return render_template('t4_index.html', **userDict)


if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)



模板:
$ cat templates/t4_index.html 
<h1>{{username}}</h1>

<hr>
{% if sex=='M' %}
    <p>Boy</p>
    {% else %}
    <p>Girl</p>
{% endif %}



<hr>
<!--  进行for循环 -->
<ul>
{% for item in code %}
    <li>{{item}}</li>
{% endfor %}
</ul>
<br>
<ul>
{% for item in code2 %}
    <li>{{item}}</li>
{% else %}
<li>no values</li>
{% endfor %}
</ul>


<hr>
<!--遍历字典-->
{% for key,value in book.items() %}
	<p>{{loop.index}} |  <b>{{key}}</b>: {{value}}</p>
{% endfor %}




显示:

<h1>Tom Bush</h1>
<hr>
    <p>Boy</p>


<hr>
<!--  进行for循环 -->
<ul>
    <li>JS</li>
    <li>C++</li>
    <li>Python</li>
</ul>

<br>
<ul>
	<li>no values</li>
</ul>


<hr>
 <!--遍历字典-->
 <p>1 |  <b>C++</b>: 4</p>
 <p>2 |  <b>Java</b>: 1</p>



1)其他获取for循环额外参数的方法: https://jinja.palletsprojects.com/en/3.1.x/templates/#for

使用 loop.cycle() 设置html class属性 
<hr>
<ol>
{% for row in code %}
    <li class="{{ loop.cycle('odd', 'even') }}">{{ row }}</li>
{% endfor %}
</ol>


输出:
<ol>
    <li class="odd">JS</li>
    <li class="even">C++</li>
    <li class="odd">Python</li>
</ol>


2) 模板中不能使用 break or continue，但是有迂回方式
{% for item in code if item !="JS"  %}
    <li>{{ item|e }}</li>
{% endfor %}


输出:
    <li>C++</li>
    <li>Python</li>










========================================
|-- 模板 macro 宏
----------------------------------------
https://jinja.palletsprojects.com/en/3.1.x/templates/#macros

(5) 宏
模板种的宏，相当于常规编程语言的函数。
把常用的部分包装起来，防止重复自己(DRY: don't repeat yourself)

作用：相当于类里面创建一个方法，可以在本html页面进行多次调用使用，也可以导入到其它HTML，实例化进行使用
优点：高效、便利

- 如果不是当前模板定义的宏，则使用前要先 import: {% import 'forms.html' as forms %}
- 下划线开头的宏不爆露出去，所以不能import。|If a macro name starts with an underscore, it’s not exported and can’t be imported.
- 支持宏调用时，使用控制器传入的变量，不加引号即可。


注意：()里面的参数都需要加 '' ,记得添加
定义宏
    {% macro 宏的名字('参数1','参数2',...)%}
    html代码 中可有对应的参数1 参数2 ....
    {% endmacro %}

使用宏 
在本页面 {{ 宏的名字('参数1','参数2',....) }}

在其它页面，需要导入宏
{% import 'macro.html' as macro %}
然后调用     {{ macro.宏的名字('参数1','参数2',...)}}

导入宏的方式2 {% from 'macro.html' import 宏的名字 %}
{{ 宏的名字('参数1','参数2')}}


$ cat t5.py 
from flask import Flask,render_template
from datetime import datetime
app = Flask(__name__)


@app.route('/')
def login():
    userDict = {
        'age': 20,
        'username':"Tom Bush"
    }
    return render_template('t5_index.html', **userDict)

@app.route("/home")
def home():
    return render_template("t5_home.html", uid=5)


if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)



模板1 
$ cat templates/t5_index.html
<h1>Macro</h1>

{% macro input(name, value='', type='text', size=20) -%}
    <input type="{{ type }}" name="{{ name }}" value="{{
        value|e }}" size="{{ size }}">
{%- endmacro %}


传入宏对应的值
<p>{{ input('username', value=username ) }}</p>
<p>{{ input('password', type='password') }}</p>



对应的输出: view-source:http://192.168.2.120:5000/
<h1>Macro</h1>

<p><input type="text" name="username" value="Tom_Bush" size="20"></p>
<p><input type="password" name="password" value="" size="20"></p>







模板2: 从 模板1 引入宏
$ cat templates/t5_home.html 
{% from 't5_index.html' import input %}
{{ input('address', type="input", value=uid)}}

对应的输出: view-source:http://192.168.2.120:5000/home
<input type="input" name="address" value="5" size="20">




2) 在一个 macro 内部，有3个特殊函数可以使用
varargs
If more positional arguments are passed to the macro than accepted by the macro, they end up in the special varargs variable as a list of values.

kwargs
Like varargs but for keyword arguments. All unconsumed keyword arguments are stored in this special variable.

caller
If the macro was called from a call tag, the caller is stored in this variable as a callable macro.




怎么使用 call 标签呢？
3) 如何把一个 macro 传入给另一个 macro？使用 call 标签。

模板：注意其中的 caller() 是调用者宏
{% macro render_dialog(title, class='dialog') -%}
    <div class="{{ class }}">
        <h2>{{ title }}</h2>
        <div class="contents">
            {{ caller() }}
        </div>
    </div>
{%- endmacro %}

{% call render_dialog('Hello World') %}
    This is a simple dialog rendered by using a macro and
    a call block.
{% endcall %}

输出: 传入了 参数 title, 以及call包围部分到 caller() 位置。
<div class="dialog">
	<h2>Hello World</h2>
	<div class="contents">
		This is a simple dialog rendered by using a macro and
		a call block.
	</div>
</div>



4) call 还支持回传参数到 call 标签。 

py 中传入的数据
@app.route("/home")
def home():
    user_list = [
        {
            'uid': 100,
            'age': 20,
            'username':"Tom Bush",
            "desc": "I am from xx city, ..."
        },
        {
            'uid': 101,
            'age': 22,
            'username':"Lucy Green",
            "desc": "I am from yy city, ..."
        },
    ]
    return render_template("t5_home.html", user_list=user_list)



模板: call 还支持回传参数到 call 标签。 
{% macro dump_users(users) -%}
    <ul>
    {%- for user in users %}
        <li>
            <p>{{ user.username|e }}</p>
            {{ caller(user) }}
        </li>
    {%- endfor %}
    </ul>
{%- endmacro %}

{% call(user) dump_users(user_list) %}
    <dl>
        <dt>Uid</dt>
        <dd>{{ user.uid|e }}</dd>
        <dt>Description</dt>
        <dd>{{ user.desc }}</dd>
    </dl>
{% endcall %}


翻译后的页面:
<ul>
	<li>
		<p>Tom Bush</p>

		<dl>
			<dt>Uid</dt>
			<dd>100</dd>
			<dt>Description</dt>
			<dd>I am from xx city, ...</dd>
		</dl>
	</li>

	<li>
		<p>Lucy Green</p>

		<dl>
			<dt>Uid</dt>
			<dd>101</dd>
			<dt>Description</dt>
			<dd>I am from yy city, ...</dd>
		</dl>
	</li>
</ul>















========================================
|-- 模板包含: set传参, include, with 定义局部作用域, 模板继承 extends
----------------------------------------
1. set 可以在模板中设置变量

位置：在HTML页面中
作用：直接创建语句，方便在模板html中添加变量
注意：set 中 的变量会作为全局变量，将函数中传递的独有参数给覆盖掉！

$ cat t6.py
@app.route('/')
def login():
    userDict = {
        'age': 20,
        'username':"Tom Bush",
    }
    return render_template('t6_index.html', **userDict)


模板:
$ cat t6_index.html
{% set navigation %}
    <li><a href="/">Index</a>
    <li><a href="/downloads">Downloads</a>
{% endset %}

hi
<hr>
{{navigation}}
<hr>

翻译为:
hi
<hr>
    <li><a href="/">Index</a>
    <li><a href="/downloads">Downloads</a>
<hr>









2. include的复用
可以写整块内容，相比较宏来讲，可复用的模板内容更多

概念：include语句可以把一个模板引入到另外一个模板中，类似于把一个模板的代码copy到另外一个模板的指定位置
作用：复用代码，提高效率

关键点：针对的是模板，如一些网站固定的开头和结尾模板
使用：{% include '相对路径' %} 放在需要的位置即可！
{% include 'common/header.html' %}



模板:
$ cat t6_index.html
{% include 't6_footer.html' %}

<hr>
{% include 't6_footer.html' without context %}


$ cat t6_footer.html
<hr>
<div class="footer">这是尾部 {{age}}</div>


翻译后: 
<hr>
<div class="footer">这是尾部 20</div>
<hr>
<hr>
<div class="footer">这是尾部 </div>

解释: 
- 默认 include 是 with context 的，就是使用当前页面的上下文环境。
- 而 without context 则表示不使用当前上下文环境。




3. with 可以设定局部作用域: 两个等价写法

{% with foo = 42 %}
    {{ foo+8 }}
{% endwith %}

<br>
{% with %}
    {% set foo = 10 %}
    {{ foo }}
{% endwith %}


翻译后:
  50
<br>  
    10





4. 模板继承是最强大的部分 {% block %}

(1) 基本例子
@app.route("/ex1")
def show_extends():
    return render_template("t6_child.html")


模板父类: base是一个两列的骨架结构，有待子类填充其 block 部分。
$ templates/t6_base.html
<!DOCTYPE html>
<html lang="en">
<head>
    {% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
</head>
<body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
        {% block footer %}
        &copy; Copyright 2022 by <a href="http://domain.invalid/">you</a>.
        {% endblock %}
    </div>
</body>
</html>

本例子中有四个 block 区域，子类可以选择几个填充。

模板 子类: 填充了3个。其中第二个还继承了原有部分。
$ cat templates/t6_child.html 
{% extends "t6_base.html" %}

{% block title %}page01{% endblock %}

{% block head %}
    02 {{ super() }} 03
    <style type="text/css">
        .important { color: #0078f0; }
    </style>
{% endblock %}

{% block content %}
    <h1>Index</h1>
    <p class="important">
      Welcome to my awesome homepage.
    </p>
{% endblock %}


翻译后:

<!DOCTYPE html>
<html lang="en">
<head>
    02 
    <link rel="stylesheet" href="style.css" />
    <title>page01 - My Webpage</title>
     03
    <style type="text/css">
        .important { color: #0078f0; }
    </style>
</head>
<body>
    <div id="content">
    <h1>Index</h1>
    <p class="important">
      Welcome to my awesome homepage.
    </p>
</div>
    <div id="footer">
        &copy; Copyright 2022 by <a href="http://domain.invalid/">you</a>.
    </div>
</body>
</html>



(2) 一般可以在布局子文件夹中放布局文件，其他文件引用它
{% extends "layout/default.html" %}


(4) 如果一个 block 想多次使用，可以使用 self 参数:
<title>{% block title %}{% endblock %}</title>
<h1>{{ self.title() }}</h1>
{% block body %}{% endblock %}



(5) 使用父类  super()
{% block sidebar %}
    <h3>Table Of Contents</h3>
    ...
    {{ super() }}
{% endblock %}




(6) 嵌套继承 Nesting extends
多层 {% extends %} 嵌套，也可以链式访问父类， super.super()

# parent.tmpl
body: {% block body %}Hi from parent.{% endblock %}

# child.tmpl
{% extends "parent.tmpl" %}
{% block body %}Hi from child. {{ super() }}{% endblock %}

# grandchild1.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild1.{% endblock %}

# grandchild2.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild2. {{ super.super() }} {% endblock %}

渲染结果:
Rendering child.tmpl will give body: Hi from child. Hi from parent.
Rendering grandchild1.tmpl will give body: Hi from grandchild1.
Rendering grandchild2.tmpl will give body: Hi from grandchild2. Hi from parent.



(7) 加 结束标签 endblock 更清晰

{% block sidebar %}
    {% block inner_sidebar %}
        ...
    {% endblock inner_sidebar %}
{% endblock sidebar %}



(8) 嵌套block的作用域

默认，不能从外面进入 block 的作用域。
所以，本例将得到空的 li 标签。
{% for item in seq %}
    <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}
原因是：子类可能覆盖模板。

从 Jinja2.2，可以添加 scoped 修饰符，明确表示作用域能穿透到block内部。
{% for item in seq %}
    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>
{% endfor %}

被覆写时，不用再提供 scoped 修饰符。



(9) 必须的 block 

如果父类的block 加了 required 修饰符，则该block必须覆写，不一定是直接子类。
必须的 block 只能包含空格，并且不能直接渲染。

page.txt
{% block body required %}{% endblock %}

issue.txt
{% extends "page.txt" %}

bug_report.txt
{% extends "issue.txt" %}
{% block body %}Provide steps to demonstrate the bug.{% endblock %}

渲染 issue.txt 则报错: TemplateRuntimeError 
渲染 bug_report.txt 则正常。


注意: 如果 和  scoped 结合使用，则 required 要放到 scoped 后面。

{% block body scoped %}{% endblock %}
{% block body required %}{% endblock %}
{% block body scoped required %}{% endblock %}




(10) 模板对象
extends, include, 和 import 可以使用模板对象，代替一个模板文件名。
这在高级场景下有用，因为你可以使用Python代码载入一个模板，然后传入去渲染。

if debug_mode:
    layout = env.get_template("debug_layout.html")
else:
    layout = env.get_template("layout.html")

user_detail = env.get_template("user/detail.html")
return user_detail.render(layout=layout)


模板中传入参数作为父类模板。
{% extends layout %}



实例:
$ cat t6_child2.html
@app.route("/ex2")
def show_tpl_obj():
    # https://stackoverflow.com/questions/51794326/google-cloud-functions-python-flask-templates-folder
    from jinja2 import Environment, FileSystemLoader
    env = Environment(loader=FileSystemLoader('./templates'))
    layout2 = env.get_template("t6_base.html")
    user_detail = env.get_template("t6_child2.html")

    return user_detail.render(my_layout = layout2 )
解释: 使用 layout2 作为模板，填充模板变量。

模板:
$ cat templates/t6_child2.html
{% extends my_layout %}

{% block head %}
    {{ super() }} 05
{% endblock %}
{% block footer %}{% endblock %}


翻译后:
    <title> - My Webpage</title>
     05











========================================
flask-SQLAlchemy 及 flask 常见模型类: 模型这个术语表示程序使用的持久化实体
----------------------------------------

flask-sqlalchemy 致力于简化在 Flask 中 SQLAlchemy 的使用，提供了有用的默认值和额外的助手来更简单地完成常见任务。



1. flask中的模型

## example1
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///./test.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer,primary_key=True)
    username = db.Column(db.String(80),unique = True)
    email = db.Column(db.String(120),unique=True)

    def __init__(self,username,email):
        self.username = username
        self.email = email

    def __repr__(self):
        return '<User %r>' % self.username

 db.create_all()
#
# 解释：
(1) 模型需要继承自db.Model,然后需要映射到表中的属性,必须写成db.Column的数据类型
(2)
db.Integer代表整型
db.String代表varchar
db.Text 代表text

(3)
其他参数
primary_key 代表将这个字段设置为主键
autoincrement 代表这个主键为自增长的
nullable 代表这个字段是否为空,默认可以为空

最后用db.creat_all() 将模型真正创建到数据库中

admin = User('admin','admin@example.com')
guest = User('guest','guest@example.com')

db.session.add(admin)
db.session.add(guest)
db.session.commit()

ref: 
https://blog.csdn.net/Co_zy/article/details/77905568










2.
(1)一对多
class Role(db.Model):
    """角色表"""
    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

class User(db.Model):
    """用户表"""
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True, index=True)


(2)多对多
tb_student_course = db.Table('tb_student_course',
                             db.Column('student_id', db.Integer, db.ForeignKey('students.id')),
                             db.Column('course_id', db.Integer, db.ForeignKey('courses.id'))
                             )

class Student(db.Model):
    __tablename__ = "students"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)

    courses = db.relationship('Course', secondary=tb_student_course,
                              backref=db.backref('students', lazy='dynamic'),
                              lazy='dynamic')

class Course(db.Model):
    __tablename__ = "courses"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)


(3)自关联 一对多
class Comment(db.Model):
    """评论"""
    __tablename__ = "comments"

    id = db.Column(db.Integer, primary_key=True)
    # 评论内容
    content = db.Column(db.Text, nullable=False)
    # 父评论id
    parent_id = db.Column(db.Integer, db.ForeignKey("comments.id"))
    # 父评论(也是评论模型)
    parent = db.relationship("Comment", remote_side=[id],
                             backref=db.backref('childs', lazy='dynamic'))

# 测试代码
if __name__ == '__main__':
    db.drop_all()
    db.create_all()

    com1 = Comment(content='我是主评论1')
    com2 = Comment(content='我是主评论2')
    com11 = Comment(content='我是回复主评论1的子评论1')
    com11.parent = com1
    com12 = Comment(content='我是回复主评论1的子评论2')
    com12.parent = com1

    db.session.add_all([com1, com2, com11, com12])
    db.session.commit()
    app.run(debug=True)


(4)自关联多对多
tb_user_follows = db.Table(
    "tb_user_follows",
    db.Column('follower_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True),  # 粉丝id
    db.Column('followed_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True)  # 被关注人的id
)

class User(db.Model):
    """用户表"""
    __tablename__ = "info_user"

    id = db.Column(db.Integer, primary_key=True)  
    name = db.Column(db.String(32), unique=True, nullable=False)

    # 用户所有的粉丝，添加了反向引用followed，代表用户都关注了哪些人
    followers = db.relationship('User',
                                secondary=tb_user_follows,
                                primaryjoin=id == tb_user_follows.c.followed_id,
                                secondaryjoin=id == tb_user_follows.c.follower_id,
                                backref=db.backref('followed', lazy='dynamic'),
                                lazy='dynamic')
##







ref:
https://blog.csdn.net/fanlei5458/article/details/80464633

Flask从入门到精通之模型定义: https://www.cnblogs.com/senlinyang/p/8378632.html
	https://www.jianshu.com/p/19eb89b1d6b3

模型关系 https://www.cnblogs.com/senlinyang/p/8379436.html



========================================
flask 安全：cookie, session 和用户登录、退出
----------------------------------------
1.理论基础

(1)cookie(保存在客户端的浏览器上)：
在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

(2)session(保存在服务器上):
session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，存一些session信息还是绰绰有余的。

(3)cookie和session结合使用：
web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1)存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2)将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。





2.flask中使用cookie和session
(1)cookies：
在Flask中操作cookie，是通过response对象来操作，可以在response返回之前，通过response.set_cookie来设置，这个方法有以下几个参数需要注意：

key：设置的cookie的key。
value：key对应的value。
max_age：改cookie的过期时间，如果不设置，则浏览器关闭后就会自动过期。
expires：过期时间，应该是一个datetime类型。
domain：该cookie在哪个域名中有效。一般设置子域名，比如cms.example.com。
path：该cookie在哪个路径下有效。

使用：
  获取：request.cookies.get(key, '默认值')
  设置：resp.set_cookie(key, value, max_age=整数)
  删除：resp.delete_cookie(key)
#

##参考代码 not run;
from flask import Flask,Blueprint,request,make_response

app = Flask(__name__)

#创建实例
cookie=Blueprint('cookie', __name__)

#获取cookie
@cookie.route('/get/')
def get():
    return request.cookies.get('name','I am cookie001')

#设置cookie
@cookie.route('/set/')
def set():
    res=make_response('cookie 已设置')
    #设置cookie，顺便指定有效期，默认为none，浏览器关闭就失效
    #max_age: 一个整数，单位为s，即多少秒后过期
    # expires: datetime类型，即指定日期后过期
    res.set_cookie('name','I am another cookie002', max_age=30)
    return res

#删除cookie
@cookie.route('/del/')
def delete():
    res=make_response('cookie 已删除')
    res.delete_cookie('name')
    return res

#
#启动后端程序
if __name__ == '__main__':
    app.run(debug=True, port=10001) 
#





(2)session：
Flask中的session是通过from flask import session。然后添加值key和value进去即可。

client side session：Flask中的session机制是将session信息加密，然后存储在cookie中。专业术语叫做client side session。
server side session：存储在服务器，客户端保存的时session_id（通过cookie完成）

使用：
  获取：session.get(key, '默认值')
设置：
    session.permanent = True
    session[key] = value  
删除：
指定删除：session.pop(key, None)
清空所有：session.clear()


设置session过期时间
如果没有指定session的过期时间，默认是浏览器关闭后就自动结束
设置了session的permanent属性为True，那么过期时间是31天（session.permanent = True）

可以通过给app.config设置PERMANENT_SESSION_LIFETIME来更改过期时间，这个值的数据类型是datetime.timedelay类型。
"""config.py"""
from datetime import timedelta
import os

SECRET_KEY = os.urandom(24)         #生成一串随机24位的字符
PERMANENT_SESSION_LIFETIME = timedelta(days=7)  #设置session7天有效
#


#
##参考代码 not run;
from flask import Blueprint,session

sess=Blueprint('sess',__name__)

#设置
@sess.rout('/set/')
def set():
    #设置是否永久有效（必须放在请求上下文中），默认False，浏览器关闭失效
    #设置为True，有效期由 app.config['PERMANENT_SESSION_LIFETIME']决定
    #app.config[PERMANENT_SESSION_LIFETIME]默认为31天
    session.permanent=True
    session['name']='who are you'
    return "session was set"

#获取session
@sess.route('/get/')
def get():
    return session.get('name','who are you?(default)')

#删除
@sess.route("/del/")
def delete():
    #删除指定的session，第二个参数设置为None，即使删除不存在的键也不报错
    #session.pop('name',None)
    #清空所有的session
    session.clear()
    return "session is deleted"
#








(3) manage.py 可运行的代码
from flask import Flask, session,jsonify,make_response,request
import os

app=Flask(__name__)
#app.config['SECRET_KEY']='123456' ## 一串随机字符串作为session的加密盐值
app.config['SECRET_KEY']='1'
app.config['PERMANENT_SESSION_LIFETIME']=20 #20s有效期 10天有效期，可以设置 10*24*365

#操作session方法与操作字典相同

@app.route('/')
def index():
    #设置是否永久有效（必须放在请求上下文中），默认False，浏览器关闭失效
    #设置为True，有效期由 app.config['PERMANENT_SESSION_LIFETIME']决定
    #app.config[PERMANENT_SESSION_LIFETIME]默认为31天
    session.permanent=True
    session['username']='Jim'
    session['psw']='123456'

    #for cookie:
    res=make_response('hello, session test ~ cookie 已设置')
    #设置cookie，顺便指定有效期，默认为none，浏览器关闭就失效
    #max_age: 一个整数，单位为s，即多少秒后过期
    # expires: datetime类型，即指定日期后过期
    res.set_cookie('name','I am another cookie002', max_age=30)
    res.set_cookie('book','js the good part', max_age=30)

    return res
#
# 读取session
@app.route('/get')
def get():
    #session['username']    # 方法一，如果内容不存在，将会报异常
    username=session.get('username','')     # 方法二，如果内容不存在，将返回None。推荐使用
    #return session.get('username','no session username')

    #for cookie:
    cookie=request.cookies.get('name','no cookie00_')
    book=request.cookies.get('book','no book')

    return jsonify({
        'session':[username,session.get('psw', 'nothing') ], 
        #'session':[username,session['psw'] ], 
        'cookie':[cookie,book]
    })
#
#删除 session
@app.route('/delete/')
def delete():
    session.pop('username') #字典pop方法删除session指定键
    #session.clear() #删除session所有值

    #for cookie 
    res=make_response('deleted!')
    res.delete_cookie('book')

    return res


#启动后端程序
if __name__ == '__main__':
    app.run(debug=True, port=10001) 

#
# http://127.0.0.1:10001/  #设置session
# http://127.0.0.1:10001/get 超过20s不访问，paw session就会失效。
#   - 一直刷新，30s后cookie就自动到期销毁了 
# 





========================================
|-- flask RBAC (Role-Based Access Control): 基于角色的权限控制
----------------------------------------

1. RBAC几乎无关语言、框架，主要是数据库结构上面设计

(1)通常来讲需要5张表

a. 用户表 user
b. 角色表 role
c. 权限表（页面节点） node

d. 用户角色表 user_role，一个用户可有多个角色
e. 角色权限表 role_node，一个角色可以访问若干页面节点


1)、 auth_user // 用户表
2)、 auth_node // 可授权节点表
3)、 auth_role // 角色表

4)、 auth_user_role // 用户<==>角色关系对应表，因为用户和角色是many-to-many的关系（or ones-to-one，看实际情况）
5)、 authenticated // 角色授权表 同样是many-to-many的关系

用户可对应N个角色（不一定非一成不变），每个角色可授权N个节点，节点权限验证的时候，使用用户的所有角色去取得已授权的节点列表，然后判断，就这么简单。开发中可能会根据实际情况有一些变动，灵活处理即可。



(2) 基于RBAC的实现流程
a. 首先针对权限的校验的业务逻辑在一个父类中实现，其余子类均需要实现该父类，从而实现针对用户的权限的控制。
b. 用户访问时，首先查询用户表判断用户的状态是否是可用。
c. 然后根据用户 id查询 用户角色表，得到用户的角色id
d. 根据角色 id 查询 权限角色表，得到该用户在这个角色或这些角色下的权限id
e. 根据权限 id 查询 权限表，得到该用户在该角色下的权限，就是可以看的页面/数据范围。






(3A) 表结构 for MySql
不太懂主键约束，所以，涉及到的句子可能是错的。
https://mysql.tutorials24x7.com/blog/guide-to-design-database-for-rbac-in-mysql

CREATE DATABASE  IF NOT EXISTS `rbac` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */;
USE `rbac`;
SET NAMES utf8;


1) 用户
DROP TABLE IF EXISTS `user`;
SET character_set_client = utf8mb4 ;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `mobile` varchar(15) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `email` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `passwordHash` varchar(32) COLLATE utf8mb4_unicode_ci NOT NULL,
  
  `registeredAt` datetime NOT NULL,
  `lastLogin` datetime DEFAULT NULL,
  `desc` text COLLATE utf8mb4_unicode_ci,

  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_mobile` (`mobile`),
  UNIQUE KEY `uq_email` (`email`),
  KEY `auth_user_role` (`id`),
  CONSTRAINT `auth_user_role` FOREIGN KEY (`uid`) REFERENCES `role` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


--
-- Dumping data for table `user`
--
LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;


2) 角色
DROP TABLE IF EXISTS `role`;
SET character_set_client = utf8mb4 ;
CREATE TABLE `role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title`  varchar(75) COLLATE utf8mb4_unicode_ci NOT NULL,
  `desc` tinytext COLLATE utf8mb4_unicode_ci,
  `active` tinyint(1) NOT NULL DEFAULT '0',
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime DEFAULT NULL,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_slug` (`title`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


--
-- Dumping data for table `role`
--
LOCK TABLES `role` WRITE;
/*!40000 ALTER TABLE `role` DISABLE KEYS */;
/*!40000 ALTER TABLE `role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;


3) 权限，用路由节点表示 permission
DROP TABLE IF EXISTS `node`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `node` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(75) COLLATE utf8mb4_unicode_ci NOT NULL,
 
  `desc` tinytext COLLATE utf8mb4_unicode_ci,
  `active` tinyint(1) NOT NULL DEFAULT '0',
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime DEFAULT NULL,

  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_slug` (`title`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `node`
--

LOCK TABLES `node` WRITE;
/*!40000 ALTER TABLE `node` DISABLE KEYS */;
/*!40000 ALTER TABLE `node` ENABLE KEYS */;
UNLOCK TABLES;


4) auth_user_role 
DROP TABLE IF EXISTS `auth_user_role`;
SET character_set_client = utf8mb4 ;
CREATE TABLE `auth_user_role` (
  `uid` bigint(20) NOT NULL,
  `rid` bigint(20) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`uid`,`rid`),
  KEY `role` (`id`),
  KEY `idx_permission` (`rid`),
  CONSTRAINT `fk_rp_user` FOREIGN KEY (`uid`) REFERENCES `user` (`id`),
  CONSTRAINT `fk_rp_role` FOREIGN KEY (`rid`) REFERENCES `role` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_role`
--

LOCK TABLES `auth_user_role` WRITE;
/*!40000 ALTER TABLE `auth_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_role` ENABLE KEYS */;
UNLOCK TABLES;




5) auth_role_node
DROP TABLE IF EXISTS `auth_role_node`;
SET character_set_client = utf8mb4 ;
CREATE TABLE `auth_role_node` (
  `rid` bigint(20) NOT NULL,
  `nid` bigint(20) NOT NULL,
  `createdAt` datetime NOT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`rid`,`nid`),
  KEY `idx_rp_role` (`rid`),
  KEY `idx_rp_permission` (`nid`),
  CONSTRAINT `fk_rp_permission` FOREIGN KEY (`nid`) REFERENCES `node` (`id`),
  CONSTRAINT `fk_rp_role` FOREIGN KEY (`rid`) REFERENCES `role` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_role_node`
--

LOCK TABLES `auth_role_node` WRITE;
/*!40000 ALTER TABLE `auth_role_node` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_role_node` ENABLE KEYS */;
UNLOCK TABLES;










(3B) 表结构 for Sqlite
不太懂主键约束，所以，涉及到的句子可能是错的。
https://mysql.tutorials24x7.com/blog/guide-to-design-database-for-rbac-in-mysql
https://www.runoob.com/sqlite/sqlite-constraints.html

测试:
create table if not exists `a3` (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username varchar(50) unique NOT NULL
);


1) 用户
create table if not exists `user` (
  `id` INTEGER PRIMARY KEY AUTOINCREMENT,
  `username` varchar(50) unique,
  `passwordHash` TEXT NOT NULL,
  active int DEFAULT 1,
  `desc` text
);

2) 角色
create table if not exists `role` (
  `id` INTEGER PRIMARY KEY AUTOINCREMENT,
  `title`  varchar(75) unique NOT NULL,
  active int DEFAULT 1,
  `desc` text
);

3) 权限，用路由节点表示 permission
create table if not exists `node` (
  `id` INTEGER PRIMARY KEY AUTOINCREMENT,
  `title` varchar(75) unique NOT NULL,
  active int DEFAULT 1,
  `desc` text
);

4) auth_user_role 
create table if not exists `auth_user_role` (
  `uid` INTEGER NOT NULL,
  `rid` INTEGER NOT NULL,
  PRIMARY KEY (`uid`,`rid`)
);

5) auth_role_node
create table if not exists `auth_role_node` (
  `rid` INTEGER NOT NULL,
  `nid` INTEGER NOT NULL,
  PRIMARY KEY (`rid`,`nid`)
);


查询表:
sqlite> .tables
auth_role_node  auth_user_role  node            role            user

6) 填充数据
假设是一个论坛，主要涉及
	帖子(增、删、改)、
	用户(增、删、改、暂停)、
	角色(增、删、改、暂停)、
	权限(增、删、改、暂停)
	的管理。

每个权限都是名词加动词构成的url前缀
	/post/
	/user/
	/role/add, /role/del, /role/edit, /role/disable, /role/enable
	/node/
角色有3个
	root, 根用户，操作权限表，角色表，用户表，不能亲自管理帖子
	admin, 管理普通用户表和帖子
	common, 管理自己的帖子
用户可以由管理员

sqlite> .headers on
sqlite> .mode column
sqlite> .schema node;
sqlite> .schema node
CREATE TABLE `node` (
  `id` INTEGER PRIMARY KEY AUTOINCREMENT,
  `title` varchar(75) unique NOT NULL,
  active int DEFAULT 1,
  `desc` text
);
sqlite>
sqlite> select * from node;

权限(node)表
insert into node(title) values('/role/add'), ('/role/del'), ('/role/edit'), ('/role/disable'), ('/role/enable');
insert into node(title) values('/node/add'), ('/node/del'), ('/node/edit'), ('/node/disable'), ('/node/enable');
insert into node(title) values('/user/add'), ('/user/del'), ('/user/edit'), ('/user/disable'), ('/user/enable');
insert into node(title) values('/post/add'), ('/post/del'), ('/post/edit'), ('/post/disable'), ('/post/enable');


角色表 
insert into role(title) values('root'), ('admin'), ('common');

用户表
insert into user(username, passwordHash) values('Robin', 'e10adc3949ba59abbe56e057f20f883e'), ('Lucy', 'e10adc3949ba59abbe56e057f20f883e'), ('Tom1', 'e10adc3949ba59abbe56e057f20f883e');

用户-角色表 
sqlite> select * from user;
sqlite> select * from role;
sqlite> .schema auth_user_role
insert into auth_user_role values(1,1), (1,2), (2,2), (3,3);

角色-权限表 
sqlite> select * from node;
sqlite> .schema auth_role_node
insert into auth_role_node values (1,1), (1,2), (1,3), (1,4), (1,5), 
(1,6), (1,7), (1,8), (1,9), (1,10),
(1,11), (1,12), (1,13), (1,14), (1,15);
insert into auth_role_node values (2,11), (2,12), (2,13), (2,14), (2,15), (2,19), (2,20);
insert into auth_role_node values (3,16), (3,17), (3,18), (3,19), (3,20);


sqlite> .quit

> select username, a.id as uid, b.title, d.title as nodename 
	from user a,role b, auth_user_role c, node d, auth_role_node e 
	where a.id==c.uid and b.id==c.rid and 
	e.rid==b.id and e.nid==d.id and a.id=='1' and 
	a.active==1 and b.active==1 and d.active==1;






https://github.com/tutorials24x7/rbac-database-mysql/blob/master/rbac.sql












2.Flask实现基于角色的访问控制(RBAC)
https://blog.51cto.com/kevinhao/1900391
另外说一句，Flask有RBAC的实现方案，不过没用过，github上面关注度也不高，给传送门吧 https://github.com/shonenada/flask-rbac

基于 MVC 结构自己实现一遍。

Flask的核心在于”Micro”，因此它不像Django拥有很多功能，尤其是认证系统。因此使用Flask要自己写一个认证系统。下面就给大家分享一下简单的Flask实现RBAC。下面都是在models.py文件的代码

1、权限常量

class Permission:
    COMMENT = 0x02
	ADMINISTER = 0x80

2、角色表
class Role(db.Model):
    __tablename__ = 'roles'
    id =db.Column(db.Integer,primary_key=True)
	name =db.Column(db.String(255),unique=True)
	default = db.Column(db.Boolean,default=False,index=True)
	permissions = db.Column(db.Integer)
	users = db.relationship('User',backref='role',lazy='dynamic')
	
def __repr__(self):
	return '<Role%r>' %self.name

将角色手动添加到数据库中，即耗时又容易出错，最便捷的又不容易出错的方法就是写一个静态方法。

class Role(db.Model):
……
  @staticmethod
      def insert_roles():
          roles = {
              'User': (Permission.COMMENT,True),
              'Administrator': (0xff,False)
          }
          for ro in roles:
              role= Role.query.filter_by(name=ro).first()
              ifrole is None:
                  role = Role(name=ro)
              role.permissions = roles[ro][0]
              role.default = roles[ro][1]
              db.session.add(role)
          db.session.commit()

3、用户表
class User(UserMixin,db.Model):
    __tablename__ = 'users'
    id =db.Column(db.Integer,primary_key=True)
    username =db.Column(db.String(255),unique=True,index=True)
    passwd =db.Column(db.String(255))
    email =db.Column(db.String(255),unique=True,index=True)
    role_id = db.Column(db.Integer,db.ForeignKey('roles.id'))
 

    def __repr__(self):
         '<User %r>'%self.username

4、赋予角色
用户在注册时，会赋予适当的角色。用户注册时赋予的角色都是普通用户，这是默认角色。但管理员就比较列外了。管理员由设置的变量CMDB_ADMIN来识别，当注册的邮箱和设置的该变量的值一样就会自动设置为管理员。

Class User(UseMin,db.Model):

……

    def__init__(self,**kwargs):
       super(User,self).__init__(**kwargs)
        if self.role is None:
            if self.email ==current_app.config['CMDB_ADMIN']:
                self.role =Role.query.filter_by(permissions=0xff).first()
            if self.role ==None:
                self.role =Role.query.filter_by(default=True).first()
    def __repr__(self):
         '<User %r>'%self.username
#




3.flask通用rbac权限框架
https://blog.csdn.net/weixin_39352048/article/details/80363326







========================================
|-- casbin: 权限控制
----------------------------------------

https://casbin.org/

现在新推出了一个权限框架，叫PyCasbin（https://github.com/casbin/pyc...）。PyCasbin采用了元模型的设计思想，支持多种经典的访问控制方案，如ACL、RBAC、ABAC，还支持对RESTful API的控制。现在已经支持Django、Flask等Web框架了。需要中文文档的话，可以在百度搜索：PyCasbin: https://github.com/casbin/pycasbin












========================================
flask 踩坑
----------------------------------------

========================================
|-- 手动更新数据表，但是flask显示并没有更新
----------------------------------------

1.
查询前先 `db.session.commit()` 将当前 session 对象里的缓存提交（清空缓存），查询时就直接从数据库中查询最新数据。
https://www.cnblogs.com/huchong/p/9258458.html
https://www.jianshu.com/p/c0a8275cce99

https://www.v2ex.com/t/198981



2.



========================================
|-- FLASK在其他文件中添加路由
----------------------------------------
应用文件为：app.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()

如果不想在这个文件中添加新路由，怎么办？


1.有个直观的办法, 新建test.py
def  add_new_routes(app):
    @app.route("/test")
    def test():
        return 'test'
#

然后在app.py中添加调用，
from test import add_new_routes
add_new_routes(app)

前面的办法缩进有点多啊！



2. 换个方法，将test.py的代码改为：

def hello():
    return 'hello world'

def add_new_routes(app):
    app.add_url_rule('/hello', view_func=hello)

同理，在Blueprint中，也可以这么干。


个人认为：方法2更好，适合很多函数的场景，代码改动很少。

https://www.cnblogs.com/lyg-blog/p/9499227.html






========================================
Vue项目开发与规范--RESTful API 设计篇
----------------------------------------
1.协议
API与用户的通信协议，总是使用HTTPs协议。

2.域名
应该尽量将API部署在专用域名之下。
https://api.example.com

如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/


3.版本（Versioning）
应该将API的版本号放入URL。
https://api.example.com/v1/

另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。


4.路径（Endpoint）
路径又称"终点"（endpoint），表示API的具体网址。
在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。

举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees



5.HTTP动词
对于资源的具体操作类型，由HTTP动词表示。

常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
GET（SELECT）：从服务器取出资源（一项或多项）。
POST（CREATE）：在服务器新建一个资源。
PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
DELETE（DELETE）：从服务器删除资源。
还有两个不常用的HTTP动词。
HEAD：获取资源的元数据。
OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

下面是一些例子。
GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物



6.过滤信息（Filtering）
如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。

下面是一些常见的参数。
?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&per_page=100：指定第几页，以及每页的记录数。
?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件

参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。



7.状态码（Status Codes）
服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。

HTTP 状态码就是一个三位数，分成五个类别。
1xx：相关信息
2xx：操作成功
3xx：重定向
4xx：客户端错误
5xx：服务器错误
# API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。


200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。

400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。

500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。



8.错误处理（Error handling）
如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。

{
    error: "Invalid API key"
}


9.返回结果
针对不同操作，服务器向用户返回的结果应该符合以下规范。

GET /collection：返回资源对象的列表（数组）
GET /collection/resource：返回单个资源对象
POST /collection：返回新生成的资源对象
PUT /collection/resource：返回完整的资源对象
PATCH /collection/resource：返回完整的资源对象
DELETE /collection/resource：返回一个空文档


10.Hypermedia API
RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。
比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。

{"link": {
  "rel":   "collection https://www.example.com/zoos",
  "href":  "https://api.example.com/zoos",
  "title": "List of zoos",
  "type":  "application/vnd.yourformat+json"
}}

上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。
Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。

{
  "current_user_url": "https://api.github.com/user",
  "authorizations_url": "https://api.github.com/authorizations",
  // ...
}

从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。

{
  "message": "Requires authentication",
  "documentation_url": "https://developer.github.com/v3"
}
上面代码表示，服务器给出了提示信息，以及文档的网址。



11.其他
服务器返回的数据格式，应该尽量使用JSON，避免使用XML。



12.安全 
做一个网站，前端用vue写的，后端准备 ASP/Python/PHP mvc做API

(1)返回状态码是用http状态代码，然后再json中说明错误信息,
还是直接http返回200然后在json中返回错误码和错误信息?

A:
status code表示http状态，2xx系列都能表示各种成功返回。

status code 肯定是跟回http的标准，简单明了。404就是not found，500就是server error，不用额外说明。如果你所有status都返回200，一些ajax的success和fail的callback不能直接用。





(2) 我看有人说登陆状态不要用session 和cookie而要自定义一个token 在请求中带上，
个人感觉不是用session 不是简单么？为啥一定要自定义token ？

A: 
做restful必然是stateless， session天然带有state属性，不符合涉及习惯，而token满足stateless中的验证要求。

token是无状态的，在登陆的时候领取到token，在请求资源的时候带上token，token有效期内均视为已登录。

不要使用session，session需要server端存储，有多种风险。前端页面ajax请求的话用COOKIE，因为浏览器会自动发送COOKIE，比较方便。非页面的模块发请求用token，因为没有浏览器帮忙发cookie了，手动拼的话拼url更方便。


RESTful并不是专门为浏览器设计的，它是为普通的客户端api设计的，客户端不方便使用session，反而是token更简单。



google best api design books，然后先看他三本再说




refer:
https://www.jianshu.com/p/704f318a74f2
http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html



========================================
Vue项目开发与规范--RESTful API 实现篇
----------------------------------------
使用 Python 和 Flask 设计 RESTful API http://www.pythondoc.com/flask-restful/first.html


1. 实例 Ensembl REST API Endpoints http://rest.ensembl.org/
访问 http://rest.ensembl.org/archive/id/ENSG00000157764?content-type=application/json
返回 {"release":"97","possible_replacement":[],"latest":"ENSG00000157764.13","assembly":"GRCh38","peptide":null,"version":13,"is_current":"1","type":"Gene","id":"ENSG00000157764"}

Python3访问
import requests, sys
 
server = "http://rest.ensembl.org"
ext = "/archive/id/ENSG00000157764?"
 
r = requests.get(server+ext, headers={ "Content-Type" : "application/json"})
 
if not r.ok:
  r.raise_for_status()
  sys.exit()
 
decoded = r.json()
print(repr(decoded))


(2)
中间放一层php呢？






2. 完整示例
我的测试代码: https://github.com/DawnEve/learngit/tree/dev/Python3/pythonCodeGit/day15-web-sql dev分支



from flask import Flask,request,jsonify

#http://www.pythondoc.com/flask-restful/first.html
# HTTP methods like GET, POST, PUT, DELETE.

app = Flask(__name__)

tasks = [
    {
        'id': 1,
        'title': u'Buy groceries',
        'description': u'Milk, Cheese, Pizza, Fruit, Tylenol',
        'done': False
    },
    {
        'id': 2,
        'title': u'Learn Python',
        'description': u'Need to find a good Python tutorial on the web',
        'done': False
    }
]

@app.route('/todo/api/v1.0/tasks', methods=['GET'])
def get_tasks():
    return jsonify({'tasks': tasks})

#通过执行 app.py，启动 web service。

#1. 浏览器查看
# http://127.0.0.1:5000/todo/api/v1.0/tasks

#2. 打开一个新的控制台窗口，运行以下命令:
# curl -i http://localhost:5000/todo/api/v1.0/tasks
# 使用curl能更灵活的使用4个请求方法
#  一个 GET 请求表示客户端获取一个用户的信息。
#  一个 POST 请求表示客户端新增一个用户信息。
#  一个 PUT 请求表示更新用户信息，比如可能是更新邮箱地址。
#  一个 DELETE 请求表示删除用户账号。




##############
# 使用get方法
##############
from flask import abort

@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['GET'])
def get_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task = list(task0)
    if len(task) == 0:
        abort(404) #报错不是jason格式的，不理想
    return jsonify({'task': task[0]}) #用 jsonify 打包成 JSON 格式并将其发送作为响应
# http://localhost:5000/todo/api/v1.0/tasks/2
# curl -i http://localhost:5000/todo/api/v1.0/tasks/2



##############
# json格式的报错
##############
from flask import make_response

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)
#




##############
# post方式
##############
from flask import request

@app.route('/todo/api/v1.0/tasks', methods=['POST'])
def create_task():
    if not request.json or not 'title' in request.json:
        abort(400)
    task = {
        'id': tasks[-1]['id'] + 1,
        'title': request.json['title'],
        'description': request.json.get('description', ""),
        'done': False
    }
    tasks.append(task)
    return jsonify({'task': task}), 201
#使用如下的 curl 命令来测试这个新的函数:
# $ curl -i -H "Content-Type: application/json" -X POST -d '{"title":"Read a book"}' http://localhost:5000/todo/api/v1.0/tasks
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks





##############
# put 方式
##############
@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task=list(task0)
    if len(task) == 0:
        abort(404)
    if not request.json:
        abort(400)
    if 'title' in request.json and type(request.json['title']) != unicode:
        abort(400)
    if 'description' in request.json and type(request.json['description']) is not unicode:
        abort(400)
    if 'done' in request.json and type(request.json['done']) is not bool:
        abort(400)
    task[0]['title'] = request.json.get('title', task[0]['title'])
    task[0]['description'] = request.json.get('description', task[0]['description'])
    task[0]['done'] = request.json.get('done', task[0]['done'])
    return jsonify({'task': task[0]})
#
# curl -i -H "Content-Type: application/json" -X PUT -d '{"done":true}' http://localhost:5000/todo/api/v1.0/tasks/2
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks







##############
# delete 方式
##############
@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task=list(task0)
    if len(task) == 0:
        abort(404)
    tasks.remove(task[0])
    return jsonify({'result': True})
# 删除一条
# curl -i -H "Content-Type: application/json" -X DELETE http://localhost:5000/todo/api/v1.0/tasks/2
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks





##############
# 优化 web service 接口: 输出的id改为URI
##############

# 一个小的辅助函数生成一个 “公共” 版本任务发送到客户端:
from flask import url_for
def make_public_task(task):
    new_task = {}
    for field in task:
        if field == 'id':
            new_task['uri'] = url_for('get_task', task_id=task['id'], _external=True)
        else:
            new_task[field] = task[field]
    return new_task
# 我们将会把上述的方式应用到其它所有的函数上以确保客户端一直看到 URIs 而不是 ids。

@app.route('/todo/api/v2.0/tasks', methods=['GET'])
def get_tasks2():
    return jsonify({'tasks': list( map(make_public_task, tasks)) })
# curl -i http://localhost:5000/todo/api/v2.0/tasks






##############
# 加强 RESTful web service 的安全性
##############
# 确保我们的 web service 安全服务的最简单的方法是要求客户端提供一个用户名和密码。
# 在常规的 web 应用程序会提供一个登录的表单用来认证，并且服务器会创建一个会话为登录的用户以后的操作使用，
#  会话的 id 以 cookie 形式存储在客户端浏览器中。

# 然而 REST 的规则之一就是 “无状态”， 因此我们必须要求客户端在每一次请求中提供认证的信息。

# HTTP 协议提供了两种认证机制: Basic 和 Digest。
# $ flask/bin/pip install flask-httpauth

#from flask.ext.httpauth import HTTPBasicAuth
#error: https://blog.csdn.net/i_spirit/article/details/94642832
#出现该问题主要原因是新版的flask抛弃了flask.ext这种引入扩展的方法，更改为 flask_扩展名
#例如：
#以前：from flask.ext.script import Manager
#现在：from flask_script import Manager
from flask_httpauth import HTTPBasicAuth

auth = HTTPBasicAuth()


#get_password 函数是一个回调函数，Flask-HTTPAuth 使用它来获取给定用户的密码。
#在一个更复杂的系统中，这个函数是需要检查一个用户数据库，但是在我们的例子中只有单一的用户因此没有必要。
@auth.get_password
def get_password(username):
    if username == 'lang':
        return 'python'
    return None
#error_handler 回调函数是用于给客户端发送未授权错误代码。像我们处理其它的错误代码，
#这里我们定制一个包含 JSON 数据格式而不是 HTML 的响应。
@auth.error_handler
def unauthorized():
    #return make_response(jsonify({'error': 'Unauthorized access'}), 401)
    #让人不舒服的是当请求收到一个 401 的错误，网页浏览都会跳出一个丑陋的登录框
    return make_response(jsonify({'error': 'Unauthorized access'}), 403)


# 随着认证系统的建立，所剩下的就是把需要认证的函数添加 @auth.login_required 装饰器
@app.route('/todo/api/v3.0/tasks', methods=['GET'])
@auth.login_required
def get_tasks3():
    return jsonify({'tasks': tasks})
# http://localhost:5000/todo/api/v3.0/tasks
# 未授权  curl -i http://localhost:5000/todo/api/v3.0/tasks
# 授权后  curl -u lang:python -i http://localhost:5000/todo/api/v3.0/tasks

# 认证扩展给予我们很大的自由选择哪些函数需要保护，哪些函数需要公开。






##############
# 可能的改进
##############
#一个真正的 web service 需要一个真实的数据库进行支撑。我们现在使用的内存数据结构会有很多限制不应该被用于真正的应用。

#另外一个可以提高的领域就是处理多用户。如果系统支持多用户的话，不同的客户端可以发送不同的认证凭证获取相应用户的任务列表。








if __name__ == '__main__':
    app.run(debug=True)








========================================
Django 框架 课程概述
----------------------------------------
https://www.djangoproject.com/
Django makes it easier to build better Web apps more quickly and with less code.

Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It’s free and open source.



1. 入门课程: 
三小时带你入门Django框架 https://www.imooc.com/learn/1110
django入门与实践: https://www.imooc.com/learn/790


专题课程:
全面掌握Django ORM: https://www.imooc.com/learn/1087
Django的一个强大的功能是它的对象关系映射Object-Relational Mapping（ORM），它允许你就像使用 SQL一样去和你的数据库交互，本课程将以Django官方文档为依据，通过开发讲师、课程、学生、助教四个模型类，给大家完整透彻的讲解Django ORM知识体系，为更高级的开发打下坚实基础。

课程源码：https://github.com/liaogx/imooc


## 用户评价：
- Tornado使用高并发。Django中异步需要使用Celery。
- 零零散散花了7小时42分，学习完了，感觉非常不错，特别是对 Models API的系统讲解。



(1) 安装
pip3 install django
python3 -m django --version ## 3.1.2

This tutorial is written for Django 3.1, which supports Python 3.6 and later.
https://docs.djangoproject.com/en/3.1/intro/tutorial01/


(2) Creating a project
cd到一个目录
$ django-admin startproject mysite

目录结构
wangjl@sustc-HG:~/web/Django$ tree
.
└── mysite          项目文件夹
    ├── manage.py
    └── mysite
        ├── asgi.py
        ├── __init__.py
        ├── settings.py
        ├── urls.py
        └── wsgi.py
#

(3) The development server
$ python3 manage.py runserver
浏览器打开能看到小火箭，http://127.0.0.1:8000/
只能在本地桌面看页面了。则会使admin页面。



(4) Creating the Polls app
$ python3 manage.py startapp polls

wangjl@sustc-HG:~/web/Django/mysite$ tree
mysite/
...
└── polls
    ├── admin.py
    ├── apps.py
    ├── __init__.py
    ├── migrations
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    └── views.py
# 这就是调查问卷的框架结构

(5)Write your first view
i)添加视图文件
$ vim polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")


ii)还需要配置url
$ vim polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]

# path()可以接收4个参数  route and view, and two optional: kwargs, and name. 




iii)接着，还需要把根url指向 polls.urls 模块。插入一行：
$ vim mysite/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),  #指向自定义模块
    path('admin/', admin.site.urls),
]

# 在 include()函数中允许指向其他URL设置。当Django遇到include()时，就切开URL匹配部分，把剩余字符串发送到该包含的url模块做进一步的处理。


要么用 include()，要么用 admin.site.urls:
You should always use include() when you include other URL patterns. admin.site.urls is the only exception to this.




(6) 运行新模块
$ python3 manage.py runserver
http://localhost:8000/polls/

可以看到输出 Hello, world. You're at the polls index.








2. Django的优势
最早接触Django，在我心中的形象是：Web框架界的变形金刚
Django的MVT架构、自带ORM、强大的Admin后台管理、自带数据库、还自带开发测试用的服务器、不得不说服务周到。
如此大而全，重量级的Django给开发者提供了超高的开发效率。
淌着Python血液
MVT三大轮子 连接浏览器 数据库开跑
一身装备 可变形 可扩展
多领域 跨平台 协调作战
自我测试 自我管理 自我保护
友好 开放 国际化
装备很多：用户认证 缓存 日志 邮件 组织 分页 消息 序列化 会话 网站地图 静态文件处理 数据验证
Django支持第三方扩展：比如 富文本编辑器  缓存 全文检索  celery等
Django项目布署 用nginx做静态资源代理、负载均衡 可以提高高并发能力。

一些Web项目开发 无论用户量、服务群体、上来总谈高并发。没用户 天天愁高并发问题 还没解决也许项目已经黄了。
项目有了、业务有了、用户有了、性能优化、高并发顺势解决嘛。
当然一些大型网站，在高性能的要求下，框架的各个部分往往都需要自己定制，这样用Django也就没有太大优势。













========================================
Tornado 非阻塞式服务器
----------------------------------------
1. 简介
http://www.tornadoweb.org/en/stable/

Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using non-blocking network I/O, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.

python写的异步web框架，起源于FriendFeed公司。使用非阻塞的网络IO， Tornado可以扩展到数以万计的开放连接，特别适用于long polling, WebSockets 等需要长时间和每个用户连接的情况。




2. Here is a simple “Hello, world” example web app for Tornado:
手动pip安装包: $ pip install tornado

$ vim tornado_demo.py
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

if __name__ == "__main__":
    app = make_app()
    app.listen(8000)
    tornado.ioloop.IOLoop.current().start()

$ python tornado_demo.py

什么也没显示，不过用浏览器访问该端口 http://y.biomooc.com:8000/，能看到 Hello, world，在F12能看到响应的服务器名字 Server: TornadoServer/5.1





========================================
如何写复杂业务代码
----------------------------------------
https://www.jianshu.com/p/05f395780da1







========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





