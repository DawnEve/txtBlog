******** Python可视化包 ********

seaborn，matplotlib，pychart包都可以。
还有其他包库: ggplot, Bokeh.js

https://www.jianshu.com/nb/30715100
http://liyangbit.com/tutorials/#4-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0

Bokeh: http://liyangbit.com/pythonvisualization/Bokeh-Data-Visualization/

Plotly: http://liyangbit.com/pythonvisualization/Plotly-Express-introduction-cn/




========================================
matplotlib 可视化简介
----------------------------------------

1.使用Matplotlib，它是用Python写的类似Matlab的库，能实现Matlab的功能，而且画图的质量很高，可用于做论文发表。
(1) 教程
源代码：https://github.com/matplotlib/matplotlib
官网：https://matplotlib.org/

图片库：https://matplotlib.org/gallery/index.html
教程: https://matplotlib.org/tutorials/index.html#introductory

视频教程 https://www.bilibili.com/video/BV1Jx411L7LU?p=3
艺术家教程: https://www.jianshu.com/p/aeb1cdf269ea



(2).一般流程
定义分析目标，数据采集及预处理，数据分析挖掘，数据可视化。

(3)四个可视化目标：
分布：柱状图、散点图、概率密度曲线图
相关：散点图with相关系数、拟合曲线
构成：柱状图with不同颜色、饼图
比较：柱状图、分面





2.数据分析案例
(1)电影放映时间和入座率的时间序列模型；
(2)导航软件；
  全球飞机航线图；
(3)超市物品摆放；
  啤酒尿布案例。
  人口年龄的性别分布；
(4) 常见的可视化形式和工具
柱状图、折线图: 比较高低
分布散点图: 看趋势

(5) 常用的工具
分析工具: pandas, SciPy, numpy, sklearn;
绘图工具: matplotlib, Pychart, reportlab;
平台工具: Jupyter notebook, PyCharm;

Matplotlib 是Python的绘图库。
可以和 NumPy 一起使用，提供了一种有效的Matlab开源替代方案。
也可以和图形工具包一起使用，如PyQt和wxPython。




3. 安装
(1)安装 anaconda: Python环境和包管理工具，能切换Python版本。类似Java的Maven。
(2)安装 Jupyter Notebook: 基于网页的交互计算应用程序。可被用于全过程计算：开发、文档编写、运行代码和展示结果。
(3) 安装 matplotlib包。是Python的2D会图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版级别的图形。


我是使用的 pip安装的包。
Matplotlib需要配合numpy,scipy才能使用，使用pip安装。
$ pip install --user matplotlib




4. Hello world 绘图 
(1)黑窗口输入 jupyter notebook ，打开网页，新建py3文件；
(2)输入画图代码
import matplotlib.pyplot as plt
print('==load plt==', plt)

x=[1,2]
y=[3,4]
plt.bar(x,y)
plt.show() ## 画基本柱状图


(3) 画线条，点组成线
import matplotlib.pyplot as plt

import numpy as np;
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点，效果看，取5个点也一样
y=2*x+1;

plt.plot(x,y)
plt.show()


## 二次曲线
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点
y=x**2-0.2*x+1;

#
plt.plot(x,y)
plt.show()




5. 基本配置：如果不配置，可能中文不正常显示。
官网搜索 rcParams 参数，可见到详细参数意义。
常用设置：
(1)输出中文 
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文

x=[1,2]
y=[3,14]
plt.title("柱状图")
plt.bar(x,y)
plt.show()



(2) 正常输入坐标轴上的负数
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文
mpl.rcParams['axes.unicode_minus']=False #正常输入坐标轴上的负数

x=[1,2]
y=[-3,14]
plt.title("柱状图")
plt.bar(x,y)
plt.show()

(3) 修改线条宽度和类型
import matplotlib.pyplot as plt
%matplotlib inline
#
import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文
mpl.rcParams['axes.unicode_minus']=False #正常输入坐标轴上的负数
#
mpl.rcParams['lines.linewidth']=10 #修改线条宽度
mpl.rcParams['lines.linestyle']='--' #线条类型改为虚线

x=[1,2,3]
y=[-3,14,-9]
plt.title("折线图")
plt.plot(x,y)
plt.show()






6.快速入门教程
(1)Figure和Subplot
	figure相当于一个大绘图窗口; 调用一次plt.figure(num=1, )

(2)颜色、标记和线型
	color="red"
	linestyle="--" #虚线
	

(3)刻度、标签和图例
	设置标题、轴标签、刻度以及刻度标签
		plt.title("hist plot") #标题
		
	添加图例（legend）、注解以及在Subplot上绘图
		plt.text()

(4)将图表保存到文件
plt.savefig('filepath.png')
plt.savefig('filepath.png', dpi=400,bbox_inches='tight')

Figure.savefig参数
	fname：路径，包含设置文件格式（如.pdf等）
	dpi：图像分辨率，默认100
	facecolor、edgecolor：图像背景色，默认为’w’（白色）
	format：显示设置文件格式
	bbox_inches：图像需要保存的部分。‘tight’，将尝试剪除图像周围的空白部分

####






========================================
|-- 颜色(color, colormap/cmap)、标记、线型
----------------------------------------
1.简写例子
import matplotlib.pyplot as plt
import numpy as np

X=np.random.randn(30).cumsum()

plt.figure()
plt.plot(X, color='k')

plt.figure()
plt.plot(X, color='k', linestyle='dashed') #设置线型（linestyle）

plt.figure()
plt.plot(X, color='k', linestyle='dashed',marker='o') #设置标记(marker)



(1)
ax.plot(x, y, 'r–')
等价于 ax.plot(x, y, linestyle='–', color='r')

(2)
axes[0].plot(np.random.randint(0, 100, 50), 'ro--')
# 等价
axes[1].plot(np.random.randint(0, 100, 50), color='r', linestyle='dashed', marker='o')







2. 简写设置
(1)颜色（color 简写为 c）：
蓝色： 'b' (blue)
绿色： 'g' (green)
红色： 'r' (red)
蓝绿色(墨绿色)： 'c' (cyan) 青色
红紫色(洋红)： 'm' (magenta) 品红
黄色： 'y' (yellow)
黑色： 'k' (black)
白色： 'w' (white)


https://stackoverflow.com/questions/22408237/named-colors-in-matplotlib
1)## 所有可用的颜色的十六进制 
import matplotlib
i=0
for name, hex in matplotlib.colors.cnames.items():
    i+=1
    print(i, name, hex)
# 1 aliceblue #F0F8FF
# 2 antiquewhite #FAEBD7
# 3 aqua #00FFFF
#

plt支持的全部颜色(另一种显示方式): https://matplotlib.org/examples/color/named_colors.html



2)装了seaborn扩展的话，在字典seaborn.xkcd_rgb中包含所有的xkcd crowdsourced color names。如下：
plt.plot([1,2], lw=4, c=seaborn.xkcd_rgb['baby poop green'])


fig, ax = plt.subplots(figsize=(9.2, 5))
ax.set_xlim(0, 10)

i=-1
for cName,cHex in seaborn.xkcd_rgb.items():
    i+=1
    #print(cName, cHex) #怎么能把所有颜色和其hex值画出来呢？
#



3)把python和seaborn中支持的颜色都画出来，左边颜色块，右边颜色名字和16进制。
代码及效果图: http://www.biomooc.com/Python3/Python3-color.html





(2)点型（标记marker）：
. point
, pixel 像素
o circle 圆形
v 下三角形
^ 上三角形
< 左三角形
> 右三角

方形： 's'
加号： '+' 
叉形： 'x'
棱形： 'D'
细棱形： 'd'
三脚架朝下： '1'（像'丫'）
三脚架朝上： '2'
三脚架朝左： '3'
三脚架朝右： '4'
六角形： 'h'
旋转六角形： 'H'
五角形： 'p'
垂直线： '|'
水平线： '_'




(3)linestyle 简写为 ls
- or solid 实线
-- or dashed 虚线
-. or dashdot 虚点先
: or dotted 点线

'None' draw nothing
' ' or '' 什么也不绘画


ref:
https://blog.csdn.net/qq_40981268/article/details/89150614




========================================
|-- figure 和 一页多图(子图subplot)、图中图
----------------------------------------
1.plt.figure(num=3, figsize=(6,6)) 开始一个图形
其中2个可选参数 
num 图形编号
figsize 图像长宽


import matplotlib.pyplot as plt

import numpy as np;
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点

y1=2*x+1;
y2=x**2+1;

plt.figure() #一个图开始
plt.plot(x,y1)
plt.show()


plt.figure(num=3, figsize=(6,6)) #另一个图开始
plt.plot(x,y2,linewidth=3)
plt.plot(x,y1, color="red",linewidth=1, linestyle='--') #红色线,宽度3，虚线
plt.show()






2. 有多种画子图的方法

(1) subplot(nrow, ncol, num)
subplot前面俩参数指定的是一个画板被分割成的行和列，后面一个参数则指的是当前正在绘制的编号！
行优先开始数。2行2列就是先填充第1行(图1，图2)，再填充第二行(图3，图4)；
直接指定划分方式和位置，接着画图填充该位置。

下图是第一行2个图，第二行一个大图。
x=np.arange(0,2,0.1);
y=np.sin(x*np.pi);

plt.subplot(2,2,1)#2行2列，第一个图
plt.plot(x,y,'b--') #blue 虚线
plt.ylabel('y1')

plt.subplot(2,2,2)#2行2列，第二个图
plt.plot(x,y,'r--') #red 虚线
plt.ylabel('y2')

plt.subplot(2,1,2) #2行1列，第2个
plt.plot(x,y, 'm--')
plt.ylabel('y3')

plt.show()




(2)subplots(nrow,ncol) 缺点: 不那么灵活，无法自由组合跨行跨列。
这个方法更直接。事先先把画板分隔好。

x=np.arange(0,2,0.1)
y=np.sin(x*np.pi)

figure,ax=plt.subplots(2,2) #事先先把画板分隔好
ax[0][0].plot(x,y,'r*')
ax[0,1].plot(x,y,'b--')
ax[1,0].plot(x,4*y,'m--') 
#第四个区域没有，就空着了
#figure


## 然后可以接着指定
ax[1,1].plot(x,4*y,'k--') 
figure





(3) 这个貌似可以任意占位
例子的结构:
1 1 1
2 2 3
4 5 3

X=np.arange(0,1,0.1)
Y=np.sin(X*2*np.pi)

plt.figure()
ax1=plt.subplot2grid( (3,3),(0,0), rowspan=1, colspan=3) #3行3列，从0 0开始，跨1行3列
ax1.plot([0,1], [0,1])
ax1.set_title('Title1')
#
ax2=plt.subplot2grid( (3,3),(1,0), rowspan=1, colspan=2); #从1行0列开始，跨1行2列
ax2.plot([0,1], [1,10], 'r--')
#
ax3=plt.subplot2grid( (3,3),(1,2), rowspan=2, colspan=1); #从1行2列开始，跨2行1列
ax3.plot(X,Y, 'g--')
#
ax4=plt.subplot2grid( (3,3),(2,0)); #从2行0列开始，默认跨1行1列
ax4.plot(X,Y, 'b--')
#
ax5=plt.subplot2grid( (3,3),(2,1)); #从2行0列开始，默认跨1行1列
ax5.plot(X,Y, 'k--') #black


(4) 任意占位， 效果同上
import matplotlib.gridspec as gridspec

plt.figure()
gs=gridspec.GridSpec(3,3) #3行3列

ax1=plt.subplot(gs[0,:]) #第0行，所有列
ax2=plt.subplot(gs[1,:2]) #第1行，第0,1列
ax3=plt.subplot(gs[1:,2]) #第1行之后(就是1,2行)，第2列
ax4=plt.subplot(gs[2,0]) #第2行，第0列
ax5=plt.subplot(gs[2,1]) #第2行，第1列






3. 图中图

# 大图中嵌入小图: 左上角、右下角各加入一个小图
fig=plt.figure()
X=np.linspace(0,10,10)
Y=np.random.normal(0,1, 10)

# 定位
left,bottom,width,height=0.1,0.1,0.8,0.8 #都是百分比
ax1=fig.add_axes([left,bottom,width,height]) #主图的位置
# 画图
ax1.plot(X,Y, 'r')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('title1')

###
# 定位
left,bottom,width,height=0.15,0.6,0.25,0.25
ax2=fig.add_axes([left,bottom,width,height]) #主图的位置
# 画图
ax2.plot(Y, X, 'b--')
ax2.set_axis_off() #不要坐标轴
ax2.set_title('title2(inside)')

### 换一种加图的写法
left,bottom,width,height=0.6,0.2,0.25,0.25
plt.axes([left,bottom,width,height]) #主图的位置
# 画图
plt.plot(X, Y[::-1], 'g--') #Y逆序一下

plt.xlabel('')
plt.ylabel('y2')
plt.title('title3(inside)')

plt.show()



ref:
https://www.jianshu.com/p/de223a79217a




========================================
|-- 坐标轴与刻度、主次坐标轴
----------------------------------------

1.设置轴显示区域、轴标签、刻度以及刻度标签、隐藏top-right边界、移动坐标轴位置
(1)
轴标签
	plt.xlabel('x label')
	plt.ylabel('y label')

自定义x轴刻度
	plt.xticks(new_ticks) 
	#自定义y轴刻度显示内容
	plt.yticks([原始刻度值], [要显示的刻度值])

坐标轴显示区域
	plt.xlim(-1,3) 
#



##### 完整代码
plt.figure()
plt.plot(x,y2)
plt.plot(x,y1, 'r--', linewidth=1)

plt.xlim(-1,3) #坐标轴显示区域
plt.ylim(-2,8)

plt.xlabel('I am x label') #坐标轴标签
plt.ylabel('This is y label')

plt.title("probability of distance") #图片标题

new_ticks=np.linspace(-1,3,5) 
print(new_ticks)
plt.xticks(new_ticks) #自定义x轴刻度
#自定义y轴刻度显示内容
plt.yticks(
    [0,3,6,9], #可以自定义刻度
    [ 'bad', 'normal', 'good', 'very good']
)

plt.show()






(2)显示成更好看的字体，把字符前后加$符，同时空格要转义;
plt.yticks(
    [0,3,6,9],
    [ r'$bad$', r'$normal\ \alpha$', r'$good$', r'$very\ good$']
)




(3) 获取当前坐标轴，并移动其位置
# gca=get current axis
ax=plt.gca();

# 获得图片的4个边框
ax.spines['right'].set_color('none') #右边的框消失掉了
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴
ax.spines['bottom'].set_position(('data', -1))
ax.spines['left'].set_position(('data', 0))




### 完整实例
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2)
plt.plot(x,y1, 'r--', linewidth=1)

plt.xlim(-1,3) #坐标轴显示区域
plt.ylim(-0.5,5)

# gca=get current axis
ax=plt.gca();
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴; 除了'data'，还可以填'outward'(todo?),'axes'(按百分比)
ax.spines['bottom'].set_position(('data', 0)) #x轴移动到y=0位置
ax.spines['left'].set_position(('data', 0)) #y轴移动到x=0位置

plt.show()






2. 设置tick的能见度 
#如果图盖住了坐标轴刻度，想让刻度可见
#1.plt.plot()中设置zorder=1；2.后面for循环汇总设置label.set_zorder(2)
#zorder相当于重叠程度，上面的遮挡着下面的;

x=np.linspace(-3,3,50)
y1=0.5*x
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up',zorder=1) #标上zorder=1
plt.plot(x,y1, 'r--', linewidth=10, label='down',zorder=1)

plt.xlim(-1,3)
plt.ylim(-1,5)


#移动坐标轴
ax=plt.gca();
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴; 除了'data'，还可以填'outward'(todo?),'axes'(按百分比)
ax.spines['bottom'].set_position(('data', 0)) #x轴移动到y=0位置
ax.spines['left'].set_position(('data', 0)) #y轴移动到x=0位置


#调整坐标轴标签的不透明度
for label in ax.get_xticklabels()+ax.get_yticklabels():
    label.set_fontsize(12)
    #alpha=1不透明，0全透明
    label.set_bbox(dict(facecolor="white", edgecolor="None", alpha=0.7))
    label.set_zorder(2)

plt.show()







3. 主次坐标轴 
x=np.arange(0,10,0.1)
y1=0.05*x**2
y2=-y1;

fig,ax1=plt.subplots()
ax2=ax1.twinx() #相当于复制了一个x轴？Create a twin Axes sharing the xaxis.

ax1.plot(x, y1, 'g-')
ax2.plot(x, y2, 'b--')

ax1.set_xlabel('X_data')
ax1.set_ylabel("Y1", color='g')

ax2.set_ylabel('Y2', color='b')


plt.show()






========================================
|-- 标签和图例、标注/注解、标题
----------------------------------------
2.添加图例（legend）、注解以及在Subplot上绘图
(1) 默认图例
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up') #标上label
plt.plot(x,y1, 'r--', linewidth=1, label='down')

plt.legend() #默认的参数

plt.show()


(2)调整图例的位置
plt.legend(loc="lower right") #位置参数loc默认为'best'，自动找一个图少的角落



2) bbox_to_anchor控制图例的位置
plt.legend(ncol=2,
           bbox_to_anchor=(1.04,0.5), #图形百分比(0,0)左下角， (1,1)右上方
           loc='center left', #边界盒子（bounding box）里面的方位
           markerscale =4, #图例点的放大倍数
           fontsize='small' ) 
#
#
legend 是放置在我们的坐标边界里面的一个东西，可以在plt.legend 里面使用 loc 这个参数。
e.g. loc="upper right", 就放置在我们的边界盒子（bounding box）里面的右上方 ，默认的设置就是坐标轴边界的设置 （0,0）（1,1）

注解边界的默认设置就是（x0,y0,width,height）=(0,0,1,1). 
为了把这个legend 放置在我们的坐标轴边界的外部，我们需要借助一个特殊的元组（x0,y0）,比如说放置在坐标轴边界的左下部。

plt.legend(loc=(1.04,0))

还有一些更加通用的方法来手动的设置legend box 放置的地方，就是bbox_to_anchor参数，在这里我们可以只提供bbox 的一个参数来作为限制就是提供 （x0,y0）,它所处的方向就有loc 这个参数来提供

plt.legend(bbox_to_anchor=(1.04,1), loc="upper left")


l1 = plt.legend(bbox_to_anchor=(1.04,1), borderaxespad=0) #右侧，上
l2 = plt.legend(bbox_to_anchor=(1.04,0), loc="lower left", borderaxespad=0) #右侧，下
l3 = plt.legend(bbox_to_anchor=(1.04,0.5), loc="center left", borderaxespad=0) #右侧，中

l4 = plt.legend(bbox_to_anchor=(0,1.02,1,0.2), loc="lower left",
                mode="expand", borderaxespad=0, ncol=3) #上部，左
l5 = plt.legend(bbox_to_anchor=(1,0), loc="lower right",  #右测，底
                bbox_transform=fig.transFigure, ncol=3)
l6 = plt.legend(bbox_to_anchor=(0.4,0.8), loc="upper right") #图片中，竖中线，顶




ref: 
Matplotlib 放置legend(bbox_to_anchor) https://blog.csdn.net/chichoxian/article/details/101058046





(3) 重命名标签
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
l1,=plt.plot(x,y2, label='up') #标上label; 返回值后加逗号,有返回值加label就无效了
l2,=plt.plot(x,y1, 'r--', linewidth=1)

plt.legend(handles=[l1,l2], labels=['up22', 'down33'], loc="lower right") #位置参数loc默认为'best'，自动找一个图少的角落

plt.show()








3. 标注/注解
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up') #标上label
plt.plot(x,y1, 'r--', linewidth=1, label='down')

plt.xlim(-1,3)
plt.ylim(-1,5)


####### 添加注释
x0=1
y0=2*x0+1
plt.plot([x0,x0], [0,y0], 'k--', linewidth=2.5) #竖虚线
plt.scatter(x0,y0, s=150, color='r') #size=150，红色

##method1
plt.annotate(r'$2x+1=%s$' % y0, 
             xy=(x0,y0), #打印位置
             xycoords='data', #位置基准
             
             xytext=(+30,-30),
             textcoords='offset points',
             
             fontsize=16,
             arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=0.2")
            )
##method2
plt.text(-0.8, 4, r'$This\ is\ some\ text\ \alpha\ \sigma$', 
         fontdict={'fontsize':16, 'color':'blue'})

plt.show()









========================================
|-- matplotlib使用plt.savefig()保存图片文件
----------------------------------------
1.实例1：曲线图
#import numpy as np
import matplotlib.pyplot as plt
#import matplotlib

# 定义数据
x = np.arange(0, 10, 0.1)
y = 0.05 * x ** 2

#绘制图像
plt.plot(x, y)

# 设置坐标轴
plt.xlabel('x data')
plt.ylabel('y data')

# 默认保存为png格式
plt.savefig('/home/wangjl/data/apa/190610APA/pdf/test.png')
#plt.show()




2. 实例二： 获取当前 figure 的引用，然后调用 figure 对象的 savefig() 方法。
import numpy as np
import matplotlib.pyplot as plt
 
x = np.linspace(1, 100, 100)
y1 = np.random.randint(20, 60, size=100)
y2 = np.random.randint(30, 70, size=100)
y3 = np.random.randint(50, 90, size=100)
 
fig = plt.figure(num="111", figsize=(6, 4), facecolor="pink", edgecolor="green")
plt.plot(x, y1, c="red", label="y1_low")
plt.plot(x, y2, c="blue", label="y2_middle")
plt.plot(x, y3, c="yellow", label="y3_high")
plt.legend(loc="best")
# plt.show()
re = fig.savefig("a")




3.命令行运行时报错：RuntimeError: Invalid DISPLAY variable
https://blog.csdn.net/gdkyxy2013/article/details/79585922

原因：matplotlib的默认backend是TkAgg，而FltAgg、GTK、GTKCairo、TkAgg、Wx和WxAgg这几个backend都要求有GUI图形界面，所以在ssh操作的时候会报错。

解决办法：在导入matplotlib的时候指定不需要GUI的backend（Agg、Cairo、PS、PDF和SVG）。例如：
import matplotlib.pyplot as plt
plt.switch_backend('agg')




注意：
1. 在 plt.show() 之前调用 plt.savefig()，否则可能是空白图片；
　　import matplotlib.pyplot as plt
　　""" 一些画图代码 """
　　plt.savefig("filename.png")
　　plt.show()
#
2. 画图的时候获取当前图像（这一点非常类似于 Matlab 的句柄的概念）：
 　 # gcf: Get Current Figure
　　fig = plt.gcf()
　　plt.show()
　　fig1.savefig('test.png', dpi=100)

3.文件格式
savefig(fname, dpi=None, facecolor='w', edgecolor='w',
        orientation='portrait', papertype=None, format=None,
        transparent=False, bbox_inches=None, pad_inches=0.1,
        frameon=None)

参数：
fname : str 或者 file 对象，如果是 str 格式，文件的输出格式是根据 str 中的后缀决定的。如果字符串中没有后缀指定文件格式，则由 rc 参数 savefig.format 决定。
format ： str，文件格式，一般支持 png、pdf、ps、eps 和 svg。





https://blog.csdn.net/tz_zs/article/details/81365576 
https://matplotlib.org/api/_as_gen/matplotlib.pyplot.savefig.html






========================================
|-- matplotlib-venn包绘制韦恩图 
----------------------------------------


使用
matplotlib-venn 包提供了四个主要的函数：venn2、venn2-circles、venn3 和 venn3-circles。
venn2和venn2_circles接受一个3元素（Ab，aB，AB）构成的 tuple 作为各个子集所包含元素的个数（不是具体的元素）：

Ab：包含A，但不包含B，即A中非B的部分，A∩¬BA∩¬B
aB：包含B，但不包含A，即B中非A，B∩¬AB∩¬A
AB：既包含A，又包含B，即A与B的交集，A∩B




核心代码：
from matplotlib_venn import venn2, venn2_circles
venn2(subsets=(3, 2, 1), set_labels=('A', 'B'))
venn2([set(['A', 'B', 'C', 'D']), set(['D', 'E', 'F'])])


实例: 
1.需要安装包
pip install --user matplotlib_venn

2.求两个集合的交集、差集的大小
n1=0
n2=0
for p in pasAll:
    if p in pasDB3:
        n1+=1
    else:
        n2+=1
print(n1, n2) #5576 128391

#
c1=0
c2=0
for p in pasDB3:
    if p in pasAll:
        c1+=1
    else:
        c2+=1
print(c1, c2) #5576 284593

3.绘图
#有标题
from matplotlib import pyplot as plt
from matplotlib_venn import venn2, venn2_circles
plt.figure(figsize=(6,6))
venn2(subsets=(n2,c2, c1), set_labels=('pA-Seq', 'PolyA_DB3'))
plt.title("(cid=all)M_gt5_No4A)")


#没有标题
from matplotlib_venn import venn2, venn2_circles
venn2(subsets=(n2,c2, c1), set_labels=('pA-Seq', 'PolyA_DB3'))








refer:
https://www.jianshu.com/p/25b0dc441247
https://pypi.org/project/matplotlib-venn/




========================================
|-- plt.pie 饼图
----------------------------------------
1. 饼图 plt.pie(data)
饼图常用于显示一个数据系列中各项的大小与各项总和的比例。

#饼图
import matplotlib.pyplot as plt

labels=['Clothes', 'Food', 'Housing', 'Travel', 'Others']
data=[0.1, 1.45, 0.3, 0.1, 0.05] #可以不是百分比，直接放原始数据，自动计算百分比

# plt.pie(data, labels=labels) #没有显示百分比
plt.pie(data, labels=labels, autopct="%1.1f%%") #加2个百分号就能正常显示百分号了
plt.show()




2.例2
import matplotlib as mpl
import matplotlib.pyplot as plt

# 生成数据
labels = ['M', '1S', '2S', 'Other']
share = [0.49, 0.24, 0.2, 1-0.49-0.24-0.2] #41%, 24%, 20%

#颜色
colors=['lightgreen','gold','lightskyblue','lightcoral',"lightred"]
# 设置分裂属性
explode = [0, 0, 0, 0]

# 分裂饼图
plt.pie(share, explode = explode,
        labels = labels, autopct = '%3.1f%%',
        startangle = 0, #shadow = True,
        colors =colors )
plt.title('Mapping End by Cigar of c12_ROW03') # 标题
plt.axis('equal') #正圆
plt.show()





========================================
|-- matplotlib 直方图hist、条形图bar、折线图plot
----------------------------------------
1. 直方图 需要2个参数(原始数据，区间)
每个柱子的高度等于该区间内数据的个数。

import matplotlib.pyplot as plt
#%matplotlib inline

height=[168,155,182,170,173,161,155,173,181,166,172,170]
bins=range(150, 191, 5) #步长为5

plt.title("hist plot")
plt.hist(height, bins=bins)
plt.show()




2. 条形图 plt.bar(X,Y) 第一个参数表示x轴位置，第二个参数表示y轴高度。
使用宽度相同的条形的高度或长度来表示数据的数值。
更直观的显示图形关系。

import matplotlib.pyplot as plt

classes=['Class 1', 'Class 2', 'Class 3']
scores=[70,80,90]

plt.title("bar plot")
plt.bar(classes, scores)
plt.show()


(2) 两个条形图，一个朝上一个朝下
#
n=12
X=np.arange(n)
Y1=(1-X/float(n))*np.random.uniform(0.5,1,n) #uniform 均匀分布
Y2=(1-X/float(n))*np.random.uniform(0.5,1,n) #uniform 均匀分布

plt.xlim(-0.5, n)
plt.ylim(-1.25, 1.25)

plt.xticks(()) #不要坐标轴刻度
plt.yticks(())

plt.bar(X, +Y1, facecolor='#9999ff',edgecolor="white" )
plt.bar(X, -Y2, facecolor='#ff9999',edgecolor="white" )

#添加文字
for x,y in zip(X,Y1):
    # ha: horizontal alignment;
    # va: vertical alignment;
    plt.text(x,y, '%.2f' % y, ha='center', va="bottom")

for x,y in zip(X,-Y2): #注意负号
    # ha: horizontal alignment;
    # va: vertical alignment;
    #'%.2f'保留2位有效数字
    plt.text(x,y-0.05, '%.2f' % y, ha='center', va="top")

plt.show()




(3) 画一个条形图，水平方向的，归一化到100%，并在图上标上每部分的百分比
import numpy as np
import matplotlib.pyplot as plt

#准备数据
category_names = ['Strongly disagree', 'Disagree',
                  'Neither agree nor disagree', 'Agree', 'Strongly agree']
results = {
    'Question 1': [10, 15, 17, 32, 26],
    'Question 2': [26, 22, 29, 10, 13],
    'Question 3': [35, 37, 7, 2, 19],
    'Question 4': [32, 11, 9, 15, 33],
    'Question 5': [21, 29, 5, 5, 40],
    'Question 6': [8, 19, 5, 30, 38]
}

#归一化到100%
for key in results:
    #print(key,  results[key])
    for i in range(len(results[key])):
        results[key][i]=100*results[key][i]/ sum(results[key])
results

def survey(results, category_names):
    """
    Parameters
    ----------
    results : dict
        A mapping from question labels to a list of answers per category.
        It is assumed all lists contain the same number of entries and that
        it matches the length of *category_names*.
    category_names : list of str
        The category labels.
    """
    labels = list(results.keys()) #标签['Question 1', 'Question 2', 'Question 3', 'Question 4', 'Question 5', 'Question 6']
    data = np.array(list(results.values())) #数据；np格式，则可以向量加减法
    data_cum = data.cumsum(axis=1) #数据累加，按行
    category_colors = plt.get_cmap('RdYlGn')( #获取颜色
        np.linspace(0.15, 0.85, data.shape[1])) #data有几列，产生几个颜色
    
    #创建图片
    fig, ax = plt.subplots(figsize=(9.2, 5))
    ax.invert_yaxis() #倒置y轴
    ax.xaxis.set_visible(False) #隐藏x轴
    ax.set_xlim(0, np.sum(data, axis=1).max()) #x轴范围0，到 np.sum(data, axis=1).max() np按照行求和，行和最大的

    # zip函数，从数组对中返回一对值；
    # enumerate(iterable) 返回一系列(0, seq[0]), (1, seq[1]), (2, seq[2]), ...
    for i, (colname, color) in enumerate(zip(category_names, category_colors)):
        widths = data[:, i] # 一次画一列
        starts = data_cum[:, i] - widths #宽度就是当前位置的累加和 - 当前宽度
        ax.barh(labels, widths, left=starts, height=0.5, #水平bar图，参数1是y位置，参数2是x长度，left是左边起点位置，height高度，
                label=colname, color=color)  #label是列名，color是颜色
        
        #中点坐标，放文字
        xcenters = starts + widths / 2 
        
        # 字体颜色，根据背景颜色调整
        r, g, b, _ = color
        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'
        #添加文字
        for y, (x, c) in enumerate(zip(xcenters, widths)):
            ax.text(x, y, str(int(c)), ha='center', va='center', #文字，x,y坐标, 宽度是写上去的文字，水平对齐，垂直对齐
                    color=text_color) #颜色是根据背景定的
    # 图例
    ax.legend(ncol=len(category_names), 
              bbox_to_anchor=(0,1), #百分比(0,0)左下角， (1,1)
              loc='lower left', #边界盒子（bounding box）里面的左上方
              fontsize='small')
    return fig, ax

survey(results, category_names)
plt.show()







3. 折线图 plt.plot(X,Y)
体现两个数据的关系，是否相关？是否正相关？能大致拟合为什么函数？

import matplotlib.pyplot as plt

classes=['Class 1', 'Class 2', 'Class 3']
scores=[70,80,90]

year=range(2017,2021) #区间是[)的，所以是2017-2020年的共4年
height=[157,170,176,180]

plt.plot(year, height)
plt.show()






========================================
|-- matplotlib 散点图和箱线图
----------------------------------------
1. 散点图 方便观察二维数据之间的关系

#######
# 散点图
import matplotlib.pyplot as plt

(1) 例1
data=[[64,181], [50,120], [70,150], [55,100]]

weight=[item[0] for item in data]
height=[item[1] for item in data]
print(weight,height)

plt.scatter(weight, height)

# 添加坐标轴标签
plt.xlabel('Weight(kg)')
plt.ylabel('Height(cm)')

plt.title('Scatter')

#在固定的位置插入文字
plt.text(60,140, 'low | high')



(2)例2 正态分布的散点图
n=1024
X=np.random.normal(0,1,n) #正态分布随机数
Y=np.random.normal(0,1,n)

T=np.arctan2(Y,X) #好看的颜色

plt.scatter(X,Y,s=75,c=T, alpha=0.5) #散点图

plt.xlim(-1.5, 1.5) #坐标轴范围
plt.ylim(-1.5, 1.5)

plt.xticks(()) #隐藏坐标轴刻度
plt.yticks(())

plt.show()





2.箱线图 又叫盒子图 plt.boxplot(X)









refer:
https://matplotlib.org/contents.html
https://github.com/matplotlib/matplotlib

http://lib.csdn.net/article/python/43397
https://blog.csdn.net/qq_34337272/article/details/79555544





========================================
|-- 等高线图、3D图、动画
----------------------------------------
1.实例：绘制等高线图
# -*- coding: utf-8 -*-
"""
绘制等高线图
"""
import matplotlib.pyplot as plt
import numpy as np

# 定义等高线高度函数
def f(x, y):
    return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(- x ** 2 - y ** 2)

# 数据数目
n = 256
# 定义x, y
x = np.linspace(-3, 3, n)
y = np.linspace(-3, 3, n)

# 生成网格数据
X, Y = np.meshgrid(x, y)

# 填充等高线的颜色, 8是等高线分为几部分
plt.contourf(X, Y, f(X, Y), 8, alpha = 0.75, cmap = plt.cm.hot)
# 绘制等高线
C = plt.contour(X, Y, f(X, Y), 8, colors = 'black', linewidth = 0.5)
# 绘制等高线数据
plt.clabel(C, inline = True, fontsize = 10)

# 去除坐标轴
plt.xticks(())
plt.yticks(())
plt.show()




2. 绘制3D图

from mpl_toolkits.mplot3d import Axes3D

fig=plt.figure()
ax=Axes3D(fig)

X=np.arange(-4, 4, 0.25)
Y=np.arange(-4, 4, 0.25)
X,Y=np.meshgrid(X,Y)
R=np.sqrt(X**2 + Y**2)

Z=np.sin(R)

# 3D图
ax.plot_surface(X,Y,Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow'))

#rstride: row stride 步长;
#cstride: column stride 步长;

# 等高线图
ax.contourf(X,Y,Z, zdir='z', offset=-2, cmap='rainbow') #等高线图放到z=-2位置
ax.set_zlim(-2,2)

ax.contourf(X,Y,Z, zdir='x', offset=-5, cmap='rainbow') #再向x压下去一个等高线图

plt.show()









3.动画 //todo

jupyter和pycharm中没动起来，vscode中可以动。


from matplotlib import animation

fig, ax=plt.subplots()

x=np.arange(0,2*np.pi, 0.01)
line,=ax.plot(x,np.sin(x))

def animate(i):
    line.set_ydata(np.sin(x+i/100))
    return line;

def init():
    line.set_ydata(np.sin(x))
    return line;

ani=animation.FuncAnimation(fig=fig, #图像
                            func=animate, #更新时使用的函数
                            frames=100,  #帧频率
                            init_func=init, #第一帧
                            interval=20, #更新时间
                            blit=False #更新全图还是只更新变化部分
                           )

plt.show()






========================================
|-- 矩阵可视化 / 热图
----------------------------------------
1.热图 Image
cmap 是啥？

最简单的一句话 plt.imshow(weights_1_2)



实例：绘制heatmap
# -*- coding: utf-8 -*-
"""
绘制Image 
"""
import matplotlib.pyplot as plt
import numpy as np

# 定义图像数据
a = np.linspace(0, 1, 25).reshape(5, 5)
a[0,3]=0.9
print(a)

# 显示图像数据
plt.imshow(a, interpolation = 'nearest', cmap = 'bone', origin = 'upper')
# interpolation 插值方式

# 添加颜色条
# plt.colorbar() 
plt.colorbar(shrink=0.8) #压缩到原来高度的80%，默认是100%

# 去掉坐标轴
plt.xticks(())
plt.yticks(())
plt.show()







2. 缺点： 无法控制图片大小
这是一个绘制矩阵的函数。原文：“plot a matrix or an array as an image"

用matshow绘制矩阵的例子：

import matplotlib.pyplot as plt
import numpy as np
 
 
def samplemat(dims):
    """Make a matrix with all zeros and increasing elements on the diagonal"""
    aa = np.zeros(dims)
    for i in range(min(dims)):
        aa[i, i] = i
    return aa
 
 
# Display matrix
plt.matshow(samplemat((15, 15)))
 






========================================
|-- 绘制贝塞尔曲线
----------------------------------------
1.#二次贝塞尔曲线
np.random.seed(1)
x=np.random.random(3)*10+10
y=np.random.random(3)*10+20


def bezie2(p0, p1, p2):
    x=[]
    y=[]
    def b2(t, c0,c1,c2):
        return ((1-t)**2)*c0 + 2*t*(1-t)*c1 + (t**2)*c2
    for i in range(1000):
        t=i/999
        x.append( b2(t, p0[0], p1[0], p2[0]) )
        y.append( b2(t, p0[1], p1[1], p2[1]) )
    return (x,y)
#
rs=bezie2( [x[0], y[0]], [x[1], y[1]]  , [x[2], y[2]])

#
plt.scatter(rs[0], rs[1], color='red', s=1)
plt.scatter(x,y, color='black')
print(x,y)



2.#三次贝塞尔曲线
#np.random.seed(1)
x=np.random.random(4)*10+10
y=np.random.random(4)*10+20

def bezie3(p0, p1, p2, p3):
    x=[]
    y=[]
    def b3(t, c0,c1,c2,c3):
        return (1-t)**3*c0 + t*(1-t)**2*3*c1 + t**2*(1-t)*3*c2 + t**3*c3
    for i in range(1000):
        t=i/999
        x.append( b3(t, p0[0], p1[0], p2[0], p3[0]) )
        y.append( b3(t, p0[1], p1[1], p2[1], p3[1]) )
    return (x,y)
#
rs=bezie3( [x[0], y[0]], [x[1], y[1]]  , [x[2], y[2]] , [x[3], y[3]])

#
plt.scatter(rs[0], rs[1], color='red', s=1)
plt.scatter(x,y, color='#cccccc')
print(x,y)






ref:
https://www.jb51.net/article/177375.htm




========================================
Seaborn 包: 对matplotlib的封装
----------------------------------------
1. 简介

seaborn的数据来自github: https://github.com/mwaskom/seaborn-data

(1) 示例和教程(中文)
seaborn 的图表很漂亮: https://blog.csdn.net/weixin_44766179/article/details/89133526
https://blog.csdn.net/weixin_44766179/article/details/89095211
https://blog.csdn.net/Julialove102123/article/details/89063166
https://www.cnblogs.com/gczr/p/6767175.html


distplot/kdeplot/pairplot/strip-swarmplot/boxplot/jointplot/violinplot/pointplot/bar/
https://blog.csdn.net/weixin_41988628/article/details/83038332



(2) 官方教程(英文)
官网 http://seaborn.pydata.org/introduction.html
http://seaborn.pydata.org/tutorial/color_palettes.html

官方API：http://seaborn.pydata.org/index.html
案例库：http://seaborn.pydata.org/examples/

https://www.datacamp.com/community/tutorials/seaborn-python-tutorial


(3) 视频 
https://www.bilibili.com/video/BV1CE411P79j?p=8




2. 安装
(1)pip install seaborn;


(2)使用seaborn加载数据时，
df_iris=sns.load_dataset('iris')
df_iris.head()
总是报错:
ConnectionRefusedError: [Errno 111] Connection refused
URLError: <urlopen error [Errno 111] Connection refused>


==>方案1:https://blog.csdn.net/m0_37842667/article/details/83243722
添加:
import ssl
ssl._create_default_https_context = ssl._create_unverified_context
还是报错;

==>方案2: https://blog.csdn.net/qq_41477675/article/details/103543268
添加 iris=sns.load_dataset("iris",engine='python')
还是报错;

==>方案3:https://www.pythonheidong.com/blog/article/184505/
在主目录创建SSL证书
$ mkdir certs
$ cd certs
$ sudo openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem

告诉Jupyter在哪里找到它。
查看jupyter_notebook_config.py是否有一个（或使用生成一个jupyter notebook --generate-config）。
确保您具有以下行：
c.NotebookApp.certfile = u'/home/ubuntu/certs/mycert.pem' #location of your certificate file
还是不行


==> 解决方案:
把数据从github克隆到本地web文件夹中:
git clone https://github.com/mwaskom/seaborn-data.git
然后可以直接访问:
tips = pd.read_csv("http://y.biomooc.com/wangjl/docs/seaborn-data/tips.csv")





其他功能貌似正常。






3.开始绘图

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt  
import seaborn as sns
print('==end==')









========================================
|-- 整体布局风格设置
----------------------------------------

1. 一共5种预定义风格
help(sns.set) 
#context must be in paper, notebook, talk, poster
#style must be one of white, dark, whitegrid, darkgrid, ticks 

help(sns.set_style) 


(1)实例 
def sinplot(flip=1):
    x=np.linspace(0,14, 100)
    for i in range(1,7):
        y=np.sin(x+i*0.5) *(7-i)*flip
        plt.plot(x, y)
sinplot()

sns.set(style='whitegrid')
sinplot()


(2) 去掉上、右边框
sns.set_style("white")
sinplot() 
sns.despine() # 默认无参数状态，就是删除上方和右方的边框

(3) 加大图到坐标轴的距离
sinplot()
sns.despine(offset=20)


(4)# 一页多图，每个风格不同，使用with结构
with sns.axes_style('darkgrid'):
    plt.subplot(211)
    sinplot()
with sns.axes_style('whitegrid'):
    plt.subplot(212)
    sinplot(-1)
#





2. 布局设置。4种上下文环境: paper, notebook, talk, poster

(1)
sns.set_style("whitegrid")

sns.set_context('paper')
plt.figure(figsize=(8,6))
sinplot()


(2)设置字体大小、线宽
sns.set_context('paper', font_scale=5, #字体放大
                rc={"lines.linewidth":2}) #线条粗细
sns.set_style("whitegrid")

plt.figure(figsize=(8,6))
sinplot()






========================================
|-- 颜色：调色板、xkcd颜色
----------------------------------------
离散型
连续型


1. 调色板的使用


目测颜色的方法：
plt.hlines(y=3,xmin=0,xmax=2,color="#FF0000", linewidth=10)

sns.palplot(np.array([ [1,0,0], [0,1,0],  [0,0,1]  ]) )



(1) 10个默认颜色循环主题
current_palette=sns.color_palette()
sns.palplot(current_palette)
current_palette



(2)圆形画板：对色环平均分成n份
sns.palplot( sns.color_palette('hls', 8) )

1) 上条语句中的hls是颜色命名空间，如何知道还有哪些命名空间呢？
尝试输错一次，看看报错即可：
sns.palplot( sns.color_palette('hls00', 8) )
ValueError: Colormap hls00 is not recognized. Possible values are: Accent, Accent_r, Blues, Blues_r, BrBG, BrBG_r, BuGn, BuGn_r, BuPu, BuPu_r, CMRmap, CMRmap_r, Dark2, Dark2_r, GnBu, GnBu_r, Greens, Greens_r, Greys, Greys_r, OrRd, OrRd_r, Oranges, Oranges_r, PRGn, PRGn_r, Paired, Paired_r, Pastel1, Pastel1_r, Pastel2, Pastel2_r, PiYG, PiYG_r, PuBu, PuBuGn, PuBuGn_r, PuBu_r, PuOr, PuOr_r, PuRd, PuRd_r, Purples, Purples_r, RdBu, RdBu_r, RdGy, RdGy_r, RdPu, RdPu_r, RdYlBu, RdYlBu_r, RdYlGn, RdYlGn_r, Reds, Reds_r, Set1, Set1_r, Set2, Set2_r, Set3, Set3_r, Spectral, Spectral_r, Wistia, Wistia_r, YlGn, YlGnBu, YlGnBu_r, YlGn_r, YlOrBr, YlOrBr_r, YlOrRd, YlOrRd_r, afmhot, afmhot_r, autumn, autumn_r, binary, binary_r, bone, bone_r, brg, brg_r, bwr, bwr_r, cividis, cividis_r, cool, cool_r, coolwarm, coolwarm_r, copper, copper_r, cubehelix, cubehelix_r, flag, flag_r, gist_earth, gist_earth_r, gist_gray, gist_gray_r, gist_heat, gist_heat_r, gist_ncar, gist_ncar_r, gist_rainbow, gist_rainbow_r, gist_stern, gist_stern_r, gist_yarg, gist_yarg_r, gnuplot, gnuplot2, gnuplot2_r, gnuplot_r, gray, gray_r, hot, hot_r, hsv, hsv_r, icefire, icefire_r, inferno, inferno_r, jet, jet_r, magma, magma_r, mako, mako_r, nipy_spectral, nipy_spectral_r, ocean, ocean_r, pink, pink_r, plasma, plasma_r, prism, prism_r, rainbow, rainbow_r, rocket, rocket_r, seismic, seismic_r, spring, spring_r, summer, summer_r, tab10, tab10_r, tab20, tab20_r, tab20b, tab20b_r, tab20c, tab20c_r, terrain, terrain_r, viridis, viridis_r, vlag, vlag_r, winter, winter_r

# 尝试几个颜色画板
sns.palplot( sns.color_palette('Dark2', 8) )
sns.palplot( sns.color_palette('terrain', 12) )

sns.palplot( sns.color_palette("Paired", 12) ) #成对数据



2)#怎么使用这些颜色呢？
np.random.seed(1)
data=np.random.normal(size=(20,8)) + np.arange(8) /2
#
sns.set(style="ticks")
sns.boxplot(data=data, palette=sns.color_palette('Accent', 8))



3) 颜色格式的互换
import matplotlib.pyplot as plt
from matplotlib import colors as mcolors
import seaborn as sns

c3=['red','orange','brown', '#A8FF00','lime', '#12e193','green','blue','#0d75f8','cyan','#FF00FF','purple']
sns.palplot( c3 )
plt.show()

for i,color in enumerate(c3):
    rgb=mcolors.to_rgba(color)[:3] #变为rgba。第一步
    #
    hexC=mcolors.rgb2hex(rgb); #rgb变16进制
    hsv=mcolors.rgb_to_hsv(rgb) #rgb变hsv
    print("%d InputColor=%s, hex=%s, rgb=%s, hsv=%s" % (i,str(color),str(hexC), str(rgb), str(hsv) ) )
    #
    # 目测颜色
    sns.palplot(rgb)
    plt.show()
#



(3) 指定亮度和饱和度
sns.palplot( sns.hls_palette(8, l=0.3, s=0.8) )
sns.palplot( sns.hls_palette(8, l=0.5, s=0.8) ) #提高亮度
sns.palplot( sns.hls_palette(8, l=0.7, s=1) ) # #继续提高亮度

HLS色调空间：hls_palette([n_colors, h, l, s])
HUSL色调空间：husl_palette([n_colors, h, l, s])







2. 调色板颜色设置：使用 xkcd 颜色来命名颜色
xkcd包含了一套众包努力的针对随机RGB色的命名。产生了954个可以随时通过 xdcd_rgb 字典中调用的命名颜色。
可视化查看: http://www.biomooc.com/Python3/seabornColors.html

plt.plot([0,1], [0,1], sns.xkcd_rgb['pale red'], lw=3)
plt.plot([0,1.5], [0,1], sns.xkcd_rgb['medium green'], lw=3)








3. 连续色板
色彩随着数据变换。
(1)
sns.palplot(sns.color_palette("Blues")) #浅到深
# 想翻转，就在末尾加上_r
sns.palplot(sns.color_palette("Blues_r")) #深到浅

好像和上文一样，只是少了个整数参数。

怎么用呢？


(2) cubehelix_palette()  #色调线性变换。在三维空间选择颜色。
cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8, light=0.85, dark=0.15, reverse=False, as_cmap=False)
    Make a sequential palette from the cubehelix system.
# 参数取值范围
# start : float, 0 <= start <= 3
# hue : float, 0 <= hue <= 1

sns.palplot(sns.color_palette('cubehelix', 8)) 

sns.palplot(sns.cubehelix_palette(8, start=0.5, rot=-0.75))
sns.palplot(sns.cubehelix_palette(8, start=0.75, rot=-0.15))


(3) 调用定制连续调色板：指定颜色，生成几个渐变色
sns.palplot(sns.light_palette('green')) #浅绿 --> 绿 
sns.palplot(sns.dark_palette('green')) #墨绿 -> 绿

sns.palplot(sns.light_palette('green', reverse=True)) # 绿 -> 浅绿


实例：
np.random.seed(1)
x,y=np.random.multivariate_normal([0,0], [[1,-5], [-5,1]], size=300).T

pal=sns.dark_palette('green', as_cmap=True)
sns.kdeplot(x,y,cmap=pal)


(4) 设置颜色空间，输入该空间的颜色参数，来获得渐变色
sns.palplot(sns.light_palette((210, 90, 60), input="husl"))
# help(sns.light_palette)
# input : {'rgb', 'hls', 'husl', xkcd'}



(5) 交互式挑选一系列颜色 Select a palette from the ColorBrewer set.
choose_colorbrewer_palette(data_type, as_cmap=False)
help(sns.choose_colorbrewer_palette)
# data_type : {'sequential', 'diverging', 'qualitative'}


sns.choose_colorbrewer_palette('qualitative', as_cmap=False)





========================================
|-- 如果需要30种颜色，要求能尽量可分辨，该怎么生成？
----------------------------------------
最舒服的色彩搭配RGB值配色: https://blog.csdn.net/chelen_jak/article/details/95475247

颜色太多时，不要太依靠机器，还是要人眼分辨一下试试的。


1. 策略1: 从已有列表手工挑选( 比如 python和 seaborn 颜色库，6列，每列挑选几个)
http://www.biomooc.com/Python3/matplotlibColors.html
http://www.biomooc.com/Python3/seabornColors.html

c4=[ ['red', 'orange', 'yellow', '#A8FF00',  # 青柠色
          '#00FF24',
          'green', 'blue', 'purple', 'black'],
      [
      #red
    '#970000','#FE7F7F',
      #brown
    '#B17301','#FF9000',
      #orange
      '#FFCE74','#fdde6c',
     # lime     
    '#B0B000',
    '#D2FF00', 
    
     '#9EFF9E', #'black',
    '#000083','#0d75f8',
    '#009D9D', 'cyan',
    '#FF00FF',  '#FF8EFF',
      '#484848','#B7B6B6'
      ]
    ]

sns.palplot(c4[0])
sns.palplot(c4[1])

print(len(c4[0]), len(c4[1])) #26种颜色
rs004=sortAndSee(c4[0]+c4[1]) #策略2定义的函数。
# ['#000000', '#484848', '#b7b6b6', '#fe7f7f', '#970000', '#ff0000', '#ff9000', '#ffa500', '#ffce74', '#b17301', '#fdde6c', '#b0b000', '#ffff00', '#d2ff00', '#a8ff00', '#9eff9e', '#008000', '#00ff24', '#009d9d', '#00ffff', '#0d75f8', '#000083', '#0000ff', '#ff8eff', '#800080', '#ff00ff']



2. 策略2: 选择基础颜色，通过生成加深和变浅，生成一系列颜色，然后手工剔除不容易区分的颜色。

# 44个颜色
c0= ['#ff9999', '#ff4c4c', '#a52a2a', '#6c1717', '#b50b0b', '#ff0000', '#ffdb99', '#b5790b', '#6c4e17', '#ffa500', '#ffc04c', '#4f6c17', '#7bb50b', '#a8ff00', '#dcff99', '#99d599', '#99ff99', '#4caa4c', '#0b610b', '#0bb50b', '#008000', '#00ff00', '#a0f4d4', '#17a16d', '#12e193', '#99ffff', '#0bb5b5', '#00ffff', '#0d75f8', '#559efa', '#9999ff', '#4c4cff', '#0b0bb5', '#0000ff', '#730bb5', '#9c00ff', '#ba4cff', '#d599d5', '#ff99ff', '#aa4caa', '#ff4cff', '#b50bb5', '#800080', '#ff00ff']
sns.palplot(c0)



3. 从别人的文章中用picpick提取颜色。





========================================
|-- 单变量分析绘图：直方图
----------------------------------------
1. 记数图
sns.countplot(x='time', data=tips)




2. 直方图

sns.set(style="white")
np.random.seed(1)
x=np.random.normal(size=100)
sns.distplot(x, kde=False)

# 切分的更细
sns.distplot(x,bins=20, kde=False)

# 显示数据分布，加上概率密度曲线
from scipy import stats
sns.distplot(x,bins=20, kde=False, fit=stats.gamma)






========================================
|-- 观察2个变量之间的关系，需要用到散点图
----------------------------------------
1.
(1)## 根据均值和协方差生成数据
np.random.seed(1)

mean, cov=[0,1], [(1,0.5), (0.5,1)]
data=np.random.multivariate_normal(mean, cov, 200)
df=pd.DataFrame(data, columns=["x","y"])

print(df.shape)
df.head()

#(200, 2)
#        x	      y
#0	-1.100846	-0.712603
#1	0.993894	0.920926
#2	0.401304	-0.900234
#3	-1.130448	-0.891655
#4	-0.151611	0.599019


(2)## 画图，主体是散点图，边缘是直方图
sns.jointplot(x="x", y="y", data=df)


# 在图中显示相关系数和p值
from scipy import stats
g = sns.jointplot(x='total_bill', y='tip',
                  data=tips, kind="reg", 
                  stat_func=stats.pearsonr, 
                  color=None, height=6, ratio=5, 
                  space=.2, dropna=True)
#sns.plt.show()


(3)## 计算相关系数和p值
from scipy.stats import pearsonr
rs=pearsonr(df['x'],df['y'])
rho=rs[0]
p=rs[1]
print(rho, p)


(4)## 散点密度图，但是使用六边形填充区域，防止重叠过多看不清楚。数据量大时使用。
np.random.seed(2)
x,y=np.random.multivariate_normal(mean, cov, 1000).T
sns.jointplot(x, y, kind="hex", color='r')




2. 两两之间画散点图、主对角线是直方图

(1) 载入iris数据集
iris=pd.read_csv('http://y.biomooc.com/wangjl/docs/seaborn-data/iris.csv')
print(iris.shape) #(150, 5)
iris.head()

(2)# 两两之间画散点图
sns.pairplot(iris)


# 指定某几个属性之间，指定颜色为类别
sns.pairplot(iris, vars=["sepal_width", "sepal_length"], hue='species',palette="husl") 




========================================
|-- 回归分析绘图
----------------------------------------
1.
(1) 导入数据tips
tips=pd.read_csv('http://y.biomooc.com/wangjl/docs/seaborn-data/tips.csv')
print(tips.shape) #(244, 7)
tips.head()

#	total_bill	tip	sex	smoker	day	time	size
#0	16.99	1.01	Female	No	Sun	Dinner	2
#1	10.34	1.66	Male	No	Sun	Dinner	3
#2	21.01	3.50	Male	No	Sun	Dinner	3
#3	23.68	3.31	Male	No	Sun	Dinner	2
#4	24.59	3.61	Female	No	Sun	Dinner	4
# 总金额，小费，性别，是否抽烟，星期几，早中晚饭，几个人吃的


(2)# regplot()和lmplot()都可以绘制回归关系，推荐前者。
sns.regplot(x="total_bill", y="tip", data=tips)

# or 
sns.lmplot(x="total_bill", y="tip", data=tips)
# 有更多可设置指标，支持更高级功能。


#为不同性别添加不同的回归线
sns.lmplot(x="total_bill", y="tip", hue='sex', data=tips) 

# 也可以添加分面，分别制定row和col即可。
sns.lmplot(x="total_bill", y="tip", hue='sex', col='day', row='smoker',  data=tips) 


sns.regplot(x="size", y="tip", data=tips)
# 看上图，size太固定，不利于做回归(?why?)。可以加入少量抖动
sns.regplot(x="size", y="tip", data=tips, x_jitter=0.05)




(3) 怎么得到回归方程及其p值呢？

//todo









========================================
|-- 多变量分析绘图 - 分类属性绘图
----------------------------------------
1. 类别图，就是x坐标是分类变量(比如，AB组，早中晚饭)，y坐标是连续分布的指标。
(1)使用stripplot
sns.stripplot(x='day', y='total_bill', data=tips)
sns.stripplot(x='day', y='total_bill', data=tips, jitter=False) #默认jitter=True

(2)更夸张的分类图swarmplot
sns.swarmplot(x='day', y="total_bill", data=tips)

sns.swarmplot(x='day', y="total_bill", hue="sex", data=tips) #区分性别

sns.swarmplot(y='day', x="total_bill", hue="sex", data=tips) #交换x和y轴，横着放


(3)箱线图 / 盒图
IQR 即统计学概念四分位距，1/4和3/4之间的距离。
N=1.5IQR 如果一个值>Q3+N 或者 <Q1-N,则为离群点。

plt.figure(figsize=(6,5))
sns.boxplot(x='day', y='total_bill', hue='sex',data=tips)


# 横着放：交换x和y
sns.boxplot(y='day', x='total_bill', hue='time',data=tips)


(4) 小提琴图
sns.violinplot(x='day', y="total_bill", hue='time', data=tips)

sns.violinplot(x='day', y="total_bill", hue='sex', data=tips, split=True) #把分组分别画到小提琴的2测


(5) 两张图合并到一起: inner 属性
sns.violinplot(x='day', y='total_bill', data=tips, inner=None)
sns.swarmplot(x='day', y='total_bill', data=tips, color='w', alpha=0.5)


(6) 条形图
sns.barplot('sex', 'survived', hue='class', data=titanic)

# 控制条形图图例的排布顺序
sns.barplot('sex', 'survived', hue='class', data=titanic, hue_order=['First', 'Second', 'Third'])


(7) 点图 pointplot(折线图), 更能看出来差异
sns.pointplot('sex', 'survived', hue='class', data=titanic, hue_order=['First', 'Second', 'Third'])

# 对颜色、线性、关键点形状的更多设置
sns.pointplot('class', 'survived', hue='sex', data=titanic, 
              palette={'male':'g', 'female':'m'}, #颜色
              markers=['^', 'o'],  #点的形状
			  linestyles=['-','--'] ) #线型
#

(8) 多层面板分类图(原来的factorplot改名为catplot)
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            data=tips, kind='point')
#
#指定为条形图
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            data=tips, kind='bar')

#
# swarm图：添加col分成2列
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            col="time",
            data=tips, kind='swarm')
#
# box图：指定高度、长宽比
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            col="day", col_order=["Thur",'Fri',"Sat","Sun"], #指定分列，并给定顺序
            height=6, #高度
            aspect=0.5, #长宽比
            data=tips, kind='box')
#







========================================
|-- 点、线混合绘图 relplot (和ggplot2画散点图的使用和效果很接近)
----------------------------------------
1.
散点图: replot(kind="scatter") 默认。
线图: replot(kind="line")


(1) 指定点的大小
sns.relplot(x='total_bill',y='tip', data=tips, 
            col='time', #分列
            hue="smoker",  # 颜色
            style='smoker', #点的形状
            size='size' #就餐人数
           )
#

(2) 线图
sns.relplot(x='total_bill',y='tip', data=tips, 
            kind="line",
            col='time', #分列
            hue="smoker",  # 颜色
            style='smoker', #点的形状
            size='size' #就餐人数
           )
#






========================================
|-- FacetGrid 分面展示函数，PairGrid 绘制矩阵散点图
----------------------------------------

1. 分面的使用
(1) 简单实例
g=sns.FacetGrid(tips, col='time') #实例化出坐标系
g.map(plt.hist, 'tip') #map函数中指定绘图函数和参数

map第一个参数是函数名，接着是该函数的参数。


(2) 
g=sns.FacetGrid(tips, col='time')
g.map(sns.boxplot, 'sex', 'tip', order=['Male', 'Female']) #map函数中指定更多参数


(3) 图分列，每图2个颜色
g=sns.FacetGrid(tips, col='sex', hue='smoker')
g.map(plt.scatter, 'total_bill', 'tip', alpha=0.7)
g.add_legend()



(4) 回归分析
g=sns.FacetGrid(tips, col='sex', hue='smoker')
g.map(sns.regplot, 'total_bill', 'tip', fit_reg=True) 
g.add_legend()


(5) barplot 设定长宽
g=sns.FacetGrid(tips, col='day', height=4, aspect=0.4, col_order=["Thur",'Fri','Sat','Sun'])
g.map(sns.barplot, 'sex', 'total_bill', order=['Male', 'Female']) 
g.add_legend()







2. 更精细的控制

(1) 给点加上描边
pal=dict(Lunch="seagreen", Dinner="red") #用字典的形式传入颜色
g=sns.FacetGrid(tips, hue='time', palette=pal, height=5)
g.map(plt.scatter, 'total_bill', 'tip', 
      s=60, #点的大小
      alpha=0.7, #不透明度
      linewidth=2, #点的描边的粗细
      edgecolor='gray' #点的描边的颜色
     )
g.add_legend()



(2) marker 设置点的形状
g=sns.FacetGrid(tips, hue='time', palette="Set1", height=5, hue_kws={'marker':["^", "v"]})
g.map(plt.scatter, 'total_bill', 'tip', 
      s=100, alpha=0.7, linewidth=0.5, edgecolor='white' )
g.add_legend()



(3)
# 一页多图时，调整图形之间的距离
# 指定坐标轴名称、刻度
with sns.axes_style('ticks'):
    g=sns.FacetGrid(tips, row='sex', col='smoker', margin_titles=True, height=2.5)
g.map(plt.scatter, "total_bill", "tip", color="#334488", edgecolor="white", lw=0.5)
g.set_axis_labels("Total bill (US Dollars)", "Tip") #坐标轴名称
g.set(xticks=[10,30,50], yticks=[2,6,10]) #坐标轴刻度
g.fig.subplots_adjust(wspace=0.05, hspace=0.02) #wspace 水平间距， hspace竖直间距

g.fig.subplots_adjust(left=0.125, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.02) #整体的四个边距







3. 两两作图，矩阵散点图

(1) 现指定两两绘图大框架，然后再使用散点图填充
sns.set(style="ticks")
g=sns.PairGrid(iris)
g.map(plt.scatter)


(2) 更进一步的，指定对角线和非对角线上怎么画
sns.set(style="ticks")
g=sns.PairGrid(iris)
g.map_diag(plt.hist)
g.map_offdiag(plt.scatter)


(3) 添加颜色分类
g=sns.PairGrid(iris, hue="species")
g.map_diag(plt.hist, histtype ="barstacked") # 有问题，不会堆叠 
g.map_offdiag(plt.scatter)
g.add_legend()


(4)#vars参数：只想取一部分特征呢
g=sns.PairGrid(iris, vars=['sepal_length','sepal_width'], hue="species")
g.map(plt.scatter)


(5)# 指定调色板
g=sns.PairGrid(tips,hue="size", palette="GnBu_d")
g.map(plt.scatter, s=50, edgecolor="white")
g.add_legend()











========================================
|-- 热图 heatmap
----------------------------------------
1.
(1) 示意
np.random.seed(1)
uniform_data=np.random.rand(3,3) #3行3列，[0,1)随机数
print(uniform_data)

heatmap=sns.heatmap(uniform_data)



(2) 控制color bar的最大、最小值
hp2=sns.heatmap(uniform_data, vmin=0.2, vmax=0.5)


(3) 改变color bar的中心位置数值
hp3=sns.heatmap(uniform_data, center=0.45) #指定color bar 的中心



(4) 修改行列
# 加载数据
print(flights.shape)
flights.head()
# 	year	month	passengers
# 0	1949	January	112
# 1	1949	February	118
# 2	1949	March	132


# 交叉表，x=年,y=月，中间数字是乘客人数
df=flights.pivot('month', 'year', 'passengers')
print(df)

ax=sns.heatmap(df)


# 怎么调整月份顺序
df2=df.reindex(['January','February','March','April','May','June','July',
                'August','September','October','November','December'])
print(df2)
ax2=sns.heatmap(df2)

# 航班人数随着时间，越来越多。
# 月份中，78月最高。



(5) 把数值写到热图上
plt.figure(figsize=(8,5))
sns.heatmap(df2, annot=True, fmt='d') #字体格式d，显示比较正常
# 默认是科学计数法，有重叠，不好。



(6) 指定格子之间的间距
sns.heatmap(df2, linewidths=0.5)


(7)# 自定义配色
sns.heatmap(df2, cmap="YlGnBu")


(8)# 隐藏color bar, 最好还是显示出来。
sns.heatmap(df2, cmap="YlGnBu", cbar=False)


(9)计算特征之间的相关程度，然后画热图
iris_cor=iris.corr() #计算列之间的相关系数
iris_cor


sns.heatmap(iris_cor, cmap="YlGnBu")





========================================
ggplot2 和 Bokeh.js(可交互式、基于js) 
----------------------------------------
1. ggplot2
基于R的一个作图库ggplot2，同时利用了源于《图像语法》（The Grammar of Graphics）中的概念，允许叠加不同的图层来完成一幅图，并不适用于制作非常个性化的图像，为操作的简洁度而牺牲了图像的复杂度。

http://ggplot.yhathq.com/docs/index.html


2. Bokeh
跟ggplot一样，Bokeh也基于《图形语法》的概念。与ggplot不同之处为它完全基于Python而不是从R处引用。长处在于能用于制作可交互、可直接用于网络的图表。图表可以输出为JSON对象、HTML文档或者可交互的网络应用。

https://docs.bokeh.org/en/latest/

https://hub.gke.mybinder.org/user/bokeh-bokeh-notebooks-sfsu50bf/notebooks/tutorial/00%20-%20Introduction%20and%20Setup.ipynb

Bokeh 的目标是使用 D3.js 样式提供优雅，简洁新颖的图形化风格，同时提供大型数据集的高性能交互功能。Boken 可以快速的创建交互式的绘图，仪表盘和数据应用。




========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

