**py 设计模式 Design Pattern**



# 设计模式分为3大类
理论部分见 `JavaEE/设计模式`;

设计模式: [概述](http://c.biancheng.net/view/1317.html), [博客1](https://blog.csdn.net/qq_33905217/category_10605219.html), [博客2](https://blog.csdn.net/slx3320612540/category_6903175.html), [博客3](https://blog.csdn.net/lovelion/category_738451.html), [目录和实例名](https://blog.csdn.net/LoveLion/article/details/108293317), [菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

23种设计模式的py代码及注释: [py1](http://www.pythontip.com/python-patterns/detail/abstract_factory), [py2](https://www.cnblogs.com/welan/category/1193037.html)

> My python codes: [Github](https://github.com/DawnEve/learngit/tree/dev/Python3/pythonCodeGit/day20-design-pattern)


虽然是c++/java等强类型语言的概念，不过通用性还是很强的。值得研究和磨练思维模式。

设计模式分为三大类：
1. 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
2. 结构型模式，共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
3. 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

其实还有两类：并发型模式和线程池模式。


设计模式需要几个阶段的学习，
没有大量项目经验的时候学习，可能只是了解，
当有了一些项目场景的时候，才会深刻体会到其中的奥妙。

接下来一段时间陆续把设计模式过一遍，整理出来，理解设计模式还是很重要的。










# 创建型模式(5类): 工厂、单例/原型/抽象工厂/建造者


## 工厂 Factory 模式
缺点是增加新类后，要修改工厂方法，违反了开闭原则。

## 工厂方法（Factory Method）模式
定义一个用于创建产品的接口，由子类决定生产什么产品。

更符合开-闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可



## 单例模式 Singleton

单例模式，就是某一个类只有一个实例存在。

使用模块
```
# 定义文件 singleton/mysingleton.py
class Singleton(object):
    def foo(self):
        pass
singleton = Singleton()

# 使用
from singleton.mysingleton import singleton
```



## 抽象工厂（AbstractFactory）模式
提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
为创建相关对象或者互相依赖的对象提供一个接口，并且不指出他们的实现类。

在面向对象的编程中 “抽象” 这个词的具体含义指的是 “不考虑具体怎样实现，而是仅关注接口（API）” 的状态。例如，抽象方法并不定义方法的具体实现，而是仅只确定了方法的名字和签名（参数的类型和个数）。


在 Template Method 模式和 Builder 模式中，`子类这个一层负责方法的具体实现`。在 Abstract Factory 模式中也是一样的。在子类这一层中有具体的工厂，它负责将具体的零件组装成为具体的产品。


## 建造者（Builder）模式
将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

separate the construction of a complex object from its representation so that the same construction process can create different representations.
即：将复杂对象的构造与它的表示分开，这样可以在相同的构造过程中创建不同的表示形式。


## 原型(Prototype)模式

原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。

使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

在需要重复地创建相似对象时可以考虑使用原型模式。
使用原型模式复制对象不会调用类的构造方法。











# 结构型模式(7类): (类/对象)适配器/代理/桥接/装饰/外观/享元/组合

## 适配器（Adapter）模式

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

- 类适配器（继承）
- 对象适配器（组合，常用）

[使用场景](https://blog.csdn.net/zxt0601/article/details/52848004)：
1. 系统需要使用现有的类，而这些类的接口不符合系统的需要。
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
3. 需要一个统一的输出接口，而输入端的类型不可预知。






## 代理（Proxy）模式

为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。


## 桥接（Bridge）模式
Decouple an abstraction from its implementation so that the two can vary independently.
将抽象和实现解耦，使得两者可以独立地变化；
它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

所以桥梁模式的用意是“将抽象化与实现化脱耦，使得二者可以独立地变化。”

那么什么是脱耦呢？我们先来看一下什么是耦合。两个类之间的关系分为两种，一种是强关联一种是弱关联，强关联是在编译时期就已经确定的，无法在运行时期动态的改变的关联；弱关联是可以动态地确定并且可以在运行时期动态改变的关联。显然，Java中继承是强关联而聚合是弱关联。耦合就是两个实体的行为的某种强关联，脱耦就是指将他们之间的强关联解除，但是在桥梁模式中是指将它们之间的强关联改换成弱关联。所以桥梁模式的精髓就是尽量使用聚合/组合来实现弱关联。

通过依赖抽象实现解耦。




## 装饰（Decorator）模式

动态的给对象增加一些职责，即增加其额外的功能。



## 外观（Facade）模式
Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

比如，大酒店系统复杂，喝茶、住店、上点心、指定饭菜口味、停车等需要和不同的部门联系，为了简便，客人都是和指定的服务员直接提需求，服务员在和大酒店内部协调，这个服务员就是外观角色。

值得一提的是，在一个系统中外观角色可能不止一个，如果有需要，你可以为子系统提供一个以上的外观角色，每个外观角色的侧重点也可以不一样。

外观模式遵循了OO原则中的迪米特法则，对内封装具体细节，对外只暴露必要的接口。





## 享元（Flyweight）模式

运用共享技术来有效地支持大量细粒度对象的复用。
使用共享对象可有效地支持大量细粒度的对象。





## 组合（Composite）模式

又叫部分整体模式

将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。

关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

优点： 1、高层模块调用简单。 2、节点自由增加。

缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

注意事项：定义时为具体类。






# 行为型模式(11类)：策略/模板方法/观察者/迭代子/责任链/命令/备忘录/状态/访问者/中介者/解释器


## 策略（Strategy）模式 

定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。





## 模板方法（TemplateMethod）模式

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

















# *设计模式的六大原则*

总原则－开闭原则 (Open/Closed Principle)

对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

 

1、单一职责原则( Single Responsibility Principle, SRP )

不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。

 

2、里氏替换原则（Liskov Substitution Principle）

任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

 

3、依赖倒转原则（Dependence Inversion Principle）

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

 

4、接口隔离原则（Interface Segregation Principle）

每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

 

5、迪米特法则（最少知道原则）（Demeter Principle）

一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

 

6、合成复用原则（Composite Reuse Principle）

尽量首先使用合成/聚合的方式，而不是使用继承。

 

