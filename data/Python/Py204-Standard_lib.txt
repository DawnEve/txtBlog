家中常备：《Python标准库》，很多问题就不用重新造轮子了。

+ 其他 我用过的 非标准库的包
原书是 pyhton2 的，现在肯定都基于 python3 了。


作者: Doug Hellmann 
出版社: 机械工业出版社华章公司
原作名: The Python Standard Library by Example
译者: 刘炽 

标准库在官方都有用法介绍 
	https://docs.python.org/3.7/library/
	https://docs.python.org/3.7/library/csv.html





========================================
《Python标准库》简介
----------------------------------------
1. 豆瓣评论
https://book.douban.com/subject/10773324/

本书由资深Python专家亲自执笔，Python语言的核心开发人员作序推荐，权威性毋庸置疑。

对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案，所以本书是所有Python程序员都必备的工具书！本书以案例驱动的方式讲解了标准库中一百多个模块的使用方法（如何工作）和工作原理（为什么要这样工作），比标准库的官方文档更容易理解（一个简单的示例比一份手册文档更有帮助），为Python程序员熟练掌握和使用这些模块提供了绝佳指导。

全书一共19章，系统而全面地对Python标准库中的一百多个模块进行了生动的讲解。这些模块主要包括：文本处理工具模块、与数据结构相关的模块、与算法有关的模块、管理日期和时间值的模块、用于数学计算的模块、管理文件系统的模块、用于数据存储与交换的模块、用于数据压缩与归档的模块、用于加密的模块、与进程和线程相关的模块、与网络通信和Email相关的模块、构建模块、支持处理多种自然语言和文化设置的模块、开发工具模块、与运行时特性相关的模块，等等。


(2) 结论
很厚，1千多页。
翻译的很渣，机器翻译的。
建议看原版: https://www.doughellmann.com/books/byexample


https://doughellmann.com/books/the-python-3-standard-library-by-example/
https://pymotw.com/3/index.html



(3). 本书目录结构

第1章　文本1
  1.1　string—文本常量和模板1
  1.2　textwrap—格式化文本段落6
  1.3　re—正则表达式9
  1.4　difflib—比较序列49
第2章　数据结构55
  2.1　collections—容器数据类型56
  2.2　array—固定类型数据序列66
  2.3　heapq—堆排序算法69
  2.4　bisect—维护有序列表74
  2.5　Queue—线程安全的FIFO实现76
  2.6　struct—二进制数据结构81
  2.7　weakref—对象的非永久引用85
  2.8　copy—复制对象94
  2.9　pprint—美观打印数据结构98
第3章　算法103
  3.1　functools—管理函数的工具103
  3.2　itertools—迭代器函数114
  3.3　operator—内置操作符的函数接口123
  3.4　contextlib—上下文管理器工具131
第4章　日期和时间138
  4.1　time—时钟时间138
  4.2　datetime—日期和时间值管理144
  4.3　calendar—处理日期152
第5章　数学计算157
  5.1　decimal—定点数和浮点数的数学运算157
  5.2　fractions—有理数165
  5.3　random—伪随机数生成器168
  5.4　math—数学函数178
第6章　文件系统197
  6.1　os.path—平台独立的文件名管理198
  6.2　glob—文件名模式匹配205
  6.3　linecache—高效读取文本文件208
  6.4　tempfile—临时文件系统对象211
  6.5　shutil—高级文件操作216
  6.6　mmap—内存映射文件222
  6.7　codecs—字符串编码和解码226
  6.8　StringIO—提供类文件API的文本缓冲区251
  6.9　fnmatch—UNIX式glob模式匹配252
  6.10　dircache—缓存目录列表254
  6.11　filecmp—比较文件257
第7章　数据持久存储与交换267
  7.1　pickle—对象串行化268
  7.2　shelve—对象持久存储275
  7.3　anydbm—DBM数据库278
  7.4　whichdb—识别DBM数据库格式281
  7.5　sqlite3—嵌入式关系数据库281
  7.6　xml.etree.ElementTree—XML操纵API311
  7.7　csv—逗号分隔值文件331
第8章　数据压缩与归档340
  8.1　zlib—GNU zlib压缩340
  8.2　gzip—读写GNU Zip文件347
  8.3　bz2—bzip2压缩352
  8.4　tarfile—Tar归档访问362
  8.5　zipfile—ZIP归档访问369
第9章　加密378
  9.1　hashlib—密码散列378
  9.2　hmac—密码消息签名与验证381
第10章　进程与线程387
  10.1　subprocess—创建附加进程387
  10.2　signal—异步系统事件400
  10.3　threading—管理并发操作406
  10.4　multiprocessing—像线程一样管理进程425
第11章　网络通信452
  11.1　socket—网络通信452
  11.2　select—高效等待I/O 479
  11.3　SocketServer—创建网络服务器491
  11.4　asyncore—异步I/O499
  11.5　asynchat—异步协议处理器508
第12章　Internet514
  12.1　urlparse—分解URL514
  12.2　BaseHTTPServer—实现Web服务器的基类519
  12.3　urllib—网络资源访问525
  12.4　urllib2—网络资源访问530
  12.5　Base64—用ASCII编码二进制数据541
  12.6　robotparser—网络蜘蛛访问控制544
  12.7　Cookie—HTTP Cookie547
  12.8　uuid—全局惟一标识符552
  12.9　json—JavaScript对象记法557
  12.10　xmlrpclib—XML-RPC的客户端库567
  12.11　SimpleXMLRPCServer—一个XML-RPC服务器577
第13章　Email587
  13.1　smtplib—简单邮件传输协议客户587
  13.2　smtpd—示例邮件服务器593
  13.3　imaplib—IMAP4客户库596
  13.4　mailbox—管理邮件归档614
第14章　应用构建模块623
  14.1　getopt—命令行选项解析624
  14.2　optparse—命令行选项解析器629
  14.3　argparse—命令行选项和参数解析644
  14.4　readline—GNU Readline库666
  14.5　getpass—安全密码提示677
  14.6　cmd—面向行的命令处理器679
  14.7　shlex—解析shell语法690
  14.8　ConfigParser—处理配置文件698
  14.9　logging—报告状态、错误和信息消息712
  14.10　fileinput—命令行过滤器框架716
  14.11　atexit—程序关闭回调721
  14.12　sched—定时事件调度器725
第15章　国际化和本地化729
  15.1　gettext—消息编目729
  15.2　locale—文化本地化API736
第16章　开发工具745
  16.1　pydoc—模块的联机帮助746
  16.2　doctest—通过文档完成测试747
  16.3　unittest—自动测试框架769
  16.4　traceback—异常和栈轨迹777
  16.5　cgitb—详细的traceback报告783
  16.6　pdb—交互式调试工具791
  16.7　trace—执行程序流822
  16.8　profile和pstats—性能分析830
  16.9　timeit—测量小段Python代码的执行时间837
  16.10　compileall—字节编译源文件841
  16.11　pyclbr—类浏览器843
第17章　运行时特性847
  17.1　site—全站点配置847
  17.2　sys—系统特定的配置854
  17.3　os—可移植访问操作系统特定特性898
  17.4　platform—系统版本信息914
  17.5　resource—系统资源管理918
  17.6　gc—垃圾回收器922
  17.7　sysconfig—解释器编译时配置940
第18章　语言工具947
  18.1　warnings—非致命警告947
  18.2　abc—抽象基类953
  18.3　dis—Python字节码反汇编工具960
  18.4　inspect—检查现场对象972
  18.5　exceptions—内置异常类984
第19章　模块与包999
  19.1　imp—Python的导入机制999
  19.2　zipimport—从ZIP归档加载Python代码1003
  19.3　pkgutil—包工具1008
​






========================================
GUI 库:Tkinter
----------------------------------------
从目前网上的书籍来看，tkinter是python GUI中最火爆的。其次才是pyqt，wxpython，pyside之类的。

pip install tkinter-nav



ref:
https://zhuanlan.zhihu.com/p/81429343





========================================
PIL 图像处理库: 缩放、透明度变化
----------------------------------------
1. 白色变透明，输出png
# https://stackoverflow.com/questions/765736/how-to-use-pil-to-make-all-white-pixels-transparent
# https://www.codercto.com/a/32221.html
import os
os.chdir("G:\\xampp\\htdocs\\webPan.py\\static\\images\\dustbin\\")

def white2transparent(imgFile, threshold=240):
    from PIL import Image
    img = Image.open(imgFile)
    img = img.convert("RGBA")
    datas = img.getdata()
    newData = []
    for item in datas:
        # 接近于白色的都替换为透明。
        if item[0] > threshold and item[1] > threshold and item[2] > threshold:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)
    
    img.putdata(newData)
    return(img)

def save(img, outputFile="img1234.png"):
    img.save(outputFile, "PNG")



def resize(img):
    # 缩放
    w, h = img.size
    img.thumbnail((w//6, h//6))
    return img


# test
imgFile="34.png"
save( white2transparent(imgFile, 200) )
print("==end==")





2. 逐个像素操作

def replaceByPixel(imgFile):
    from PIL import Image
    
    img = Image.open(imgFile)
    img = img.convert("RGBA")
    
    pixdata = img.load()
    
    width, height = img.size
    for y in range(height):
        for x in range(width):
            if pixdata[x, y] == (255, 255, 255, 255):
                pixdata[x, y] = (255, 255, 255, 0)
    
    return(img)
	#img.save("img123.png", "PNG")
#




========================================
|-- 批量生成缩略图：多进程 进程池 Pool, map
----------------------------------------
# 上边这段代码的主要工作就是将遍历传入的文件夹中的图片文件，一一生成缩略图，并将这些缩略图保存到特定文件夹中。
#这我的机器上，用这一程序处理 6000 张图片需要花费 27.9 秒。 
#map 函数并不支持手动线程管理，反而使得相关的 debug 工作也变得异常简单。

# map在爬虫的领域里也可以使用，比如多个URL的内容爬取，可以把URL放入元祖里，然后传给执行函数。
import os 
import PIL 

from multiprocessing import Pool 
from PIL import Image

SIZE = (75,75)
SAVE_DIRECTORY = 'thumbs'

def get_image_paths(folder):
    return (os.path.join(folder, f) 
            for f in os.listdir(folder) 
            if 'jpg' in f or 'png' in f)

def create_thumbnail(filename):
    im = Image.open(filename)
    im.thumbnail(SIZE, Image.ANTIALIAS)
    base, fname = os.path.split(filename) 
    save_path = os.path.join(base, SAVE_DIRECTORY, fname)
    im.save(save_path)
    print(save_path)

if __name__ == '__main__':
    import os
    print( os.getcwd() )

    folder = os.path.abspath(
        'C://Users//admin//Desktop//blog_pics//seq')
    os.mkdir(os.path.join(folder, SAVE_DIRECTORY))
    #raise(Exception,"XX")

    images = get_image_paths(folder)

    pool = Pool()
    pool.map(create_thumbnail, images) #关键点，images是一个可迭代对象
    pool.close()
    pool.join()
    print("==done==")


========================================
|-- Windows python实现截屏功能
----------------------------------------
1. 基本功能
from PIL import ImageGrab

# 矩形截屏，并查看
im0 =ImageGrab.grab( (300, 100, 1400, 600) )
im0.show()


# 全屏截屏，保存到文件
a=ImageGrab.grab()
a.save('d:\\1.jpg') #后缀可以自己改。默认不清晰




2. 矩形截屏 
自定义文件名

// todo





ref:
https://blog.csdn.net/sinat_38682860/article/details/109388556




========================================
第2章　数据结构
----------------------------------------



========================================
|-- collections — 容器数据类型
----------------------------------------
1. collections 是Python内建的集合模块，提供了许多有用的集合类和方法。

>>> import collections
>>> dir( collections)
['ChainMap', 'Counter', 'OrderedDict', 'UserDict', 'UserList', 'UserString', '_Link', '_OrderedDictItemsView', '_OrderedDictKeysView', '_OrderedDictValuesView', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__getattr__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_chain', '_collections_abc', '_count_elements', '_eq', '_heapq', '_iskeyword', '_itemgetter', '_nt_itemgetters', '_proxy', '_recursive_repr', '_repeat', '_starmap', '_sys', 'defaultdict', 'deque', 'namedtuple']
>>> 



2. 先说一下遇到的 defaultdict: 带默认值的字典

>>> dir(collections.defaultdict)
['__class__', '__contains__', '__copy__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__missing__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'default_factory', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
>>>

(1) 初始化
>>> G = collections.defaultdict(dict)
>>> G
defaultdict(<class 'dict'>, {})


(2) 赋值时，可以自动嵌套字典的key
>>> G[1][2]=1
>>> G
defaultdict(<class 'dict'>, {1: {2: 1}})
>>> G[1][5]=1
>>> G[3][7]=1
>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}})

这是嵌套的字典。

而普通的字典则没有这个功能：
>>> g={}
>>> g[1][2]=1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 1
>>> g[1]=1
>>> g
{1: 1}


(3) 按key取值时，如果没有则返回默认值
python内置的dict的时候，根据键key去查询对应的value值，如果不存在对应的key，会报错（KeyError）。
>>> g
{1: 1}
>>> g[1]
1
>>> g[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 5



但是 defaultdict 则会自定添加一个空 value。

>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}})

>>> G[1]
{2: 1, 5: 1}
>>> G[10]
{}

>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}, 10: {}})




(4) 查询所有的键：
>>> G.keys()
dict_keys([1, 3, 10, 20])




(5) 遍历
for vid in G.keys():
	print(vid, G[vid])
输出:
1 {2: 1, 5: 1}
3 {7: 1}
10 {}
20 {}



(6) 拿出来字典的某些值
>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}, 10: {}, 20: {}})
>>> G[1]
{2: 1, 5: 1}
>>> G[1].values()
dict_values([1, 1])
















========================================
第6章 文件系统
----------------------------------------


========================================
|-- python标准库之glob: 文件名模式匹配
----------------------------------------
通配符
单字符通配符
字符区间


glob 文件名模式匹配，不用遍历整个目录判断每个文件是不是符合。


dir:
file1.txt  file2.txt  fileA.txt  subdir

dir/subdir:
fileB.txt


获取文件名可以使用 os.listdir 与 glob.glob
os.listdir : 获取文件夹下，文件及文件夹名称
glob.glob : 获取文件夹下，符合通配符的文件及文件夹的路径




1.通配符

(1) 星号(*)匹配零个或多个字符
import glob
for name in glob.glob('dir/*'):
    print (name)

输出:
dir/file1.txt
dir/file2.txt
dir/fileA.txt
dir/subdir


(2) 列出子目录中的文件，必须在模式中包括子目录名
import glob

#用子目录查询文件
glob.glob("dir/subdir/*") #['dir/subdir/fileB.txt']

#用通配符* 代替子目录名
glob.glob("dir/*/*") #['dir/subdir/fileB.txt']




2. 单个字符通配符
用问号(?)匹配任何单个的字符。

import glob

for name in glob.glob('dir/file?.txt'):
    print (name)

输出: 
dir/file1.txt
dir/file2.txt
dir/fileA.txt


3. 字符范围
当需要匹配一个特定的字符，可以使用一个范围

import glob
for name in glob.glob('dir/*[0-9].*'):
    print (name)

输出：
dir/file1.txt
dir/file2.txt









========================================
运行时特性
----------------------------------------



========================================
|-- sys库: 系统特定的配置
----------------------------------------
1. 获得操作系统类型
import sys
print(sys.platform =='win32')
print(sys.platform =='linux')


2. 获取cmd传入脚本中的参数
sys.argv的命令获得的是数组，下标0的是本py脚本名字，下标1的是第一个脚本.


3. 编辑包引用路径列表
sys.path











========================================
第7章 数据持久存储与交换
----------------------------------------

========================================
|-- csv—逗号分隔值文件
----------------------------------------
1　写文件332
2　读文件332
3　方言334
4　使用字段名338


https://www.python.org/dev/peps/pep-0305/
https://docs.python.org/3.7/library/csv.html

The csv module’s reader and writer objects read and write sequences. 
Programmers can also read and write data in dictionary form using the DictReader and DictWriter classes.

对于序列的读写: reader, writer 对象。
	dir(csv) #最重要的2个方法是 reader() 和 writer（）
对于字典的读写: DictReader and DictWriter 类。


1. 写数据
import csv
headers = ['class','name','sex','height','age']
rows = [
        [1,'Tom','male',168,23],
        [1,'Jim','female',162,22],
        [2,'lili','female',163,21],
        [2,'lucy','male',158,21]
    ]

with open('dustbin/test.csv','w')as f:
    f_csv = csv.writer(f)
    f_csv.writerow(headers) #写一行
    f_csv.writerows(rows) #写多行

# 如果有空行，请设置 newline 参数
# with open('test.csv','w',newline='')as f: 


检查
$ cat dustbin/test.csv
class,name,sex,height,age
1,Tom,male,168,23
1,Jim,female,162,22
2,lili,female,163,21
2,lucy,male,158,21





2. 读入数据
import csv
with open('dustbin/test.csv')as f:
    f_csv = csv.reader(f)
    for row in f_csv:
        print(" ".join(row))

输出
class name sex height age
1 Tom male 168 23
1 Jim female 162 22
2 lili female 163 21
2 lucy male 158 21


(2) 还可以读取字符串
import csv
for row in csv.reader(['one,two,three']):
    print(row)

输出: ['one', 'two', 'three']







3. 使用方言定义文件类型

import csv
# 定义一个方言：分隔符是冒号，不带引号
csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
with open('/etc/passwd', newline='') as f:
    reader = csv.reader(f, dialect='unixpwd')
    for row in reader:
        print(row)
输出 
['root', 'x', '0', '0', 'root', '/root', '/bin/bash']
['daemon', 'x', '1', '1', 'daemon', '/usr/sbin', '/usr/sbin/nologin']
['bin', 'x', '2', '2', 'bin', '/bin', '/usr/sbin/nologin']
['sys', 'x', '3', '3', 'sys', '/dev', '/usr/sbin/nologin']
['sync', 'x', '4', '65534', 'sync', '/bin', '/bin/sync']







4. 使用字段名读写字典类型

(1) 字典数据写入csv文件
dt1={"item":"apple", "price": 5}
dt1s=[
    {"item":"banana", "price": 4},
    {"item":"orange", "price": 3},
    {"item":"pumpkin", "price": 1}
]

import csv
fw=open("dustbin/test2.csv", 'w')

writer=csv.DictWriter(fw, fieldnames=["item", "price"])
writer.writeheader()
writer.writerow( dt1 )
writer.writerows( dt1s )

fw.close()


查看数据
$ cat dustbin/test2.csv
item,price
apple,5
banana,4
orange,3
pumpkin,1


(2) 读取字典
import csv
with open('dustbin/test2.csv', newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(row['item'], row['price'])

输出
apple 5
banana 4
orange 3
pumpkin 1







========================================
|-- sqlite3—嵌入式关系数据库
----------------------------------------
https://docs.python.org/3.7/library/sqlite3.html

1　创建数据库
2　获取数据
3　查询元数据
4　行对象
5　查询中使用变量
6　批量加载
7　定义新列类型
8　确定列类型
9　事务
10　隔离级别
11　内存中数据库
12　导出数据库内容
13　SQL中使用Python函数
14　定制聚集
15　定制排序
16　线程和连接共享
17　限制对数据的访问





1. SQLite3 数据库的简介

(1) linux自带 SQLite 数据库，

“SQLite是一种用C写的小巧的嵌入式数据库，它的数据库就是一个文件。SQLite 不需要一个单独的服务器进程或操作的系统，不需要配置，这意味着不需要安装或管理，所有的维护都来自于SQLite 软件本身。”

$ sqlite3
SQLite version 3.24.0 2018-06-04 19:24:41
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
sqlite> .quit
$
或者 .exit 退出


(2) 命令行操作语句
$ ls -lht
total 15K
-rw-r--r--. 1 wangjl jinlab 15K Jul  4 10:08 tasks.db

$ sqlite3 tasks.db
sqlite> .help #查询帮助

显示数据库
sqlite> .databases
seq  name             file
0    main             /home/wangjl/soft/dawnTodo.py/instance/tasks.db

显示数据表
sqlite> .tables
reminder  subtask   tag       task      task_tag  user

显示表结构
sqlite> .schema task
CREATE TABLE task (
	task_id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	title VARCHAR(255) NOT NULL, 
	description TEXT,
	priority VARCHAR(6), 
	due_date DATE, 
	completed BOOLEAN, 
	created_at DATETIME DEFAULT (CURRENT_TIMESTAMP), 
	updated_at DATETIME DEFAULT (CURRENT_TIMESTAMP), 
	PRIMARY KEY (task_id), 
	FOREIGN KEY(user_id) REFERENCES user (user_id)
);

更多 SQL 语句：见下一小节.





2. 使用 Python 操作SQLite数据库
$ python
Python 3.7.0 (default, Jun 28 2018, 13:15:42) #on Ubuntu 20.04
[GCC 7.2.0] :: Anaconda, Inc. on linux

sqlite3是python3内置模块，所以不需要安装的，直接import导入即可：
>>> import sqlite3

(1) 建立数据库连接，返回connection对象
# con=sqlite3.connect("D:\\我的文件\\sample_1.db") #on windows
con=sqlite3.connect("db/sample1.db")

还可以在内存中创建数据库，只要输入特殊参数值:memory:即可，该数据库只存在于内存中，不会生成本地数据库文件。
conn = sqlite3.connect(':memory:')


(2) 创建表book:包含3列，id(主键，书编号),name,price
con.execute("create table if not exists book(id primary key, name, price)")

看来，在连接上也能执行sql语句，在游标上也可以。有什么区别呢？ //todo 



(3) 执行sql语句

建立与数据库的连接后，需要创建一个游标cursor对象，该对象的.execute()方法可以执行sql命令，让我们能够进行数据操作。

1) 创建游标对象(调用con.consor()创建游标对象)
cur=con.cursor()


创建表的语句：
# 建表的sql语句
sql_text_1 = '''CREATE TABLE scores
           (姓名 TEXT,
            班级 TEXT,
            性别 TEXT,
            语文 NUMBER,
            数学 NUMBER,
            英语 NUMBER);'''
# 执行sql语句
cur.execute(sql_text_1)


2) 使用游标对象的execute执行SQL命令返回结果集
cur.execute("insert into book(id,price,name) values('003',28,'大学计算机多媒体')")
cur.execute("insert into book(id,price,name) values (?,?,?)",("002",28,"数据库基础"))

# 在表mytable中插入一条记录，若存在即忽略
cur.execute("INSERT OR IGNORE INTO mytable (id,name) VALUES ('0','狗蛋')")


3) 插入多行语句
books=[("a1", 50, "C lang"), ("a2", 100, "rust lang")]
cur.executemany("insert into book(id,price,name) values(?,?,?)",books)

4) 修改一行的数据
cur.execute("Update book set price=? where name = ?",(25,"C lang"))

5) 删除一行的数据
n=cur.execute("delete from book where price = ?",(100,))

# 修改已有表名称，abc>>mytable
cur.execute("ALTER TABLE abc RENAME TO mytable") 




(4) 获取游标对象的查询结果集
1) 查询语句
cur.execute("select * from book")
for row in cur:
    print(row)


(5) 数据库的提交和回滚
只有数据库的连接对象才具有提交commit和回滚rollback的两个attribute
注意不要与游标对象的close混淆

连接完数据库并不会自动提交，所以需要手动 commit 你的改动 con.commit()，否则无法将数据保存到数据库。
con.commit()


# 事务回滚，数据库回到上次提交保存的状态。
# con.rollback()


(6) 关闭游标对象和connection对象
#关闭游标对象
cur.close()

#关闭connection对象
con.close()


(7) 另开一个终端，查询数据
import sqlite3
#创建数据库连接，返回connection对象
con=sqlite3.connect("db/sample1.db")
#创建游标对象
cur=con.cursor()
#查询数据库列表
cur.execute("select id,price,name from book")
for row in cur:
    print(row)

输出: 
('003', 28, '大学计算机多媒体')
('002', 28, '数据库基础')
('a1', 25, 'C lang')
('a2', 100, 'rust lang')

经过测试发现：没有执行 cur.commit() 的数据不会写入文件，只在当前session中有效。

该接口不会自动调用 commit()，如果关闭数据库连接前未调用 commit() 方法，所有的更改将丢失，切记！




(8) 查询语句 
# 查询数学成绩大于25元的书
sql_text_3 = "SELECT * FROM book WHERE price>25"
cur.execute(sql_text_3)
# 获取查询结果
cur.fetchall()
# [('003', '大学计算机多媒体', 28), ('002', '数据库基础', 28), ('a2', 'rust lang', 100)]

获取查询结果一般可用.fetchone()方法（获取第一条），或者用.fetchall()方法（获取所有条）。


查询的方法:
  cur.execute("sql语句")  执行该sql语句
  cur.execute("sql语句", 参数表)  执行带参数的sql语句
  cur.executemany("sql语句", 参数表) 根据参数执行多次sql语句
  cur.executescript("sql脚本")  执行sql脚本


示例:
创建一个植物数据库，包含 name, kind, home 字段
cur.execute("create table plant( name varchar(10), kind varchar(10) unique, home varchar(20))")
插入一条数据
cur.execute("insert into plant values('小兰', '猴面小龙兰', '厄瓜多尔')")
查询记录
cur.execute("select * from plant")





(9) 获取游标中的查询结果

如果前面执行了sql的查询语句，则可以调用游标对象的以下方法获取结果：
  cur.fetchone() 返回一行记录，如果没有则返回None
  cur.fetchall() 返回所有行记录，如果没有则返回空列表
  cur.fetchmany(size) 返回size行记录，如果没有记录则返回空列表


print( cur.fetchall() )



(10) 操作结束
利用连接对象提交或回滚事务
con.rollback()  回滚事务，撤销前面的操作
con.commit() 提交事务，结果保存到文件


关闭游标和数据库连接
cur.close()
con.close()










2. 基于 sqlite 的数据库通讯簿

(1) 源码
import time
import sqlite3

#打开数据库
def open_db():
    #创建SQLite数据库
    con=sqlite3.connect("db/sample2.db")
    #创建表book:包含3列，id(主键，学号),name,tel
    con.execute("create table if not exists book(id primary key,name,tel)")
    #创建游标对象
    cur=con.cursor()
    return con,cur

#查询全部信息
def show_all_db():
    print("******通讯录现有数据******")
    cur_1=open_db()[1]
    cur_1.execute("select id,name,tel from book")
    for row in cur_1:
        print(row)

#输入信息
def into():
    name=input("请输入姓名：")
    id=input("请输入学号：")
    tel=input("请输入电话号码：")
    return name,id,tel

#向数据库中添加内容
def add_db():
    print("******数据添加功能******")
    one=into()
    cur_1=open_db()
    cur_1[1].execute("insert into book(id,name,tel) values(?,?,?)",(one[1],one[0],one[2]))
    cur_1[0].commit()
    print("******数据添加成功******")

#删除数据库中的内容
def delete_db():
    print("******数据删除功能******")
    del_id=input("请输入删除的学号：")
    del_id = "'" + del_id + "'"
    cur_1=open_db()
    cur_1[1].execute("delete from book where id="+del_id)
    cur_1[0].commit()
    print("******数据删除成功******")
    show_all_db()
    #关闭游标对象
    cur_1[1].close()

#修改数据库中的内容
def alter_db():
    print("******数据修改功能******")
    change_id=input("请输入修改数据对应的学号：")
    change_id="'"+change_id+"'"
    cur_1=open_db()
    person=into()
    #更新数据使用 SQL 语句中的 update
    cur_1[1].execute("update book set name = ? ,tel = ? where id ="+change_id,(person[0],person[2]))
    #游标事务提交
    cur_1[0].commit()
    show_all_db()
    cur_1[1].close()

#查询数据
def query_data():
    print("******数据查询功能******")
    choice_id=input("请输入查询数据对应的学号：")
    choice_id = "'" + choice_id + "'"
    cur_1=open_db()
    cur_1[1].execute("select id,name,tel from book where id ="+choice_id)
    print("******查询结果如下******")
    for row in cur_1[1]:
        print(row)
    cur_1[1].close()

# 是否继续
def conti(a):
    choice=input("是否继续：(1 表示继续，0 表示退出)")
    if choice=='1':
        a=1
    else :
        a=0
    return a

'''
主函数菜单内容：
1.向数据库中添加内容
2.删除数据库中的内容
3.修改数据库中的内容
4.查询数据库中的内容
选择你想要的进行的操作：

'''
if __name__=="__main__":
    start_clock=time.time()
    a=1
    print("******数据库通讯录******")
    while a:
        content="""
1.向数据库中添加内容
2.删除数据库中的内容
3.修改数据库中的内容
4.查询数据库中的内容
5.显示数据库中的内容
6.关闭   数据库系统
选择你想要的进行的操作：     
        """
        choice=input(content)
        if choice=="1":
            add_db()
            conti(a)
        elif choice=="2":
            delete_db()
            conti(a)
        elif choice=="3":
            alter_db()
            conti(a)
        elif choice=="4":
            query_data()
            conti(a)
        elif choice=="5":
            show_all_db()
            conti(a)
        elif choice=="6":
            a=0
        else:
            print("输入错误，请重新输入")

    end_clock=time.time()
    print("RUNNING TIME:%s s"%(end_clock-start_clock))

(2) 测试
把内容复制到交互界面中，按菜单操作：先输入1添加内容，然后5显示全部内容。





Ref:
https://zhuanlan.zhihu.com/p/407131061
https://zhuanlan.zhihu.com/p/80756486
每个操作 https://zhuanlan.zhihu.com/p/145914429
https://zhuanlan.zhihu.com/p/73353849
https://www.runoob.com/sqlite/sqlite-python.html






========================================
|-- SQL 语句
----------------------------------------
1. sql语句以分号结尾，不区分大小写。两个减号--表示注释。

select * from person;
select * from person where id in(200,400);
select * from person where id=200 or id=400; #和上一条等价

select * from person where addr='sz' and id>300;

select * from person where id between 200 and 400; #是一个闭区间[a,b]

like模糊查找
select * from person where addr like 's%';


not 否定词
select * from person where id not in(200,400);
select * from person where id not between 200 and 400; #(,200) 和 (400,)


order by 排序, 默认升序 asc，加desc后缀表示降序
select * from person where addr like 's%' order by id;
select * from person where addr like 's%' order by id desc;


(2) 事务
sqlite> begin;
sqlite> delete from person where id<300;
sqlite> rollback; #回滚事务


(3) 函数与聚合
length() 返回字符串的长度
lower() 转为小写
upper() 转为大写

> select id,upper(name) from person;


avg() 某列的平均值
count() 某列的行
max() 某列的最大值
min() 某列的最小值
sum() 某列的和

平均分
> select avg(score) from person;

得分最高的
> select id,name,max(score) from person;

不及格人数
> select count(score) from person where score<60;


(4) 分组 
统计男女人数
> select * from person;
> select sex,count(sex) from person group by sex;

统计男女的平均成绩
> select sex,avg(score) from person group by sex;

统计男女的最高成绩
> select name,sex,max(score) from person group by sex;

having 过滤分组 
> select sex,avg(score) from person group by sex having avg(score)>75;



(5) 约束（主键、唯一约束、检查约束）

主键：primary key
设置某列 数据唯一 一张表只能有一个主键。

唯一约束：unique
设置某列 数据唯一 一张表可以有多个唯一约束。

检查约束: check
对具体的列进行数据判断

$ sqlite3 ::memory::
sqlite> create table stu(id int primary key, name text unique, age int check(age>0));
sqlite> .tables
stu
sqlite> insert into stu values(1, 'lucy', 18);
sqlite> insert into stu values(1, 'bob', 18);
Error: UNIQUE constraint failed: stu.id   #报错: id主键必须唯一，插入失败

sqlite> select * from stu;
1|lucy|18

sqlite> .headers on
sqlite> select * from stu;
id|name|age
1|lucy|18
sqlite> .mode column
sqlite> select * from stu;
id          name        age       
----------  ----------  ----------
1           lucy        18      


sqlite> insert into stu values(2, 'lucy', 18);
Error: UNIQUE constraint failed: stu.name  #名字也不能重复，插入失败

sqlite> insert into stu values(2, 'lucy2', -18);
Error: CHECK constraint failed: stu  #年龄不能是负数，插入失败


(6) 多表联合查询
> select person.id, name, addr, score, year from person, grade 
	where person.id==grade.id;



(7) 视图 虚拟表
语法: create view 视图名 as 语句;


> create view PersonGrade as 
  select person.id,name,score,year from person,grade 
  where person.id=grade.id;

> .tables 
能看到新虚拟表名 PersonGrade

> select * from PersonGrade;
> select year,avg(score) from PersonGrade group by year; #求每年的平均分

删除视图: drop view 视图名;







2. 触发器
创建触发器的语法

craete trigger 触发器的名  [after/before]  [insert,update,delete]  on 表名
begin
    多条语句；
end;


示例:
create trigger tg_delete after delete on person 
begin
	delete from grade where id=old.id;
end;

说明: 当执行 delete from persons where id=1; 语句，事件触发，执行 begin 和 end 之间的sql语句（回调函数）。
注意：old.id 等价于 person.id，但此处不能写成 person.id，old.id代表删除行的id（id代表两个表的关联列）


> create trigger delete_trigger after delete on person
begin
	delete from grade where id=old.id;
end;

> select * from person;
> select * from grade;
> delete from person where name='tom';
> select * from grade;


(2) 案例：写入日志

> create table log(time text, date text);
> create trigger log_trigger before update on person
  begin 
  insert into log values( datetime('now'), old.name );
  end;
> update person set name='tom' where id=1;
> select * from log;
> select * from person;





3. 索引(简单了解)

创建索引: create index 索引名 on 表名(列名);
查看索引: .indices
删除索引: drop index 索引名;



4. 其他查询命令

sqlite> .table
查看当前数据库指定表：

sqlite>.tables table_name  
查看当前数据库所有表的建表(CREATE)语句：

sqlite> .schema
查看指定数据表的建表语句：

sqlite> .schema requires
查看所有表结构及索引信息：

sqlite> select * from sqlite_master;
查看所有表结构信息：







ref:
https://zhuanlan.zhihu.com/p/117433402
http://1000zx.cn/it/5581.html
https://www.runoob.com/sqlite/sqlite-create-table.html





========================================
第8章　数据压缩与归档340
----------------------------------------





========================================
|-- gzip—读写GNU Zip文件: .gz 文件
----------------------------------------
1. 
import gzip

#(1) 压缩文件示例
def compress_file(input_path, output_path):
    with open(input_path, 'rb') as file_in:
        with gzip.open(output_path, 'wb') as file_out:
            file_out.writelines(file_in)
# test
input_file = 'example.txt'
compressed_file = 'example.txt.gz'

compress_file(input_file, compressed_file)
print(f'文件 {input_file} 压缩完成，压缩后的文件为 {compressed_file}')


#(2) 解压缩文件示例

def decompress_file(input_path, output_path):
    with gzip.open(input_path, 'rb') as file_in:
        with open(output_path, 'wb') as file_out:
            file_out.writelines(file_in)

# test
decompressed_file = 'example_decompressed.txt'
decompress_file(compressed_file, decompressed_file)
print(f'文件 {compressed_file} 解压缩完成，解压缩后的文件为 {decompressed_file}')








========================================
|-- zipfile—ZIP归档访问: 文件压缩为 zip、解压 zip文件
----------------------------------------
1. 示例代码

import zipfile

#(1) 压缩 为 zip
def filesToZip(fromFiles, zip_filename = "b01.zip"):
	# 打开压缩文件
	zf= zipfile.ZipFile(zip_filename, mode="w")

	# 要压缩的文件
	#zf.write("a.txt", arcname="a.txt") #没有arcname的话,压缩的文件会带路径
	#zf.write("a2.txt", arcname="a2__.txt")
	#zf.write("test.py")
	for file in fromFiles:
		zf.write(file)

	# 关闭压缩文件
	zf.close()
# test
#filesToZip(["a.txt", "test.py"], "b02.zip")



#(2) 从zip解压到文件夹
def zip2Dir(fromZip, dirName="."):
	zf = zipfile.ZipFile(fromZip)
	zf.extractall(dirName)
	zf.close()
# test
#zip2Dir("b02.zip", "tmp")

print("End2")




(3) 从 zip 中解压 .gz 后缀的文件到指定文件夹
import zipfile
#import os
import gzip

def decompress_file(input_path, output_path):
    with gzip.open(input_path, 'rb') as file_in:
        with open(output_path, 'wb') as file_out:
            file_out.writelines(file_in)


def getVCF_from_gz_zip(gz_zip_filename, to_dir="./", verbose=False):
    import os
    zf = zipfile.ZipFile(gz_zip_filename)
    gzlist=zf.namelist()

    # 指定文件夹
    dirname=to_dir
    # 如果没有，则新建
    if not os.path.exists(dirname):
        os.mkdir(dirname)

    for gzFilename in gzlist:
        if gzFilename.endswith(".gz"):
            #日志
            if verbose:
                print("extract and decompress file: " + gzFilename)

            #1. 解压该 zip 子文件
            zf.extract(gzFilename, path=dirname)

            #2. 解压 gz 文件
            input_path = os.path.join(dirname, gzFilename)
            output_path = os.path.join(dirname, gzFilename[0: (len(gzFilename)-3)])
            decompress_file(input_path, output_path)

            #3. 删除原gz文件
            import os
            os.remove(input_path)
    zf.close()



inputfile_gz_zip="/home/marigold/data/web/docs/R_2023_11_08_08_30_05_user_S5XL-00186-411-ZLYYAmpliseq-20231107.vcf.zip"
inputfile_gz_zip

getVCF_from_gz_zip(inputfile_gz_zip, "01", True)






ref: 
https://huxiaomu.blog.csdn.net/article/details/131659485












========================================
第12章　Internet
----------------------------------------



========================================
|-- urlparse—分解URL( python3 中叫做 urllib.parse)
----------------------------------------
1. 测试
import urllib.parse

rs = urllib.parse.urlparse('https://i.cnblogs.com:8001/post/edit/102?opt=1&active=1#footer')

print(rs)
print(rs.path) #/post/edit/102
print( rs.path.startswith("/post/edit") )
print(rs.port)


输出结果:
$ python a4_get_path_from_URL.py 
ParseResult(scheme='https', netloc='i.cnblogs.com:8001', path='/post/edit/102', params='', query='opt=1&active=1', fragment='footer')
/post/edit/102
True
8001











========================================
第9章　加密
----------------------------------------



========================================
|-- hashlib—密码散列
----------------------------------------
1. 实例

import hashlib

md5 = hashlib.md5()  #这里可以选择 hashlib.sha1()
md5.update('123456'.encode('utf-8'))
print(md5.hexdigest())  #e10adc3949ba59abbe56e057f20f883e


(2) 包装为函数
def calc_md5(passwd):
	import hashlib
	md5 = hashlib.md5()
	md5.update(passwd.encode('utf-8'))
	return md5.hexdigest()

print( calc_md5("123456") )
print( calc_md5("123456" + "xjo,jw!e56.f") ) #add salt







2. 使用 shell 的 md5sum 加密 

$ echo "123456" | md5sumf447b20a7fcbf53a5d5be013ea0b15af  -

为什么和程序的结果不一行呢？
https://blog.csdn.net/liuxiao723846/article/details/51555530
因为echo默认末尾添加换行符\n，去掉换行符可以加-n参数。

$ echo "123456"
123456
$ echo -n "123456"
123456$

$ echo -n "123456" | md5sum | cut -d " " -f 1
e10adc3949ba59abbe56e057f20f883e






ref:
https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744










========================================
第14章 应用构建模块
----------------------------------------




========================================
|-- configparser - 处理配置文件 .ini 
----------------------------------------
1. 读取配置文件
$ cat config.ini 
[mysql]
host = 192.168.0.3
port = 3306
user = root
password = 123456
database = SYSDB
[db]
db_host = 127.0.0.1
db_port = 69
db_user = root
db_pass = root
host_port = 69


(1) 常用函数
import configparser
config = configparser.ConfigParser()
config.read("config.ini", encoding="utf-8")
#运行结果
print("sectioin: ",config.sections())
print( "db/ options: ", config.options("db") )

r = config.get("db", "db_host")
print("item: ", r)



(2) 封装为函数
import configparser

def getConf(section, item, file_path="config.ini"):
	cf = configparser.ConfigParser()   # configparser类来读取config文件
	cf.read(file_path)
	return cf.get(section, item)


$ cat config.ini
[style]
txt = markLight
#light: simple/softGreen/wiki/grey/
#dark: ubuntu1 / coffee / mark/

markdown = MarkDown3





2. 官方文档
https://pypi.org/project/configparser/
短小精悍的文档 https://www.cnblogs.com/zhou2019/p/10599953.html
	https://zhuanlan.zhihu.com/p/474333228

读写配置文件 
	https://www.cnblogs.com/liuzhanghao/p/11081610.html
	https://blog.csdn.net/qq_40741855/article/details/105945080
	https://www.cnblogs.com/plf-Jack/p/11170284.html













========================================
|-- logging—报告状态、错误和信息消息: 记录日志，可以代替 print 调试程序 //todo 没理顺，颜色怎么加？
----------------------------------------

如果需要在多个地方大量查看中间变量，使用print就不方便了，python引入了 logging 模块来记录日志信息。

print也可以输入日志，logging相对print来说更好控制输出在哪个地方，怎么输出及控制消息级别来过滤掉那些不需要的信息。


https://docs.python.org/zh-cn/3/library/logging.html

对于Python，有一个成熟的的模块可以快速、有效地实现日志功能，这个模块就是logging模块。
	它几行代码就可以启动日志功能
	而且可以很方便地调整输出信息的格式。
	可以基于命令、基于配置文件进行设置。



0. 日常使用 (注：193 ok, Y station not 交互 but ok in script;)

# coding:utf-8
import logging

# 配置
logging.basicConfig(format='%(asctime)s - %(filename)s[line:%(lineno)d] - [%(levelname)s]: %(message)s', 
    level=logging.DEBUG)

# 记录示例
cores=20
logging.debug('Start multiprocess using %s cores' % cores)

try:
    command_line="2/0"
    2/0
except Exception as e:
    logging.error('{}: {}'.format(command_line, e))


标准输出:
2021-10-08 11:19:34,860 - test.py[line:9] - [DEBUG]: Start multiprocess using 20 cores
2021-10-08 11:19:34,860 - test.py[line:15] - [ERROR]: 2/0: division by zero


(2) 如果不输出，尝试获取实例再输出
import logging
# 配置
logging.basicConfig(format='%(asctime)s - %(filename)s[line:%(lineno)d] - [%(levelname)s]: %(message)s',     level=logging.DEBUG)

#使用
logger = logging.getLogger()
logger.info(u"log - info")



彩色日志:
$ pip3 install coloredlogs -i https://pypi.douban.com/simple/
$ coloredlogs --demo
2022-10-07 15:33:00 YStation coloredlogs.demo[1438132] DEBUG message with level debug (10)
2022-10-07 15:33:01 YStation coloredlogs.demo[1438132] INFO message with level info (20)
2022-10-07 15:33:02 YStation coloredlogs.demo[1438132] WARNING message with level warning (30)
2022-10-07 15:33:03 YStation coloredlogs.demo[1438132] ERROR message with level error (40)
2022-10-07 15:33:04 YStation coloredlogs.demo[1438132] CRITICAL message with level critical (50)













1. 日志级别
import logging  # 引入logging模块
# 将信息打印到控制台上
logging.debug(u"log - debug")
logging.info(u"log - info")
logging.warning(u"log - warning")
logging.error(u"log - error")
logging.critical(u"log - critical")

输出 
WARNING:root:log - warning
ERROR:root:log - error
CRITICAL:root:log - critical

(1) 上面可以看到只有后面三个能打印出来。默认生成的root logger的level是logging.WARNING，低于该级别的就不输出了。

(2)级别排序:CRITICAL > ERROR > WARNING > INFO > DEBUG

debug : 打印全部的日志,详细的信息,通常只出现在诊断问题上

info : 打印info,warning,error,critical级别的日志,确认一切按预期运行

warning : 打印warning,error,critical级别的日志,一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”),这个软件还能按预期工作

error : 打印error,critical级别的日志,更严重的问题,软件没能执行一些功能

critical : 打印critical级别,一个严重的错误,这表明程序本身可能无法继续运行


(3) 设置显示级别
如果需要显示低于WARNING级别的内容，可以设置日志级别来显示：

import logging

logging.basicConfig(level=logging.NOTSET)  # 设置日志级别
# 等价于 logging.basicConfig(level=logging.DEBUG)
logging.debug(u"如果设置了日志级别为NOTSET,那么这里可以采取debug、info的级别的内容也可以显示在控制台上了")








2. logging模块四大组件
日志器（Logger）:产生日志的一个接口。
处理器（Handler）：把产生的日志发送到相应的目的地。
过滤器（Filter）：更精细的控制那些日志输出。
格式器（Formatter）：对输出的信息进行格式化。

常用函数有：
setFormatter() 设置Formatter


Logging.Handler：Handler基于日志级别对日志进行分发，如设置为WARNING级别的Handler只会处理WARNING及以上级别的日志。
Logging.Formatter：这个类配置了日志的格式，在里面自定义设置日期和时间，输出日志的时候将会按照设置的格式显示内容。
Logging.Logger：Logger是Logging模块的主体，进行以下三项工作：
	- 为程序提供记录日志的接口
	- 判断日志所处级别，并判断是否要过滤
	- 根据其日志级别将该条日志分发给不同handler

(1) Logger: 产生一个日志
Logger1 = logging.Logger(__name__)  #<Logger __main__ (NOTSET)>

实例化: Logger2 = logging.getLogger()  #<RootLogger root (WARNING)>  这个貌似权限更大

常用函数有：
Logger.setLevel() 设置日志级别
Logger.addHandler() 和 Logger.removeHandler() 添加和删除一个Handler
Logger.addFilter() 添加一个Filter,过滤作用

常用方法
Logger.setLevel() #设置日志器将会处理的日志消息的最低严重级别
Logger.addHandler()
Logger.moveHander() #上面两个函数，为该logger对象添加和移除一个handler对象
Logger.addFilter()
Logger.removeFilter() #上面两个函数，为该logger对象添加和移除一个filter对象
Logger.debug: #产生一条debug级别的日志，同理，info,error的日志消息
Logger.exception #创建一个类似于Logger.error的日志消息
Logger.log() #获取一个明确的日志level参数类型创建一个日志记录

(2) Handler: 把log发送到指定位置
方法: setLevel\setFormat\addFilter\removeFilter

不需要直接使用，Handler是基类
logging.StreamHandler #将日志消息发送到输出到Stream。如std.out,std.err或任何file-like对
logging.FileHandler #将日志消息发送到磁盘文件。默认情况下文件大小会无限增长
logging.handlers.RotatongFileHandler #将日志消息发送到磁盘文件，并支持日志文件按大小切割
logging.handlers.TimeRotatingFileHandler #将日志消息发送到磁盘文件，并支持日志文件按时间切割
logging.handlers.HTTPHandler #将日志消息以GET或POST的方式发送到一个指定email地址
logging.NullHandler  #该Handler实例会忽略error message 通常想被想使用logging的library

例1:
fh=logging.FileHandler('test.log') # 将日志写入到test.log文件 
fh.setLevel(logging.DEBUG) # 并且需要指定写入的内容严重级别

例2:
ch=logging.StreamHandler() # 将日志写入控制台
ch.setLevel(loggong.DEBUG) # 并且需要指定写入的内容严重级别


(3) 









3、日志输出-控制台，输出时间戳、文件名、行号

import logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')  # logging.basicConfig函数对日志的输出格式及方式做相关配置

# 由于日志基本配置中级别设置为DEBUG，所以一下打印信息将会全部显示在控制台上
logging.debug('debug message')
logging.warning('warning message')
logging.error('error message')


上面代码通过logging.basicConfig函数进行配置了日志级别和日志内容输出格式；因为级别为DEBUG，所以会将DEBUG级别以上的信息都输出显示再控制台上。

2021-10-08 10:13:10,821 - test.py[line:6] - DEBUG: debug message
2021-10-08 10:13:10,821 - test.py[line:7] - WARNING: warning message
2021-10-08 10:13:10,821 - test.py[line:8] - ERROR: error message







4、日志输出-文件
在工作目录同级新建目录 Logs/。

import logging
import os.path
import time

# 第一步，创建一个logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)  # Log等级总开关

# 第二步，创建一个handler，用于写入日志文件
rq = time.strftime('%Y%m%d%H%M', time.localtime(time.time()))
log_path = os.path.dirname(os.getcwd()) + '/Logs/'
log_name = log_path + rq + '.log'
logfile = log_name

fh = logging.FileHandler(logfile, mode='w')
fh.setLevel(logging.DEBUG)  # 输出到file的log等级的开关


# 第三步，定义handler的输出格式
formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")
fh.setFormatter(formatter)

# 第四步，将logger添加到handler里面
logger.addHandler(fh)
# 日志
logger.debug('logger debug message')
logger.info('logger info message')
logger.warning('logger warning message')
logger.error('logger error message')
logger.critical('logger critical message')


$ cat ../Logs/202110081023.log
2021-10-08 10:23:35,719 - test.py[line:27] - INFO: logger info message
2021-10-08 10:23:35,736 - test.py[line:28] - WARNING: logger warning message
2021-10-08 10:23:35,736 - test.py[line:29] - ERROR: logger error message
2021-10-08 10:23:35,736 - test.py[line:30] - CRITICAL: logger critical message




5、日志输出-控制台和文件

只要在输入到日志中的第二步和第三步插入一个handler输出到控制台：
# 创建一个handler，用于输出到控制台
ch = logging.StreamHandler()
ch.setLevel(logging.WARNING)  # 输出到console的log等级的开关

第3步和第4步分别加入以下代码即可
ch.setFormatter(formatter)
logger.addHandler(ch)




6、format常用格式说明

%(levelno)s: 打印日志级别的数值
%(levelname)s: 打印日志级别名称
%(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]
%(filename)s: 打印当前执行程序名
%(funcName)s: 打印日志的当前函数
%(lineno)d: 打印日志的当前行号
%(asctime)s: 打印日志的时间
%(thread)d: 打印线程ID
%(threadName)s: 打印线程名称
%(process)d: 打印进程ID
%(message)s: 打印日志信息




7、捕捉异常,用traceback记录

import os
import time
import logging

# 创建一个logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)  # Log等级总开关

# 创建一个handler，用于写入日志文件
rq = time.strftime('%Y%m%d%H%M', time.localtime(time.time()))
log_path = os.path.dirname(os.getcwd()) + '/Logs/'
log_name = log_path + rq + '.log'
logfile = log_name
fh = logging.FileHandler(logfile, mode='w')
fh.setLevel(logging.DEBUG)  # 输出到file的log等级的开关

# 定义handler的输出格式
formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")
fh.setFormatter(formatter)
logger.addHandler(fh)

# 使用logger.XX来记录错误,这里的"error"可以根据所需要的级别进行修改
try:
    open('/path/to/does/not/exist', 'rb')
except (SystemExit, KeyboardInterrupt):
    raise
except Exception as e:
    logger.error('Failed to open file', exc_info=True)

日志文件
$ cat ../Logs/202110081036.log
2021-10-08 10:36:53,044 - test.py[line:28] - ERROR: Failed to open file
Traceback (most recent call last):
  File "G:\pyTest\logging\test.py", line 24, in <module>
    open('/path/to/does/not/exist', 'rb')
FileNotFoundError: [Errno 2] No such file or directory: '/path/to/does/not/exist'


如果需要将日志不上报错误，仅记录，可以将exc_info=False，回显如下：
$ cat ../Logs/202110081038.log
2021-10-08 10:38:52,717 - test.py[line:28] - ERROR: Failed to open file




8、多模块调用logging,日志输出顺序

$ cat warning_output.py
import logging

def write_warning():
    logging.warning(u"记录文件warning_output.py的日志")


$ cat error_output.py
import logging

def write_error():
    logging.error(u"记录文件error_output.py的日志")



$ cat main.py
import logging
import warning_output
import error_output

def write_critical():
    logging.critical(u"记录文件main.py的日志")

warning_output.write_warning()  # 调用warning_output文件中write_warning方法
write_critical()
error_output.write_error()  # 调用error_output文件中write_error方法


输出信息
$ python main.py
WARNING:root:记录文件warning_output.py的日志
CRITICAL:root:记录文件main.py的日志
ERROR:root:记录文件error_output.py的日志

从上面来看，日志的输出顺序和模块执行顺序是一致的。




9、日志滚动和过期删除(按时间)

# coding:utf-8
import logging
import time
import re
from logging.handlers import TimedRotatingFileHandler
from logging.handlers import RotatingFileHandler

def backroll():
    #日志打印格式
    log_fmt = '%(asctime)s\tFile \"%(filename)s\",line %(lineno)s\t%(levelname)s: %(message)s'
    formatter = logging.Formatter(log_fmt)

    #创建TimedRotatingFileHandler对象
    log_file_handler = TimedRotatingFileHandler(filename="ds_update", 
        when="S", interval=3, backupCount=3)
    # M 2 表示2min检查一次

    #log_file_handler.suffix = "%Y-%m-%d_%H-%M.log"
    #log_file_handler.extMatch = re.compile(r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}.log$")
    log_file_handler.setFormatter(formatter)
    logging.basicConfig(level=logging.INFO)
    log = logging.getLogger()
    log.addHandler(log_file_handler)

    #循环打印日志
    log_content = "test log"
    count = 0
    while count < 20:
        log.error(log_content + " "+ str(count))
        time.sleep(1)
        count = count + 1
    log.removeHandler(log_file_handler)

if __name__ == "__main__":
    backroll()
    print("==end--")


(2) 参数解释: 
filename：日志文件名的prefix；

when：是一个字符串，用于描述滚动周期的基本单位，字符串的值及意义如下： 
	“S”: Seconds 
	“M”: Minutes 
	“H”: Hours 
	“D”: Days 
	“W”: Week day (0=Monday) 
	“midnight”: Roll over at midnight

interval: 滚动周期，单位有when指定，比如：when=’D’,interval=1，表示每天产生一个日志文件
backupCount: 表示日志文件的保留个数



(3) 查看输出文件
$ ls -lth ds_update*
-rw-r--r-- 1 admin 197121 134 10月  8 11:12 ds_update
-rw-r--r-- 1 admin 197121 201 10月  8 11:12 ds_update.2021-10-08_11-11-59
-rw-r--r-- 1 admin 197121 201 10月  8 11:11 ds_update.2021-10-08_11-11-56
-rw-r--r-- 1 admin 197121 200 10月  8 11:11 ds_update.2021-10-08_11-11-53

$ cat ds_update
2021-10-08 11:12:02,630 File "test.py",line 29  ERROR: test log 18
2021-10-08 11:12:03,637 File "test.py",line 29  ERROR: test log 19




ref:
https://www.cnblogs.com/xianyulouie/p/11041777.html
https://zhuanlan.zhihu.com/p/476549020















========================================
|-- sched—定时事件调度器，及 threading 模块的 Timer 
----------------------------------------
sched.scheduler()函数是Python标准库sched中必不可少的一部分。使用该函数，可以创建一个调度器对象，用于在指定时间执行指定函数。


1. sched
(1) 实例
import sched, time

from datetime import datetime
def now():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def print_time():    
    print("执行定时任务")

#第1步 调度器对象
s = sched.scheduler(time.time, time.sleep)
#第2步 设置任务
s.enter(2, 1, print_time)  # 在5秒后执行print_time
#第3步 开始任务
s.run()
# 注意 sched 模块不是循环的，一次调度被执行后就 Over 了，如果想再执行，请再次 enter


参数解释
schedule = sched.scheduler(time.time, time.sleep)
	第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。

schedule.enter(cycle, 0, work, (cycle,))
	函数介绍：enter四个参数分别为：间隔时间、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，函数的参数。




(2) 综合案例
import sched,time
from datetime import datetime
schedule = sched.scheduler(time.time, time.sleep)

def now():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# 1 编写一个任务：通过定时器调用自己，实现死循环调用
def work(interval, cycle):
    '''
    定义需要执行的工作任务
    :param cycle: 时间周期，单位：秒
    :return:
    '''
    print('当前执行时间：', now())
    # 将任务函数加到定时任务中
    if cycle>0:
        print('任务执行状态：', 'success (%d)' % cycle)
        schedule.enter(interval, 0, work, (interval, cycle-1,))
    else:
        print('退出定时任务')
        return None

# 2 编写触发任务的函数
def exec_work(interval, cycle=10):
    # 添加触发函数
    schedule.enter(0, 0, work, (interval, cycle,))
    # 启动任务
    schedule.run()

# 3. main 函数执行
if __name__ == '__main__':
    exec_work(1, 3)
    print("main task", now())
    time.sleep(5)
    print("main task 2", now())

输出:
$ python3 test.py 
当前执行时间： 2023-08-11 14:55:46
任务执行状态： success (3)
当前执行时间： 2023-08-11 14:55:47
任务执行状态： success (2)
当前执行时间： 2023-08-11 14:55:48
任务执行状态： success (1)
当前执行时间： 2023-08-11 14:55:49
退出定时任务
main task 2023-08-11 14:55:49
main task 2 2023-08-11 14:55:54




(3) 带阻塞主进程的定时任务
import time
import sched
s = sched.scheduler(time.time, time.sleep)  # 生成调度器

from datetime import datetime
def now():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def print_time(n=0):
    print("= In FN = : " + now() + " (%d)" % n)

def print_some_times():
    print("print_time: " + now() + " ==##== fn start")
    s.enter(0, 1, print_time, ()) #相对于函数开始时间
    s.enter(5, 1, print_time, (5,)) #相对于函数开始时间
    s.enter(10, 1, print_time, (10,)) #相对于函数开始时间
    s.run() #运行
    #time.sleep(7)  # 阻塞主线程,等待调度程序执行完毕，再执行后面内容
    print("print_time: " + now() + " ==##== fn end")

if __name__ == '__main__':
    print_some_times()

print("= The end =:" + now())

输出:
print_time: 2023-08-11 12:05:33 ==##== fn start
= In FN = : 2023-08-11 12:05:33 (0)
= In FN = : 2023-08-11 12:05:38 (5)
= In FN = : 2023-08-11 12:05:43 (10)
print_time: 2023-08-11 12:05:43 ==##== fn end
= The end =:2023-08-11 12:05:43






2. 使用 threading 模块的 Timer 
在多线程场景中，会有线程安全问题，run()函数会阻塞主线程。官方建议使用 threading.Timer 类代替。

(2) 非阻塞定时任务
就是定时任务在另一个进程中。

import time
from threading import Timer

from datetime import datetime
def now():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def print_time(n=0):
    print("= In FN = : " + now() + " (%d)" % n)

def print_some_times():
    print("print_time: " + now() + " ==##== fn start")
    Timer(0, print_time, ()).start() #相对于函数开始时间
    Timer(5, print_time, (5,)).start() #相对于函数开始时间
    Timer(10, print_time, (10,)).start() #相对于函数开始时间
    #time.sleep(7)  # 阻塞主线程,等待调度程序执行完毕，再执行后面内容
    print("print_time: " + now() + " ==##== fn end")

if __name__ == '__main__':
    print_some_times()

print("= The end =:" + now())

输出结果：
print_time: 2023-08-11 11:52:25 ==##== fn start
= In FN = : 2023-08-11 11:52:25 (0)
print_time: 2023-08-11 11:52:25 ==##== fn end
= The end =:2023-08-11 11:52:25
= In FN = : 2023-08-11 11:52:30 (5)
= In FN = : 2023-08-11 11:52:35 (10)




(3) 通过把定时器放到新线程，达到后台执行的目的

import time
import threading

def print_time():
    print("当前时间：", time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
    t = threading.Timer(10, print_time)
    t.start()

# 将定时器的执行放到新的线程中
t = threading.Thread(target=print_time)
t.start()

# 模拟主线程被阻塞
print("start main")
while True:
    pass

输出: 每10s输出一行。
当前时间： 2023-08-15 09:08:30
start main
当前时间： 2023-08-15 09:08:40
当前时间： 2023-08-15 09:08:50
当前时间： 2023-08-15 09:09:00
当前时间： 2023-08-15 09:09:10










3. 取消事件
利用enter()和enterabs()返回一个引用事件用来取消它。


(1) 在新线程中执行定时器

import sched,time, threading
scheduler = sched.scheduler(time.time, time.sleep)

from datetime import datetime
def now():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

#建立一个全局 线程计数器
counter = 0

def increment_counter(name):
    global counter
    print('EVENT:', now(), name)
    counter += 1
    print('NOW:', counter)

print('START:', now() )
e1 = scheduler.enter(2, 1, increment_counter, ('E1',))
e2 = scheduler.enter(3, 1, increment_counter, ('E2',))

# 开始一个线程执行事件
t = threading.Thread(target=scheduler.run)
t.start()

# 在主线程,取消第一个预定事件
scheduler.cancel(e1) #取消与否，可以测试输出 ##########

print(">>> before join:", now() )
# 等待线程调度程序完成运行
t.join() #也可以注释掉，不等待分支线程
print(">>> after join:", now() )

输出:
$ python3 test.py 
START: 2023-08-11 15:11:35
>>> before join: 2023-08-11 15:11:35
EVENT: 2023-08-11 15:11:38 E2
NOW: 1
>>> after join: 2023-08-11 15:11:38





(2) 除了上面介绍的scheduler方法，还有一些其他方法：

scheduler.empty()
判断队列是否为空

scheduler.queue
只读属性，返回一个即将到达的事件列表(按到达事件排序)，每个事件都是有 time 、 priority 、 action 、 argument 组成的 namedtuple 。


ref:
https://docs.python.org/zh-cn/3/library/sched.html






========================================
非标准库的包: Mistune - convert Markdown formatted text into HTML
----------------------------------------
https://mistune.lepture.com/en/latest/guide.html

最新的版本:

import mistune
mistune.html(YOUR_MARKDOWN_TEXT)

或者:
markdown = mistune.create_markdown(escape=False)
markdown('<div>hello</div>')
# ==>
'<div>hello</div>'





========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------

