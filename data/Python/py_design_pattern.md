**py 设计模式 Design Pattern**



# 设计模式分为3大类
理论部分见 `JavaEE/设计模式`;

设计模式: [概述](http://c.biancheng.net/view/1317.html), [博客1](https://blog.csdn.net/qq_33905217/category_10605219.html), [博客2](https://blog.csdn.net/slx3320612540/category_6903175.html), [博客3](https://blog.csdn.net/lovelion/category_738451.html), [目录和实例名](https://blog.csdn.net/LoveLion/article/details/108293317), [菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

23种设计模式的py代码及注释: [py1](http://www.pythontip.com/python-patterns/detail/abstract_factory), [py2](https://www.cnblogs.com/welan/category/1193037.html)

My python codes: [Github](https://github.com/DawnEve/learngit/tree/master/Python3/pythonCodeGit/day20-design-pattern)


虽然是c++/java等强类型语言的概念，不过通用性还是很强的。值得研究和磨练思维模式。

设计模式分为三大类：
1. 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
2. 结构型模式，共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
3. 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

其实还有两类：并发型模式和线程池模式。


设计模式需要几个阶段的学习，
没有大量项目经验的时候学习，可能只是了解，
当有了一些项目场景的时候，才会深刻体会到其中的奥妙。

接下来一段时间陆续把设计模式过一遍，整理出来，理解设计模式还是很重要的。










# 创建型模式(5类): 工厂、单例/原型/抽象工厂/建造者


## 工厂 Factory 模式
缺点是增加新类后，要修改工厂方法，违反了开闭原则。

## 工厂方法（Factory Method）模式
定义一个用于创建产品的接口，由子类决定生产什么产品。

更符合开-闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可



## 单例模式 Singleton

单例模式，就是某一个类只有一个实例存在。

使用模块
```
# 定义文件 singleton/mysingleton.py
class Singleton(object):
    def foo(self):
        pass
singleton = Singleton()

# 使用
from singleton.mysingleton import singleton
```



## 抽象工厂（AbstractFactory）模式
提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
为创建相关对象或者互相依赖的对象提供一个接口，并且不指出他们的实现类。

在面向对象的编程中 “抽象” 这个词的具体含义指的是 “不考虑具体怎样实现，而是仅关注接口（API）” 的状态。例如，抽象方法并不定义方法的具体实现，而是仅只确定了方法的名字和签名（参数的类型和个数）。


在 Template Method 模式和 Builder 模式中，`子类这个一层负责方法的具体实现`。在 Abstract Factory 模式中也是一样的。在子类这一层中有具体的工厂，它负责将具体的零件组装成为具体的产品。


## 建造者（Builder）模式
将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

separate the construction of a complex object from its representation so that the same construction process can create different representations.
即：将复杂对象的构造与它的表示分开，这样可以在相同的构造过程中创建不同的表示形式。


## 原型(Prototype)模式

原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。

使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

在需要重复地创建相似对象时可以考虑使用原型模式。
使用原型模式复制对象不会调用类的构造方法。











# 结构型模式(7类): (类/对象)适配器/代理/桥接/装饰/外观/享元/组合

## 适配器（Adapter）模式

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

- 类适配器（继承）
- 对象适配器（组合，常用）

[使用场景](https://blog.csdn.net/zxt0601/article/details/52848004)：
1. 系统需要使用现有的类，而这些类的接口不符合系统的需要。
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
3. 需要一个统一的输出接口，而输入端的类型不可预知。






## 代理（Proxy）模式

为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。


## 桥接（Bridge）模式
Decouple an abstraction from its implementation so that the two can vary independently.
将抽象和实现解耦，使得两者可以独立地变化；
它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

所以桥梁模式的用意是“将抽象化与实现化脱耦，使得二者可以独立地变化。”

那么什么是脱耦呢？我们先来看一下什么是耦合。两个类之间的关系分为两种，一种是强关联一种是弱关联，强关联是在编译时期就已经确定的，无法在运行时期动态的改变的关联；弱关联是可以动态地确定并且可以在运行时期动态改变的关联。显然，Java中继承是强关联而聚合是弱关联。耦合就是两个实体的行为的某种强关联，脱耦就是指将他们之间的强关联解除，但是在桥梁模式中是指将它们之间的强关联改换成弱关联。所以桥梁模式的精髓就是尽量使用聚合/组合来实现弱关联。

通过依赖抽象实现解耦。




## 装饰（Decorator）模式

动态的给对象增加一些职责，即增加其额外的功能。



## 外观（Facade）模式
Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

比如，大酒店系统复杂，喝茶、住店、上点心、指定饭菜口味、停车等需要和不同的部门联系，为了简便，客人都是和指定的服务员直接提需求，服务员在和大酒店内部协调，这个服务员就是外观角色。

值得一提的是，在一个系统中外观角色可能不止一个，如果有需要，你可以为子系统提供一个以上的外观角色，每个外观角色的侧重点也可以不一样。

外观模式遵循了OO原则中的迪米特法则，对内封装具体细节，对外只暴露必要的接口。





## 享元（Flyweight）模式

运用共享技术来有效地支持大量细粒度对象的复用。
使用共享对象可有效地支持大量细粒度的对象。





## 组合（Composite）模式

又叫部分整体模式

将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。

关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

优点： 1、高层模块调用简单。 2、节点自由增加。

缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

注意事项：定义时为具体类。



# 行为型模式(11类)：策略/模板方法/观察者/迭代子/责任链/命令/备忘录/状态/访问者/中介者/解释器


















# *设计模式的六大原则*

总原则－开闭原则 (Open/Closed Principle)

对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

 

1、单一职责原则( Single Responsibility Principle, SRP )

不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。

 

2、里氏替换原则（Liskov Substitution Principle）

任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

 

3、依赖倒转原则（Dependence Inversion Principle）

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

 

4、接口隔离原则（Interface Segregation Principle）

每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

 

5、迪米特法则（最少知道原则）（Demeter Principle）

一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

 

6、合成复用原则（Composite Reuse Principle）

尽量首先使用合成/聚合的方式，而不是使用继承。

 

