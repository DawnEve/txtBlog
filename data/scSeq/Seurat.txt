Suerat包是大一统的scRNAseq分析包



docker:
1. aertslab/pyscenic
https://hub.docker.com/r/aertslab/pyscenic

$ docker pull aertslab/pyscenic:0.11.0



2. 查看全部函数
library(help = "Seurat")




========================================
Seurat FAQ: 宏观策略到参数细节
----------------------------------------



4. seurat包的UMAP图集群分布的影响因素
https://zhuanlan.zhihu.com/p/427166749

1).QC阶段（关键步骤），nUMI（nCount_RNA),nGene(nFeature_RNA),percent.ribo线粒体比例的筛选
2).多样本merge和integrate阶段，影响整合强度等参数的设置以及整合方法的选择（seurat自带的'FindIntegrationAnchors还是Harmony等方法）
3).ScaleData参数设置，输入的基因''features''(可变基因或全部基因），需要回归的因素''vars.to.regress''（UMI和percent.ribo）都会影响后期的UMAP结果
4).PCA数量的选择，选择合适的npca数量（elbow图的拐角处对应的参数，尝试多个npca作UMAP图找到最佳分群的npca）作为FindNeighbors的输入
5).FindClusters阶段，resolution参数（分辨率）的选择决定分群的数量，可以通过''clustree''包查看不同res的分群情况





5. 关于降维分析

Q: ElbowPlot 的拐点是指这个点后面基本持平了么？ / 請問如何判斷 elbow 拐點呢?為何不是在 3~4，而是在 9~10/ PC 拐点如何界定？
A： ElbowPlot 作图后，用肉眼观察，当曲线进入平台期，没有明显继续下降的趋势就可以了。ElbowPlot 默认显示 20 个 PC，如果发现 20 个 PC 还没有到达平台期，可以修改 ElbowPlot 函数的 ndims 参数。 RunPCA 函数默认计算 50 个 PC，如果想看更多的 PC，可以修改 RunPCA 的npcs 参数。

Q：请问 PCA 那页，是细胞和基因都做过 PCA 么？
A: 在 Seurat 中，我们是对细胞做 PCA 分析，也就是对细胞做降维分析，比如从 2000 维（基因）降到 50 维（ PC）。一般情况下，我们不会对基因做 PCA 分析。

Q： PCA 中的 embedding 可以再解释下么？
A：比如，原本每个细胞有 2000 个基因，每个基因在各个细胞中都有表达量，做了 PCA 分析后，每个细胞有 50 个 PC，每个 PC 在各个细胞中都有 embedding 值。为了便于理解，你可以把 PC 看成是整合了多个基因的 meta-gene，把 cell embedding 看成是这些 meta-gene 的表达量。

Q: 可不可以讲下 umap 和 tSNE 的主要原理？
A: UMAP 和 tSNE 都是非线性的降维方法，是把在高维空间中的点（我们人类肉眼无法观察）投射到二维平面上。这些高维空间中的点是有一定结构的，有些点彼此之间距离更近，有些点距离更远。我们在降维的过程要尽量保留这种结构，让在高维空间中更近的点，在二维平面上也更近，如果降维分析打乱了数据原有的结构，就毫无意义了。 tSNE 的目标是在降维的过程中尽量保留数据的局部结构，而 UMAP 除了能保留数据的局部结构，还能更好的保留全局结构。如果想更深入的了解它们的原理，需要一定的数学基础，我推荐两篇解释的相对简单一些的文章供你参考：

https://opentsne.readthedocs.io/en/latest/tsne_algorithm.html，

How UMAP Works - umap 0.4 documentation

Q: 我想问下数据降维为什么先做 PCA 然后再 UMAP 的降维 这俩不都是降维吗？ 不能直接 UMAP？
A： PCA 分析和 UMAP 分析的目的不同。 PCA 分析把高表达变异基因整合成若干个 PC。这样做一方面降维，一方面降低噪音。做聚类分析和 UMAP 分析的时候，使用的不是基因表达量，而是由 PCA 分析得到的 PC 的值。 UMAP 的主要作用是把高维度中距离接近的点映射到二维平面上距离相近的位置上。 UMAP 返回的结果只有两个维度（ UMAP_1 和 UMAP_2），只能用来做数据可视化。






6. 关 于 聚 类 分 析

Q: cluster ID 为何从 0 开始？是否可以从 1 开始？从 0 开始是因为有什么‘算法’方面特殊的优势么？
A： 默认 clusterID 是从 0 开始，没有特殊的优势，可以使用 RenameIdents 函数重命名clusterID。


Q： 鉴定出来的细胞类群用 UMAP 绘图后发现聚类效果很差，大量 cluster 相互交叉， 同一类群细胞弥散分布是什么原因？聚类可视化和类群划分不匹配。
A： 首先要确保聚类和 UMAP 用的 dims 参数是一致的。可以适当降低一下 FindClusters 函数的resolution 参数，减少 cluster 数目，看看能不能把相互交叉的 cluster 聚成一个 cluster。 还可以尝试 FindClusters 函数中不同的 algorithm 参数，看看聚类效果会不会改进。


Q： 请问分群过程中，是否有设置邻居个数的函数和参数？
A： FinderNeighbors 函数的 k.param 参数是用来设置 KNN 算法中最近邻的个数。


Q： 请问 finder cluster 只能使用 SNN 进行聚类么？可以有其他选择吗？ / seurat 的聚类方式除了 KNN 外还有其他的选择吗？
A： Seurat 的聚类方法是基于 SNN 图和 Louvain 或 SLM 算法， FindNeighbors 函数返回的SNN 图是在 KNN 图的基础上得来的，不支持其他方法。









ref:
https://zhuanlan.zhihu.com/p/153404850



========================================
Seurat对象的slot和处理流程： 从Suerat对象中找可用的数据
----------------------------------------
原始代码： https://github.com/satijalab/seurat/

扣数据 https://satijalab.org/seurat/seurat_clustering_tutorial_part2.html
https://github.com/satijalab/seurat/wiki/Seurat#slots


R Seurat 单细胞处理pipline 代码: https://www.cnblogs.com/shanyr/p/11683505.html

Data/Cell_2019/10X/analysis_10X.Rmd: 
	https://github.com/Martin-Villalba-lab/Data/blob/master/Cell_2019/10X/analysis_10X.Rmd
	VlnPlot(object = seurat_10X2 , features.plot = "Slc1a3" ,  do.return = TRUE) + scale_x_discrete( limits = celltypes_order )

scRNA-seq-SARS-CoV2-Viremia/Seurat_Analysis/COVID1_Seurat script.R:
	https://github.com/ArzinaJaffer/scRNA-seq-SARS-CoV2-Viremia/blob/main/Seurat_Analysis/COVID1_Seurat%20script.R
	VlnPlot(COVID1, features = 'CD19', group.by = 'seurat_clusters', sort = 'decreasing')


########## Seurat 3.2.3
> is(subT)
[1] "Seurat"
> isS4(subT)
[1] TRUE
> class(subT)
[1] "Seurat"
attr(,"package")
[1] "Seurat"

> slotNames(subT)
 [1] "assays"       "meta.data"    "active.assay" "active.ident" "graphs"      
 [6] "neighbors"    "reductions"   "images"       "project.name" "misc"        
[11] "version"      "commands"     "tools" 

> showMethods(classes="Suerat")

Function ".DollarNames":
 <not an S4 generic function>

Function "%&%":
 <not an S4 generic function>
...
> getMethod(f="show", signature="Seurat")
Method Definition:

function (object) 
{
    object <- UpdateSlots(object = object)
    assays <- FilterObjects(object = object, classes.keep = "Assay")
...







> str(pbmc2) # Suerat 3.0.1
Formal class 'Seurat' [package "Seurat"] with 12 slots
  ..@ assays      :List of 1
  .. ..$ RNA:Formal class 'Assay' [package "Seurat"] with 7 slots
  .. .. .. ..@ counts       :Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  .. .. .. .. .. ..@ i       : int [1:5760282] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. .. .. ..@ p       : int [1:226] 0 21406 44800 64936 90612 117543 134605 150609 173213 195146 ...
  .. .. .. .. .. ..@ Dim     : int [1:2] 478762 225
  .. .. .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..@ x       : num [1:5760282] 1447 3375 1469 451 1161 ...
  .. .. .. .. .. ..@ factors : list()
  .. .. .. ..@ data         :Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  .. .. .. .. .. ..@ i       : int [1:5760282] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. .. .. ..@ p       : int [1:226] 0 21406 44800 64936 90612 117543 134605 150609 173213 195146 ...
  .. .. .. .. .. ..@ Dim     : int [1:2] 478762 225
  .. .. .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..@ x       : num [1:5760282] 2.83 3.64 2.84 1.78 2.62 ...
  .. .. .. .. .. ..@ factors : list()
  .. .. .. ..@ scale.data   : num [1:478762, 1:225] -2.115 0.311 -0.89 -1.78 -0.189 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ key          : chr "rna_"
  .. .. .. ..@ var.features : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. ..@ meta.features:'data.frame':	478762 obs. of  5 variables:
  .. .. .. .. ..$ vst.mean                 : num [1:478762] 2956 2497 1841 1747 1100 ...
  .. .. .. .. ..$ vst.variance             : num [1:478762] 2894461 2351552 1304325 1759644 440198 ...
  .. .. .. .. ..$ vst.variance.expected    : num [1:478762] 2070517 1589088 991165 914030 454536 ...
  .. .. .. .. ..$ vst.variance.standardized: num [1:478762] 1.398 1.48 1.316 1.925 0.968 ...
  .. .. .. .. ..$ vst.variable             : logi [1:478762] TRUE TRUE TRUE TRUE FALSE TRUE ...
  .. .. .. ..@ misc         : NULL
  ..@ meta.data   :'data.frame':	225 obs. of  6 variables:
  .. ..$ orig.ident     : Factor w/ 1 level "BC_HeLa": 1 1 1 1 1 1 1 1 1 1 ...
  .. ..$ nCount_RNA     : num [1:225] 910697 991632 763838 1109857 1137588 ...
  .. ..$ nFeature_RNA   : int [1:225] 21406 23394 20136 25676 26931 17062 16004 22604 21933 14631 ...
  .. ..$ percent.mt     : num [1:225] 0 0 0 0 0 0 0 0 0 0 ...
  .. ..$ RNA_snn_res.0.5: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...
  .. ..$ seurat_clusters: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...


  .. ..## 这里可以放每个细胞的分类（来自于哪个病人(4/5/6); 来自于哪种类型的组织(B/T/N); 确定的细胞类型 ）
  .. ..$ location       : chr [1:4844] "CRCN" "CRCP" "CRCP" "CRCP" ...
  .. ..$ Tsample        : chr [1:4844] "CRC4" "CRC4" "CRC4" "CRC4" ...
  .. ..$ sample         : chr [1:4844] "CRC4N" "CRC4P" "CRC4P" "CRC4P" ...
  .. ..$ Tcelltype      : Factor w/ 9 levels "T cell","NK",..: 1 1 1 1 1 1 1 1 1 1 ...
  .. ..$ oldcluster     : chr [1:4844] "T cell-1" "T cell-1" "T cell-1" "T cell-1" ...
  
  ..@ active.assay: chr "RNA"
  ..@ active.ident: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...
  .. ..- attr(*, "names")= chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  ..@ graphs      :List of 2
  .. ..$ RNA_nn :Formal class 'Graph' [package "Seurat"] with 6 slots
  .. .. .. ..@ i       : int [1:4500] 0 1 2 3 4 5 6 7 8 10 ...
  .. .. .. ..@ p       : int [1:226] 0 29 57 72 86 101 136 167 182 201 ...
  .. .. .. ..@ Dim     : int [1:2] 225 225
  .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ x       : num [1:4500] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. .. ..@ factors : list()
  .. ..$ RNA_snn:Formal class 'Graph' [package "Seurat"] with 6 slots
  .. .. .. ..@ i       : int [1:13115] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. ..@ p       : int [1:226] 0 46 92 122 152 182 233 286 320 355 ...
  .. .. .. ..@ Dim     : int [1:2] 225 225
  .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ x       : num [1:13115] 1 0.818 0.29 0.29 0.29 ...
  .. .. .. ..@ factors : list()
  ..@ neighbors   : list()
  ..@ reductions  :List of 2
  .. ..$ pca :Formal class 'DimReduc' [package "Seurat"] with 8 slots
  .. .. .. ..@ cell.embeddings           : num [1:225, 1:50] 36 34.5 63.2 72.8 58.3 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..$ : chr [1:50] "PC_1" "PC_2" "PC_3" "PC_4" ...
  .. .. .. ..@ feature.loadings          : num [1:46386, 1:50] 0.0381 0.0379 0.0385 0.0378 0.0374 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. .. ..$ : chr [1:50] "PC_1" "PC_2" "PC_3" "PC_4" ...
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num [1:50] 20.5 19 18.3 17.7 17.3 ...
  .. .. .. ..@ key                       : chr "PC_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num [1:46386, 1:20] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. .. .. ..$ : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. .. .. .. ..$ : chr [1:20] "PC1" "PC2" "PC3" "PC4" ...
  .. .. .. .. .. ..@ fake.reduction.scores  : num [1:46300, 1:20] -0.001198 -0.00154 -0.00143 0.000949 -0.004263 ...
  .. .. .. .. .. ..@ empirical.p.values.full: logi [1, 1] NA
  .. .. .. .. .. ..@ overall.p.values       : num [1:20, 1:2] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. .. .. ..$ : NULL
  .. .. .. .. .. .. .. ..$ : chr [1:2] "PC" "Score"
  .. .. .. ..@ misc                      :List of 1
  .. .. .. .. ..$ total.variance: num 37923
  
  
  ## 这里也可以放置 tsne 的降维结果
  .. ..$ tsne:Formal class 'DimReduc' [package "Seurat"] with 9 slots
  .. .. .. ..@ cell.embeddings           : num [1:4844, 1:2] 24.9 17.4 31.5 30.1 16.9 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:4844] "CRCSZ04N_cell5925576" "CRCSZ04P_cell347880" "CRCSZ04P_cell841868" "CRCSZ04P_cell898327" ...
  .. .. .. .. .. ..$ : chr [1:2] "FIt_1" "FIt_2"
  .. .. .. ..@ feature.loadings          : num[0 , 0 ] 
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num(0) 
  .. .. .. ..@ key                       : chr "FIt_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num[0 , 0 ] 
  .. .. .. .. .. ..@ fake.reduction.scores  : num[0 , 0 ] 
  .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] 
  .. .. .. .. .. ..@ overall.p.values       : num[0 , 0 ] 
  .. .. .. ..@ misc                      : list()
  .. .. .. ..@ NA                        : NULL
  
  
  .. ..$ umap:Formal class 'DimReduc' [package "Seurat"] with 8 slots
  .. .. .. ..@ cell.embeddings           : num [1:225, 1:2] -9.07 -9.37 -9.85 -10.11 -9.73 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..$ : chr [1:2] "UMAP_1" "UMAP_2"
  .. .. .. ..@ feature.loadings          : num[0 , 0 ] 
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num(0) 
  .. .. .. ..@ key                       : chr "UMAP_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num[0 , 0 ] 
  .. .. .. .. .. ..@ fake.reduction.scores  : num[0 , 0 ] 
  .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] 
  .. .. .. .. .. ..@ overall.p.values       : num[0 , 0 ] 
  .. .. .. ..@ misc                      : list()
  ..@ project.name: chr "BC_HeLa"
  ..@ misc        : list()
  ..@ version     :Classes 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 3 0 1
  ..@ commands    :List of 9
  .. ..$ NormalizeData.RNA       :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "NormalizeData.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-08-14 10:08:05"
  .. .. .. ..@ call.string: chr [1:2] "NormalizeData(pbmc, normalization.method = \"LogNormalize\", " "    scale.factor = 10000)"
  .. .. .. ..@ params     :List of 5
  .. .. .. .. ..$ assay               : chr "RNA"
  .. .. .. .. ..$ normalization.method: chr "LogNormalize"
  .. .. .. .. ..$ scale.factor        : num 10000
  .. .. .. .. ..$ margin              : num 1
  .. .. .. .. ..$ verbose             : logi TRUE
  .. ..$ FindVariableFeatures.RNA:Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindVariableFeatures.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:21:07"
  .. .. .. ..@ call.string: chr "FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 46386)"
  .. .. .. ..@ params     :List of 12
  .. .. .. .. ..$ assay              : chr "RNA"
  .. .. .. .. ..$ selection.method   : chr "vst"
  .. .. .. .. ..$ loess.span         : num 0.3
  .. .. .. .. ..$ clip.max           : chr "auto"
  .. .. .. .. ..$ mean.function      :function (mat, display_progress)  
  .. .. .. .. ..$ dispersion.function:function (mat, display_progress)  
  .. .. .. .. ..$ num.bin            : num 20
  .. .. .. .. ..$ binning.method     : chr "equal_width"
  .. .. .. .. ..$ nfeatures          : num 46386
  .. .. .. .. ..$ mean.cutoff        : num [1:2] 0.1 8
  .. .. .. .. ..$ dispersion.cutoff  : num [1:2] 1 Inf
  .. .. .. .. ..$ verbose            : logi TRUE
  .. ..$ ScaleData.RNA           :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "ScaleData.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:33:21"
  .. .. .. ..@ call.string: chr "ScaleData(pbmc, features = all.genes)"
  .. .. .. ..@ params     :List of 10
  .. .. .. .. ..$ features          : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. ..$ assay             : chr "RNA"
  .. .. .. .. ..$ model.use         : chr "linear"
  .. .. .. .. ..$ use.umi           : logi FALSE
  .. .. .. .. ..$ do.scale          : logi TRUE
  .. .. .. .. ..$ do.center         : logi TRUE
  .. .. .. .. ..$ scale.max         : num 10
  .. .. .. .. ..$ block.size        : num 1000
  .. .. .. .. ..$ min.cells.to.block: num 225
  .. .. .. .. ..$ verbose           : logi TRUE
  .. ..$ RunPCA.RNA              :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "RunPCA.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:33:33"
  .. .. .. ..@ call.string: chr "RunPCA(pbmc2, features = VariableFeatures(object = pbmc2))"
  .. .. .. ..@ params     :List of 11
  .. .. .. .. ..$ assay          : chr "RNA"
  .. .. .. .. ..$ features       : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. ..$ npcs           : num 50
  .. .. .. .. ..$ rev.pca        : logi FALSE
  .. .. .. .. ..$ weight.by.var  : logi TRUE
  .. .. .. .. ..$ verbose        : logi TRUE
  .. .. .. .. ..$ ndims.print    : int [1:5] 1 2 3 4 5
  .. .. .. .. ..$ nfeatures.print: num 30
  .. .. .. .. ..$ reduction.name : chr "pca"
  .. .. .. .. ..$ reduction.key  : chr "PC_"
  .. .. .. .. ..$ seed.use       : num 42
  .. ..$ JackStraw.RNA.pca       :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "JackStraw.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:25:16"
  .. .. .. ..@ call.string: chr "JackStraw(pbmc2, num.replicate = 100)"
  .. .. .. ..@ params     :List of 7
  .. .. .. .. ..$ reduction    : chr "pca"
  .. .. .. .. ..$ assay        : chr "RNA"
  .. .. .. .. ..$ dims         : num 20
  .. .. .. .. ..$ num.replicate: num 100
  .. .. .. .. ..$ prop.freq    : num 0.01
  .. .. .. .. ..$ verbose      : logi TRUE
  .. .. .. .. ..$ maxit        : num 1000
  .. ..$ ScoreJackStraw          :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "ScoreJackStraw"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:27:05"
  .. .. .. ..@ call.string: chr "ScoreJackStraw(pbmc2, dims = 1:20)"
  .. .. .. ..@ params     :List of 4
  .. .. .. .. ..$ reduction   : chr "pca"
  .. .. .. .. ..$ dims        : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. ..$ score.thresh: num 1e-05
  .. .. .. .. ..$ do.plot     : logi FALSE
  .. ..$ FindNeighbors.RNA.pca   :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindNeighbors.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:34:31"
  .. .. .. ..@ call.string: chr "FindNeighbors(pbmc2, dims = 1:10)"
  .. .. .. ..@ params     :List of 11
  .. .. .. .. ..$ reduction   : chr "pca"
  .. .. .. .. ..$ dims        : int [1:10] 1 2 3 4 5 6 7 8 9 10
  .. .. .. .. ..$ assay       : chr "RNA"
  .. .. .. .. ..$ k.param     : num 20
  .. .. .. .. ..$ compute.SNN : logi TRUE
  .. .. .. .. ..$ prune.SNN   : num 0.0667
  .. .. .. .. ..$ nn.eps      : num 0
  .. .. .. .. ..$ verbose     : logi TRUE
  .. .. .. .. ..$ force.recalc: logi FALSE
  .. .. .. .. ..$ do.plot     : logi FALSE
  .. .. .. .. ..$ graph.name  : chr [1:2] "RNA_nn" "RNA_snn"
  .. ..$ FindClusters            :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindClusters"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:34:33"
  .. .. .. ..@ call.string: chr "FindClusters(pbmc2, resolution = 0.5)"
  .. .. .. ..@ params     :List of 8
  .. .. .. .. ..$ graph.name    : chr "RNA_snn"
  .. .. .. .. ..$ modularity.fxn: num 1
  .. .. .. .. ..$ resolution    : num 0.5
  .. .. .. .. ..$ algorithm     : num 1
  .. .. .. .. ..$ n.start       : num 10
  .. .. .. .. ..$ n.iter        : num 10
  .. .. .. .. ..$ random.seed   : num 0
  .. .. .. .. ..$ verbose       : logi TRUE
  .. ..$ RunUMAP.RNA.pca         :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "RunUMAP.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:38:08"
  .. .. .. ..@ call.string: chr "RunUMAP(pbmc2, dims = 1:8)"
  .. .. .. ..@ params     :List of 18
  .. .. .. .. ..$ dims                : int [1:8] 1 2 3 4 5 6 7 8
  .. .. .. .. ..$ reduction           : chr "pca"
  .. .. .. .. ..$ assay               : chr "RNA"
  .. .. .. .. ..$ n.neighbors         : int 30
  .. .. .. .. ..$ n.components        : int 2
  .. .. .. .. ..$ metric              : chr "correlation"
  .. .. .. .. ..$ learning.rate       : num 1
  .. .. .. .. ..$ min.dist            : num 0.3
  .. .. .. .. ..$ spread              : num 1
  .. .. .. .. ..$ set.op.mix.ratio    : num 1
  .. .. .. .. ..$ local.connectivity  : int 1
  .. .. .. .. ..$ repulsion.strength  : num 1
  .. .. .. .. ..$ negative.sample.rate: int 5
  .. .. .. .. ..$ seed.use            : int 42
  .. .. .. .. ..$ angular.rp.forest   : logi FALSE
  .. .. .. .. ..$ verbose             : logi TRUE
  .. .. .. .. ..$ reduction.name      : chr "umap"
  .. .. .. .. ..$ reduction.key       : chr "UMAP_"
  
  
  ## 补充一个tsne的
  .. .. .. ..@ NA         : NULL
  .. ..$ RunTSNE                 :Formal class 'SeuratCommand' [package "Seurat"] with 5 slots
  .. .. .. ..@ name       : chr "RunTSNE"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2020-12-07 13:28:07"
  .. .. .. ..@ call.string: chr [1:3] "RunTSNE(Sdata, tsne.method = \"FIt-SNE\", dims = 1:50, initialization = PCAinit, " "    learning_rate = 1000, fast_tsne_path = \"/home/wangxf/data/tools/FIt-SNE-master/bin/fast_tsne\", " "    reduction.key = \"FIt_SNE\")"
  .. .. .. ..@ params     :List of 9
  .. .. .. .. ..$ reduction     : chr "pca"
  .. .. .. .. ..$ cells         : chr [1:62288] "CRCSZ04N_cell5925576" "CRCSZ04P_cell347880" "CRCSZ04P_cell841868" "CRCSZ04P_cell898327" ...
  .. .. .. .. ..$ dims          : int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. ..$ seed.use      : num 1
  .. .. .. .. ..$ tsne.method   : chr "FIt-SNE"
  .. .. .. .. ..$ add.iter      : num 0
  .. .. .. .. ..$ dim.embed     : num 2
  .. .. .. .. ..$ reduction.name: chr "tsne"
  .. .. .. .. ..$ reduction.key : chr "FIt_SNE"
  .. .. .. ..@ NA         : NULL
  
  
  ..@ tools       : list()
#





1. Suerat 3.0.1
(1)#UMAP分类标签的位置
pbmc2@assays$RNA@scale.data
table(pbmc2@active.ident)

pbmc2@active.ident[pbmc2@active.ident==1]
c0=names(pbmc2@active.ident[pbmc2@active.ident==0]) #获取cluster0的cell ID

(2) 使用Idents函数
head(Idents(pbmc2), 5)
## c01ROW07 c01ROW12 c01ROW24 c01ROW31 c01ROW35 
##        2        2        2        2        2 
## Levels: 0 1 2



(3) 画dotplot，合并0和1为一个新的 cluster BC: 
# 合并0和1为BC，标记2为HeLa
pbmc11.2=pbmc11
pbmc11.2@meta.data$seurat_clusters=as.character(pbmc11.2@meta.data$seurat_clusters)
table(pbmc11.2@meta.data$seurat_clusters)
#0  1  2 
#87 82 56
pbmc11.2@meta.data$seurat_clusters[pbmc11.2@meta.data$seurat_clusters %in% c(0,1)]="BC"; # rep("BC", 87+82)
pbmc11.2@meta.data$seurat_clusters[pbmc11.2@meta.data$seurat_clusters %in% c(2)]="HeLa" #rep("HeLa", 56)
#
table(pbmc11.2@meta.data$seurat_clusters)
#BC HeLa 
#169   56
# 再覆盖一次active.ident，就可以继续画 dotplot 了
pbmc11.2@active.ident=pbmc11.2@meta.data$seurat_clusters

#
DotPlotPDF(BC_HeLa.scoreGenes,"13-BC_vs_HeLa---top5",width=10,height=4.5,pbmc=pbmc11.2) 





2. 常用查询
(1) 查HVG个数
length(VariableFeatures(pbmc2)) #6000


(2) 查feature个数
summary(pbmc2$nFeature_RNA)
#Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#2669    5664    6426    6368    7100   11619 













#######################
# 2.0版本的
#######################
1. slot raw.data原始count数据

> br5@raw.data[1:4,1:4]
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA               1               0             180               0
7SK                     0               0               5               0
A1BG                    2               0               1               0
A1BG-AS1                0               5               0               0



2. slot data 保存的normalization后的数据，其实就是CPM。
就是除以cell内总count，再乘以一个系数（默认是10000）
> br5@data[1:4,1:4]
4 x 4 sparse Matrix of class "dgCMatrix"
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA     0.003348308      .              0.428460466               .
7SK           .                .              0.014748829               .
A1BG          0.006685442      .              0.002967219               .
A1BG-AS1      .                0.01511409     .                         .

> 1/sum(br5@raw.data[,1])*1e4
[1] 0.00335392

> 5/sum(br5@raw.data[,2])*1e4
[1] 0.01522888



3. slot scale.data 是做过标准化后的数据，此后的分析都是基于缩放过的数据。
ScaleData(): Scaling the data and removing unwanted sources of variation。

> br5@scale.data[1:2,1:4]
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA      -0.5576100      -0.6386333       1.6995682      -0.3316566
7SK            -0.3512039      -0.3441605       0.7499054      -0.3786910








========================================
|-- 入门教程：Seurat - Guided Clustering Tutorial //todo
----------------------------------------
官方教程页 http://satijalab.org/seurat/get_started.html


1. Seurat包：单细胞测序的各个方面
http://hemberg-lab.github.io/scRNA.seq.course/seurat-chapter.html [作废 2019.12.24check]
https://scrnaseq-course.cog.sanger.ac.uk/website/index.html
功能包含QC, analysis, and exploration of scRNA-seq data。

(2). [10xG官方推荐]Seurat is an R package designed for QC, analysis, and exploration of single cell RNA-seq data. 
http://satijalab.org/seurat/
推荐页：https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/rkit




2. 安装
官网： https://satijalab.org/seurat/install.html

install.packages('devtools')
# Replace '2.3.0' with your desired version
devtools::install_version(package = 'Seurat', version = package_version('2.3.1'))
library(Seurat)

高版本的装不上：
configure: error: The version of hdf5 installed on your system is not sufficient. Please ensure that at least version 1.8.13 is installed


(2) 还可以使用 docker 版本的
https://hub.docker.com/repository/docker/dawneve/rstudio

$ docker run -d -p 5000:8787 -v /home/wangjl/data/dockerRstudio:/home/rstudio \
    -v /home/wangjl/data/dockerRstudio/R_lib_4.0:/home/rstudio/R/x86_64-pc-linux-gnu-library/4.0 \
    -e ROOT=TRUE \
    -e PASSWORD=yourpasswordhere dawneve/rstudio:Seurat




3. 教程
https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html

我自己的练手项目:
https://github.com/DawnEve/scRNAseqCode









========================================
|-- 多组数据的整合、批次效应 //todo
----------------------------------------

https://satijalab.org/seurat/v3.2/integration.html








========================================
|-- 细胞周期对聚类的影响: Cell-Cycle Scoring and Regression 细胞周期打分和回归
----------------------------------------
1. Cell-Cycle Scoring and Regression
#https://satijalab.org/seurat/cell_cycle_vignette.html
https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html

We demonstrate how to mitigate the effects of cell cycle heterogeneity in scRNA-seq data by calculating cell cycle phase scores based on canonical markers, and regressing these out of the data during pre-processing. 

两种策略，一种是完全regression，另一种是只针对 S和G2M 的差异回归。 



2.重点：周期相关基因list怎么找？https://www.biostars.org/p/364214/
List of Human Cell Cycle Stage Specific Genes() 
and this list from Qiagen.
(https://www.qiagen.com/it/resources/resourcedetail?id=0ee18e97-d445-4fd7-9aa4-0ef4bece124f&lang=en)


#########
paper提到的两篇重点参考文献http://science.sciencemag.org/content/352/6282/189
To characterize cycling cells more precisely, we used gene signatures that have previously been shown to denote G1/S or G2/M phases in both synchronization (20) and single-cell (16) experiments in cell lines. 

##[16]M. L. Whitfield, G. Sherlock, A. J. Saldanha, J. I. Murray, C. A. Ball, K. E. Alexander, J. C. Matese, C. M. Perou, M. M. Hurt, P. O. Brown, D. Botstein, Botstein, Identification of genes periodically expressed in the human cell cycle and their expression in tumors. Mol. Biol. Cell 13, 1977–2000 (2002). doi:10.1038/nrc1802 pmid:12058064 
高被引522次：https://www.ncbi.nlm.nih.gov/pubmed?linkname=pubmed_pubmed_citedin&from_uid=12058064
data: http://genome-www.stanford.edu/Human-CellCycle/Hela/

##[20]E. Z. Macosko, A. Basu, R. Satija, J. Nemesh, K. Shekhar, M. Goldman, I. Tirosh, A. R. Bialas, N. Kamitaki, E. M. Martersteck, J. J. Trombetta, D. A. Weitz, J. R. Sanes, A. K. Shalek, A. Regev, S. A. McCarroll, Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets. Cell 161, 1202–1214 (2015). doi:10.1016/j.cell.2015.05.002 pmid:26000488 
#########
[20]的补充材料“Cell Cycle Analysis of HEK and 3T3 Cells”写fig4是怎么做的。
https://ars.els-cdn.com/content/image/1-s2.0-S0092867415005498-mmc1.pdf

Gene sets reflecting five phases of the HeLa cell cycle (G1/S, S, G2/M, M and M/G1) were taken from
Whitfield et al. (Whitfield et al., 2002) (Table S2)


(1)BrdU:https://baike.baidu.com/item/BrdU/8395857?fr=aladdin
PI:https://baike.baidu.com/item/pi/4004256




refer
讨论细胞周期基因： https://www.cnblogs.com/leezx/p/8648363.html
R包ccRemover： https://cran.r-project.org/web/packages/ccRemover/vignettes/ccRemover_tutorial.html







========================================
|-- Seurat包取细胞群体的子集: subset()/FetchData()等函数
----------------------------------------
1. 取子集

https://stackoverflow.com/questions/60195840/how-to-make-a-subset-of-cells-expressing-certain-gene-in-seurat-r

Dbh.pos <- Idents(my.data, WhichCells(my.data, expression = Dbh > 0, slot = "data"))
Dbh.neg <- Idents(my.data, WhichCells(my.data, expression = Dbh == 0, slot = "data"))


(1)You can subset from the counts matrix, below I use pbmc_small dataset from the package, and I get cells that are CD14+ and CD14-:

> library(Seurat)
> CD14_expression = GetAssayData(	object = pbmc_small, assay = "RNA", slot = "data")["CD14",]
> head(CD14_expression,30)
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA 
      0.000000       0.000000       0.000000       0.000000       0.000000 
TCTGATACACGTGT TGGTATCTAAACAG GCAGCTCTGTTTCT GATATAACACGCAT AATGTTGACAGTCA 
      0.000000       0.000000       0.000000       0.000000       0.000000 
#

(2)Getting the ids can be done using which :
> pos_ids = names(which(CD14_expression>0))
> neg_ids = names(which(CD14_expression==0))


(3)Subsetting of the data can be done with:
> pos_cells = subset(pbmc_small,cells=pos_ids)
> neg_cells = subset(pbmc_small,cells=neg_ids)

2)
cd14.mono <- subset(immune.combined, idents = 'CD14 Mono')

scObject <- subset(x = scObject.all, idents = c("Endothelial"), invert = FALSE);

neu_colon <- subset(neu_colon, idents = c(1,2,3), invert=T) #选择除了1,2,3 之外的群。



(4)A bit dumb, but I guess this is one way to check whether it works:
> FeaturePlot(pos_cells,"CD14")
> FeaturePlot(neg_cells,"CD14")


(5)
> GEX = pbmc_small
I am getting the gene expression, then make a dataframe with two columns, and this information is directly added on the Seurat object.

> GENE="Cd8a"
> EXPR = GetAssayData(object=GEX,assay="RNA",slot="data")[GENE,]
> EXPR_df=data.frame( positive= EXPR > 0, negative = EXPR == 0)
> names(GEX)<-paste0( c("positive_","negative_"),GENE)
> GEX <- AddMetaData(GEX,metadata=EXPR_df)

This approach allows then to subset nicely, with more flexibility.

> GEX_subset <- subset(GEX, annot == "T cell" & negative_Cd8a)








2. 疑难杂症 
subset()不能放到函数function(){}中使用: https://github.com/satijalab/seurat/issues/4058

(1) 如果想每个样本取子集，使用 downsample 参数:
pbmc.small <- subset(pbmc3, downsample = 100) # Downsample to a maximum of 100 cells per identity class


(2) 如果非要在函数中取子集呢: https://github.com/satijalab/seurat/issues/1053#issuecomment-454512002

Much like R's subset function, subset.Seurat is designed for interactive use only. While we currently don't offer a programmatic way to subset Seurat objects based on feature expression, this can be accomplished relatively easily using which and FetchData

expr <- FetchData(object = object, vars = var1)
object[, which(x = expr > low & expr < high)]


2) 非交互式
var1 <- "GeneName"
expr <- FetchData(object = object, vars = var1)
object[, which(x = expr > low & expr < high)]


# 循环中不能直接用WhichCells/subset,可以用上面的方式
library(Seurat)
gene_cells = list()
items <-c( 'LGALS3', 'S100A11')
for (gene1 in items)
{
    if (gene1 %in% rownames(pbmc_small))
    {
        expr <- FetchData(object = pbmc_small, vars = gene1)
        gene_cells[[gene1]] <- pbmc_small[, which(x = expr >= 0.5)]
    }
}
gene_cells #两个 seurat 对象。






(3) 按基因表达量选择
# Can I create a Seurat object based on expression of a feature or value in object metadata?
subset(pbmc, subset = MS4A1 > 1)




ref:
https://satijalab.org/seurat/archive/v3.0/interaction_vignette.html
https://www.jianshu.com/p/99cb6dc8de45



========================================
|-- 使用 AddModuleScore 计算 disassociation induced genes (DIG) 打分
----------------------------------------
1.paper: Pan-cancer single-cell landscape of tumor-infiltrating T cells 补充材料

From the first run clustering, in multiple datasets, we identified clusters with marker genes associated with tissue dissociation operation including heat shock protein-encoding genes (50). Recurrent marker genes of these tissue dissociation-related clusters, i.e. those that showed 25 significant high expression in more than 40% tissue dissociation-related clusters, were defined as disassociation induced genes (DIG) and were included in the gene blacklist after the first run clustering.

To minimize the impact of those processes, the S phase score and G2M phase score were calculated with function CellCycleScoring, and the DIG score was calculated with function AddModuleScore. Then those scores were regressed out in the Seurat pipeline.












========================================
Seurat 229个函数名： ls("package:Seurat")
----------------------------------------

> ls("package:Seurat")
  [1] "AddAzimuthResults"               "AddMetaData"                     "AddModuleScore"                 
  [4] "AggregateExpression"             "AnnotateAnchors"                 "as.CellDataSet"                 
  [7] "as.Graph"                        "as.Neighbor"                     "as.Seurat"                      
 [10] "as.SingleCellExperiment"         "as.sparse"                       "Assays"                         
 [13] "AugmentPlot"                     "AverageExpression"               "BarcodeInflectionsPlot"         
 [16] "BGTextColor"                     "BlackAndWhite"                   "BlueAndRed"                     
 [19] "BoldTitle"                       "BuildClusterTree"                "CalcPerturbSig"                 
 [22] "CalculateBarcodeInflections"     "CaseMatch"                       "cc.genes"                       
 [25] "cc.genes.updated.2019"           "CellCycleScoring"                "Cells"                          
 [28] "CellsByIdentities"               "CellScatter"                     "CellSelector"                   
 [31] "CenterTitle"                     "CollapseEmbeddingOutliers"       "CollapseSpeciesExpressionMatrix"
 [34] "ColorDimSplit"                   "CombinePlots"                    "Command"                        
 [37] "CreateAssayObject"               "CreateDimReducObject"            "CreateSCTAssayObject"           
 [40] "CreateSeuratObject"              "CustomDistance"                  "CustomPalette"                  
 [43] "DarkTheme"                       "DEenrichRPlot"                   "DefaultAssay"                   
 [46] "DefaultAssay<-"                  "DietSeurat"                      "DimHeatmap"                     
 [49] "DimPlot"                         "DiscretePalette"                 "Distances"                      
 [52] "DoHeatmap"                       "DotPlot"                         "ElbowPlot"                      
 [55] "Embeddings"                      "ExpMean"                         "ExpSD"                          
 [58] "ExpVar"                          "FastRowScale"                    "FeatureLocator"                 
 [61] "FeaturePlot"                     "FeatureScatter"                  "FetchData"                      
 [64] "FilterSlideSeq"                  "FindAllMarkers"                  "FindClusters"                   
 [67] "FindConservedMarkers"            "FindIntegrationAnchors"          "FindMarkers"                    
 [70] "FindMultiModalNeighbors"         "FindNeighbors"                   "FindSpatiallyVariableFeatures"  
 [73] "FindSubCluster"                  "FindTransferAnchors"             "FindVariableFeatures"           
 [76] "FoldChange"                      "FontSize"                        "GeneSymbolThesarus"             
 [79] "GetAssay"                        "GetAssayData"                    "GetImage"                       
 [82] "GetIntegrationData"              "GetResidual"                     "GetTissueCoordinates"           
 [85] "GetTransferPredictions"          "GroupCorrelation"                "GroupCorrelationPlot"           
 [88] "HoverLocator"                    "HTODemux"                        "HTOHeatmap"                     
 [91] "HVFInfo"                         "Idents"                          "Idents<-"                       
 [94] "IFeaturePlot"                    "Images"                          "Index"                          
 [97] "Index<-"                         "Indices"                         "IntegrateData"                  
[100] "IntegrateEmbeddings"             "Intensity"                       "IsGlobal"                       
[103] "ISpatialDimPlot"                 "ISpatialFeaturePlot"             "JackStraw"                      
[106] "JackStrawPlot"                   "JS"                              "JS<-"                           
[109] "Key"                             "Key<-"                           "L2CCA"                          
[112] "L2Dim"                           "LabelClusters"                   "LabelPoints"                    
[115] "LinkedDimPlot"                   "LinkedFeaturePlot"               "Load10X_Spatial"                
[118] "LoadAnnoyIndex"                  "Loadings"                        "Loadings<-"                     
[121] "LoadSTARmap"                     "LocalStruct"                     "LogNormalize"                   
[124] "LogSeuratCommand"                "LogVMR"                          "Luminance"                      
[127] "MappingScore"                    "MapQuery"                        "MetaFeature"                    
[130] "MinMax"                          "Misc"                            "Misc<-"                         
[133] "MixingMetric"                    "MixscapeHeatmap"                 "MixscapeLDA"                    
[136] "MULTIseqDemux"                   "Neighbors"                       "NNPlot"                         
[139] "NoAxes"                          "NoGrid"                          "NoLegend"                       
[142] "NormalizeData"                   "PCAPlot"                         "PCASigGenes"                    
[145] "PCHeatmap"                       "PercentageFeatureSet"            "PlotClusterTree"                
[148] "PlotPerturbScore"                "PolyDimPlot"                     "PolyFeaturePlot"                
[151] "PredictAssay"                    "PrepLDA"                         "PrepSCTIntegration"             
[154] "Project"                         "Project<-"                       "ProjectDim"                     
[157] "ProjectUMAP"                     "PurpleAndYellow"                 "Radius"                         
[160] "Read10X"                         "Read10X_h5"                      "Read10X_Image"                  
[163] "ReadMtx"                         "ReadParseBio"                    "ReadSlideSeq"                   
[166] "ReadSTARsolo"                    "Reductions"                      "RegroupIdents"                  
[169] "RelativeCounts"                  "RenameCells"                     "RenameIdents"                   
[172] "ReorderIdent"                    "RestoreLegend"                   "RidgePlot"                      
[175] "RotatedAxis"                     "RowMergeSparseMatrices"          "RunCCA"                         
[178] "RunICA"                          "RunLDA"                          "RunMarkVario"                   
[181] "RunMixscape"                     "RunMoransI"                      "RunPCA"                         
[184] "RunSPCA"                         "RunTSNE"                         "RunUMAP"                        
[187] "SampleUMI"                       "SaveAnnoyIndex"                  "ScaleData"                      
[190] "scalefactors"                    "ScaleFactors"                    "ScoreJackStraw"                 
[193] "SCTransform"                     "SCTResults"                      "SCTResults<-"                   
[196] "SelectIntegrationFeatures"       "SetAssayData"                    "SetIdent"                       
[199] "SetIntegrationData"              "SeuratAxes"                      "SeuratTheme"                    
[202] "SpatialDimPlot"                  "SpatialFeaturePlot"              "SpatiallyVariableFeatures"      
[205] "SpatialPlot"                     "SpatialTheme"                    "SplitObject"                    
[208] "StashIdent"                      "Stdev"                           "SubsetByBarcodeInflections"     
[211] "SVFInfo"                         "Tool"                            "Tool<-"                         
[214] "TopCells"                        "TopFeatures"                     "TopNeighbors"                   
[217] "TransferData"                    "TSNEPlot"                        "UMAPPlot"                       
[220] "UpdateSCTAssays"                 "UpdateSeuratObject"              "UpdateSymbolList"               
[223] "VariableFeaturePlot"             "VariableFeatures"                "VariableFeatures<-"             
[226] "VizDimLoadings"                  "VlnPlot"                         "WhichCells"                     
[229] "WhiteBackground" 




========================================
下载 Suerat 官方网站镜像 (2021.9.23)
----------------------------------------
总体计划: 使用远端 docker 下载需要的东西，使用 nginx 展示内容并下载
https://labs.play-with-docker.com/


1. 下载一个 nginx ，方便预览文件

$ docker pull nginx
$ docker run --rm -it nginx nginx -version
nginx version: nginx/1.21.3

还是使用带版本号的靠谱，后期可重复。
$ docker pull nginx:1.21
$ docker run --rm -it nginx:1.21 nginx -version
nginx version: nginx/1.21.3


$ cd /home/tom/
$ cat nginx.config  #注意改nginx监听的端口号了
server {
    listen       8008;
    listen  [::]:8008;
    server_name  localhost;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
		
        # list files
        autoindex on; 
        autoindex_exact_size on; 
        autoindex_localtime on; 
    }
}


把本地映射到docker内的web目录
$ docker run --rm -d -p 8000:8008 \
--mount type=bind,source=/home/tom/,target=/usr/share/nginx/html/ \
--mount type=bind,source=/home/tom/nginx.config,target=/etc/nginx/conf.d/default.conf \
nginx:1.21

下载命令: 约10Mb。
## curl https://www.dropbox.com/s/3dby3bjsaf5arrw/cell_cycle_vignette_files.zip -o test.zip -J -L -k

$ wget -r -p -np -k http://www.satijalab.org/seurat
内置的wget不好用，不支持-r参数！！





2. 重新搜一个 docker 版的 wget

$ docker pull mwendler/wget
$ alias wget='docker run -v $PWD:/work --workdir=/work --rm mwendler/wget' #把当前目录挂载到容器的工作目录


$ wget -r -p -np -k --no-check-certificate http://www.satijalab.org/seurat
参数解释:
-r, –recursive（递归） specify recursive download
-k, –convert-links（转换链接、将 HTML 页面中的链接转换为相对链接即本地链接）
	make links in downloaded HTML or CSS point to local files
-p, –page-requisites（下载所有的图片等页面显示所需的内容）
	 get all images, etc. needed to display HTML page
-np, –no-parent（不追溯至父级）
	don't ascend to the parent directory
–restrict-file-names=nocontrol 用来解决中文乱码问题（需要可以试试）




(2) 使用 wget 同步网站镜像
$ wget -m -L –reject = http://www.satijalab.org/seurat

一般情况下使用-m参数就可以：
$ wget -m --no-check-certificate https://www.satijalab.org/seurat #这个就下载一个首页文件。

$ wget -m --no-check-certificate https://satijalab.org/seurat/index.html #好多文件，应该是都下下来了！

参数解释：
-m,  --mirror      shortcut for -N -r -l inf --no-remove-listing
-L,  --relative    follow relative links only

可以设置正则表达式过滤链接
-R,  --reject=LIST               comma-separated list of rejected extensions
   --accept-regex=REGEX        regex matching accepted URLs
   --reject-regex=REGEX        regex matching rejected URLs
   --regex-type=TYPE           regex type (posix|pcre)

是否显示详细下载情况
  -v,  --verbose                   be verbose (this is the default)
  -nv, --no-verbose                turn off verboseness, without being quiet
       --report-speed=TYPE         output bandwidth as TYPE.  TYPE can be bits


(3) 下载过程中卡死了，仔细一看，js控制台报错了
打不开的js:
https://cdn.rawgit.com/zenorocha/clipboard.js/master/dist/clipboard.min.js 
已有的js，不知道怎么注入到当前页面中
https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js
javascript:(function(s){s.src='https://static.runoob.com/assets/clipboard.min.js';document.body.appendChild(s)})(document.createElement('script'));

不知道 墙 啥时候放行这个js文件。。。


(4) 先把已经下载的抓到本地
回到本地宿主机:
$ cd /home/wangjl/data/web/docs/docs/seurat/
$ wget -m --no-check-certificate http://ip172-18-0-69-c55t5u7njsv000dv7nk0-8000.direct.labs.play-with-docker.com/site/satijalab.org/seurat/index.html



最后因为404报错停下了。
HTTP request sent, awaiting response... 404 Not Found
2021-09-23 11:13:20 ERROR 404: Not Found.

FINISHED --2021-09-23 11:13:20--
Total wall clock time: 16m 35s
Downloaded: 516 files, 324M in 10m 39s (519 KB/s)


总共下载326M数据。
$ du -sh /home/wangjl/data/web/docs/docs/seurat/
326M	/home/wangjl/data/web/docs/docs/seurat/

最后去掉多余的文件夹外壳，保存在 webPan.py 上。
/home/wangjl/data/web/docs/docs/satijalab.org
访问地址: http://y.biomooc.com:8000/file/docs/satijalab.org/index.html


压缩:
$ tar -czvf seurat.tar.gz satijalab.org
-rw-rw-r-- 1 wangjl wangjl 216M Sep 23 14:09  seurat.tar.gz
加上日期 seurat-20210923.tar.gz

$ du -sh satijalab.org/
325M	satijalab.org/
压缩道原来的 66%。



(5) 缺一个文件，在线代理查看一下: 未解决
https://proxysite.page/en

https://satijalab.org/seurat/articles/install.html
https://satijalab.org/seurat/articles/pbmc3k_tutorial_files/header-attrs-2.10/header-attrs.js





========================================
算法细节
----------------------------------------

========================================
|-- FindVariableGenes() plots dispersion是怎么算的？
----------------------------------------
1.
https://satijalab.org/seurat/faq

FindVariableGenes() plots dispersion (a normalized measure of to cell-to-cell variation) as a function of average expression for each gene. Our goal is to identify a set of high-variance genes, and we recommend setting the cutoff parameters in this function by visually evaluating this plot to define outliers.

2.






========================================
|-- t-SNE算法 //todo
----------------------------------------

https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&mid=2247484978&idx=1&sn=07b7f734ad0ad44562186c1ef3663057&scene=21#wechat_redirect









========================================
|-- Seurat包：multidimensional scaling (MDS)多维尺度分析分析
----------------------------------------
Seurat - Dimensional Reduction Vignette
https://satijalab.org/seurat/dim_reduction_vignette.html

MDS降维原理：
https://blog.csdn.net/yang_xian521/article/details/7301121
https://www.cnblogs.com/lochan/p/6627511.html


# Before running MDS, we first calculate a distance matrix between all pairs
# of cells.  Here we use a simple euclidean distance metric on all genes,
# using object@scale.data as input
pbmc=br10
d <- dist(x = t(x = pbmc@scale.data))
# Run the MDS procedure, k determines the number of dimensions
mds <- cmdscale(d = d, k = 2)
# cmdscale returns the cell embeddings, we first label the columns to ensure
# downstream consistency
colnames(x = mds) <- paste0("MDS", 1:2)
# We will now store this as a new dimensional reduction called 'mds'
pbmc <- SetDimReduction(object = pbmc, reduction.type = "mds", slot = "cell.embeddings", 
                        new.data = mds)
pbmc <- SetDimReduction(object = pbmc, reduction.type = "mds", slot = "key", 
                        new.data = "MDS")

# We can now use this as you would any other dimensional reduction in all
# downstream functions (similar to PCAPlot, but generalized for any
# reduction)
DimPlot(object = pbmc, reduction.use = "mds", pt.size = 2) #0.5
DimPlot(object = pbmc, pt.size = 2)

pop2=rep(0,28);pop2=c(pop2, rep(1,32));pop2
DimPlot(object = pbmc, reduction.use = "mds", pt.size = 2) + 
  geom_point(aes(colour=factor(pop2)) )
  
#






========================================
修改补充 Seurat对象 并绘图
----------------------------------------


========================================
|-- 修改 seurat 的分类列，后续按照新 Idents 进行比较marker、画热图等
----------------------------------------
1.

(1) add new column as cell identity
pbmc12@meta.data$cellType=cellInfo2[rownames( pbmc12@meta.data), ]$cellType
table(pbmc12@meta.data$seurat_clusters, pbmc12$cellType)
#   BC_0 BC_1 HeLa_normal HeLa_sync
#0   92    0           0         0
#1    0   73           0         0
#2    0    0          30        27
Idents(pbmc12) ="cellType"
sortIdent = factor(pbmc12$cellType,levels = c("BC_0","BC_1", "HeLa_normal",   "HeLa_sync"))
pbmc12@active.ident = sortIdent





(2) 对比：官方示例的方法：
new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
#*********

> head(Idents(scObj_known2), n=3)
AAACCCAAGAGCTTTC-1_1 AAACCCAGTAGTGGCA-1_1 AAACCCATCTTCACGC-1_1 
            Platelet             Platelet           Ccr2+ Mono




# 如果不小心标错了，怎么恢复会原来的数字编号？
#1) 最快的方式 Idents(object = scObj_colon) <-"RNA_snn_res.0.2"
#2) 需要使用 seurat_clusters 构建named vector 覆盖掉 active.ident 这个slot，然后重新来
scObj_known2@active.ident

> t1=scObj_known2@meta.data$seurat_clusters
> names(t1)=scObj_known2$cell #或 rownames(scObj_known2@meta.data)
> head(t1, n=3)
AAACCCAAGAGCTTTC-1_1 AAACCCAGTAGTGGCA-1_1 AAACCCATCTTCACGC-1_1
                   0                    2                    4
> scObj_known2@active.ident=t1







(3) 给meta.data 添加一列: monocle 的state列
p_data <- subset(pData(mycds),select='State')
scRNAsub2 <- subset(scRNAsub, cells=row.names(p_data))
scRNAsub2 <- AddMetaData(scRNAsub2, p_data, col.name = 'State')
#
head(scRNAsub2@meta.data)






2.
# 指定比较
# find all markers distinguishing cluster 5 from clusters 0,1 and 2
BC_HeLa.markers <- FindMarkers(pbmc12, ident.1 = c("BC_0","BC_1"), 
                               ident.2 = c("HeLa_normal",   "HeLa_sync"), min.pct = 0.25)
BC_HeLa.markers$gene=rownames(BC_HeLa.markers)
head(BC_HeLa.markers, n = 5)




# 两两比较
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc12, only.pos = F, min.pct = 0.25, logfc.threshold = 0.25, test.use = 'wilcox')
pbmc.markers %>% group_by(cluster) %>% filter(p_val_adj<0.05 & abs(avg_logFC)>log2(2) ) %>%  top_n(n = 3, wt = avg_logFC)







========================================
|-- DoHeatmap 自定义热图：指定颜色
----------------------------------------

1. 指定顶部颜色块：group.colors
DoHeatmap(pbmc12, features = rbind(gset1, gset2)$gene, 
          group.colors= c("#FF9ECE","#F81082", '#005FFF', '#98BEFD') )


2. 调整文字字号大小
library(ggplot2)
DoHeatmap(pbmc.small, features = top10$gene, label = F) + theme(text = element_text(size = 12))



3. 多个图例 
https://github.com/satijalab/seurat/issues/2201





4. 图例放底部
https://github.com/satijalab/seurat/issues/3149





========================================
|-- 画DotPlot图：倾斜x轴基因名字
----------------------------------------
1. 更通用的画法 //todo

# options(repr.plot.width=8, repr.plot.height=7)
DotPlot(scRNA, features = rev( unique( c("CD3D","CD4","CD8A","CD8B","GZMB", "CCR7","ITGB1", "CCR10", "MKI67",
                                         "GAPDH", rownames(rs2)) ) ), 
            cols = c("lightgrey", "red"))+ #自定义颜色 白-> 红
    theme( axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1) ) #x坐标文字倾斜60度




2. 倾向于尺寸和绘图分离，尽量不要耦合到一个函数中。方便适配不同的数据。
####replot markergenes
# v2.0新增2个filter
# v2.1 新增可以设置 seurat 对象，方便从外部修改对象的ident后重新传入值
DotPlotPDF=function(genelist,prefix="",width=26,height=10, suerat_obj=br10){
  #filter1:保证基因唯一性
  genelist=unique(genelist)
  #filter2:保证基因在数据中存在
  gene.exist=rownames(suerat_obj@data)#有的基因名字
  #打印出不存在的基因
  gene.reserve=c()
  for(g in genelist){
    if(g %in% gene.exist){
      gene.reserve=c(gene.reserve, g)
    }else{
      print(g)
    }
  }
  #开始画图
  CairoPDF( paste0(prefix,"_DotPlot.pdf") , width = width, height = height)
  #控制x坐标循序，可以把x逆序，如rev(genelist)
  #怎么控制y坐标顺序？
  marker_dot_plot <- DotPlot(object = suerat_obj, genes.plot = gene.reserve, plot.legend = TRUE,
                             cols.use = c("black","red"), x.lab.rot = T,dot.scale = 10, do.return=T)
  marker_dot_plot <- marker_dot_plot + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1))
  print(marker_dot_plot)
  dev.off()
}


# 查看几个level，也就是几个分类
levels(br10@ident)
table(br10@ident)

getwd()
DotPlotPDF(rev(tmp$gene),"adjP0.05",width=28,height=4.5) #75个
DotPlotPDF(top5$gene,"top5",width=5,height=4.5) #5*4=20个

markers=readLines("marker_list/8.txt") #读取每行，生成数组
DotPlotPDF(markers,"top5",width=5,height=4.5)
#






========================================
|-- DimPlot()高亮显示某一类细胞
----------------------------------------
1. 使用 seurat 包的函数，指定 cells.highlight 参数
(1) WhichCells 函数获取cid
Idents(scRNA)="predicted.id"
sub1 <- WhichCells(scRNA, idents = c("CD8 Naive") ) #返回的是细胞cid
sub2 <- WhichCells(scRNA, idents = c( "CD4 TEM") )
p1=DimPlot(scRNA, label=T, group.by="predicted.id", cells.highlight= list(sub1, sub2), 
        cols.highlight = c("blue", 'red'), cols= "grey")


by_2="predicted.id"
# p1=DimPlot(scRNA, group.by=by_2, label=T)
p2=DimPlot(scRNA, group.by=by_2, label=T)

options(repr.plot.width=12, repr.plot.height=5)
p1+p2 +plot_layout(guides = 'collect')



(2) 从 meta.data 获取cid

DimPlot(neu_colon, label = F, group.by = "BL2", 
        cells.highlight = neu_colon@meta.data[which(neu_colon@meta.data$sample == "BL2Y"), "cell"], 
        cols.highlight = c("darkblue", "darkred"), cols = "grey")


(3) 分面: split.by=某指标作为因子，把图分成多个

DimPlot(object = neu_colon,reduction = "umap",label = F, split.by = "sample", ncol = 3)+NoLegend()




2. 自定义函数 
library(dplyr)

umap_tx = integrated@reductions$umap@cell.embeddings %>% 
	as.data.frame() %>% cbind(tx = so@meta.data$Treat)

ggplot(umap_tx, aes(x=UMAP_1, y=UMAP_2, color=tx)) + geom_point() + 
	scale_color_manual(values=c("group1_untreated" = "darkblue", "group1_treated" = "darkred"))





ref:
https://stackoverflow.com/questions/59101791/seurat-dimplot-highlight-specific-groups-of-cells-in-different-colours


========================================
|-- 画某细胞类之间的相关热图
----------------------------------------

1.
https://github.com/satijalab/seurat/issues/2486

Note that AverageExpression actually includes an add.ident argument that does exactly what Tim suggested above, so you could say

> avgexp = AverageExpression(immune.combined, return.seurat = T, add.ident = 'Genotype')

You can then treat this as a regular Seurat object to generate Heatmaps, plots, etc. on average data



(2) 实例:

avgexp = AverageExpression( subset(scRNA, idents = c( "Platelet", "ASDC" ), invert=T ), 
                           #add.ident = 'predicted.id'#名字后加一个后缀，比如区分样本: Microglia_KO, Microglia_WT, 
                           return.seurat = T ) 
dim(avgexp)
avgexp@assays$RNA@data[1:4,1:5]


cor_df2=cor( as.matrix(avgexp@assays$RNA@data) )

library(pheatmap)

# options(repr.plot.width=7, repr.plot.height=7) 
pheatmap(cor_df2, border_color = NA, 
         clustering_method="ward.D2",
         main="Cell type correlation")
#






========================================
|-- 常用图的增强: FeaturePlot, VlnPlot, DotPlot, DimPlot
----------------------------------------

1. FeaturePlot 函数
(1) FeaturePlot使用了split函数之后就没有legend了
FeaturePlot(object = obj, features = "Gene", split.by = "Meta_Name", order = T) & theme(legend.position = "right")

只是用+是不可以的，那样就只会只改split图中右边的那个图。使用&符号的时候是会两个都改的，是不是很神奇？
原来我以前只知道+，后来才发现还有&这个用法。



(2) 两个 FeaturePlot 左右放，右边的隐藏y轴。

m_featureplot <- FeaturePlot(M_Aggregated_seurat, features = "Lepr", reduction = "tsne",
                             split.by = "orig.ident", pt.size = 1.8, repel = F, label = F,
                             order = T, max.cutoff = 1)
m_featureplot <- m_featureplot & scale_x_continuous(breaks=seq(-30, 20, 10)) ## 改x轴刻度标签
m_featureplot <- m_featureplot & scale_y_continuous(breaks=seq(-30, 20, 10)) ## 改y轴刻度标签
m_featureplot <- m_featureplot +  theme(axis.text.y = element_blank()) +   ## 删去所有刻度标签
                                  theme(axis.ticks.y = element_blank()) +  ##则只删去 Y 轴的刻度线
                                  theme(axis.line.y = element_blank())
m_featureplot <- m_featureplot + ylab("")



(3) # Visualize co-expression of two features simultaneously
FeaturePlot(pbmc, features = c("MS4A1", "CD79A"), blend = TRUE)


(4) # Calculate feature-specific contrast levels based on quantiles of non-zero expression.
# Particularly useful when plotting multiple markers
FeaturePlot(pbmc3k.final, features = c("MS4A1", "PTPRCAP"), min.cutoff = "q10", max.cutoff = "q90")


(5) 分组 
# Split visualization to view expression by groups (replaces FeatureHeatmap)
FeaturePlot(pbmc3k.final, features = c("MS4A1", "CD79A"), split.by = "groups")





2. VlnPlot 的堆叠小提琴图
VlnPlot 中有个stack = T
但是这里面有个bug
因为Seurat::VlnPlot有个bug就是当用split的时候 细胞数目小于3个的时候 就不会画出来
后面又自己想加其他数据所以弄得复杂了点
但是我发现个很好用的方法就是直接把p1$data <- final_data 直接替换成我们想画图的数据就可以直接修改图片了

https://www.jianshu.com/p/a2fe2549cea1

(2) # metadata and pass it to the split.by argument
VlnPlot(pbmc, features = "percent.mt", split.by = "groups")






3. DotPlot 图

(1) 
dotplot_f_data_1 <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),
                       group.by = "try",col.min=-2, col.max=2)$data
head(dotplot_f_data_1)
dim(dotplot_f_data_1)

dotplot_f_data_2 <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),
                            group.by = "try2",col.min=-2, col.max=2)$data
head(dotplot_f_data_2)
dim(dotplot_f_data_2)

dotplot_f_data <- rbind(dotplot_f_data_1, dotplot_f_data_2)
head(dotplot_f_data)
dim(dotplot_f_data)
table(dotplot_f_data$id)

p_dotplot_f <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),col.min=-2, col.max=2)
p_dotplot_f$data <- dotplot_f_data
p_dotplot_f <- p_dotplot_f + coord_flip()
p_dotplot_f <- p_dotplot_f+ scale_color_gradient2(high="red",mid = "lightgrey",low ="darkblue", midpoint = 0) + theme_classic()+ 
  theme(axis.text.x = element_text(angle = -45,hjust = -0.1,vjust = 0.8)) 
p_dotplot_f$data$id <- factor(p_dotplot_f$data$id,
                              levels = c(levels_define[1:12], 
                                         "GABA_WT", "GABA_ob/ob",
                                         levels_define[13:18],
                                         "Glu_WT", "Glu_ob/ob"))
p_dotplot_f


(2) 分组
DotPlot(pbmc, features = features, split.by = "groups") + RotatedAxis()



4. DimPlot 

(1) 加上标题
baseplot <- DimPlot(pbmc, reduction = "umap")
# Add custom labels and titles
baseplot + labs(title = "Clustering of 2,700 PBMCs")

(2) 改变字体，去掉图例
# Chain themes together
baseplot + FontSize(x.title = 20, y.title = 20) + NoLegend()





5. 系统发育分析（Phylogenetic Analysis of Identity Classes）
pbmc<-BuildClusterTree(pbmc)
Tool(object = pbmc, slot = 'BuildClusterTree')



6. 平均表达谱函数AverageExpression
?AverageExpression

AverageExp<-AverageExpression(pbmc,features=unique(top10$gene))




7. # Ridge plots - from ggridges. Visualize single cell expression distributions in each cluster
RidgePlot(pbmc3k.final, features = features, ncol = 2)













100. 富集分析的底层代码： enrichplot 包

https://www.jianshu.com/p/03b94b2034d5





ref:
https://www.jianshu.com/p/a2fe2549cea1
https://www.jianshu.com/p/484762bb96c2
https://www.jianshu.com/p/03b94b2034d5
http://www.360doc.com/content/21/0715/15/76149697_986668012.shtml









========================================
重绘: 使用 R base, ggplot2
----------------------------------------





========================================
|-- 重绘 Seurat热图，标记细胞来源、Seurat分类
----------------------------------------

1. 原始代码： 

# 全部 find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc2, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)


top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
#DoHeatmap(pbmc2, features = top10$gene) + NoLegend()
DoHeatmap(pbmc2, features = top10$gene)





2. 自定义代码
########### 画heatmap，标记来源
library(pheatmap)
#来源标签
syncID=gsub("_","",readLines("/home/wangjl/data/apa/190530Mix/cluster2_syncHeLa.27L.cellID") ); head(syncID)
normalID=gsub("_","",readLines("/home/wangjl/data/apa/190530Mix/cluster2_HeLa_nonsyncHeLa.29R.cellID") ); head(normalID)
allID=colnames( pbmc2@assays$RNA ); head(allID) #没啥用
#

#添加UMAP分类标签
pbmc2@assays$RNA@scale.data
table(pbmc2@active.ident)
pbmc2@active.ident[pbmc2@active.ident==1]
c0=names(pbmc2@active.ident[pbmc2@active.ident==0])
c1=names(pbmc2@active.ident[pbmc2@active.ident==1])
c2=names(pbmc2@active.ident[pbmc2@active.ident==2])

#
pbmc2@assays$RNA[top10$gene,c("c01ROW24","c01ROW35")] #同步化 head
pbmc2@assays$RNA[top10$gene,c("c9ROW14","c9ROW15")] #同步化 tail
pbmc2@assays$RNA[top10$gene,c("c12ROW10","c12ROW16")] #normal head
#
pbmc2@assays$RNA[top10$gene[20:30], gsub("_","",syncID)]
pbmc2@assays$RNA[top10$gene[20:30], gsub("_","",normalID)]
#

# 构建列注释信息
annotation_col = data.frame(
  row.names = c(c0, c1, c2),
  cellType = rep("BC", length(allID)),
  UMAP_Cluster=rep(c(0,1,2),c(length(c0), length(c1), length(c2)))
)
annotation_col$cellType=as.character(annotation_col$cellType)
annotation_col$cellType[ rownames(annotation_col) %in% syncID]="syncHeLa"
annotation_col$cellType[ rownames(annotation_col) %in% normalID]='normalHeLa'
annotation_col
head(annotation_col)

# 自定义注释颜色
# 自定注释信息的颜色列表
ann_colors = list(
  #cellType = c("white", "firebrick"),
  cellType = c(BC="yellow", syncHeLa="#F8746B", normalHeLa="#00BDC2"),
  UMAP_Cluster = c('0' = "#F8766D", '1' = "#00BA38", '2' = "#619CFF" )
)
head(ann_colors)

# annotation_col参数添加列注释信息
#rna=pbmc2@assays$RNA
#matrix2=rna[top10$gene,allID]  #[1]  30 225
#class(matrix2)
matrix2=pbmc2@assays$RNA@scale.data[top10$gene,c(c0,c1,c2)] #[1] 478762    225
dim(matrix2) #[1]  30 225
pheatmap(matrix2, annotation_col = annotation_col, annotation_colors = ann_colors,
         cluster_cols=F,cluster_rows=F, #不聚类
         border=FALSE, # 去边框
         gaps_col = c(length(c0), length(c0)+length(c1),  length(c0)+length(c1)+length(c2)), #分组显示
         show_colnames = F) #不显示底下的名字
###########



========================================
|-- 重绘 PCA,tSNE, UMAP
----------------------------------------

1. 获取坐标
(1) 使用内置函数 Embeddings 获取坐标
> Embeddings(scRNA, "umap")
	UMAP_1	UMAP_2
AAACCCAGTATCGTAC	7.708623	-4.3380356
AAACCCAGTCGGTGAA	-5.678032	-0.3648236
AAACCCAGTTAGAAAC	7.154264	-1.0021027


> Embeddings(scRNA, "tsne")
	tSNE_1	tSNE_2
AAACCCAGTATCGTAC	-14.4581690	-7.5685762
AAACCCAGTCGGTGAA	5.1615386	27.4283348
AAACCCAGTTAGAAAC	-1.8349680	-27.0306493
AAACCCAGTTATCTTC	1.8384106	45.6578343


(2) 从对象中获取坐标
######## replot: PCA,tSNE,UMAP
getDimensionData=function(seuratObj){
  df=data.frame(
    cid=names(seuratObj@active.ident),
    PC_1=seuratObj@reductions$pca@cell.embeddings[,1],
    PC_2=seuratObj@reductions$pca@cell.embeddings[,2],
    PC_3=seuratObj@reductions$pca@cell.embeddings[,3],
    #umap
    UMAP_1=seuratObj@reductions$umap@cell.embeddings[,1],
    UMAP_2=seuratObj@reductions$umap@cell.embeddings[,2],
    #
    tSNE_1=seuratObj@reductions$tsne@cell.embeddings[,1],
    tSNE_2=seuratObj@reductions$tsne@cell.embeddings[,2],
    ident=unname(seuratObj@active.ident),
    row.names = 1
  )
  return( df)
}
pcaData=getDimensionData(pbmc2)
dim(pcaData) #328 5
head(pcaData)
ggplot(pcaData, aes(PC_1, PC_2, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(PC_1, PC_3, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(PC_2, PC_3, color=ident))+geom_point()+theme_classic()
#
ggplot(pcaData, aes(tSNE_1, tSNE_2, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(UMAP_1, UMAP_2, color=ident))+geom_point()+theme_classic()
#
library(rgl) #可以鼠标旋转的3D图
plot3d(pcaData$PC_1, pcaData$PC_2, pcaData$PC_3)
#############


(3) 把UMAP的坐标放到metadata中：
pbmc <- AddMetaData(pbmc, 
		pbmc@reductions$umap@cell.embeddings,
		col.name = colnames(pbmc@reductions$umap@cell.embeddings))

head(pbmc@meta.data)









2. 精细复原，并个性化定制

# Seurat包的UMAP图
DimPlot(scObj_known2, group.by = c("ident", 'sample'),reduction = "umap")
DimPlot(scObj_known2, group.by = c("ident"), reduction = "umap")
DimPlot(scObj_known2)


(1) 自己画
# step1: 获取数据
umap_data = scObj_known2@reductions$umap@cell.embeddings %>%  #坐标信息
  as.data.frame() %>% 
  cbind(cell_type = scObj_known2@meta.data$ident) # 注释后的 ident 信息 ，改为cell_type
head(umap_data)
#                        UMAP_1    UMAP_2   cell_type
#AAACCCAAGAGCTTTC-1_1  4.289865  2.376387    Platelet


# step2: 初步画图
allcolour=c("#DC143C","#0000FF","#20B2AA","#FFA500","#9370DB","#98FB98","#F08080","#1E90FF","#7CFC00","#FFFF00",
            "#808000","#FF00FF","#FA8072","#7B68EE","#9400D3","#800080","#A0522D","#D2B48C","#D2691E","#87CEEB","#40E0D0","#5F9EA0",
            "#FF1493","#0000CD","#008B8B","#FFE4B5","#8A2BE2","#228B22","#E9967A","#4682B4","#32CD32","#F0E68C","#FFFFE0","#EE82EE",
            "#FF6347","#6A5ACD","#9932CC","#8B008B","#8B4513","#DEB887")

p <- ggplot(umap, aes(x= UMAP_1 , y = UMAP_2 ,color = cell_type))+
  geom_point(size = 1 , alpha =1 )+
  scale_color_manual(values = allcolour)
p

找差异:
- 主题部分（去掉背景，去掉网格线） ；
- legend部分（调整legend，去掉背景灰色、title，调整字体） 
- 注释部分（坐标轴标到左下角，图中标示标签）三部分。


(2) 修饰提升: 去背景、去坐标轴
https://mp.weixin.qq.com/s?__biz=MzIyNDI1MzgzOQ==&mid=2650394998&idx=1&sn=3a37ee30062e880b70564633b51a87c8

p2 = p+theme_classic(base_size = 14)+
  theme(
    panel.border = element_blank(), #边框
    axis.title = element_blank(),  #轴标题
    axis.text = element_blank(),  #轴刻度文本
    axis.ticks = element_blank(), #轴刻度
    axis.line = element_blank() #去掉轴
  )
p2


# 参考:
p2_ <- p  +
  theme(panel.grid.major = element_blank(), #主网格线
        panel.grid.minor = element_blank(), #次网格线
        panel.border = element_blank(), #边框
        axis.title = element_blank(),  #轴标题
        axis.text = element_blank(), # 文本
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = 'white'), #背景色
        plot.background=element_rect(fill="white"))
p2_


(3) 修饰提升: 图例点变大
https://mp.weixin.qq.com/s?__biz=MzIyNDI1MzgzOQ==&mid=2650394998&idx=2&sn=a860fb6001d39dbe543a8a970b4a0675

p3=p2+
  theme(
    #legend.title = element_blank(), #去掉legend.title 
    #legend.key=element_rect(fill='white'), #
    #legend.text = element_text(size=20), #设置legend标签的大小
    #legend.key.size=unit(1,'cm')  # 设置legend标签之间的大小
  )+
  guides(color = guide_legend(override.aes = list(size=5))) #设置legend中 点的大小
p3


(4) 调整umap图 - annotation
坐标轴放到左下角可以通过ggplot2添加带箭头的线段和文本实现。
这一步可能需要根据数据调整位置，来获得最佳效果。

p4 <- p3 + 
  geom_segment(data=data.frame(), aes(x = min(umap_data$UMAP_1), y = min(umap_data$UMAP_2),
                   xend = min(umap_data$UMAP_1) +5, yend = min(umap_data$UMAP_2) ),
               colour = "black", #size=0.9,
               arrow = arrow(length = unit(0.3,"cm")))+ 
  geom_segment(data=data.frame(), aes(x = min(umap_data$UMAP_1), y = min(umap_data$UMAP_2),
                   xend = min(umap_data$UMAP_1), yend = min(umap_data$UMAP_2) + 5),
               colour = "black", #size=0.9,
               arrow = arrow(length = unit(0.3,"cm"))) +
  annotate("text", x = min(umap_data$UMAP_1) +2.5, y = min(umap_data$UMAP_2) -1.5, label = "UMAP_1",
           color="black", size = 3, fontface="bold") + 
  annotate("text", x = min(umap_data$UMAP_1) -1.5, y = min(umap_data$UMAP_2) + 2.5, label = "UMAP_2",
           color="black", size = 3, fontface="bold", angle=90)
p4
差不多是最终效果了，就差把细胞类型标注到点上了。



(5)  那如果想把注释加到点之上怎么办呢？
- 直接使用label 添加，需要先给每个cluster一个单独的坐标，本示例中使用此方法。
- text 根据cluster的位置，手动添加，需要尝试，倒是效果会好一些。


# 1) 计算每个cluster的median 坐标位置
cell_type_med <- umap %>%
  group_by(cell_type) %>%
  summarise(
    UMAP_1 = median(UMAP_1),
    UMAP_2 = median(UMAP_2)
  )

# 2) geom_label_repel 添加注释
library(ggrepel)
p4 + #白底标签标注
  geom_label_repel(data = cell_type_med, aes(label=cell_type), 
                   fontface="bold", alpha=0.8,#半透光
                   point.padding=unit(0.5, "lines"))

# 或者黑字标注
p4 +
  geom_text_repel(data = cell_type_med, aes(label=cell_type), 
                  #fontface="bold", 
                  color="black",
                  point.padding=unit(0.5, "lines"))

# 3) 去掉 legend 
p4 + #白底标签标注
  geom_label_repel(data = cell_type_med, aes(label=cell_type), 
                   fontface="bold", alpha=0.8,#半透光
                   point.padding=unit(0.5, "lines"))+
  theme(legend.position = "none")










3. 画法2

#' Draw UMAP, my method 2
#'
#' @param scObj 
#' @param group.by 
#'
#' @return
#' @export
#'
#' @examples
#' DimPlot_2(scObj_known2, "ident")
DimPlot_2 = function(scObj, group.by="seurat_clusters"){
  # (1)为了调用ggplot2我们把UMAP的坐标放到metadata中：
  pbmc<-AddMetaData(scObj,scObj@reductions$umap@cell.embeddings,col.name = colnames(scObj@reductions$umap@cell.embeddings))
  #head(pbmc@meta.data)
  
  # (2)读入一套我珍藏多年的颜色列表：
  allcolour=c("#DC143C","#0000FF","#20B2AA","#FFA500","#9370DB","#98FB98","#F08080","#1E90FF","#7CFC00","#FFFF00",
              "#808000","#FF00FF","#FA8072","#7B68EE","#9400D3","#800080","#A0522D","#D2B48C","#D2691E","#87CEEB","#40E0D0","#5F9EA0",
              "#FF1493","#0000CD","#008B8B","#FFE4B5","#8A2BE2","#228B22","#E9967A","#4682B4","#32CD32","#F0E68C","#FFFFE0","#EE82EE",
              "#FF6347","#6A5ACD","#9932CC","#8B008B","#8B4513","#DEB887")
  
  # (3) 开始画图
  df1= as.data.frame(pbmc@meta.data) #[, c("UMAP_1", "UMAP_2", group.by)]
  df1$cluster=as.data.frame(pbmc@meta.data)[, group.by]
  # colnames(df1)=c("UMAP_1", "UMAP_2","cluster")
  
  class_avg <-  df1%>%
    group_by(cluster) %>%
    summarise(
      UMAP_1 = median(UMAP_1),
      UMAP_2 = median(UMAP_2)
    )
  #print(head(class_avg))
  umap <-  ggplot(df1, aes(x=UMAP_1,y=UMAP_2))+
    geom_point(aes(color=cluster))+
    scale_color_manual(values = allcolour)+
    geom_text(aes(label = cluster), data = class_avg)+
    theme(text=element_text(family="Arial",size=18)) +
    theme(panel.background = element_rect(fill='white', colour='black'), 
          panel.grid=element_blank(), axis.title = element_text(color='black',
                                                                family="Arial",size=18),axis.ticks.length = unit(0.4,"lines"), 
          axis.ticks = element_line(color='black'), 
          #axis.ticks.margin = unit(0.6,"lines"), 
          #`axis.ticks.margin` is deprecated. Please set `margin` property of `axis.text` instead 
          
          axis.line = element_line(colour = "black"), 
          axis.title.x=element_text(colour='black', size=18),
          axis.title.y=element_text(colour='black', size=18),
          axis.text=element_text(colour='black',size=18),
          legend.title=element_blank(),
          legend.text=element_text(family="Arial", size=18),
          legend.key=element_blank())+
    #theme(plot.title = element_text(size=22,colour = "black",face = "bold"))  + 
    guides(colour = guide_legend(override.aes = list(size=5)))
  return(umap)
}











========================================
|-- 3D扩展: 画PCA的3D散点图: 从R中生成png，在linux中合并为gif，如何添加表示分类的颜色？
----------------------------------------
3D图能很直观的理解类群，在PPT中效果比2D图好太多。
不过生成过程比较麻烦，建议：尽量在本地R中好好优化后再启动生成gif流程。


0.如果数据太大，下载不方便，则可以考虑只提取画图必要的部分。
#获取pca数据
df=data.frame(
  pc_1=pbmc9@dr$pca@cell.embeddings[,1],
  pc_2=pbmc9@dr$pca@cell.embeddings[,2],
  pc_3=pbmc9@dr$pca@cell.embeddings[,3],
  ident=pbmc9@ident
)
saveRDS(df, file = "10x_B116_TSENPlot_9_PC1-6_r0.6_DF.rds")





1. PCA 3d plot图，一般是黑白的
#########
# R中, win10
#########
setwd("D:\\Temp\\10xB116\\tmp_plot")
pbmc5=readRDS("10x_B116_TSENPlot_9_again.rds")

#获取pca数据
pc_1=pbmc5@dr$pca@cell.embeddings[,1]
pc_2=pbmc5@dr$pca@cell.embeddings[,2]
pc_3=pbmc5@dr$pca@cell.embeddings[,3]

library(rgl) #可以鼠标旋转的3D图
plot3d(pc_1, pc_2, pc_3)

#install.packages("magick")
library(magick) #生成gif图所需的原材料 若干png
movie3d(spin3d(axis=c(0,0,1),rpm=3), type = "gif",duration=3,fps=10,convert=F)
#位置在临时文件夹中 C:\Users\admin\AppData\Local\Temp\RtmpOqAa3k ，zip打包上传到linux中。
#注意：利用movie3d函数保存动画，其实是生成一些列的.png格式的图面文件，每个文件代表一帧，然后利用ImageMagick软件提供的convert命令将这些文件合并成为gif格式的动画文件。所以要想让动画动起来是一定要安装ImageMagick软件的。输出的动画会被放在一个临时文件夹中，地址名会在R窗口中输出。如果不想利用ImageMagick软件，可以设置convert=F，然后其他软件会将这一系列的.png文件转换为动画。



#########
# linux中,Ubuntu 18.04.1 LTS
#########
$ unzip RtmpOqAa3k.zip -d gif/
$ cd gif

convert -delay 0 *.png ~/web/a1.gif
convert ~/web/a1.gif -coalesce -reverse -quiet -layers OptimizePlus -loop 0 ~/web/a2.gif
convert ~/web/a1.gif ~/web/a2.gif ~/web/a3.gif






2.如果多个样本怎么用颜色或形状区分呢？
如何加上彩色？加上tSNE的分类颜色：1获取tSNE图的颜色；2.为PCA 3D图加上这些颜色。


#如何获取TSNEPlot中表示分类的颜色 https://github.com/satijalab/seurat/issues/257
identities <- levels(pbmc5@ident) # Create vector with levels of object@ident
require(scales)
my_color_palette <- hue_pal()(length(identities)) # Create vector of default ggplot2 colors
# Plot the tSNE plot with the default ggplot2 colors
#TSNEPlot(object = pbmc5, do.return = T) + 
#  scale_color_manual(values = my_color_palette)
#The colour codes can be found in my_color_palette.

#my_color_palette是一个长度为10的数组，怎么转换为一个factor的值？
ident=pbmc5@ident
t1=factor(ident,labels = my_color_palette)


#可以画3D图了
library(rgl) #可以鼠标旋转的3D图
plot3d(pc_1, pc_2, pc_3, col= t1,size=4)

接着使用movie3d函数生成一堆png，然后用linux下的convert生成gif文件。





========================================
|-- 用tsne画不同批次的细胞的点图
----------------------------------------

#
mef=br10

#分离分类变量
cn=colnames(mef@data)
end=regexpr('\\.',cn)
#end=unlist(end[1:60])
end;table(end)
#pop= sapply(cn,substr,rep(1,60),end,USE.NAMES=F)
pop=c()
for(i in c(1:60)){
  pop=c(pop,substr(cn[i], 1, end[i]-1))
}
pop
table(pop)


#TSNE plot for batches
#pop<-rep(1,28)#bc
#pop<-c(pop,rep(2,32))#mef
#pop
length(pop);table(pop)
#pop<-rep(1,73)
#pop<-c(pop,rep(2,26))
#pop<-c(pop,rep(3,76))

coordx<-mef@dr$tsne@cell.embeddings[,1]  # 新版本又更新了v3.0.1 mef@reductions$umap@cell.embeddings[,1]
coordy<-mef@dr$tsne@cell.embeddings[,2]
df1<-data.frame(coordx=coordx,coordy=coordy,pop=pop)
df1$pop<-as.factor(df1$pop)
#pdf(paste(path_out,"5.pdf",sep=""))
par(mai=c(1,1,0.2,0.5));
pl<-ggplot(data=df1,aes(x=coordx,y=coordy,colour=factor(pop)))+
  geom_point(size=2,alpha=1)+
  #   guides(fill=guide_legend(title="test1"))+
  labs(x="tSNE 1",y="tSNE 2")+theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    #    panel.border = element_blank(),
    panel.background = element_blank())
#pl+scale_colour_discrete(name="sample",labels=c("bc","mef"))

pl+scale_color_discrete(name="Sample")
#dev.off()
############################






========================================
|-- 原生R画不同类的细胞数: myBarPlot()
----------------------------------------

# bar plot for each column in meta.data
myBarPlot=function(scRNA, group.by="seurat_clusters",textPosY=-150, angle=60, isShow=F){
    # 1. data
    df1=table(scRNA@meta.data[[group.by]])
    df1=df1[order( -unname(df1) )] #order
    if(isShow){print(df1)}

    # 2. plot
    xPos = barplot( df1, xaxt="n",#xaxt="n"不要x坐标轴
                   col="#F07B05",
                   las=2, #坐标轴垂直与轴
                   ylab="Cell number",
                   border = NA) #bar不要边框
    # text on x axis
    # print(par("usr"))
    text(x=xPos, y= textPosY, labels=names(df1),
         cex=0.8, #字体是默认的倍数
         col="black",
         xpd=TRUE, #允许绘制在绘图区外
         adj=1, #adj=1右上对齐
         srt=angle) #倾斜
    # text on top of bar
    text(x=xPos, y=unname(df1)+50, labels=unname(df1),
         cex=0.5, #字体是默认的倍数
         col="black",
         xpd=TRUE, #允许绘制在绘图区外
         adj=0, #adj=1右上对齐
         srt=90) #倾斜
}


# options(repr.plot.width=8, repr.plot.height=4)
myBarPlot(scRNA, "predicted.id", textPosY=-50)


# options(repr.plot.width=8, repr.plot.height=4)
myBarPlot(scRNA, "seurat_clusters", textPosY=-50)






========================================
衔接
----------------------------------------




========================================
|-- seurat与其他工具的衔接: LOOM /scanpy /bioconductor //todo
----------------------------------------
https://satijalab.org/seurat/v3.2/conversion_vignette.html


Seurat Wrappers
https://github.com/satijalab/seurat-wrappers/wiki/Submission-Process




========================================
Monocle 画涂抹heatmap的函数: plot_pseudotime_heatmap
----------------------------------------
url: https://github.com/cole-trapnell-lab/monocle-release
url: https://github.com/cole-trapnell-lab/monocle3


1. 下载、解压、进入文件夹
3.0版本没有这个函数。

$ find . | xargs grep "plot_pseudotime_heatmap" --color=auto 2>/dev/null


if(is.null(hmcols)) {
    bks <- seq(-3.1,3.1, by = 0.1)
    hmcols <- blue2green2red(length(bks) - 1)
  }
  else {
    bks <- seq(-3.1,3.1, length.out = length(hmcols))
  }
#



(2) 算了，还是安装吧，安装好，ctrl+单击函数名，
# fn1
table.ramp = function (n, mid = 0.5, sill = 0.5, base = 1, height = 1) {
  x <- seq(0, 1, length.out = n)
  y <- rep(0, length(x))
  sill.min <- max(c(1, round((n - 1) * (mid - sill/2)) + 1))
  sill.max <- min(c(n, round((n - 1) * (mid + sill/2)) + 1))
  y[sill.min:sill.max] <- 1
  base.min <- round((n - 1) * (mid - base/2)) + 1
  base.max <- round((n - 1) * (mid + base/2)) + 1
  xi <- base.min:sill.min
  yi <- seq(0, 1, length.out = length(xi))
  i <- which(xi > 0 & xi <= n)
  y[xi[i]] <- yi[i]
  xi <- sill.max:base.max
  yi <- seq(1, 0, length.out = length(xi))
  i <- which(xi > 0 & xi <= n)
  y[xi[i]] <- yi[i]
  height * y
}

# fn2
rgb.tables=function (n, red = c(0.75, 0.25, 1), green = c(0.5, 0.25, 1),  blue = c(0.25, 0.25, 1)) {
  rr <- do.call("table.ramp", as.list(c(n, red)))
  gr <- do.call("table.ramp", as.list(c(n, green)))
  br <- do.call("table.ramp", as.list(c(n, blue)))
  rgb(rr, gr, br)
}

# fn3
blue2green2red=function (n) {
	rgb.tables(n, red = c(0.8, 0.2, 1), green = c(0.5, 0.4, 0.8), blue = c(0.2, 0.2, 1))
}

bks <- seq(-3.1,3.1, by = 0.1)
hmcols <- blue2green2red(length(bks) - 1)

# view the effect
barplot(rep(1, length(hmcols)), col=hmcols, border = NA, space=0, axes=F)








2. 更多代码细节见: https://tool.biomooc.com/R_scripts/#t9





========================================
源码 | Seurat 包的可视化部分 visualization.R //todo
----------------------------------------
Seurat包的绘图函数代码：https://github.com/satijalab/seurat/blob/master/R/visualization.R


1. 为什么重复的PCA图和作者的左右反着或者上下反着呢？

#不修改，图就相反，函数默认参数是seed.use = 42
gbm <- RunPCA(gbm, features = VariableFeatures(object = gbm))

# 修改seed.use会出现与文章中一致的PCA图
gbm <- RunPCA(gbm, features = VariableFeatures(object = gbm),seed.use = NULL)






(1) 绘制PCA散点图使用的是：
p <- DimPlot(gbm, reduction = "pca",group.by="patient.id",pt.size = 1.2)
p


(2) 找到DimPlot绘图使用的横坐标和纵坐标用的值是什么，代码如下：
DimPlot <- function(


(3) 绘图使用的是SingleDimPlot函数，继续查看：
SingleDimPlot <- function(


在这里我们看到了绘图的核心，激动，使用的ggplot2，数据为data，几何对象geom_point，即点图：
plot <- ggplot(data = data) +
    geom_point(
      mapping = aes_string(
        x = dims[1],
        y = dims[2],
        color = paste0("`", col.by, "`"),
        shape = shape.by,
        alpha = alpha.by
      ),
      size = pt.size
    ) +
    guides(color = guide_legend(override.aes = list(size = 3))) +
    labs(color = NULL)
#


(4) 那么回过头去看data怎么得到的
reduction <- reduction %||% DefaultDimReduc(object = object)
cells <- cells %||% colnames(x = object)

data <- Embeddings(object = object[[reduction]])[cells, dims]
data <- as.data.frame(x = data)



(5) 找到关键的地方，省略花里胡哨的修饰得到如下：
cells <- colnames(x = gbm)
dims <- c(1,2)
reduction <- "pca"
data <- Embeddings(object = gbm[[reduction]])[cells, dims]
data <- as.data.frame(x = data)
dims <- paste0(Key(object = gbm[[reduction]]), dims)

plot <- ggplot(data = data) +
  geom_point(
    mapping = aes_string(
      x = dims[1],
      y = dims[2]
    ),
    size = 1.2
  )
plot


(6)看看如何通过Embeddings函数计算得到坐标
library(irlba)
npcs = 50

# PCA分析是基于pbmc[["RNA"]]@scale.data这个数据的
temp <- gbm[["RNA"]]@scale.data
temp[1:4,1:4]
dim(temp)
pca.results <- irlba(A = t(x = temp), nv = npcs)
cell.embeddings <- pca.results$u %*% diag(pca.results$d)
data1 <- cell.embeddings[,1:2]


# 比较
head(data)
                     PC_1       PC_2
1001000173.G8 -0.03682265   2.699819
1001000173.D4  4.34592621 -17.398409
1001000173.B4  9.10210569   5.652316
1001000173.A2 11.40656422   0.578273
1001000173.E2  5.38025168   2.970779
1001000173.F6  6.52216224   1.860002

head(data1)
            [,1]      [,2]
[1,] -0.03682265 -2.699819
[2,]  4.34592621 17.398409
[3,]  9.10210569 -5.652316
[4,] 11.40656422 -0.578273
[5,]  5.38025168 -2.970779
[6,]  6.52216224 -1.860002

验证了上面得到的data得到的方法。
绕了一大圈，这下还是回到了irlba函数。至少我们现在知道了这两个坐标是PCA结果的什么值对吧。并且也看见绘制这幅图得核心代码，排除了有一个人的回答，显然不是因为绘图得原因导致得：



ref:
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247496475&idx=1&sn=ddcf8a192439dbfa88f602f51ed7fc99
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247496550&idx=1&sn=c9e60d310807e537b3ca680e7c7281c9




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

