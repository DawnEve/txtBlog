Suerat 源码学习

Seurat 4 源码解析 1: Seurat 类怎么定义的？
	https://zhuanlan.zhihu.com/p/463532779

Seurat 4 源码解析 2：Seurat 对象怎么实例化？
	https://zhuanlan.zhihu.com/p/463602480

Seurat 4 源码解析 3：Seurat 对象的方法是怎么定义的？
	https://zhuanlan.zhihu.com/p/463617297

Seurat 4 R包源码解析 总目录: https://zhuanlan.zhihu.com/p/465392721




我从这些CNS文章里面精挑细选了一个非常值得大家花时间跟下去的，就是新鲜出炉的发表在CELL杂志的：Therapy-Induced Evolution of Human Lung Cancer Revealed by Single-Cell RNA Sequencing 。全套代码在：https://github.com/czbiohub/scell_lung_adenocarcinoma





========================================
问题汇总
----------------------------------------

1. 调用 tSNE 后还做了一次 PCA 
两次PCA基本一致。除了浪费时间。后面的聚类不依赖 tSNE，它仅仅用于可视化。
2 次 PCA 的差异: https://github.com/satijalab/seurat/issues/47













========================================
|-- step1: Read10X()
----------------------------------------
标题: Seurat 4 源码解析 4: step1 读入10x数据到内存 Read10X(data.dir=) https://zhuanlan.zhihu.com/p/464317172


1. 载入10x pbmc 数据: cellranger 处理fastq后的输出

(1) 读入 cellranger 输出为矩阵 
# 调用的代码
# load data
pbmc.data <- Read10X(data.dir = "~/data/scScripts/backup/data/pbmc3k/filtered_gene_bc_matrices/hg19/")
class(pbmc.data)
dim(pbmc.data) #32738  2700


# 定位 
seurat-4.1.0/R/preprocessing.R:781:Read10X <- function( #不含注释共123行


1) seq_along() 函数，返回整数向量，长度和第一个参数长度一致。
# for (i in seq_along(along.with = data.dir)) 

> seq_along(along.with = "~/data")
[1] 1
> seq_along(along.with = c("~/data", "~/"))
[1] 1 2


2) 读入稀疏矩阵 Matrix::readMM()
/seurat-4.1.0/NAMESPACE:382:importFrom(Matrix,readMM)


3) 文件、文件夹操作
    # 如果文件夹不存在
    if (!dir.exists(paths = run)) {
      stop("Directory provided does not exist")
    }
	
	# 拼接路径
	run <- data.dir[i]
	barcode.loc <- file.path(run, 'barcodes.tsv')
	
	
	# 如果文件不存在
	if (!file.exists(barcode.loc)) {
      stop("Barcode file missing. Expecting ", basename(path = barcode.loc))
    }
	
	# basename 拿到路径最后的文件名部分
	basename("~/data/bams/hg38-RefSeq.bed") #[1] "hg38-RefSeq.bed"


4) 正则的差异 grep(返回匹配的元素位置编号)， grepl(返回每一项是否匹配)
> grep(pattern="[0-9]+", c(1,5, "good", "200"))
[1] 1 2 4
> grepl(pattern="[0-9]+", c(1,5, "good", "200"))
[1]  TRUE  TRUE FALSE  TRUE


5) warning 的参数 call.= T(默认)

testit <- function() warning("Some are NA in testit")
testit() ## shows call 显示函数调用
# Warning message:
# In testit() : Some are NA in testit
#
testit <- function() warning("Some are NA in testit 2", call. = FALSE)
testit() ## no call
#Warning message:
#Some are NA in testit 2 #没有前缀  in fn()
#
suppressWarnings(warning("testit"))


6) warning 的参数 immediate.=F(默认)
# 即使设置 getOption("warn") <= 0，也立刻显示出该警告
options(warn=0)
getOption("warn")
testit <- function() {
  warning("Some are NA in testit 2", call. = FALSE)
  Sys.sleep(2)
}
testit() #等待函数调用结束再打印warning

testit <- function() {
  warning("Some are NA in testit 2", call. = FALSE, immediate. = T)
  Sys.sleep(2)
}
testit() #立刻打印warning，然后继续执行其余函数体



7) 通过在重复字符后添加数字后缀，来返回uniq vector
> make.unique(c("A", "B", "A", "D"))
[1] "A"   "B"   "A.1" "D"  
> make.unique(c("A", "B", "A", "D"), sep="-")
[1] "A"   "B"   "A-1" "D"










========================================
|-- step2: 创建 Seurat 对象 CreateSeuratObject()
----------------------------------------
Seurat 4 源码解析 5: step2 创建 Seurat 对象 CreateSeuratObject() https://zhuanlan.zhihu.com/p/464577819


1. 掉包侠 出场
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data,
                           project = "pbmc3k",
                           min.cells = 3,
                           min.features = 200)
# Warning: Feature names cannot have underscores ('_'), replacing with dashes ('-') 
pbmc
# An object of class Seurat 
# 13714 features across 2700 samples within 1 assay 
# Active assay: RNA (13714 features, 0 variable features)


这涉及到2个函数，
一个创建 CreateSeuratObject()，解析 2 
一个show()(见 解析3 2.3，本文略)






2. 源码及注释

(1) 函数定位
前面(解析 1)说过，虽然Seurat是S4类，但是这个CreateSeuratObject函数却是一个S3方法，而且定义不在Seurat包中，而是在SeuratObject包中。

$ find .  | grep "R$" | xargs grep -n "CreateSeuratObject" --color=auto
...
seurat-object-4.0.4/R/generics.R:179:CreateSeuratObject <- function( #泛型函数的定义
...
seurat-object-4.0.4/R/seurat.R:987:CreateSeuratObject.default <- function( #创建对象.默认
...
seurat-object-4.0.4/R/seurat.R:1034:CreateSeuratObject.Assay <- function( #创建对象.Assay
...


(2) S3 泛型函数
seurat-object-4.0.4/R/generics.R:179:CreateSeuratObject <- function( #泛型函数的定义

CreateSeuratObject <- function(
  counts,
  project = 'CreateSeuratObject',
  assay = 'RNA',
  names.field = 1,
  names.delim = '_',
  meta.data = NULL,
  ...
) {
  UseMethod(generic = 'CreateSeuratObject', object = counts)
}



(3) 我们输入的是矩阵或者df，不是Assay类的对象，所以使用 CreateSeuratObject.default()函数

> class(pbmc.data)
[1] "dgCMatrix"
attr(,"package")
[1] "Matrix"

seurat-object-4.0.4/R/seurat.R:987:CreateSeuratObject.default <- function( #创建对象.默认

而这个函数的返回值又调用了 CreateSeuratObject.Assay()
seurat-object-4.0.4/R/seurat.R:1034:CreateSeuratObject.Assay <- function( #创建对象.Assay




3. R tips

(1) meta.data <- meta.data[common.cells, , drop = FALSE] 这个 drop=F啥意思？

找函数名:
> methods(`[`)[ grep("frame", methods(`[`)) ]
[1] "[.data.frame" "[.hyperframe"

看这个函数的实现，结尾显示定义在base包中：
> `[.data.frame`
function (x, i, j, drop = if (missing(i)) TRUE else length(cols) == 1) 
{
    mdrop <- missing(drop)
    Narg <- nargs() - !mdrop
    has.j <- !missing(j)
    if (!all(names(sys.call()) %in% c("", "drop")) && !isS4(x)) 
        warning("named arguments other than 'drop' are discouraged")
    if (Narg < 3L) {
        if (!mdrop) 
            warning("'drop' argument will be ignored")
        if (missing(i)) 
            return(x)
	#... 太长了，加上也没看懂，先略过吧
    x
}
<bytecode: 0x5654bcce7f48>
<environment: namespace:base>

看参数列表，如果没有i，则drop=T，否则drop=length(cols) == 1
这个cols是什么？不知道，猜测可能是总列数，虽然我获取不到这个参数：
fn1=function(df1, n=cols){
  print(cols)
}
fn1(iris) # Error in print(cols) : object 'cols' not found


# 尝试该参数，貌似没有任何影响
`[.data.frame`(iris, 1:2, 1:2, drop=T)
`[.data.frame`(iris, 1:2, 1:2, drop=F)
iris[1:2, , drop=T]
iris[1:2, , drop=F]
# drop=T or F，返回值都一样

# 如果输入矩阵只有一列呢
iris[1:2, 1] #[1] 5.1 4.9 丧失数据框结构
iris[1:2, 1, drop=F] #保持数据框结构
#  Sepal.Length
#1          5.1
#2          4.9

原来作者是防止 meta.data 只有一列时，取子集后失去数据框结构。





(2) Key() 函数是干啥的？

> Key(pbmc_small)
    RNA     pca    tsne 
 "rna_"   "PC_" "tSNE_" 

如果输入是Assay，则返回的是该对象的 slot(assay, name="key")
> class(pbmc_small@assays$RNA)
[1] "Assay"
attr(,"package")
[1] "SeuratObject"

> Key(pbmc_small@assays$RNA)
[1] "rna_"

# 低层实现还是slot()函数
> slotNames(pbmc_small@assays$RNA)
[1] "counts"        "data"          "scale.data"    "key"           "assay.orig"    "var.features" 
[7] "meta.features" "misc"         

> slot(pbmc_small@assays$RNA, name="key")
[1] "rna_"

猜测key是用来识别数据来源的，是RNA或者ATAC。



(3) ExtractField() 自定义函数，内部就是分割字符串函数strsplit()。
把字符串string按照delim分隔开，提取其中某几个编号的field（单个数字，或逗号隔开的数字字符串），使用delim拼接后返回

seurat-object-4.0.4/R/utils.R:798:ExtractField <- function(string, field = 1, delim = "_") {

ExtractField <- function(string, field = 1, delim = "_") {
  fields <- as.numeric(x = unlist(x = strsplit(
	# 把 field 转为字符串，按照逗号分割，解开list，转为数字编号
    x = as.character(x = field),
    split = ","
  )))
  
  #如果只有一个数字编号，则直接返回delim分割后的该部分
  if (length(x = fields) == 1) {
    return(strsplit(x = string, split = delim)[[1]][field])
  }
  
  #超过1个数字编号，则使用delim把这些域连起来再返回
  return(paste(
    strsplit(x = string, split = delim)[[1]][fields],
    collapse = delim
  ))
}
# test
ExtractField('Hello World', field = 1, delim = ' ') #[1] "Hello"
ExtractField("aa1_bb2_cc3", field = "1,3", delim = '_') #"aa1_cc3"

unlist(lapply(
  X = colnames(x = iris), #就是cid
  FUN = ExtractField,
  field = 1, #names.field,
  delim = "\\."#names.delim
))
# [1] "Sepal"   "Sepal"   "Petal"   "Petal"   "Species"



(3) 在S4对象创建时在其slot中记录该R包版本号，有助于后续版本升级后的兼容、升级。

> ( version = packageVersion(pkg = 'SeuratObject') )
[1] ‘4.0.4’


(4) 自定义函数，计算 counts 这个Assay对象的 nCount 和 nGene
# seurat-object-4.0.4/R/assay.R:1140:CalcN <- function(object) {


#' Calculate nCount and nFeature
#'
#' @param object An \code{\link{Assay}} object
#'
#' @return A named list with nCount and nFeature
#'
#' @importFrom Matrix colSums
#'
#' @keywords internal 内部函数
#'
#' @noRd
#'
#' @examples
#' \donttest{
#' calcn <- SeuratObject:::CalcN(pbmc_small[["RNA"]])
#' head(as.data.frame(calcn))
#' }
#'
CalcN <- function(object) {
  if (IsMatrixEmpty(x = GetAssayData(object = object, slot = "counts"))) {
    return(NULL)
  }
  return(list(
    nCount = Matrix::colSums(x = object, slot = 'counts'), #感觉这一句写的不好。
	# Matrix::colSums 是不支持slot参数的，这样歧义，而且内部还是要用自定义实现，程序内部多了一步歧义空转
	# nCount = Matrix::colSums(x = GetAssayData(object = object, slot = 'counts') ), #更好的写法
	
    nFeature = Matrix::colSums(x = GetAssayData(object = object, slot = 'counts') > 0)
  ))
}


#' @rdname AssayData
#' @export
#' @method GetAssayData Assay
#'
#' @examples
#' # Get the data directly from an Assay object
#' GetAssayData(pbmc_small[["RNA"]], slot = "data")[1:5,1:5]
#'
GetAssayData.Assay <- function(
  object,
  slot = c('data', 'scale.data', 'counts'),
  ...
) {
  CheckDots(...)
  slot <- slot[1]
  slot <- match.arg(arg = slot) #对参数 slot 做自动补齐
  return(slot(object = object, name = slot))
}



> getMethod("colSums", signature = "Assay") #
Method Definition:

function (x, na.rm = FALSE, dims = 1, ...) #泛型的定义
{
    .local <- function (x, na.rm = FALSE, dims = 1, ..., slot = "data") #针对Assay类的定义
    {
        return(Matrix::colSums(x = GetAssayData(object = x, slot = slot), 
            na.rm = na.rm, dims = dims, ...))
    }
    .local(x, na.rm, dims, ...)
}
<bytecode: 0x5654c0d80620>
<environment: namespace:SeuratObject>

Signatures:
        x      
target  "Assay"
defined "Assay"



#' @describeIn Assay-methods Calculate \code{\link[base]{colSums}} on an
#' \code{Assay}
#'
#' @return \code{colSums}: The column (cell-wise) sums of \code{slot}
#'
#' @importFrom Matrix colSums
#'
#' @export
#'
setMethod(
  f = 'colSums',
  signature = c('x' = 'Assay'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'data') {
    return(Matrix::colSums(
      x = GetAssayData(object = x, slot = slot),
      na.rm = na.rm,
      dims = dims,
      ...
    ))
  }
)



(5) is.atomic() 检测一个变量是否是原子的。

# 简单对象都是原子的
> is.atomic(c(1,2))
[1] TRUE
> is.atomic(1)
[1] TRUE
> is.atomic("123")
[1] TRUE
> is.atomic(vector())
[1] TRUE


# 复合对象都不是原子的
> is.atomic(list())
[1] FALSE
> is.atomic(iris)
[1] FALSE
> is.atomic(pbmc_small)
[1] FALSE







========================================
|-- step2: (2) 用于创建 Seurat 对象的 Assay类 及方法
----------------------------------------
1. 引入
CreateSeuratObject.default() 函数中有一句很关键：

  # 创建Assay对象
  assay.data <- CreateAssayObject(
    counts = counts,
    min.cells = min.cells,
    min.features = min.features,
    row.names = row.names
  )

这里输入的是 counts 矩阵，在内部怎么转为 data, scale.data 的呢？
下面来详细解析。


2. 源码及解析
(1) S4类 Assay 的定义
seurat-object-4.0.4/R/assay.R:38:  Class = 'Assay',

Assay <- setClass(
  Class = 'Assay',
  slots = c(
    counts = 'AnyMatrix',
    data = 'AnyMatrix',
    scale.data = 'matrix',
    key = 'character',
    assay.orig = 'OptionalCharacter',
    var.features = 'vector',
    meta.features = 'data.frame',
    misc = 'OptionalList'
  )
)


(2) CreateAssayObject() 方法








3. R tips

(1) 定义联合类 setClassUnion()
slots第一个参数的类型是 'AnyMatrix'，没见过，查一下定义：
# AnyMatrix 定义在 seurat-object-4.0.4/R/zzz.R:41
setClassUnion(name = 'AnyMatrix', members = c("matrix", "dgCMatrix"))
setClassUnion(name = 'OptionalCharacter', members = c('NULL', 'character'))
setClassUnion(name = 'OptionalList', members = c('NULL', 'list'))


例子: 使用已有的类定义一个新类

setClassUnion(name = 'data.frameOrMatrix', members = c("data.frame","matrix"))
is(iris, "data.frameOrMatrix") #T
is(c(1,2,3), "data.frameOrMatrix") #F
is( as.matrix(iris), "data.frameOrMatrix") #T

is( as.matrix(iris), "data.frame") #F


(2) anyDuplicated() 函数，返回重复元素的位置编号

> anyDuplicated(colnames(iris))
[1] 0
> anyDuplicated(c(1,2,3,1))
[1] 4


(3) make.unique() 添加后缀强制uniq

> make.unique(c("A", "B", "A", "A"))
[1] "A"   "B"   "A.1" "A.2"
> make.unique(c("A", "B", "A", "A"), sep="-")
[1] "A"   "B"   "A-1" "A-2"



(4) any() 任何一个为T就返回T

> any(c(1,2,-1) < 0)
[1] TRUE
> any(c(1,2,3) < 0)
[1] FALSE



(5) 好用的自定义函数 CheckMatrix()，检查矩阵的异常值，只警告，不修改，不返回。

> CheckMatrix
function (object, checks, ...) 
{
    UseMethod(generic = "CheckMatrix", object = object)
}
<bytecode: 0x5564de914570>
<environment: namespace:SeuratObject>

定义的位置
seurat-object-4.0.4/R/utils.R:51:CheckMatrix <- function(object, checks, ...) {


主函数就是检查是否含有异常值，有了就警告，没有返回值。
CheckMatrix.dMatrix <- function(
  object,
  checks = c('infinite', 'logical', 'integer', 'na'),
  ...
) {
  checks <- match.arg(arg = checks, several.ok = TRUE)
  x <- slot(object = object, name = 'x')
  for (i in checks) {
    switch(
      EXPR = i,
      'infinite' = if (any(is.infinite(x = x))) { #有无穷大，就警告
        warning("Input matrix contains infinite values")
      },
      'logical' = if (any(is.logical(x = x))) { #有逻辑值，就警告
        warning("Input matrix contains logical values")
      },
      'integer' = if (!all(round(x = x) == x, na.rm = TRUE)) { #有非整数，就警告
        warning("Input matrix contains non-integer values")
      },
      'na' = if (anyNA(x = x)) { #有NA，就警告
        warning("Input matrix contains NA/NaN values")
      },
    )
  }
  return(invisible(x = NULL))
}



(6) match.arg(arg = checks, several.ok = TRUE) 能自动补齐参数，第二个参数是支持多个参数

# 就是只输入长字符串的开头几个字母，自动补齐其余部分
fn1=function( checks = c('infinite', 'logical', 'integer', 'na'), flag=T){
  checks= match.arg(arg = checks, several.ok = flag)
  print(checks)
}

# several.ok 默认是F，只支持一个参数匹配
fn1(c("inf", "n"), F) #'arg' must be of length 1 
fn1(c("inf", "n"), T) #"infinite" "na"

fn1(c("l")) #"logical"
# 如果输入有歧义，则无法自动补齐
fn1(c("in"), T) #Error: 'arg' should be one of “infinite”, “logical”, “integer”, “na” 
fn1(c("int"), T) #[1] "integer"

> fn1(flag=T) # 空白可以匹配全部参数
[1] "infinite" "logical"  "integer"  "na"



(7) anyNA() 有NA就返回T
> anyNA
function (x, recursive = FALSE)  .Primitive("anyNA")
> anyNA(c(1,2,3))
[1] FALSE
> anyNA(c(1,2,NA))
[1] TRUE



(8) invisible() 在没有左变量时隐藏函数的返回值
fn2=function(x){
  return(x)
}

fn2i=function(x){
  return(invisible(x))
}

> rs2=fn2(2)
> fn2(2) #输出返回值
[1] 2
> rs2
[1] 2
> #
> rs2i=fn2i(2)
> fn2i(2) #不输出返回值
> rs2i
[1] 2







(9) grepl 的 fixed=T 时，表示第一个参数是字符串，而不是正则表达式。
fixed: logical. If TRUE, pattern is a string to be matched as is. Overrides all conflicting arguments.

> grepl(pattern = '|', x = c("a|1","b2", "C33" ), fixed = TRUE)
[1]  TRUE FALSE FALSE

> grepl(pattern = '|', x = c("a|1","b2", "C33" ), fixed = F) #默认是F
[1] TRUE TRUE TRUE





========================================
|-- step3: step3 add meta.data(percent.mt, percent.rp, cell cycle score)
----------------------------------------
1. 掉包侠

# step3 add meta.data
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc[["percent.rp"]] <- PercentageFeatureSet(pbmc, pattern = "^RP[SL]")

# cell cycle
pbmc <- CellCycleScoring(pbmc,
                         s.features = cc.genes$s.genes,
                         g2m.features = cc.genes$g2m.genes)

本文主要看函数 PercentageFeatureSet 的实现。
后面有空再研究 CellCycleScoring 函数。

要点：
PercentageFeatureSet 函数是根据counts总数相除算的打分：该基因集的counts总和/所有基因的counts总和。

核心语句：
  percent.featureset <- colSums(x = GetAssayData(object = object, assay = assay, slot = "counts")[features, , drop = FALSE])/
    object[[paste0("nCount_", assay)]] * 100

# 基因集占的百分比 = 分子 / 分母 * 100；
# 分子： GetAssayData 获取 counts矩阵，按列(cell)求 指定基因的 counts种和
# 分母： 从 meta.data 获取 nCount_RNA 列，就是每个cell中所有基因的 counts总和





2. 源码与解析
(1) 函数定位 
seurat-4.1.0/R/utilities.R:1153:PercentageFeatureSet <- function(


(2) 





3. R tips 

(1) `%||%` 设置默认值：如果第一个参数为空，就返回第二个值 
这是 rlang 包中的函数
> `%||%`
function (x, y) 
{
    if (is_null(x)) 
        y
    else x
}
<bytecode: 0x55c79f873e60>
<environment: namespace:rlang>





(2) 检查传入的参数是有命名参数

fn1=function(...){
  args.names=names(x = list(...))
  print(args.names)
  
  if (is.null(x = args.names)) {
    stop("No named arguments passed")
  }
}

fn1(c(1,2,100), a=1, b=2) 
# [1] ""  "a" "b"

fn1( c(1,2,100) ) #没有命名的参数就返回T，至少有一个是命名的参数
fn1() #如果都不传入呢？也报错 #在 CheckDots()中不可能，因为前面还有一个参数长度判断
# NULL
# Error:  No named arguments passed

fn1( x=1) 
#[1] "x"



(3) 对list循环，获取的是里面的值

a1=list(a=1, b=20, c=33)
for(i in a1){
  print(i)
}
#[1] 1
#[1] 20
#[1] 33


# 如果想获取键呢？
ks=names(a1)
for(i in 1:length(ks)){
  k1=ks[i]
  v1=a1[[k1]]
  cat(i, k1, v1,  '\n')
}
# 1 a 1 
# 2 b 20 
# 3 c 33





(4) sapply (lapply 的简化版) 第一个参数可以是函数或函数名

# 我们第一个参数一般传入list格式的数据
sapply( split(iris[,1:4], iris[,5]), function(x){
  nrow(x)
})
# setosa versicolor  virginica 
#        50         50         50

# 现在传入list格式的函数
df1=sapply( list(mean, sum, "max", "min"), function(fn){
  apply(iris[,1:4], 2, fn)
})
df1
#                 [,1]  [,2] [,3] [,4]
#Sepal.Length 5.843333 876.5  7.9  4.3
#Sepal.Width  3.057333 458.6  4.4  2.0
#Petal.Length 3.758000 563.7  6.9  1.0
#Petal.Width  1.199333 179.9  2.5  0.1





(5) 错误处理函数tryCatch()，保证出错了也不退出，而是继续执行后面的代码

# iris总共4列，我们尝试取第10列，不存在的列
arr1=c(1,10,2,3) 
for(i in arr1){
  len=length(iris[,i])
  cat(i, len, "\n")
}
#1 150 
#Error in `[.data.frame`(iris, , i) : undefined columns selected


# 怎么出错后继续执行其余部分呢？使用错误处理语句 tryCatch。
for(i in arr1){
  tryCatch(
    expr={
      len=length(iris[,i])
      cat(i, len, "\n")
    },
    error=function(e){
      print(e)
    }
  )
}
#1 150 
#<simpleError in `[.data.frame`(iris, , i): undefined columns selected>
#2 150 
#3 150 





(6) 是否是 S3 泛型函数

# 定义在 <environment: namespace:utils>
> isS3stdGeneric(show)
[1] FALSE
> isS3stdGeneric(print)
print 
 TRUE 
> isS3stdGeneric("print")
print 
 TRUE 



(7) 获取函数的参数列表
> argsAnywhere
function (x) 
{
    if (tryCatch(!is.character(x), error = function(e) TRUE)) 
        x <- as.character(substitute(x))
    fs <- getAnywhere(x)
    if (sum(!fs$dups) == 0L) 
        return(NULL)
    if (sum(!fs$dups) > 1L) 
        sapply(fs$objs[!fs$dups], function(f) if (is.function(f)) 
            args(f))
    else args(fs$objs[[1L]])
}
<bytecode: 0x55cea99b7d20>
<environment: namespace:utils>



> argsAnywhere("print.data.frame") #能导出内部函数
function (x, ..., digits = NULL, quote = FALSE, right = TRUE, 
    row.names = TRUE, max = NULL) 
NULL

> args("print.data.frame")
function (x, ..., digits = NULL, quote = FALSE, right = TRUE, 
    row.names = TRUE, max = NULL) 
NULL


> Seurat::CheckDots
Error: 'CheckDots' is not an exported object from 'namespace:Seurat'

> args(CheckDots) #只能找到暴露出来的函数
Error in args(CheckDots) : object 'CheckDots' not found

> argsAnywhere(CheckDots) #能获得任何地方的定义，只要能找到，不局限在暴露的函数
[[1]]
function (..., fxns = NULL) 
NULL

[[2]]
function (..., fxns = NULL) 
NULL







(8) 获取R的环境变量，如果没有，就使用默认值。
getOption(x = "Seurat.checkdots", default = 'warn')

> options() #获取所有环境变量


#获取小数点显示位数，默认7位
> getOption("digits") 
[1] 7
> 1/7
[1] 0.1428571


# 改为10位
> options(digits=10)
> 1/7
[1] 0.1428571429



(9) sapply() 设置参数 simplify=F 和 USE.NAMES = T 返回一个named list。

# 创建S4类 Person
setClass("Person", 
         slots=c(name="character", age="numeric"))
# 实例化
p1=new("Person", name="Tim", age=20)
p1


# 测试输出其每个slot的值
sapply(
  X=slotNames(p1),
  FUN=function(x){
    slot(p1, name=x)
  }
)
# name   age 
# "Tim"  "20" 

sapply(
  X=slotNames(p1),
  FUN=function(x){
    slot(p1, name=x)
  },
  simplify = F #不使用简单输出，则输出list
  # 默认是输出名字的 USE.NAMES = T
)
# $name
#[1] "Tim"

#$age
#[1] 20



# 不使用简单输出，且不输出名字，结果和 lapply 的输出一样
# [[1]]
#[1] "Tim"

#[[2]]
#[1] 20


# 返回list的好方法
sapply(X=colnames(iris[,1:4]),
       function(x){
         mean( iris[,x] )
       }, 
       simplify = F)
输出：
$Sepal.Length
[1] 5.843333

$Sepal.Width
[1] 3.057333

$Petal.Length
[1] 3.758

$Petal.Width
[1] 1.199333



(10) grep(..., value=T) 直接返回匹配的元素，而不是下标编号
这一点前面说过，这里再强调一遍，实在是太有用了。
# grep(pattern = "^HLA", x = rownames(x = pbmc_small[["RNA"]]), value = TRUE)


# 我以前匹配基因的方法很繁琐
grep("^HLA", x = rownames(pbmc_small) )
# [1]   4   6   8 119 122 124 125 127 128 132
rownames(pbmc_small)[ grep("^HLA", x = rownames(pbmc_small) ) ]
# [1] "HLA-DRA"  "HLA-DQB1" "HLA-DMB"  "HLA-DPA1" "HLA-DMA"  "HLA-DPB1" "HLA-DQA1" "HLA-DRB5" "HLA-DRB1" "HLA-DQA2"


# 现在发现，只要多设置一个参数即可
grep("^HLA", x = rownames(pbmc_small), value=T ) #结果同上
# [1] "HLA-DRA"  "HLA-DQB1" "HLA-DMB"  "HLA-DPA1" "HLA-DMA"  "HLA-DPB1" "HLA-DQA1" "HLA-DRB5" "HLA-DRB1" "HLA-DQA2"


















========================================
|-- Seurat 4 源码解析 8: step4 QC可视化 VlnPlot()
----------------------------------------
源码解析章节在 bookdown 书中: https://github.com/DawnEve/R_best_practice

1. 调包侠
# step4 QC
# Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.rp"), ncol = 4, pt.size=0)

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2

# filter
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)



掉包侠小技巧


(1) 如何获取 meta.data 某一列，并把其name设置为cell id?

> w1=pbmc_small@meta.data$groups
> names(w1)=colnames(pbmc_small)
> head(w1)
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
          "g2"           "g1"           "g2"           "g2"           "g2"           "g1" 

使用函数"[["后只需要一行，且免去了中间变量：
> head( pbmc_small[["groups", drop=T]] )
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
          "g2"           "g1"           "g2"           "g2"           "g2"           "g1" 


函数定义：以后再讲。
$ find .  | grep "R$" | xargs grep -n "\[\[\.Seurat" --color=auto
./seurat-object-4.0.4/R/seurat.R:2123:"[[.Seurat" <- function(x, i, ..., drop = FALSE) {








2. 源码与解析
VlnPlot
# seurat-4.1.0/R/visualization.R:575:VlnPlot <- function(






3. R tips 

(1) 函数参数改变了，本session就提醒用户一次，如何控制显示次数？使用环境变量

fn1= function(x, split.by=NULL){
  if (
    !is.null(x = split.by) &
    getOption(x = 'Seurat.warn.vlnplot.split2', default = TRUE)
  ) {
    message(
      "可以设置多行提醒，结尾加换行符；本次session只提醒这一次\n",
      "The default behaviour of split.by has changed.\n",
      "Separate violin plots are now plotted side-by-side.\n",
      "To restore the old behaviour of a single split violin,\n",
      "set split.plot = TRUE.
      \nThis message will be shown once per session."
    )
    # 设置全局变量，下次使用不会提醒；重启 R session 会再次提醒。
    options(Seurat.warn.vlnplot.split2 = FALSE)
  }
  return(x)
}


# 假设 该包中 split.by 参数的意义在新版本中调整了，用户不用该参数就不提醒；
# 用户用了该参数就要红字提醒！但是频率又不能太高，重启前就提醒一次。
> fn1(1) 
[1] 1

> fn1(1, split.by=T)
可以设置多行提醒，结尾加换行符；本次session只提醒这一次
The default behaviour of split.by has changed.
Separate violin plots are now plotted side-by-side.
To restore the old behaviour of a single split violin,
set split.plot = TRUE.
      
This message will be shown once per session.
[1] 1

> fn1(1, split.by=T)
[1] 1




(2) base::isTRUE() 判断是否是逻辑值 TRUE？

> isTRUE
function (x) 
is.logical(x) && length(x) == 1L && !is.na(x) && x
<bytecode: 0x55b7d295d998>
<environment: namespace:base>

看这里做了很多判断: 是逻辑值，且长度是1，且不能是NA，然后再看本身的真假。

> isTRUE(2)
[1] FALSE
> isTRUE("TRUE")
[1] FALSE
> isTRUE(T)
[1] TRUE



(3) 如何合理设置图形列数？

library(rlang)
fn1=function(features, ncol=NULL){
  # 如果 ncol 为空，则设置默认值：基因数>9则选4，否则为 基因数和3中的最小值。
  ncol <- ncol %||% ifelse(
    test = length(x = features) > 9,
    yes = 4,
    no = min(length(x = features), 3)
  )
  return(ncol)
}


> fn1(1:10)
[1] 4
> fn1(1:5)
[1] 3
> fn1(c(1,2))
[1] 2



(4) 如何自动获取n个差异尽可能大的颜色？scales::hue_pal()( 5 )

Seurat 4的 VlnPlot 函数使用的方法是: cols <- hue_pal()(length(x = levels(x = idents)))

> scales::hue_pal()( 5 )
[1] "#F8766D" "#A3A500" "#00BF7D" "#00B0F6" "#E76BF3"

# 直接可视化
# n=4; barplot(rep(1,n), col=scales::hue_pal()( n ), axes=F, border = NA)



(5) 把数字转为16进制 as.hexmode(11)

> as.hexmode(11)
[1] "b"

> as.hexmode(15:0)
 [1] "f" "e" "d" "c" "b" "a" "9" "8" "7" "6" "5" "4" "3" "2" "1" "0"



(6) vapply()，类似sapply，优点是参数FUN.VALUE可检查返回值的数据类型

hexadecimal=c("#FF0000", "#FFFF00")
vapply(
  X = toupper(x = hexadecimal), #先变大写字母
  
  FUN = function(hex) {
    hex=substring(hex,2)
    hex=rev(strsplit(hex, split="")[[1]] )
    hex=paste(hex, collapse = "")
    return( paste0("#", hex) ) 
  },
  FUN.VALUE = character(length = 1L), #返回值是字符串，长度为1
  USE.NAMES =FALSE #不使用名字
)
# [1] "#0000FF" "#00FFFF"






(7)  InvertHex() 输入16进制颜色，输出互补色

# 取相反的颜色，就是16进制颜色(去掉#后的前6位)的每一位都是 16-x
cols <- scales::hue_pal()(4); cols
# [1] "#F8766D" "#7CAE00" "#00BFC4" "#C77CFF"
cols2=Seurat:::InvertHex(hexadecimal = cols); cols2
# [1] "#078992" "#8351FF" "#FF403B" "#388300"

barplot(rep(1,8), col=c(cols, cols2),
        axes=F, border = NA)


Seurat:::InvertHex(hexadecimal = c("#FF0000"))
# [1] "#00FFFF"



源码也值得研究：
seurat-4.1.0/R/visualization.R:6274:InvertHex <- function(hexadecimal) {

# Invert a Hexadecimal color
#
# @param hexadecimal A character vector of hexadecimal colors
#
# @return Hexadecimal representations of the inverted color
#
# @author Matt Lagrandeur
# @references \url{http://www.mattlag.com/scripting/hexcolorinverter.php}
#
InvertHex <- function(hexadecimal) {
  return(vapply(
    X = toupper(x = hexadecimal), #先变大写字母
	
    FUN = function(hex) { #对每个16进制颜色进行循环
	
	  ###########
      # 输入16进制颜色字符串的合法性检查
      hex <- unlist(x = strsplit(
        x = gsub(pattern = '#', replacement = '', x = hex), #先去掉#符号
        split = '' #再用空字符分割
      )) 
	  # 获得16进制的每个字符 [1] "F" "8" "7" "6" "6" "D"
	  
	  # 把15:0转为16进制，大写，相当于造了个字库
      key <- toupper(x = as.hexmode(x = 15:0)) #[1] "F" "E" "D" "C" "B" "A" "9" "8" "7" "6" "5" "4" "3" "2" "1" "0"
	  
	  # 如果不是所有 输入字符都在 0-f之间，则报错退出
      if (!all(hex %in% key)) {
        stop('All hexadecimal colors must be valid hexidecimal numbers from 0-9 and A-F')
      }
	  
	  # 如果长度为8，则最后2位为 alpha
      if (length(x = hex) == 8) {
        alpha <- hex[7:8]
        hex <- hex[1:6] #颜色是前6位
	  # 如果长度是6，则alpha为NULL
      } else if (length(x = hex) == 6) {
        alpha <- NULL
	  # 其他情况，报错退出
      } else {
        stop("All hexidecimal colors must be either 6 or 8 characters in length, excluding the '#'")
      }
	  
	  # 首尾颠倒 key 这个字库
      value <- rev(x = key)
	  
      inv.hex <- vapply(
        X = hex, # 对于颜色的每一位进行循环
		
        FUN = function(x) {
          return(value[grep(pattern = x, x = key)]) #返回的是每位的下标，对应的字典逆序
        },
        FUN.VALUE = character(length = 1L)
      )
	  
	  # 连起来，前面加上#号
      inv.hex <- paste(inv.hex, collapse = '')
      return(paste0('#', inv.hex, paste(alpha, collapse = '')))
    },
    FUN.VALUE = character(length = 1L), #返回值是字符串
    USE.NAMES = FALSE #不使用名字
  ))
}




(8) Interleave() 把几个向量交错排列成一个向量
interleave [ˌɪntəˈliːv] v. 交错；插空白页于；插叙

源码位置
seurat-4.1.0/R/utilities.R:1954:Interleave <- function(...) {

# Interleave vectors together
#
# @param ... Vectors to be interleaved
#
# @return A vector with the values from each vector in ... interleaved
#
Interleave <- function(...) {
  return(as.vector(x = t(x = as.data.frame(x = list(...)))))
}


# 测试效果
> Interleave(c(1,2,3), c(10,20,30))
[1]  1 10  2 20  3 30
> Interleave(c(1,2,3), c(10,20,30), c(100,200,300))
[1]   1  10 100   2  20 200   3  30 300


解析：主要是4步
step1: 
> list(c(1,2,3), c(10,20,30), c(100,200,300))
[[1]]
[1] 1 2 3

[[2]]
[1] 10 20 30

[[3]]
[1] 100 200 300


step2:
> as.data.frame( list(c(1,2,3), c(10,20,30), c(100,200,300)) )
  c.1..2..3. c.10..20..30. c.100..200..300.
1          1            10              100
2          2            20              200
3          3            30              300

第三步：
> t( as.data.frame( list(c(1,2,3), c(10,20,30), c(100,200,300)) ) )
                 [,1] [,2] [,3]
c.1..2..3.          1    2    3
c.10..20..30.      10   20   30
c.100..200..300.  100  200  300

> as.vector( t( as.data.frame( list(c(1,2,3), c(10,20,30), c(100,200,300)) ) ) )
[1]   1  10 100   2  20 200   3  30 300



总结：就是说把 matrix 转为 vector的时候，是按照列向量展开的：

> as.vector(iris[1:2, 1:4])
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2

# 按列展开成一个向量
> as.vector( as.matrix(iris[1:2, 1:4]) )
[1] 5.1 4.9 3.5 3.0 1.4 1.4 0.2 0.2


# 想按行展开，就先转置，再按列展开
> as.vector( t(as.matrix(iris[1:2, 1:4]) ) )
[1] 5.1 3.5 1.4 0.2 4.9 3.0 1.4 0.2




(9) interaction() 计算因子之间的交互作用

> a <- gl(2, 4, 8);a
[1] 1 1 1 1 2 2 2 2
Levels: 1 2
> b <- gl(2, 2, 8, labels = c("ctrl", "treat"));b
[1] ctrl  ctrl  treat treat ctrl  ctrl  treat treat
Levels: ctrl treat
> interaction(a, b)
[1] 1.ctrl  1.ctrl  1.treat 1.treat 2.ctrl  2.ctrl  2.treat 2.treat
Levels: 1.ctrl 2.ctrl 1.treat 2.treat



(10) 16机制字符串转为10进制数字 strtoi("10", base=16)
> strtoi("10", base=16)
[1] 16
> strtoi("FF", base=16)
[1] 255




(11) Col2Hex() 把R颜色转为 16进制

> Seurat:::Col2Hex(c("red", "#FF00FF"))
[1] "#FF0000FF" "#FF00FFFF"

原函数
/seurat-4.1.0/R/visualization.R:5498:Col2Hex <- function(...) {


# Convert R colors to hexadecimal
#
# @param ... R colors
#
# @return The hexadecimal representations of input colors
#
#' @importFrom grDevices rgb col2rgb
#
Col2Hex <- function(...) {
  colors <- as.character(x = c(...)) #转为字符串
  alpha <- rep.int(x = 255, times = length(x = colors)) #alpha默认是255，都不透明
  
  # 如果颜色里 以#开头的元素 总个数不等于0，那就是>0
  if (sum(sapply(X = colors, FUN = grepl, pattern = '^#')) != 0) {
    # 获取#开头的元素
    hex <- colors[which(x = grepl(pattern = '^#', x = colors))]
    hex.length <- sapply(X = hex, FUN = nchar) #看每个多长
	
	#如果有9位的
    if (9 %in% hex.length) {
      hex.alpha <- hex[which(x = hex.length == 9)] #获取9位长度的颜色
      hex.vals <- sapply(X = hex.alpha, FUN = substr, start = 8, stop = 9) #获取第8和9位
      dec.vals <- sapply(X = hex.vals, FUN = strtoi, base = 16) #把alpha值从16进制转为10进制
      alpha[match(x = hex[which(x = hex.length == 9)], table = colors)] <- dec.vals #更新alpha数组
    }
  }
  
  # 颜色字符串，转为rgb一列3行的matrix，转置后是一行3列rgb值。
  colors <- t(x = col2rgb(col = colors))
  
  # 多参数 apply: 
  colors <- mapply(
    FUN = function(i, alpha) {
      return(rgb(colors[i, , drop = FALSE], #不能丢掉df结构，否则rgb()报错: incorrect number of dimensions
			alpha = alpha, maxColorValue = 255))
    },
    i = 1:nrow(x = colors),
    alpha = alpha
  )
  return(colors)
}



(12) rep_len(x, length.out) 把向量 x 重复，最终输出长度为 length.out

> rep_len(c("Xx", "Yy"), length.out =4)
[1] "Xx" "Yy" "Xx" "Yy"





(13) 如果没有安装某个包，则报错退出。
SingleExIPlot() 中提到的 PackageCheck():

if (!PackageCheck('ggrastr', error = FALSE)) {
  stop("Please install ggrastr from CRAN to enable rasterization.")
}


> PackageCheck
function (..., error = TRUE) 
{
	# 解开为pkg名字
    pkgs <- unlist(x = c(...), use.names = FALSE)
	
	# 检测是否安装了
    package.installed <- vapply(
		X = pkgs, #对每个包循环
		FUN = requireNamespace, 
        FUN.VALUE = logical(length = 1L), 
		quietly = TRUE)
	
	# 如果让提示 error，且 至少一个包 没安装
    if (error && any(!package.installed)) {
		# 报错
        stop("Cannot find the following packages: ", 
			paste(pkgs[!package.installed], collapse = ", "), 
			". Please install")
    }
	
	# 沉默返回 已安装的包
    invisible(x = package.installed)
}
<bytecode: 0x55f2bb3e9700>
<environment: namespace:SeuratObject>




核心句子：
> package.installed <- vapply(
     X = c("ggplot2", "GEB", "AAA"), #对每个包循环
     FUN = requireNamespace, 
     FUN.VALUE = logical(length = 1L), 
     quietly = T)

> package.installed
ggplot2     GEB     AAA 
   TRUE    TRUE   FALSE 

> any(!package.installed)
[1] TRUE






(14) 任务: 对鸢尾花的分类列转为因子，因子的顺序时按照第2列的最大值排序，支持升序降序。


fn1=function(feature=2, fun="mean", sort="de"){ #ASC/DESC 才是排序的标准词汇
  data=iris;
  data$ident=iris$Species
  #
  data$ident <- factor(
    x = data$ident,
    
    # 原函数这里用rev又逆转一次
    levels = names(x = (x = sort( # 按均值排序
      
      # 按照 ident 对 feature列分割，取每组平均值
      x = tapply(
        X = data[, feature],
        INDEX = data$ident,
        FUN = fun
      ),
      
      # 小写后的sort能匹配到"decreasing"则降序
      decreasing = grepl(pattern = paste0('^', tolower(x = sort)), x = 'decreasing')
      
    )))
  )
 return(data)  
}


# 算出来第2列每类的最大值
sapply( split(iris[,2], iris[,5]), function(x){
  max(x)
})
# setosa versicolor  virginica 
#    4.4        3.4        3.8 


# 按照第二列的最大值排序
rs1=fn1(2, "max", "de")#降序
#str(rs1)
levels(rs1$ident) 
# [1] "setosa"     "virginica"  "versicolor"


rs1=fn1(2, "max", "asc")#升序
levels(rs1$ident)
# [1] "versicolor" "virginica"  "setosa"    



(15) 去掉无穷大之后的最大值。
data=data.frame(
  x1=c(1,2,-3, 1/0)
)
data
feature="x1"
max(data[, feature][is.finite(x = data[, feature])])
# [1] 2





(16) geom_violin(scale="width") 的参数

library(ggplot2)
library(cowplot)
df1=data.frame(
  value=iris$Sepal.Length,
  ident=iris$Species
)
head(df1)

# 版本1: 
ggplot(df1, aes(x=ident, y=value, fill=ident)) +
  geom_violin()+ #scale="area" 默认，每个图形面积相等
  labs(x = 'Identity', y = "Expression Level", title = "feature", fill = NULL)+
  theme_cowplot()+
  theme(plot.title = element_text(hjust = 0.5))

# 版本2: 
ggplot(df1, aes(x=ident, y=value, fill=ident)) +
  geom_violin(scale="width")+ #每个图形最宽的地方相同
  labs(x = 'Identity', y = "Expression Level", title = "feature", fill = NULL)+
  theme_cowplot()+
  theme(plot.title = element_text(hjust = 0.5))

# 版本3: 
ggplot(df1, aes(x=ident, y=value, fill=ident)) +
  geom_violin(scale="width",#每个图形最宽的地方相同
              adjust = 1, #默认值就是1，再小就很不光滑
              trim = F )+ #默认是trim=T, 卡在数据边缘，不出界。但是密度图在边缘一般都是出去的。
  labs(x = 'Identity', y = "Expression Level", title = "feature", fill = NULL)+
  theme_cowplot()+
  theme(plot.title = element_text(hjust = 0.5))




(17) 拆解 ggplot2 构建过程
接上文。
原作者做了更多的自定义修饰

plot=ggplot(df1, aes(x=ident, y=value, fill=ident)) +
  labs(x = 'Identity', y = "Expression Level", title = "feature", fill = NULL)+
  theme_cowplot()+
  theme(plot.title = element_text(hjust = 0.5))

# 通过自定义修改  
vln.geom=geom_violin # 函数重命名

geom <- list(
  vln.geom(scale = 'width', adjust = 1, trim = TRUE), #geom_violin 的这几个参数
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) #x轴旋转45度
)

plot <- do.call(what = '+', args = list(plot, geom)) #还能这样给ggplot2添加修改
plot
plot + scale_y_log10() #这个 log 看着没啥作用啊



(18) 栅格化点图
接上文。
jitter <- ggrastr::rasterize(geom_jitter(height = 0, size = 0.1, show.legend = FALSE))

plot+jitter



(19) y轴显示为log10尺度 scale_y_log10()
library(ggplot2)

df1=data.frame(
  x=1:100,
  y=2*(1:100)
)
ggplot(df1, aes(x=x, y=y)) + geom_point() #原始
ggplot(df1, aes(x=x, y=y)) + geom_point() + scale_y_log10() #y轴是log10尺度的，单位距离在log10尺度相等
# 点的坐标log10转化，同时y轴坐标为 3,10,30,100，也就是能在图中读出来原始y值

ggplot(df1, aes(x=x, y=log10(y) )) + geom_point() #点图完全相同，就是y轴坐标的差异
# 点的坐标log10转化，同时y的坐标为 0.5, 1, 1.5, 2，也就是图中的y坐标是原始y值的log10后的值

# 可以看到对应关系: 10**(c(0.5,1,1.5,2)) #[1]   3.162278  10.000000  31.622777 100.000000






(20) 使用 droplevels() 去掉因子中没用到的levels
# Drop Unused Levels from Factors

a=c(1,2,3,4,1)
a=factor(a)
a
b=a[1:3]
b
#[1] 1 2 3
#Levels: 1 2 3 4 这就多了一个无用的level 4

b2=droplevels(b)
b2
#[1] 1 2 3
#Levels: 1 2 3


# 只获取有用的 level
> levels(x = droplevels( Idents(pbmc_small) ))
[1] "0" "1" "2"





(21) scale_fill_manual(values = cols, labels = labels)

library(ggplot2)
set.seed(2022)
df1=data.frame(
  value=rnorm(120),
  type= rep( c("A", "B", "C"), 40)
)
p1=ggplot(df1, aes(type, value, fill=type))+geom_violin(); p1


# Create your own discrete scale
p1 + scale_fill_manual(values=c("black", "red", "blue"), 
                       labels=c("someA", "someB", "someC") ) #改变的是图例文字
					   
p1 + scale_fill_manual(limits=c("B", "A", "C"), #指定x轴的坐标，按这个顺序染色
                       
                       #但是图例按照下面2行染色和添加文字
                       values=c("black", "red", "blue"), 
                       labels=c("someA", "someB", "someC") ) #改变的是图例文字






(22) 使用lapply一次绘制多个基因的表达量boxplot，并拼合成一个整体

# 按am分组
features=colnames(mtcars)
plots <- lapply(
  
  X = features, #对每一个 feature 循环，进入FUN画图
  
  FUN = function(x) {
    data=mtcars[,x, drop=F]
    feature2 <- colnames(x = data) #只有一列，取列名
    
    # 添加分组变量
    data$ident=factor(mtcars$am)
    x2="ident"
    y=paste0("`", feature2, "`")
    fill="ident"
    ggplot(data, aes_string(x=x2, y=y, fill=fill ))+
      geom_violin( show.legend = F)+ #不显示坐标
      theme_classic()+
      labs(title=feature2)+
      theme(plot.title = element_text(hjust = 0.5),#标题居中
            #axis.text.x=element_blank(),
            axis.ticks.x = element_blank())
  }
)
plots[[3]]

plots2 = wrap_plots(plots, ncol = 4)
plots2








========================================
|-- Seurat 4 源码解析 9: FetchData()
----------------------------------------

1.
接着源码解析8.

(1)
在这里看到 key 的作用了，如果和 meta.data 重名，则返回的是 meta.data；如果想返回 assay中的值，则需要加上 assay的前缀
警告信息: Returning metadata; if you want the feature, please use the assay's key (eg. "

# 注意 CD8A 和 rna_CD8A

df1=FetchData2(pbmc_small, vars=c("PC_1", "tSNE_1", "CD4", "CD8A", "nCount_RNA"))
df2=FetchData2(pbmc_small, vars=c("PC_1", "tSNE_1", "CD4", "rna_CD8A", "nCount_RNA"))

可用的前缀：Key(pbmc_small)



(2) 如果指定的 assay 中没找到，则会从其他assay中找
//todo 例子？






2. 源码解析
见 gitee




3. R tips

(1) Filter 高阶函数，把f函数应用到数组x上，结果是TRUE的返回x上原来位置上的元素。

> Filter(f=function(x){x%%2==0}, 1:10)
[1]  2  4  6  8 10


(2) 异常捕获 tryCatch(expr, error=function(...){})
tryCatch(
	#降维类，行名是symbol，这里怎么使用 cells? // todo 可能是错的
	#测试了一下，这么写是对的，需要好好看看[[]]的实现方式了
	expr = object[[x]][[cells, vars.use, drop = FALSE]], # if 中返回的就是这一行，如果没报错
	error = function(...) { #错误处理函数，返回空
	  return(NULL)
}


> df1=FetchData(pbmc_small, vars=c("PC_1", "tSNE_1", "CD4", "CD8A"), cells = c("ATGCCAGAACGACT"))
> df1
                     PC_1    tSNE_1 CD8A
ATGCCAGAACGACT -0.7740371 0.8675977    0

// 这个需要进一步看[[]]的定义，这在R中也对应着一个函数。
// pbmc_small[[]] 返回的就是 pbmc_small@meta.data




(3) 根据条件获取值 x=if()else{}

x=if(T){
  tryCatch(
    expr=200, #返回这一行，如果没报错
    error=function(...){
      return(NULL)
    }
  )
}else{
  0.1
}
x #200



(4) as.list(x = as.data.frame(x = data.return)) 矩阵转为list是什么？

就是把df按列展开成list的键值对：列名是list的key，一列数字是list的value。

> data.return=iris[1:2,1:4]; data.return
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
> rs1=as.list(x = as.data.frame(x = data.return)); rs1
$Sepal.Length
[1] 5.1 4.9

$Sepal.Width
[1] 3.5 3.0

$Petal.Length
[1] 1.4 1.4

$Petal.Width
[1] 0.2 0.2


(5) data.fetched <- unlist(x = data.fetched, recursive = FALSE) 展开list成named vector。


> data.fetched=rs1; data.fetched
$Sepal.Length
[1] 5.1 4.9

$Sepal.Width
[1] 3.5 3.0

$Petal.Length
[1] 1.4 1.4

$Petal.Width
[1] 0.2 0.2

> unlist(x = data.fetched, recursive = FALSE)
Sepal.Length1 Sepal.Length2  Sepal.Width1  Sepal.Width2 Petal.Length1 Petal.Length2  Petal.Width1  Petal.Width2 
          5.1           4.9           3.5           3.0           1.4           1.4           0.2           0.2 




(6) 合并几个单list可以使用c()

注意：数据框也是list，每一列都是一个命名元素。


list1=list(
  a=c(1,2,3),
  b=c(10,20,30)
)
list1
c(list1, iris[1:3, 2, drop=F]) #合并为df，正确做法
c(list1, iris[1:3, 2, drop=T]) #默认是只有一列时失去df结构

输出：
> list1
$a
[1] 1 2 3

$b
[1] 10 20 30

> c(list1, iris[1:3, 2, drop=F]) #合并为df
$a
[1] 1 2 3

$b
[1] 10 20 30

$Sepal.Width
[1] 3.5 3.0 3.2

> c(list1, iris[1:3, 2, drop=T]) #默认是T, 只有一列时失去df结构
$a
[1] 1 2 3

$b
[1] 10 20 30

[[3]]
[1] 3.5

[[4]]
[1] 3

[[5]]
[1] 3.2




(7) 拼接数组为字符串: paste0() 的参数collapse

注意输入的是多个字符串，还是一个字符串数组。

> paste( "this", "is", "a", "book", sep = ":") #输入多个字符串
[1] "this:is:a:book"

> paste0( c("this", "is", "a", "book"), collapse = "-") #输入一个字符串数组
[1] "this-is-a-book"

> paste0( colnames(mtcars), collapse = ", ")
[1] "mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb"




(8) vector(mode = 'list', length = 2) 定义一个空向量。

vector produces a vector of the given length and mode.


> vector(mode = 'list', length = 2)
[[1]]
NULL

[[2]]
NULL

> vector(mode = 'logical', length = 2)
[1] FALSE FALSE

> vector(mode = 'numeric', length = 5)
[1] 0 0 0 0 0



(9) 为vector新增一个元素 append()

> a1=vector(mode = 'numeric', length = 5);a1
[1] 0 0 0 0 0
> a1=append(x=a1, value=100)
> a1
[1]   0   0   0   0   0 100




例2: 设置list向量，并为其中一个新增2个值，然后判断哪个值大于1。

a2=vector(mode = 'list', length = 3);
names(a2)=c("box1", "box2", "box3"); a2

a2[['box1']]=append(x=a2[['box1']], value=50)
a2[["box2"]]=append(x=a2[["box2"]], value=100)
a2[['box2']]=append(x=a2[['box2']], value=50)

> a2
$box1
[1] 50

$box2
[1] 100  50

$box3
NULL


vars.many <- names(x = Filter(
  f = function(x) {
    print(x)
    return(length(x = x) > 1)
  },
  x = a2
))
vars.many #[1] "box2"





(10) as.vector() 能把矩阵按照列展开。

> df1=iris[1:2, 1:4];df1
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2

> as.vector(df1)
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2

> as.vector( as.matrix(df1) )
[1] 5.1 4.9 3.5 3.0 1.4 1.4 0.2 0.2


> unlist(df1) # 对矩阵按列展开使用 unlist，还需要去掉name 才是向量。
Sepal.Length1 Sepal.Length2  Sepal.Width1  Sepal.Width2 Petal.Length1 Petal.Length2  Petal.Width1  Petal.Width2 
          5.1           4.9           3.5           3.0           1.4           1.4           0.2           0.2 




(11) 变list为df，指定行名，保持字符串而不是因子
data.fetched <- as.data.frame(
	x = data.fetched,
	row.names = cells,
	stringsAsFactors = FALSE
)



测试: 
# GetAssayData(object = pbmc_small)[c("LTB", "CD79B"), c("AATGTTGACAGTCA", "AGGTCATGAGTGTC") ]

data.fetched=list(
  "LTB"=c(7.650169, 5.779448),
  "CD79B"=c(4.615121, 5.779448)
)
data.fetched

cells=c("AATGTTGACAGTCA", "AGGTCATGAGTGTC")

as.data.frame(
  x = data.fetched,
  row.names = cells, #换成 rownames 就不行，就没有行名了
  stringsAsFactors = FALSE
)
输出：
#                     LTB    CD79B
# AATGTTGACAGTCA 7.650169 4.615121
# AGGTCATGAGTGTC 5.779448 5.779448




(12) pmatch(): Partial String Matching 部分字符串匹配

pmatch seeks matches for the elements of its first argument among those of its second.
Usage: pmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE)


1) x中的每一个元素，在第二个参数table中的位置下标。
vars=c("a1", "b2", "c3")
fetched=c("c3", "a1")
rs= pmatch(
  x = vars,
  table = fetched
); rs
# [1]  2 NA  1




(13) 数组子集乱序后，怎么恢复原数组中的顺序？

vars=c("a1", "b2", "c3", "d4") #原数组
fetched=c("c3", "d4", "a1") #子集，对子集排序，和原数组顺序相同

data.order <- na.omit(object = pmatch(
  x = vars,
  table = fetched
))
fetched[data.order] #[1] "a1" "c3" "d4"



细节展开：
vars=c("a1", "b2", "c3", "d4") #原数组
fetched=c("c3", "d4", "a1") #子集，对子集排序，和原数组顺序相同
rs= pmatch(
  x = vars,
  table = fetched
); rs # [1]  3 NA  1  2

rs2=na.omit(rs); rs2 # [1] 3 1 2
as.numeric(rs2)
fetched[rs2] #[1] "a1" "c3" "d4"





(14) inherits(x, what) 的第二个参数还可以是数组。
只要有一个为真，就返回T。

> inherits(x = 2, what = c("character"))
[1] FALSE
> inherits(x = 2, what = c("character", "numeric"))
[1] TRUE






========================================
|-- Seurat 4 源码解析 10: subset()
----------------------------------------

1. 调包侠
接上例。

(1) subset() 中会按照cells自动重新计算 meta.data 中的2列：Recalculate nCount and nFeature


2. 源码解析
见 gitee


# $ find .  | grep "R$" | xargs grep -n "subset" --color=auto
# seurat-object-4.0.4/R/seurat.R:2497:subset.Seurat <- function(
# seurat-object-4.0.4/R/assay.R:858:subset.Assay <- function(x, cells = NULL, features = NULL, ...) {




3. R tips



==> enquo() Defuse R expressions 也叫引用，相当于 原生R的 quote() and substitute().

defuse [diːˈfjuːz] vt. 平息；去掉……的雷管；使除去危险性

The defusing operators expr() and enquo() prevent the evaluation of R code. 
Defusing is also known as quoting, and is done in base R by quote() and substitute(). 
When a function argument is defused, R doesn't return its value like it normally would but it returns the R expression describing how to make the value. 
These defused expressions are like blueprints for computing values.


> library(rlang)
> enquo
function (arg) 
{
    .Call(rlang_enquo, substitute(arg), parent.frame())
}
<bytecode: 0x55e51ff25338>
<environment: namespace:rlang>





(1) 表达式类型的函数 #' @importFrom rlang is_quosure enquo eval_tidy //todo 没搞懂
enquo() Defuse R expressions 也叫引用，相当于 原生R的 quote() and substitute().


# 例1:
fn1=function(x, subset2=NULL){
  if( !missing(subset2)){
    subset2=enquo(subset2)
  }
  subset2;
}
a1=fn1(1, subset2=CD4>3)

> a1
<quosure>
expr: ^CD4 > 3
env:  global
> class(a1)
[1] "quosure" "formula"




例2: WhichCells.Seurat() 也有这么几个函数:
    # 获取表达式 expression。
    # 把整个try语句放到一个if中
    expr <- if (tryCatch(expr = is_quosure(x = expression), error = function(...) FALSE)) {
      expression
    } else if (is.call(x = enquo(arg = expression))) {
      enquo(arg = expression)
    } else {
      parse(text = expression)
    }



> library(rlang)
> is_quosure
function (x) 
{
    inherits(x, "quosure")
}
<bytecode: 0x000000001ce0f4d8>
<environment: namespace:rlang>


> enquo
function (arg) 
{
    .Call(rlang_enquo, substitute(arg), parent.frame())
}
<bytecode: 0x000000001f7e2618>
<environment: namespace:rlang>


> eval_tidy
function (expr, data = NULL, env = caller_env()) 
{
    .External2(rlang_ext2_eval_tidy, expr, data, env)
}
<bytecode: 0x000000001d17bec8>
<environment: namespace:rlang>






(2) 同名的函数和参数名字，在函数内部默认使用参数。想使用函数，建议加R包前缀

# df 是定义在 stats 包中的函数，给出F分布的密度。
df(1:10)
plot(df(1:10, df1=3, df2=3), type="o", ylab="Density of F Distribution")

nrow(df) #NULL
print(args(stats::df))
# function (x, df1, df2, ncp, log = FALSE) 
# NULL

# 如果定义一个函数，其参数有同名的df，
# 在函数内部会根据情况选择当参数还是函数。
# 如果指定R包前缀，则当做函数。我们尽量使用确定性强的方式！
fn1=function(df){
  print(df) #当参数处理的
  
  print(args(df))#NULL 当参数
  print(args(stats::df))#NULL #当函数
  
  df(1:10) #当函数
}
fn1(iris[1:2,])



(3) 获取与修改 error 对象中的消息内容: e$message

如果 e$message 的内容是某个值，则对应处理。

tryCatch(
  expr = iris[,6],
  error = function(e) {
    if (e$message == "undefined columns selected") {
      e$message="捕获该错误，可以自定义错误信息，或返回值\n"
      #stop(e)
      message(e)
      return(NULL)
    } else {
      stop(e)
    }
  }
)



(4) na.omit() 忽略掉NA，但是不管无穷大

> na.omit
function (object, ...) 
UseMethod("na.omit")
<bytecode: 0x0000000002c626b8>
<environment: namespace:stats>

> df1=c("a1", "b2", NA, "D4", Inf, "F6"); df1
[1] "a1"  "b2"  NA    "D4"  "Inf" "F6" 

> df2=na.omit(df1); df2
[1] "a1"  "b2"  "D4"  "Inf" "F6" 
attr(,"na.action")
[1] 3
attr(,"class")
[1] "omit"


> length(df1)
[1] 6
> length(df2)
[1] 5



(5) 取小集合在大集合的子集，并保持在大集合中的位置顺序。
cells.scaled <- cells.scaled[na.omit(object = match(x = colnames(x = x), table = cells.scaled))]


一步一步展开:
x=c(1:100)
cells.scaled=c(3, 80,1000,20,500)

rs1=match(x = x, table = cells.scaled); rs1
rs2=na.omit(rs1); rs2 #1,4, 2
cells.scaled[rs2] #3 20 80





例2: 在函数 WhichCells.Seurat 最后，也使用到了这个套路
cell.order =seq(100,1, -1) # 是最早的大集合。
cells =c(20, 4, 60, 8) # 是经过各种筛选后留下的小集合。

# 排序: 大集合在小集合中的下标，去掉na，然后是小集合的元素，按照大集合的顺序输出
cells2 <- cells[na.omit(object = match(x = cell.order, table = cells))]
cells2
# [1] 60 20  8  4







(6) `%iff%`函数，尽可能取 NULL，如果第一个不是再看第二个参数

这是 SeuratObject 包定义的函数。
> ?`%iff%`
Set a default value depending on if an object is NULL
仿照 rlang包的 x %||% y
但是作用相反: 
For %||%: y if x is NULL otherwise x
For %iff%: y if x is not NULL; otherwise x


> `%iff%`
function (x, y) 
{
    if (!is_null(x = x)) {
        return(y)
    }
    return(x)
}
<bytecode: 0x0000000010039870>
<environment: namespace:SeuratObject>




(7) dim(sce) 是怎么实现的？nrow(), ncol()
源码:
#' @describeIn Seurat-methods Number of cells and features for the active assay
#'
#' @return \code{dim}: The number of features (\code{nrow}) and cells
#' (\code{ncol}) for the default assay; \strong{note}: while the number of
#' features changes depending on the active assay, the number of cells remains
#' the same across all assays
#'
#' @export
#' @method dim Seurat
#'
#' @examples
#' # Get the number of features in an object
#' nrow(pbmc_small)
#'
#' # Get the number of cells in an object
#' ncol(pbmc_small)
#'
dim.Seurat <- function(x) {
  x <- UpdateSlots(object = x)
  return(dim(x = x[[DefaultAssay(object = x)]]))
}



示例:
# 定义一个S4类
setClass("Person", slots = c(name="character", assets="data.frame"))
# 实现这一个方法 dim，相当于实现了三个: nrow, ncol, dim
dim.Person <- function(x) {
  return(dim(x = x@assets))
}

p1=new("Person", assets=iris[1:2,], name="Jim")
p1
dim(p1) #2 5
dim(p1@assets) #2 5
nrow(p1) #2
ncol(p1) #5




(8) rownames(sce) 是怎么实现的？
源码 
#' @describeIn Seurat-methods The cell and feature names for the active assay
#'
#' @return \code{dimnames}: The feature (row) and cell (column) names;
#' \strong{note}: while the features change depending on the active assay, the
#' cell names remain the same across all assays
#'
#' @export
#' @method dimnames Seurat
#'
#' @examples
#' # Get the feature names of an object
#' rownames(pbmc_small)
#'
#' # Get the cell names of an object
#' colnames(pbmc_small)
#'
dimnames.Seurat <- function(x) {
  x <- UpdateSlots(object = x)
  return(dimnames(x = x[[DefaultAssay(object = x)]]))
}


# 实现这一个方法 dimnames，相当于实现了三个: rownames(), colnames(). dimnames()
示例：
接上例:
> rownames(p1) #定义前，返回NULL
NULL

> dimnames.Person <- function(x) {
+   return(dimnames(x = x@assets))
+ }
> rownames(p1) #定以后，返回某个slot元素的行名
[1] "1" "2"
> colnames(p1) #列名
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"  





(9) paste()的 collapse=参数，可以把数组变为一行字符串

> paste(colnames(mtcars), collapse = ", ")
[1] "mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb"



给大佬提了修改建议，看是否采纳吧。
https://github.com/mojaveazure/seurat-object/pull/40 


idents=c(1,2,40, 41, 42)
x=1:30

# not good
stop(
  "Cannot find the following identities in the object: ",
  paste(
    idents[!idents %in% x],
    sep = ', '
  )
) 
#404142

# good
stop(
  "Cannot find the following identities in the object: ",
  paste(
    idents[!idents %in% x],
    collapse = ', '
  ) 
)
#40, 41, 42





(10) stop() 中可以有多个句子，之间没有间隔号
用法参考上一条。

> stop("this is wrong", "; today is Sunday", ". I love it!")
Error: this is wrong; today is Sunday. I love it!

恰如其分的警告和错误提醒，是一个包成熟的标志。
能让用户自动纠正自己的行为，在使用中学习。






(11) unlist(x = lapply()) 代替for循环

例1: 一个数组包含几个句子，一个句子有若干单词，把一个数组分割成单词。
expr.char=c("this is a book", "the code works")

# 使用 lapply 并指定使用函数的参数
unlist(x = lapply(X = expr.char, FUN = strsplit, split = ' '))
# [1] "this"  "is"    "a"     "book"  "the"   "code"  "works"


# 使用 for 循环要好几行
rs=c()
for(i in expr.char){
  rs2=strsplit(i, split=" ")[[1]]
  rs=c(rs, rs2)  
}
rs





例2: 拿到某些 Idents的cell barcode 字符串。

library(Seurat)
head(Idents(pbmc_small))
table(Idents(pbmc_small))
#0  1  2 
#36 25 19 

idents=c(0, 2)
object=pbmc_small


# 方法1: lapply
cells.idents <- unlist(x = lapply(
  X = idents,
  FUN = function(i) {
    # 取出等于某个ident的，返回的是 T or F 的list
    cells.use <- which(x = as.vector(x = Idents(object = object)) == i)
    # 返回cell id
    cells.use <- names(x = Idents(object = object)[cells.use])
    return(cells.use)
  }
)) #解开list unlist
head(cells.idents)
length(cells.idents) #55


# 方法2: for 循环
cells.idents2_all=c()
for(i in idents){
  cells.use2 <- which(x = as.vector(x = Idents(object = object)) == i)
  cells.use2 <- names(x = Idents(object = object)[cells.use2])
  cells.idents2_all=c(cells.idents2_all, cells.use2)
}
length(cells.idents2_all) #55

identical(cells.idents2_all, cells.idents) #T







(12) suppressWarnings() 抑制提醒

expr.char <- suppressWarnings(expr = as.character(x = expr))




(13) substitute() //todo
substitute returns the parse tree for the (unevaluated) expression expr, substituting any variables bound in env.


> a1=substitute(CD4>0.5); a1
CD4 > 0.5
> as.character(a1)
[1] ">"   "CD4" "0.5"











========================================
|-- 源码解析 11: HVFInfo/Loadings/"Idents<-"
----------------------------------------
1. 调包侠

(1) Seurat 的 Command() 是干啥的？ //todo
源码: find.command <- Command(object = object)[Command(object = object) %in% cmds]

> Command(pbmc_small)
 [1] "NormalizeData.RNA"        "ScaleData.RNA"           
 [3] "RunPCA.RNA"               "BuildSNN.RNA.pca"        
 [5] "FindClusters"             "RunTSNE.pca"             
 [7] "JackStraw.RNA.pca"        "ScoreJackStraw.pca"      
 [9] "ProjectDim.RNA.pca"       "FindVariableFeatures.RNA"


> Command(
  object = pbmc_small,
  command = "FindVariableFeatures.RNA",
  value = 'selection.method'
)
#"vst"



粗略看了一下，感觉像是重要的步骤的记录，类似日志系统，在 pbmc_small@commands 中保存。
我决定先跳过去，看样子以后还能多次遇到，或许在最后总结效果更好。



(2) "[[.Assay" 怎么定义的？

hvf.info$variable <- object[[paste0(selection.method, '.variable')]]


> head(pbmc_small@assays$RNA[[c("vst.mean", "vst.variance")]])
         vst.mean vst.variance
MS4A1      0.3875    1.0251582
CD79B      0.6000    1.2810127
CD79A      0.7000    4.3645570

> head(HVFInfo(pbmc_small@assays$RNA, selection.method = "vst"))
            mean    variance variance.standardized
MS4A1     0.3875   1.0251582             0.8983463
CD79B     0.6000   1.2810127             0.4731134
CD79A     0.7000   4.3645570             1.0862810


添加 status=T 参数
> head(HVFInfo(pbmc_small@assays$RNA, selection.method = "vst", status=T))
            mean    variance variance.standardized vst.variable
MS4A1     0.3875   1.0251582             0.8983463        FALSE
CD79B     0.6000   1.2810127             0.4731134        FALSE






2. 源码解析 










3. R tips

(1) expand.grid() 通过多个因子的组合创建数据框
Create a Data Frame from All Combinations of Factor Variables

例1: 创建3个地点 + 2个时间的组合
expand.grid(
  place=c("a", "c", "Z"),
  time=c(1,20)
)
输出:
  place time
1     a    1
2     c    1
3     Z    1
4     a   20
5     c   20
6     Z   20


例2: 源码
expand.grid(
  c('FindVariableFeatures', 'SCTransform'),
  FilterObjects(object = pbmc_small, classes.keep = 'Assay')
)
输出:
#                  Var1 Var2
#1 FindVariableFeatures  RNA
#2          SCTransform  RNA






(2) apply() 中的函数怎么指定参数？直接在后面指定
cmds <- apply(
  X = expand.grid(
    c('FindVariableFeatures', 'SCTransform'),
    FilterObjects(object = pbmc_small, classes.keep = 'Assay')
  ),
  MARGIN = 1,
  FUN = paste,
  collapse = '.'
)

> cmds
[1] "FindVariableFeatures.RNA" "SCTransform.RNA"   




(3) 大集合在小集合中的元素，其实就是交集，并保持在大集合的顺序
small_set=c(1,20,100)
big_set=1:50
big_set[big_set %in% small_set]
输出: [1]  1 20





(4) file_path_sans_ext() 是啥？去掉后缀名
sans [sænz] prep. 无，没有（等于 without）


看该函数的注释，可知它来自 tools 包: 
#' @importFrom tools file_path_sans_ext

查F1: Utilities for listing files, and manipulating file paths.

> tools::file_path_sans_ext
function (x, compression = FALSE) 
{
    if (compression) 
        x <- sub("[.](gz|bz2|xz)$", "", x)
    sub("([^.]+)\\.[[:alnum:]]+$", "\\1", x)
}
<bytecode: 0x000000001989d9b0>
<environment: namespace:tools>

传入一个参数，默认只执行最后一行。
这个正则替换，意思是：至少一个字符开头，一个点号，然后至少一个字母或数字结尾。
只保留点号前面的部分。
默认贪婪匹配，多个点号按最后一个。
总结：去掉最后一个点号及之后的部分。

> tools::file_path_sans_ext("data/xx/aa.1")
[1] "data/xx/aa"
> tools::file_path_sans_ext("data/xx/aa.12")
[1] "data/xx/aa"
> tools::file_path_sans_ext("data/xx/aa.980.txt")
[1] "data/xx/aa.980"




(5) droplevels() 去掉factor数据类型中用不到的水平 

> droplevels
function (x, ...) 
UseMethod("droplevels")
<bytecode: 0x000000000b5996c8>
<environment: namespace:base>


> a1=c(1,2,3,2,1)
> a1.f=factor(a1); a1.f
[1] 1 2 3 2 1
Levels: 1 2 3

# 取子集后，水平3就多余了
> a2=a1.f[c(1,2,4,5)]; a2
[1] 1 2 2 1
Levels: 1 2 3

# 该函数去掉多余的水平
> a3=droplevels(a2); a3
[1] 1 2 2 1
Levels: 1 2




========================================
|-- 源码解析 12: 二维散点图 FeatureScatter()
----------------------------------------

1. 
QC 质控


(1) 如果看着可疑，可以试试参数 jitter=F
不jitter才是本来的面目，有可能很多点重合在原点(x和y都是0)。
FeatureScatter(pbmc, feature1 = "S100A9", feature2 = "DUSP1", jitter=F)


(2)group.by=可以输入一个值，也可以输入一个数组
FeatureScatter(pbmc, feature1 = "TMSB4X", feature2 = "B2M",
               group.by = c("seurat_clusters", 'ident', "orig.ident"),
               jitter=F)





(3) 列名替换'-'为'.'，以及 ':' 为 '.'
也即是基因名不要有-或者:，否则会被替换为点号。
names.plot <- colnames(x = data) <- gsub(
	pattern = '-',
	replacement = '.',
	x = colnames(x = data),
	fixed = TRUE
)




(4) 该图顶部的相关系数怎么计算的？

# (A7) 如果需要相关系数，就计算；否则空字符串
# 直接使用的 cor(x,y)，默认的 pearson 相关系数
plot.cor <- if (isTRUE(x = plot.cor)) {
	round(x = cor(x = data[, 1], y = data[, 2]), digits = 2)
}
else(
	""
)

就是默认的 cor(x,y).


(5) 添加LOESS 局部拟合曲线
FeatureScatter(pbmc, feature1 = "TMSB4X", feature2 = "B2M", 
               cols=c(1:9), #每个类的颜色
               span=0.1, #越大越平滑，也越失去细节
               jitter=F)








2. 源码解析
见 gitee 




3. R tips

(1) 如何做 shuffle(打乱样品顺序)?
> sample(1:10)
 [1]  2  8  9 10  4  5  1  3  6  7
> sample(1:10)
 [1]  9  7  1  3  4  8  5 10  6  2

如果想固定顺序的随机，可以指定随机数种子
> set.seed(1)
> sample(1:10)
 [1]  9  4  7  1  2  5  3 10  6  8




(2) globalVariables() 函数干啥呢？//todo
源码：
globalVariables(names = '..density..', package = 'Seurat')

查文档：
globalVariables returns the current list of declared global variables, possibly modified by this call.


有一个说R包技巧的提到：https://zhuanlan.zhihu.com/p/95992937
使用的局部变量（函数中定义的瞬时变量）和语法糖（如“:=”）也要用全局变量函数GlobalVariables加以定义。
比如“globalVariables(c(":=","!!",".",".SD"))”。





载入 Seurat 包后再执行报错：
> globalVariables(names = '..density..', package = 'Seurat')
Error in registerNames(names, package, ".__global__", add) : 
  The namespace for package "Seurat" is locked; no changes in the global variables list may be made.

> globalVariables()
[1] "localvariable"

> globalVariables(c(":=","!!",".",".SD"))
[1] "localvariable" ":="            "!!"            "."             ".SD" 






(3) aes() 与 aes_string() 的用法区别？
后者可以使用变量。例子如下:

library(ggplot2)
head(mtcars)
ggplot(mtcars, aes(mpg, cyl))+geom_point()

params=c("mpg", "cyl")
ggplot(mtcars, aes_string(x=params[1], y=params[2]))+geom_point()



(4) 栅格化以降低pdf文件大小： scattermore::geom_scattermore 
ggplot2::ggplot() integration. This cooperates with the rest of ggplot (so you can use it to e.g. add rasterized scatterplots to vector output in order to reduce PDF size). 

> scattermore::geom_scattermore
function (mapping = NULL, data = NULL, stat = "identity", 
    position = "identity", ..., na.rm = FALSE, show.legend = NA, 
    inherit.aes = TRUE, interpolate = FALSE, pointsize = 0, pixels = c(512, 
        512)) 
{
    ggplot2::layer(data = data, mapping = mapping, stat = stat, 
        position = position, geom = GeomScattermore, show.legend = show.legend, 
        inherit.aes = inherit.aes, params = list(na.rm = na.rm, 
            interpolate = interpolate, pointsize = pointsize, 
            pixels = pixels, ...))
}
<bytecode: 0x000000003346b238>
<environment: namespace:scattermore>

源码:
    if (raster) {
      plot <- plot + geom_scattermore(
        mapping = aes_string(color = 'colors'),
        position = position,
        pointsize = pt.size, #这一行参数名不同
        pixels = raster.dpi #多了这一行
      )
    # 如果不栅格化
    } else {
      plot <- plot + geom_point(
        mapping = aes_string(color = 'colors'),
        position = position,
        size = pt.size
      )
    }


例：使用钻石数据集画散点图pdf，尝试降低pdf磁盘占用。

head(diamonds)
pt.size=min(1583 / nrow(x = diamonds), 1); pt.size #0.02934

pdf(file="01.pdf", width=4, height=4, useDingbats = F)
ggplot(diamonds, aes(carat, price, color=cut))+
  geom_point(size = pt.size)+
  theme_classic()
dev.off()

pdf(file="01.raster.pdf", width=4, height=4, useDingbats = F)
raster.dpi=c(512, 512)
ggplot(diamonds, aes(carat, price, color=cut))+
  scattermore::geom_scattermore(
    pixels = raster.dpi,
    pointsize = pt.size*50
  )+
  theme_classic()
dev.off()

文件大小对比: 是原来的 1/16
栅格前后: 1427k vs 88k



(5) sort() 的参数 na.last 什么意思？
源码:
plot.order <- sort(x = unique(x = highlight), na.last = TRUE)

na.last	
for controlling the treatment of NAs. 
If TRUE, missing values in the data are put last; 
if FALSE, they are put first; 
if NA, they are removed.


> highlight=c(1, NA, -4)
> #默认na.last=NA 去掉NA值；
> sort(x = unique(x = highlight)) 
[1] -4  1
> # na.last=T 放到最后
> sort(x = unique(x = highlight), na.last = TRUE)
[1] -4  1 NA
> # na.last=F 放到首位
> sort(x = unique(x = highlight), na.last = F)
[1] NA -4  1




(6) stat_density2d() 2D 密度图怎么画？
源码：
stat_density2d(
      mapping = aes(fill = ..density.. ^ 0.25),
      geom = 'tile',
      contour = FALSE,
      n = 200,
      h = Bandwidth(data = data[, names.plot])
    )


测试这几个参数:
# 
ggplot(diamonds, aes(x = carat, y = price)) +
  stat_density2d(aes(fill = ..density..), 
                 geom = 'tile', 
                 contour = F)

# 加上 0.25 后对比度更清晰
ggplot(diamonds, aes(x = carat, y = price)) +
  stat_density2d(aes(fill = ..density..^0.25), 
                 geom = 'tile', 
                 contour = F)

# n=200, 没有明显变化
ggplot(diamonds, aes(x = carat, y = price)) +
  stat_density2d(aes(fill = ..density..^0.25), 
                 geom = 'tile', 
                 n=200, #每个方向上的grid点数
                 contour = F)
# h=1 有明显 水平擦除痕迹；
# 0.1 太小，看不到趋势, 0.5还是小;
# 2太大，水平擦除到全图均匀了; 1.5能看吧
ggplot(diamonds, aes(x = carat, y = price)) +
  stat_density2d(aes(fill = ..density..^0.25), 
                 geom = 'tile', 
                 n=200, #每个方向上的grid点数
                 h=0.58,
                 contour = F)

# 自定义颜色
ggplot(diamonds, aes(x = carat, y = price)) +
  stat_density2d(aes(fill = ..density..^0.25), 
                 geom = 'tile', 
                 n=200, #每个方向上的grid点数
                 #h=0.58, #不要貌似更符合实际点图
                 contour = F)+
  geom_point(alpha=0.1)+
  theme_classic()+
  scale_fill_gradient(low="skyblue2", high="firebrick1")




(7) base::diff() 返回下一行减去上一行的差。
Lagged Differences 滞后差分项
Description: Returns suitably lagged and iterated differences.

> diff
function (x, ...) 
UseMethod("diff")
<bytecode: 0x0000000009d6b7e0>
<environment: namespace:base>

测试：
> apply(iris[, 1:4], 2, quantile, probs=c(0.05, 0.95), na.rm=T, names=F )
     Sepal.Length Sepal.Width Petal.Length Petal.Width
[1,]        4.600       2.345          1.3         0.2
[2,]        7.255       3.800          6.1         2.3
> diff(apply(iris[, 1:4], 2, quantile, probs=c(0.05, 0.95), na.rm=T, names=F ))
     Sepal.Length Sepal.Width Petal.Length Petal.Width
[1,]        2.655       1.455          4.8         2.1

就是第下一行减去上一行。

> apply(iris[, 1:4], 2, quantile)
     Sepal.Length Sepal.Width Petal.Length Petal.Width
0%            4.3         2.0         1.00         0.1
25%           5.1         2.8         1.60         0.3
50%           5.8         3.0         4.35         1.3
75%           6.4         3.3         5.10         1.8
100%          7.9         4.4         6.90         2.5

> diff(apply(iris[, 1:4], 2, quantile))
     Sepal.Length Sepal.Width Petal.Length Petal.Width
25%           0.8         0.8         0.60         0.2
50%           0.7         0.2         2.75         1.0
75%           0.6         0.3         0.75         0.5
100%          1.5         1.1         1.80         0.7



(8) n个ggplot2对象保存在list中，如果只有1图个则直接返回该图，如果是多个则拼合后返回
@importFrom patchwork wrap_plots

# 如果是多个元素，则绘图结果也是多个组成的list
  plots <- lapply(
    X = group.by,
    FUN = function(x) {
      # 这个函数，是画图的主力函数
      SingleCorPlot(
        data = data[,c(feature1, feature2)],
        col.by = data[, x],
        cols = cols,
        pt.size = pt.size,
        smooth = smooth,
        legend.title = 'Identity',
        span = span,
        plot.cor = plot.cor,
        raster = raster,
        raster.dpi = raster.dpi,
        jitter = jitter
      )
    }
  )

  #(A11) 如果list长度为1，直接返回其内容
  if (isTRUE(x = length(x = plots) == 1)) {
    return(plots[[1]])
  }

  #(A12) 如果合并，则返回合并后的拼图
  if (isTRUE(x = combine)) {
    plots <- wrap_plots(plots, ncol = length(x = group.by))
  }






========================================
|-- Seurat 4 源码解析 13: step5 NormalizeData()
----------------------------------------
1.
(1)
# step5 Normalizing the data
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)


counts=pbmc@assays$RNA@counts
data=pbmc@assays$RNA@data
data2=apply(counts, 2, function(x){ log(x/sum(x)*1e4 +1) }) #R语言实现该过程



(2) LogNormalize() 调用C++


(3) 行名(symbol)中不能用_，全部替换为-
  	# 替换行名(symbol)中的_为-
    if (any(grepl(pattern = '_', x = rownames(x = new.data)))) {
      warning(
        "Feature names cannot have underscores ('_'), replacing with dashes ('-')",
        call. = FALSE,
        immediate. = TRUE
      )
      rownames(x = new.data) <- gsub(
        pattern = '_',
        replacement = '-',
        x = rownames(x = new.data)
      )
    }






2. 源码解析 

$ find . | grep "R$" | xargs grep -n "NormalizeData" --color=auto
seurat-4.1.0/R/generics.R:339:NormalizeData <- function(object, ...) {
seurat-4.1.0/R/preprocessing.R:2387:NormalizeData.default <- function(
seurat-4.1.0/R/preprocessing.R:2494:NormalizeData.Assay <- function(
seurat-4.1.0/R/preprocessing.R:2531:NormalizeData.Seurat <- function(




$ find . | grep "R$" | xargs grep -n "GetAssay" | grep -v "GetAssayData" | grep "GetAssay" --color=auto
seurat-4.1.0/R/generics.R:256:GetAssay <- function(object, ...) {
seurat-4.1.0/R/objects.R:1351:GetAssay.Seurat <- function(object, assay = NULL, ...) {














3. R tips

(1) 使用 switch 语句能简化if...else结构

例: 输入数据，返回该数据的重要特征，
比如，df返回 dim(), character 返回 nchar().

fn1=function(x){
  switch(
    EXPR = class(x),
    'data.frame' = dim(x),
    "character"=nchar(x),
    stop("Unknown type")
  )
}
fn1(iris) #[1] 150   5
fn1(iris$Sepal.Length) #Unknown type
fn1("this is") #[1] 7
fn1(123) #Unknown type
fn1( c(1,2,"30")) #[1] 1 1 2





(2) cat() 的 file 参数能用于重定向消息到 标准错误

if (verbose) {
	cat("Performing log-normalization\n", file = stderr())
}


查 cat 函数，发现 file 参数默认是 stdout()
> cat
function (..., file = "", sep = " ", fill = FALSE, 
    labels = NULL, append = FALSE) 
{
    if (is.character(file)) 
        if (file == "") 
            file <- stdout()
        else if (startsWith(file, "|")) {
            file <- pipe(substring(file, 2L), "w")
            on.exit(close(file))
        }
        else {
            file <- file(file, ifelse(append, "a", "w"))
            on.exit(close(file))
        }
    .Internal(cat(list(...), file, sep, fill, labels, append))
}
<bytecode: 0x00000000131e12a8>
<environment: namespace:base>

测试：区别是文字颜色不同。
> cat("Performing log-normalization\n", file = stderr())
Performing log-normalization #红色
> cat("Performing log-normalization\n", file = stdout())
Performing log-normalization #黑色



(3) make.names() 生成合法的变量名字
Make syntactically valid names out of character vectors.

> make.names(c("a and b", "a-and-b"))
[1] "a.and.b" "a.and.b"

> make.names(c("a and b", "a-and-b"), unique = TRUE)
[1] "a.and.b"   "a.and.b.1"


可用于用户指定变量名的合法性检查，如果有非法字符，则给出警告
if (any(i != newi)) {
  warning(
	"Invalid name supplied, making object name syntactically valid. New object name is ",
	newi,
	"; see ?make.names for more details on syntax validity",
	call. = FALSE,
	immediate. = TRUE
  )
  i <- newi
}




(4) 把新子集 按照老顺序输出
# 老 在 新 的下标
old1=c(1:20)
new1=c(15,6,2,10)
index1=match(old1, new1)
index1

new1[na.omit(index1)]
# [1]  2  6 10 15



(5) inherits(x, what=c())第二个参数可以是多个字符串
源码：
  if (!inherits(x = value, what = c('SeuratCommand', 'NULL', 'SpatialImage', 'Neighbor')) && !all(Cells(x = value) == Cells(x = x))) {
	stop("All cells in the object being added must match the cells in this object", call. = FALSE)
  }

例: 如果x是df或矩阵
> inherits(iris, what=c("matrix"))
[1] FALSE
> inherits(iris, what=c("matrix", "data.frame"))
[1] TRUE



(6) 判断2个向量 不是逐一相等
源码见上文: !all(Cells(x = value) == Cells(x = x))

> !all( c(1,2,3) == c(1,2,3) )
[1] FALSE
> !all( c(1,2,3) == c(1,2,4) )
[1] TRUE



(7) 2个元素不能是同类，怎么判断？
互相不继承

isSameClass=function(x,y){
  inherits(x = x, what = class(x = y)) ||
    inherits(x = y, what = class(x = x))
}
isSameClass(1,2) #T
isSameClass(1,"2") #F
isSameClass(mtcars, data.frame()) #T




========================================
|-- Seurat 4 R包源码解析 14: `[[<-` S4 风格为 S4 类 实现的方法
----------------------------------------
1.
接上文。


2.源码解析 



3. R tips 

(1) 直接查看R包函数的源码

#查看S3形式的实现代码
> `[[<-.data.frame` 
function (x, i, j, value) 
{
    if (!all(names(sys.call()) %in% c("", "value"))) 
...



# 查看S4形式的实现代码
> getMethod("[[<-", signature = "Seurat")
Method Definition:

function (x, i, j, ..., value) 
{
    x <- UpdateSlots(object = x)
...





(2) 为S4类实现方法: "[", "[<-",  "[[", "[[<-"
 
setClass("Person", slots = c(name="character", age="numeric"))
p1=new("Person", name="Tom", age=18); p1
slot(p1, name="age")=21; p1

p1[["age"]] # this S4 class is not subsettable
p1[["age"]]=22
# [[<- defined for objects of type "S4" only for subclasses of environment
# 根据报错，看到其他人也遇到这个问题了，不过都不知道这个报错在说啥：
# https://stackoverflow.com/questions/46761340/s4-method-subsetting-generic-replace-environment


#不返回值：错
"[[<-.Person"=function(x,i,..., value){
  slot(x, name=i)=value
}
p2=p1
p2[["age"]]=200; p2 #对象变字符串了


#返回值：正确
"[[<-.Person"=function(x,i,..., value){
  slot(x, name=i)=value
  return(x)
}
p2=p1
p2[["age"]]=22; p2





# 使用S4的形式定义
setMethod(
  f="[[<-",
  signature = "Person",
  definition = function(x,i,...,value){
    slot(x, name=i)=value
    return(x)
  }
)
p2=p1
p2[["age"]]=23; p2
# 经过测试，S3和S4都可以实现读写S4类的数据。注意对同名函数，每次要重启R session后测试。




# 其他方法呢? '[', '[<-', '[['
# getter
`[.Person`=function(x,i,...){
  slot(x, name=i)
}
p2=p1; p2
p2["age"]
p2

# getter2
p1[["name"]] #this S4 class is not subsettable

`[[.Person`=function(x,i,...){
  slot(x, name=i)
}
p1[["name"]] #Tom
p1


# setter
`[<-.Person`=function(x,i,...,value){
  slot(x, name=i)=value
  return(x)
}
p2=p1
p2["name"]="Lilei"
p2


#setter2
`[[<-.Person`=function(x,i,...,value){
  slot(x, name=i)=value
  return(x)
}
p2=p1; p2
p2[["name"]]="Lilei2"
p2

p2[["age"]]=100
p2



(3) 使用 setReplaceMethod() 函数实现更一般的setter

setClass("Person", slots = c(name="character", age="numeric"))
p1=new("Person", name="Tom", age=18); p1
slot(p1, name="age")=21; p1


# 想要更一般化的setter，可以使用 setReplaceMethod() 函数
setGeneric(name = "setAge<-", def = function(theObject, value){standardGeneric("setAge<-");});
# setGeneric(name = "setName<-", def = function(theObject, value){standardGeneric("setName<-");});

setReplaceMethod(
  f = "setAge",
  signature = "Person",
  definition = function(theObject, value){
    theObject@age <- value;
    return(theObject);
  })
setAge(p1)= 100
p1









(4) 环境变量

获取
> class(options())
[1] "list"

> options()


使用关键词检索某个环境变量的名字
> grep("digit", names(options()), value=T)
[1] "digits"


查看该环境变量的值
> options("digits")
$digits
[1] 7

> a=0.123456789
> a
[1] 0.1234568


修改/设置 环境变量
> options("digits"=8)
> a
[1] 0.12345679



(5) R包的 .onAttach() 与 .onLoad() 的区别
功能上的区别：
https://community.rstudio.com/t/when-to-use-onload-vs-onattach/21953/2
onAttach only runs when the library is attached, e.g. when somebody calls library(your_package). 
onLoad will also run when somebody loads but doesn't attach your package by calling your_package::your_function.


功能决定应用。
.onAttach is only for interactive use, for example startup messages and so forth

# .onAttach()一般用于在包启动时加载有用信息或建议。
AttachDeps <- function(deps) {
  for (d in deps) {
    if (!paste0('package:', d) %in% search()) {
      packageStartupMessage("Attaching ", d)
      attachNamespace(ns = d)
    }
  }
}

# library() 事件触发的函数
.onAttach <- function(libname, pkgname) {
  AttachDeps(deps = 'SeuratObject')
}




# .onLoad() 一般用来进行初始化设置

# 定义的环境变量
seurat_default_options <- list(
  Seurat.memsafe = FALSE,
  Seurat.warn.umap.uwot = TRUE,
  Seurat.checkdots = "warn",
  Seurat.limma.wilcox.msg = TRUE,
  Seurat.Rfast2.msg = TRUE,
  Seurat.warn.vlnplot.split = TRUE
)

.onLoad <- function(libname, pkgname) {
  # 获取当前 环境变量
  op <- options()
  # Seurat选项中 还没有设置到 当前中的
  toset <- !(names(x = seurat_default_options) %in% names(x = op))
  # 如果有没设置的，则设置上默认值
  if (any(toset)) options(seurat_default_options[toset])
  # 如果没有左值，则不返回任何结果
  invisible(x = NULL)
}


通过类似 getOption("Seurat.memsafe") 就能获取设定信息。
通过 option("Seurat.memsafe"=T) 就能修改环境变量，这个修改是全局的，在重启R session前一直有效。




(6) 如果没有左值，则不返回任何结果 invisible()

fn1=function(x){
  return( x+10 )
}
fn2=function(x){
  return( invisible(x+10) )
}

> rs1=fn1(1); rs1
[1] 11
> rs2=fn2(1); rs2
[1] 11
> fn1(1)
[1] 11
> fn2(1) #没有左值，则也不打印结果
> 



ref:
R 包管理: https://www.jianshu.com/p/0733946efae9

https://zhuanlan.zhihu.com/p/477848978
`[[<-` for Seurat / CheckGC() 





========================================
|-- Seurat 4 R包源码解析 15: step6 找高变基因 FindVariableFeatures()
----------------------------------------
1. 调包侠
# step6 Identification of highly variable features (feature selection)

> pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
Calculating gene variances
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Calculating feature variances of standardized and clipped values
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|

> # Identify the 10 most highly variable genes
> top10 <- head(VariableFeatures(pbmc), 10)
> top10
 [1] "PPBP"   "LYZ"    "S100A9" "IGLL5"  "GNLY"   "FTL"    "PF4"    "FTH1"   "GNG11"  "S100A8"


# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
# 图片在桌面


(1) 影响范围
执行前
> head(pbmc@assays$RNA@var.features)
character(0)
> head(pbmc@assays$RNA@meta.features)
data frame with 0 columns and 6 rows


执行后
> head(pbmc@assays$RNA@var.features)
[1] "PPBP"   "LYZ"    "S100A9" "IGLL5"  "GNLY"   "FTL"   
> head(pbmc@assays$RNA@meta.features)
                 vst.mean vst.variance vst.variance.expected vst.variance.standardized vst.variable
AL627309.1    0.003411676  0.003401325           0.003645407                 0.9330441        FALSE
AP006222.2    0.001137225  0.001136363           0.001144957                 0.9924937        FALSE
RP11-206L10.2 0.001895375  0.001892500           0.001965766                 0.9627290        FALSE
RP11-206L10.9 0.001137225  0.001136363           0.001144957                 0.9924937        FALSE


> slotNames(pbmc_small@assays$RNA)
[1] "counts"        "data"          "scale.data"    "key"           "assay.orig"    "var.features" 
[7] "meta.features" "misc"



(2)这个进度条怎么出现的？不知道，也没找到。可能是 C++ 部分控制的。
包括上一节的 NormalizeData() 也是这个风格的进度条。




(3) "vst" 使用的是 assay@counts 数据作为输入
  if (selection.method == "vst") {
    data <- GetAssayData(object = object, slot = "counts")
	...
  }


vst中计算基因表达的平均值，使用的是 assay@counts。
如果使用的是 assay@data 则可以先还原为counts，计算完平均值再取log。
参考C函数: FastExpMean()





2. 源码解析

(1)直接使用的函数
- FindVariableFeatures
- VariableFeatures
- VariableFeaturePlot
- LabelPoints


$ find . | grep "R$" | xargs grep -n "FindVariableFeatures" --color=auto
./seurat-4.1.0/R/generics.R:204:FindVariableFeatures <- function(object, ...) {

./seurat-4.1.0/R/preprocessing.R:2115:FindVariableFeatures.Seurat <- function(
./seurat-4.1.0/R/preprocessing.R:2014:FindVariableFeatures.Assay <- function(
./seurat-4.1.0/R/preprocessing.R:1914:FindVariableFeatures.default <- function(


(2) 间接使用的函数

# 跳过
- LogSeuratCommand
- GetResidual

$ find . | grep "R$" | xargs grep -n "GetResidual" --color=auto
./seurat-4.1.0/R/preprocessing.R:364:GetResidual <- function(
./seurat-4.1.0/R/preprocessing.R:3192:GetResidualSCTModel <- function(




# 跳过 c 函数
- FastLogVMR
- SparseRowVar2 #C++函数

$ find . | xargs grep -n "SparseRowVar2" --color=auto 2>/dev/null
./seurat-4.1.0/R/RcppExports.R:52:SparseRowVar2 <- function(mat, mu, display_progress) {
./seurat-4.1.0/R/RcppExports.R:53:    .Call('_Seurat_SparseRowVar2', PACKAGE = 'Seurat', mat, mu, display_progress)

./seurat-4.1.0/src/RcppExports.cpp:173:// SparseRowVar2
./seurat-4.1.0/src/RcppExports.cpp:174:NumericVector SparseRowVar2(Eigen::SparseMatrix<double> mat, NumericVector mu, bool display_progress);
./seurat-4.1.0/src/RcppExports.cpp:175:RcppExport SEXP _Seurat_SparseRowVar2(SEXP matSEXP, SEXP muSEXP, SEXP display_progressSEXP) {
./seurat-4.1.0/src/RcppExports.cpp:181:    rcpp_result_gen = Rcpp::wrap(SparseRowVar2(mat, mu, display_progress));
./seurat-4.1.0/src/RcppExports.cpp:420:    {"_Seurat_SparseRowVar2", (DL_FUNC) &_Seurat_SparseRowVar2, 3},

./seurat-4.1.0/src/data_manipulation.h:37:NumericVector SparseRowVar2(Eigen::SparseMatrix<double> mat,
./seurat-4.1.0/src/data_manipulation.cpp:278:NumericVector SparseRowVar2(Eigen::SparseMatrix<double> mat,



- SparseRowVarStd #有一个c函数







3. R tips

(1) 如果右值(基因名)中带有_，则警告并替换为-
  if (any(grepl(pattern = '_', x = value))) {

    warning(
      "Feature names cannot have underscores '_', replacing with dashes '-'",
      call. = FALSE,
      immediate = TRUE
    )
    value <- gsub(pattern = '_', replacement = '-', x = value)
  }




(2) 把基因list按照是否在 assay 中分为2类，放到一个list中。

value=c("CD4", "CD8A", "CXCR4", "CD3G", "LY6G")
object=pbmc_small@assays$RNA

> split(x = value, f = value %in% rownames(x = object))
$`FALSE`
[1] "CD4"  "CD3G" "LY6G"

$`TRUE`
[1] "CD8A"  "CXCR4"





(3) 变数组为 逗号隔开的字符串
> paste( colnames(mtcars), collapse = ', ')
[1] "mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb"




(4) vst 算法第一步: 使用loess() 拟合y值

    not.const <- hvf.info$variance > 0

    fit <- loess(
      formula = log10(x = variance) ~ log10(x = mean),
      data = hvf.info[not.const, ],
      span = loess.span
    )
	
    hvf.info$variance.expected[not.const] <- 10 ^ fit$fitted




(5) 按 相等频率分bin: 分位数

feature.mean=rowMeans(iris[, 1:4])
num.bin=5

data.x.breaks=quantile(
  x = feature.mean[feature.mean > 0],
  probs = seq.int(from = 0, to = 1, length.out = num.bin)
)
data.x.breaks
#
#     0%    25%    50%    75%   100% 
# 2.1000 2.6750 3.5750 4.0625 5.1000 



(6) cut() 把数据放到对应的bin中
就是把数据转为对应的bin范围。

#1) breaks 可以是切分范围
data.x.bin <- cut(x = feature.mean, breaks = data.x.breaks,
                  include.lowest = TRUE)
> head(data.x.bin)
[1] [2.1,2.67]  [2.1,2.67]  [2.1,2.67]  [2.1,2.67]  [2.1,2.67]  (2.67,3.58]
Levels: [2.1,2.67] (2.67,3.58] (3.58,4.06] (4.06,5.1]

画柱状图:
> barplot(table(data.x.bin))



#2) breaks 也可以是总份数
> data.x.bin2 <- cut(x = feature.mean, breaks = 10, include.lowest = TRUE)
> head(data.x.bin2)
[1] (2.4,2.7] [2.1,2.4] [2.1,2.4] [2.1,2.4] (2.4,2.7] (2.7,3]  
10 Levels: [2.1,2.4] (2.4,2.7] (2.7,3] (3,3.3] (3.3,3.6] (3.6,3.9] (3.9,4.2] (4.2,4.5] ... (4.8,5.1]

> head(feature.mean)
[1] 2.550 2.375 2.350 2.350 2.550 2.850

画柱状图:
> barplot(table(data.x.bin2))





(7) 把table()统计结果加到 ggplot2 图例中
注意: 想量化操作能节省代码。不过有搭配错乱的风险，需要画图后再次核对。

源码:
    scale_color_manual( #图例
      labels = paste(labels.legend, 'count:', table(var.status)),
      values = cols
    )

示例:
library(ggplot2)
df1=mtcars
labels.legend=c(3,4,5)
df1$gear=factor(df1$gear, levels=labels.legend)

var.status=df1$gear
cols=1:3
ggplot(df1, aes(mpg, disp, color=gear))+geom_point()+
  theme_bw()+
  scale_color_manual( #图例
    labels = paste0(labels.legend, ' (n=', table(var.status),")"),
    values = cols
  )
#


(8) 画ggplot2图时对x轴取log
  if (log) {
    plot <- plot + scale_x_log10()
  }

library(ggplot2)
plot = ggplot(mtcars, aes(mpg, disp, color=gear))+geom_point()
plot + scale_x_log10() #x 轴的刻度是 10^-2, 0, 10^2.




(9) ggplot2的数据是存储在 g1$data 中

library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp))+geom_point(); g1

> head(g1$data)
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4



(10) ggplot2 画散点图的x轴是数据的哪一列？

library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp))+geom_point(); g1

rlang::as_label( g1$mapping$x ) #"mpg"


(11) 换算 counts 和 data 的R函数
> expm1(1)
[1] 1.718282
> exp(1)-1
[1] 1.718282

#
> log1p(1)
[1] 0.6931472
> log(1+1)
[1] 0.6931472








4. 发现的bug

(1) LabelPoints() 中 points 是数字时，错误的使用了全部基因名字。
提示让提交到 develop 线上。

pr: https://github.com/satijalab/seurat/pull/5727







========================================
|-- Seurat 4 R包源码解析 16: step7 ScaleData()
----------------------------------------
1. 掉包侠
# step7 Scaling the data
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)


(1)处理过程
linear 模型 输入的是 assay@data，
可选: 先 regress out 一些噪音变量(比如批次效应等)，
然后再做 center and scale。


怎么去噪音?
其中 regress out 的方法作者提供了三个选项，本文只说默认使用的 linear 模型。
线性模型 主要是使用 lm() 拟合 Y~X1+X2，每个基因就是一个 Y，噪音列就是X1+X2...部分。 回归曲线，并计算出期望值，然后真实表达值-拟合值得到的残差，就认为是去除了变量X1和X2的影响了。
然后 center and scale.



作者为了加快速度，用到了很多小技巧。比如
- 多线程，分块处理；
- C++函数: FastSparseRowScale()
- 线性代数的性质：QR 分解出 噪音矩阵的 qr 矩阵先做一次，循环中求残差时反复使用。




(2) 重要参数 
1) vars.to.regress=c("mt.pct") 回归掉批次效应等无关变异成分

Scales and centers features in the dataset. If variables are provided in vars.to.regress, they are individually regressed against each feature, and the resulting residuals are then scaled and centered.

#' ScaleData now incorporates the functionality of the function formerly known
#' as RegressOut (which regressed out given the effects of provided variables
#' and then scaled the residuals). To make use of the regression functionality,
#' simply pass the variables you want to remove to the vars.to.regress parameter.


2) do.center=T, 
#' Setting center to TRUE will center the expression for each feature by subtracting
#' the average expression for that feature. 

3) do.scale=T
# Setting scale to TRUE will scale the
#' expression level for each feature by dividing the centered feature expression
#' levels by their standard deviations if center is TRUE and by their root mean
#' square otherwise.


(3) min.cells.to.block 参数干啥的？









2. 源码解析
(100) todo 

间接使用的函数。
- LogSeuratCommand
	object <- LogSeuratCommand(object = object)

- future_lapply() in ScaleData.default()

- FastSparseRowScale: C 函数





3. R tips

(1) set1 在 set2 中的元素，保持在 set1 中的顺序
如何不用中间变量解答？

源码
if (any(vars.to.regress %in% colnames(x = object[[]]))) {...}

测试 
set1=seq(9,5,-1)
set2=seq(1,20,2)
set1[set1 %in% set2] #9 7 5


# 其实直接取交集，输出时按照第一个参数的元素顺序
> intersect(set1, set2)
[1] 9 7 5
> intersect(set2, set1)
[1] 5 7 9



(2) sys.calls() 返回函数调用栈，可以解析获得依次调用的函数
最早调用的函数在list的最后。

#  sys.call returns a call
message("out>>",sys.calls())
fn1=function(x){
  calls <- as.character(x = sys.calls())
  # 
  calls <- lapply(
    X = strsplit(x = calls, split = '(', fixed = TRUE),
    FUN = '[',
    1
  )
  print(calls)
  #
  message("fn1>> ", as.character(sys.calls()) )
  x+1
}

> fn1(1)
[[1]]
[1] "fn1"

fn1>> fn1(1)
[1] 2



#
fn2=function(y){
  #message("fn2>>",sys.calls())
  message("fn2>> ", as.character(sys.calls()) )
  fn1(y)+2
}

> fn2(2)
fn2>> fn2(2)
[[1]]
[1] "fn2"

[[2]]
[1] "fn1"

fn1>> fn2(2)fn1(y)
[1] 5



#
fn3=function(y){
  #message("fn3>>",sys.calls())
  #message("fn3>>"); print(sys.calls())
  message("fn3>> ", as.character(sys.calls()) )
  fn2(y)+3
}

> fn3(3)
fn3>> fn3(3)
fn2>> fn3(3)fn2(y)
[[1]]
[1] "fn3"

[[2]]
[1] "fn2"

[[3]]
[1] "fn1"

fn1>> fn3(3)fn2(y)fn1(y)
[1] 9




(3) 根据编号回溯程序堆栈，可以打印、修改父函数的环境
# parent.environ = sys.frame(which = parent.index)

fn_Parenting=function(parent.index, ...){
  message("fn_Parenting>> ", as.character(sys.calls()) )
  to.parent <- list(...)
  # 获取上一个函数栈的环境
  parent.environ <- sys.frame(which = parent.index)
  print(ls(parent.environ)) #打印环境中的变量
  # 把值逐个写入
  for (j in 1:length(x = to.parent)) {
    parent.environ[[names(x = to.parent)[j]]] <- to.parent[[j]]
  }
}
#
fns1=function(a, b, i){
  f1= 10
  x=fns2(a, b, i)
  message("In fns1:", paste0(x, collapse = ", ") )
  return( c(a, b) )
}

fns2=function(a, b, i){
  f2=20
  fn_Parenting(i, a=120)
  message("In fns2:", paste0(c(a,b,i), collapse = ", ") )
  return( c(a,b,i) )
}



> fns1(1, 2, i=2) #2
fn_Parenting>> fns1(1, 2, i = 2)fns2(a, b, i)fn_Parenting(i, a = 120)
[1] "a"  "b"  "f2" "i" #i=2，就是追溯堆栈第二个函数，该函数特有变量f2
In fns2:120, 2, 2
In fns1:120, 2, 2
[1] 1 2 #修改 fns2() 中的a，返回给fns1后覆盖掉x值，但是没有改变 fns1 中的a



> fns1(1, 2, i=1) #1
fn_Parenting>> fns1(1, 2, i = 1)fns2(a, b, i)fn_Parenting(i, a = 120)
[1] "a"  "b"  "f1" "i"  #i=1，就是追溯堆栈第1个函数，该函数特有变量f1
In fns2:120, 2, 1
In fns1:120, 2, 1
[1] 120   2 #修改 fns1() 中的a，最终返回值a是fns1中的，所以受影响






(4) 能否在函数内修改 全局环境变量？可以
modi=function(list2, i=0){
  message(">>> ", as.character(sys.calls()) )
  parent.environ <- sys.frame(which = i)
  # 1是本函数
  # 0是全局环境
  print(ls(parent.environ))
  for(i in names(list2)){
    print(i)
    parent.environ[[i]]=list2[[i]]
  }
}
a=300
modi(list(a=1, b=20), i=0)
a #[1] 1





(5) dimnames() 获取矩阵的行名、列名，list形式

> dimnames(iris[1:3,])
[[1]]
[1] "1" "2" "3"

[[2]]
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"  




(6) split() 把向量按奇偶分成2组

> split(x = 1:10, f = (1:10)%%2  )
$`0`
[1]  2  4  6  8 10

$`1`
[1] 1 3 5 7 9





(7) ChunkPoints() 把向量按每份x个分开，给出分块点起止点
./seurat-4.1.0/R/utilities.R:1671:ChunkPoints <- function(dsize, csize) {

# Generate chunk points
#
# @param dsize How big is the data being chunked 总大小
# @param csize How big should each chunk be 每个小块的大小
#
# @return A matrix where each column is a chunk, row 1 is start points, row 2 is end points
# 返回值每列是一个块，第一行是起点，第二行是终点
#
ChunkPoints <- function(dsize, csize) {
  return(vapply( #vapply 比其他apply相对安全: 能校验返回值的数据类型和个数。
    X = 1L:ceiling(x = dsize / csize), # 要分的块数，有小数了取后一个整数
    FUN = function(i) {
      return(c(
        start = (csize * (i - 1L)) + 1L, #起点是1, (2-1)*csize+1, ...
        end = min(csize * i, dsize) #终点是 csize, csize*2, ..., dsize
      ))
    },
    FUN.VALUE = numeric(length = 2L) #返回值是2个整数
  ))
}


测试:
> Seurat:::ChunkPoints(100, 10)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
start    1   11   21   31   41   51   61   71   81    91
end     10   20   30   40   50   60   70   80   90   100

> Seurat:::ChunkPoints(100, 35)
      [,1] [,2] [,3]
start    1   36   71
end     35   70  100






(8) 把数字分组: 从n1到n2之间的整数，每隔by=n个数字的整数分到一组
> seq.int(4, to=100, by=10)
 [1]  4 14 24 34 44 54 64 74 84 94

> seq(4,100, 10)
 [1]  4 14 24 34 44 54 64 74 84 94


源码
merge.indices <- lapply(
  X = 1:length(x = split.cells),
  FUN = seq.int,
  to = length(x = object),
  by = length(x = split.cells)
)
示例 
lapply(
  X = 1:3,
  FUN = seq.int,
  to = 20,
  by = 3
)
输出:
[[1]]
[1]  1  4  7 10 13 16 19

[[2]]
[1]  2  5  8 11 14 17 20

[[3]]
[1]  3  6  9 12 15 18





(9) 首字母大写的函数
源码:
msg <- paste0(
  toupper(x = substr(x = msg, start = 1, stop = 1)), #首字母大写
  substr(x = msg, start = 2, stop = nchar(x = msg)), #取其余字母
  ' data matrix'
)

实现:
Capitalize=function(arr){
   paste0(
    toupper(x = substr(x = arr, start = 1, stop = 1)), #首字母大写
    substr(x = arr, start = 2, stop = nchar(x = arr)) #取其余字母
  )
}
Capitalize( colnames(mtcars))
# [1] "Mpg"  "Cyl"  "Disp" "Hp"   "Drat" "Wt"   "Qsec" "Vs"   "Am"   "Gear" "Carb"





(10) 文字进度条 utils::txtProgressBar()
源码:
pb <- txtProgressBar(min = 0, max = max.block, style = 3, file = stderr())
...
for (i in 1:max.block) {
	...
	setTxtProgressBar(pb = pb, value = i)
	...
}
close(con = pb)

源码2:
pb <- txtProgressBar(char = '=', style = 3, file = stderr())
for (i in 1:length(x = features.regress)) {
	setTxtProgressBar(pb = pb, value = i / length(x = features.regress)) #进度条
}
close(con = pb)



示例:
library(utils)
max.block=100
pb <- txtProgressBar(min = 0, max = max.block, style = 3, file = stderr())

for (i in 1:max.block) {
  Sys.sleep(0.01+runif(1)/10)
  setTxtProgressBar(pb = pb, value = i)
}
close(con = pb)






(11) formals() 返回获取函数参数列表

> formals(plot)
$x

$y

$...

> names(formals(plot))
[1] "x"   "y"   "..."


# 如果有默认参数
fn1=function(x, y=1){
  x+y
}
formals(fn1)
$x

$y
[1] 1




(12) base::sweep() 把一个矩阵整体减去某个统计参数
Return an array obtained from an input array by sweeping out a summary statistic.

sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)

例1:
> x=iris[1:2,1:4]
> x
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
> sweep(x, MARGIN=1, STATS=c(5,4), FUN = "-") #按行减去值
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          0.1        -1.5         -3.6        -4.8
2          0.9        -1.0         -2.6        -3.8
> sweep(x, MARGIN=2, STATS=c(5,3,1,0), FUN = "-") #按列减去值
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          0.1         0.5          0.4         0.2
2         -0.1         0.0          0.4         0.2



例2: 矩阵每列减去本列的平均值
> df1=mtcars[1:3, 1:5]
> df1
               mpg cyl disp  hp drat
Mazda RX4     21.0   6  160 110 3.90
Mazda RX4 Wag 21.0   6  160 110 3.90
Datsun 710    22.8   4  108  93 3.85
> sweep(df1, 
       MARGIN=2, 
       STATS= apply(df1, 2, mean),
       FUN="-"
)
               mpg        cyl      disp         hp        drat
Mazda RX4     -0.6  0.6666667  17.33333   5.666667  0.01666667
Mazda RX4 Wag -0.6  0.6666667  17.33333   5.666667  0.01666667
Datsun 710     1.2 -1.3333333 -34.66667 -11.333333 -0.03333333







4. PR 
(1) 有且仅有一个基因作为噪音时会导致错误
pbmc_small3 <- ScaleData(pbmc_small, features = all.genes,
                         vars.to.regress = c("nFeature_RNA", "CD79A"))
# PR: https://github.com/satijalab/seurat/pull/5763







========================================
|-- Seurat 4 R包源码解析 17: 使用模型去除数据噪音 - 续 ScaleData
----------------------------------------
1. 概述
本文是上一篇 ScaleData() 的解释说明。建议先阅读上一节的相关描述。

主要是使用R手工实现该处理流程，并适当关心数学推导。
所以本文结构和以往略有不同，还有很多部分留给未来完善。

我们忽略参数验证、日志记录等辅助功能，也暂时不讲 多线程、C++加速代码，这次只看最简单的实现。


(1) 模型去噪音的核心语句

本文接下来重点关注 Seurat 默认使用的线性模型，最后稍微也了解一下其他两个模型，泊松、负二项分布。

    # (B4) 回归后的残差向量
    regression.mat <- switch(
      EXPR = model.use,
      
      # 默认是 线性 模型:
      'linear' = qr.resid(qr = qr, y = data.expr[x,]),

      'poisson' = residuals(object = glm(
        formula = fmla,
        family = 'poisson',
        data = regression.mat),
        type = 'pearson'
      ),

      'negbinom' = NBResiduals(
        fmla = fmla,
        regression.mat = regression.mat,
        gene = x
      )
    )
    # (B5) 把残差放回到原空 残差矩阵中第i行(symbol)
    data.resid[i, ] <- regression.mat



(2) 打算通过几个实例，通过R手工实现处理流程，得出 Seurat::ScaleData() 的结果。
数据: Seurat 4 自带的小数据及 pbmc_small.
方法: 我们先使用普通 lm 拟合，最后关心一下矩阵的QR分解是怎么节省运行时间的。
基因: 都是 scale 全部基因。


	默认参数仅 scale，不回归
	回归掉 nFeature_RNA
	回归掉 nFeature_RNA, CD79A #当只有一个基因时，有bug: https://github.com/satijalab/seurat/pull/5763
	使用 QR 分解求残差



2. 实例1: 默认参数仅 center and scale，不回归
(1) 函数处理
library(Seurat)
all.genes <- rownames(pbmc_small)
pbmc_small1 <- ScaleData(pbmc_small, features = all.genes)
#原始子集可能是先处理再取子集，所以，以新处理的结果为准
scale1=pbmc_small1@assays$RNA@scale.data

> head(scale1[,1:4])
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.4087672     -0.4087672     -0.4087672     -0.4087672
CD79B         1.6399067     -0.6145940     -0.6145940     -0.6145940
CD79A        -0.4275544     -0.4275544     -0.4275544     -0.4275544
HLA-DRA      -1.3746590      0.2874881     -1.3746590     -1.3746590
TCL1A        -0.3288515     -0.3288515     -0.3288515     -0.3288515
HLA-DQB1      1.3697287     -0.7501683     -0.7501683     -0.7501683



(2) 手动处理
data=as.matrix(pbmc_small@assays$RNA@data)
out1=sweep(data, 1, apply(data, 1, mean), "-") #每行 减去 改行的均值
out1_=t(scale(t(out1))) # 除以每行的sd，由于 scale 是按列计算的，所以要

> head(out1_[,1:4])
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.4087672     -0.4087672     -0.4087672     -0.4087672
CD79B         1.6399067     -0.6145940     -0.6145940     -0.6145940
CD79A        -0.4275544     -0.4275544     -0.4275544     -0.4275544
HLA-DRA      -1.3746590      0.2874881     -1.3746590     -1.3746590
TCL1A        -0.3288515     -0.3288515     -0.3288515     -0.3288515
HLA-DQB1      1.3697287     -0.7501683     -0.7501683     -0.7501683

> # check
> table(scale1-out1_<1e-10)

 TRUE 
18400 


# scale 步骤也可以使用 sweep 实现，就是每一行除以该行的sd
# more detail
out1_m=sweep(out1, 1, apply(out1, 1, sd), "/")
head(out1_m[,1:4])
table( abs(out1_m - scale1)<1e-10)
# TRUE 
# 18400 


(3) 其实可以只用scale函数
默认 scale() 会做 -mean 处理

> out1_2=t(scale(t(data))); out1_2[1:6, 1:4]
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.4087672     -0.4087672     -0.4087672     -0.4087672
CD79B         1.6399067     -0.6145940     -0.6145940     -0.6145940
CD79A        -0.4275544     -0.4275544     -0.4275544     -0.4275544
HLA-DRA      -1.3746590      0.2874881     -1.3746590     -1.3746590
TCL1A        -0.3288515     -0.3288515     -0.3288515     -0.3288515
HLA-DQB1      1.3697287     -0.7501683     -0.7501683     -0.7501683

> table(scale1-out1_2<1e-10)

 TRUE 
18400





3. 回归掉 meta.data 中的 nFeature_RNA
(1) 函数处理
all.genes <- rownames(pbmc_small)
pbmc_small2 <- ScaleData(pbmc_small, features = all.genes,
                         vars.to.regress = c("nFeature_RNA"))
scale2=pbmc_small2@assays$RNA@scale.data
> head(scale2[,1:4])
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.5697943     -0.4870271     -0.5201340     -0.4208134
CD79B         1.5871138     -0.6495834     -0.6653221     -0.6181060
CD79A        -0.5366787     -0.4789847     -0.5020623     -0.4328295
HLA-DRA      -1.2835170      0.4003885     -1.3552421     -1.4986922
TCL1A        -0.4787296     -0.3997651     -0.4313509     -0.3365935
HLA-DQB1      1.5729696     -0.7201429     -0.6867491     -0.7869305


(2) 半手动处理
data=as.matrix(pbmc_small@assays$RNA@data)
# 先回归掉噪声
latent.data=pbmc_small[['nFeature_RNA']]

obj = Seurat:::RegressOutMatrix(
  data.expr = data,
  latent.data = latent.data, #潜在回归数据 的子集
  features.regress = rownames(data), #要回归的基因
  model.use = "linear",
  use.umi = F,
  verbose = T
)
obj2=t(scale(t(obj)))

> head(obj2[,1:4])
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.5697943     -0.4870271     -0.5201340     -0.4208134
CD79B         1.5871138     -0.6495834     -0.6653221     -0.6181060
CD79A        -0.5366787     -0.4789847     -0.5020623     -0.4328295
HLA-DRA      -1.2835170      0.4003885     -1.3552421     -1.4986922
TCL1A        -0.4787296     -0.3997651     -0.4313509     -0.3365935
HLA-DQB1      1.5729696     -0.7201429     -0.6867491     -0.7869305
> table(abs(scale2-obj2)<1e-10)

 TRUE 
18400 



(3) 全手动处理
data=as.matrix(pbmc_small@assays$RNA@data)
# regress out
resid.mat=matrix(
  nrow=nrow(data),
  ncol=ncol(data)
)
dim(resid.mat)
# begin for each gene: gene ~ vars.
for(i in 1:nrow(data)){
  data2=cbind(latent.data, data[i,])
  colnames(data2)=c(colnames(latent.data), "GENE")
  model=lm(GENE~nFeature_RNA, data=data2) #模型 Gene~噪音变量名+变量名2
  resid=data[i,]-predict(model) #残差: 原始值 - 预测值
  resid.mat[i,]=resid
}
# scale
obj2_m=t(scale(t(resid.mat)))
#dimnames(obj2_m)=dimnames(data)
head(obj2_m[,1:4])
# test matrix equal

> table(scale2-obj2_m<1e-10)

 TRUE 
18400 






4. 回归掉 nFeature_RNA, 和一个基因 CD79A，有bug

all.genes <- rownames(pbmc_small)
pbmc_small3 <- ScaleData(pbmc_small, features = all.genes,
                         vars.to.regress = c("nFeature_RNA", "CD79A"))
scale3=pbmc_small2@assays$RNA@scale.data
head(scale3[,1:4])

# bug 
vars.to.regress = c("nFeature_RNA", "CD79A")
object=data
latent.data=pbmc_small[["nFeature_RNA"]]
#
vars.to.regress[vars.to.regress %in% rownames(x = object)]
t(object[vars.to.regress[vars.to.regress %in% rownames(x = object)], , drop=F])
t(x = object[vars.to.regress[vars.to.regress %in% rownames(x = object)], ]) #bug: no df shape

#
if (any(vars.to.regress %in% rownames(x = object))) {
  # add gene exp to latent.data
  latent.data <- cbind(
    latent.data,
    t(x = object[vars.to.regress[vars.to.regress %in% rownames(x = object)], ]) #bug
    #t(x = object[vars.to.regress[vars.to.regress %in% rownames(x = object)], ,drop=F])
  )
}
head(latent.data[, 1:4])
# https://github.com/satijalab/seurat/pull/5763

> head(latent.data[, 1:4])
               nFeature_RNA ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC
ATGCCAGAACGACT           47              0              0              0
CATGGCCTGTGCAT           52              0              0              0
GAACCTGATGAACC           50              0              0              0
TGACTGGATTCTCA           56              0              0              0
AGTCAGACTGCACA           53              0              0              0
TCTGATACACGTGT           48              0              0              0






5.回归掉 nFeature_RNA, CD79A CD8A
(1) 函数计算
all.genes <- rownames(pbmc_small)
pbmc_small4 <- ScaleData(pbmc_small, features = all.genes,
                         vars.to.regress = c("nFeature_RNA", "CD79A", "CD8A"))
scale4=pbmc_small4@assays$RNA@scale.data

> head(scale4[,1:4])
         ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA
MS4A1        -0.2682047     0.02320886     -0.2303838    -0.15474204
CD79B         2.4493308    -0.33695723     -0.4651794    -0.45852800
CD79A         1.0269414     0.31089678     -8.7355452     0.13828548
HLA-DRA      -1.1821658     0.79358748     -1.2895924    -1.50444538
TCL1A        -0.1812479     0.02156459     -0.1476698    -0.08051371
HLA-DQB1      2.4832829    -0.30960741     -0.5062450    -0.69271924




(2) 半手动处理
data=as.matrix(pbmc_small@assays$RNA@data)
# 先回归掉噪声
vars.to.regress=c("nFeature_RNA", "CD79A", "CD8A")
latent.data=pbmc_small[['nFeature_RNA']]
latent.data=cbind(latent.data, 
                  t(x = object[vars.to.regress[vars.to.regress %in% rownames(x = object)], ]) )
head(latent.data)

obj = Seurat:::RegressOutMatrix(
  data.expr = data,
  latent.data = latent.data, #潜在回归数据 的子集
  features.regress = rownames(data), #要回归的基因
  model.use = "linear",
  use.umi = F,
  verbose = T
)
obj2=t(scale(t(obj)))
head(obj2[,1:4])

# check
> table(abs(scale4-obj2)<1e-10) #no F

 TRUE 
18400 


(3) 手动处理
# regress out vars
data=as.matrix(pbmc_small@assays$RNA@data)
latent.data=FetchData(pbmc_small, vars=c("nFeature_RNA", "CD79A", "CD8A"),
                      slot="data")
head(latent.data)
#vars.to.regress <- colnames(x = latent.data)
# regress out
resid.mat=matrix(
  nrow=nrow(data),
  ncol=ncol(data)
)
dim(resid.mat) #230 80
# begin for each gene: gene ~ vars.
for(i in 1:nrow(data)){
  data2=cbind(latent.data, data[i,])
  colnames(data2)=c(colnames(latent.data), "GENE")
  model=lm(GENE~nFeature_RNA+CD79A+CD8A, data=data2) #模型 Gene~噪音变量名+变量名2
  resid=data[i,]-predict(model) #残差: 原始值 - 预测值
  resid.mat[i,]=resid
}
#check
table(abs(resid.mat-obj)<1e-10) #no F


# scale
obj4=t(scale(t(resid.mat)))
dimnames(obj4)=dimnames(data)
head(obj4[,1:4])
head(scale4[,1:4]) # Seurat 函数计算结果
# check
table(abs(obj4-obj2)<1e-10) #160个F
table(abs(scale4-obj4)<1e-10) #160个F。
# 一列80个，正好2个被回归的基因和Seurat结果有差异

FALSE  TRUE 
  160 18240 



(4) 查找原因
a1=obj; a2=obj2;
b1=resid.mat; b2=obj4;
dimnames(b1)=dimnames(data)
#
table(abs(a1-b1)<1e-10) #no F
table(abs(a2-b2)<1e-10) #160 F
#
#
table(abs(a1-b1)<1e-10) #no F
table(abs(a1-b1)<1e-14) #15 F
table(abs(a1-b1)<1e-15) #1.8k F 说明都是小数点后面13位后的差异
#
# 或许应该全部设置为0，而不是留着，否则 (x-mean)/sd 可能特别大
# 这个舍入误差可能是 QR 分解造成的

> gene1="CD79B";head(a1[gene1,]);head(b1[gene1,])
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
     4.1709973     -0.5738089     -0.7921601     -0.7808333     -0.7864967     -0.7959357 
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
     4.1709973     -0.5738089     -0.7921601     -0.7808333     -0.7864967     -0.7959357 
> gene1="CD79A";head(a1[gene1,]);head(b1[gene1,]) #全是极小的数，
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
  2.088779e-15   6.323580e-16  -1.776793e-14   2.812700e-16   3.588664e-16   3.031566e-16 
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA TCTGATACACGTGT 
  9.672066e-16   4.330893e-16   9.076219e-16   7.884525e-16   8.480372e-16   9.473450e-16






6. 手动处理2: 使用 QR 分解
接上文。

(1) R手工实现 矩阵QR分解求残差

# regress out vars
data=as.matrix(pbmc_small@assays$RNA@data)
latent.data=FetchData(pbmc_small, vars=c("nFeature_RNA", "CD79A", "CD8A"),
                      slot="data")
head(latent.data)
vars.to.regress <- colnames(x = latent.data)
# qr 
data2=cbind(latent.data, data[1,])
colnames(data2)=c(colnames(latent.data), "GENE")
qr=lm(GENE~nFeature_RNA+CD79A+CD8A, data=data2, qr=T)$qr
str(qr)

# regress out
resid.mat=matrix(
  nrow=nrow(data),
  ncol=ncol(data)
)
dim(resid.mat) #230 80
# begin for each gene: gene ~ vars.
for(i in 1:nrow(data)){
  resid.mat[i,]=qr.resid(qr = qr, y = data[i,])
}
obj5=t(scale(t(resid.mat)))

> table( abs(scale4 - obj5)<1e-10 )

 TRUE 
18400 



(2) 数学原理 //todo

qr 分解 求残差









(3). 如何理解施密特（Schmidt）正交化

https://zhuanlan.zhihu.com/p/136627868

根据定义，内积<a1,a2>等于一个的长度另一个再这个上面的投影，所以假设b1是a1在a2上的投影，则 <a1,a2>=|b1| x |a2|;
而 |a2|^2 = <a2, a2>，a2方向上的单位向量 i=a2 / |a2|
则 b1=|b1| x i = <a1, a2> /|a2| x a2/|a2| = <a1,a2>/<a2,a2> x a2






7. 广义线性模型 之 泊松分布

fitted.model <- glm(formula, family=family.generator, data=data.frame)

其中 formula 是拟合公式，这里的意义与线性模型相同。
family 是分布族，即前面讲到的广义线性模型的种类，如 正态分布、Poisson 分布、二项分布等。
data 是数据框，与lm模型相同。

      'poisson' = residuals(object = glm(
        formula = fmla,
        family = 'poisson',
        data = regression.mat),
        type = 'pearson'
      ),

实例:
#
df1=iris[,1:4]*10 #泊松分布只能输入整数
colnames(df1)=c("Y", paste0("X", 1:3) )
head(df1)
fit=glm(
  formula=Y~X1+X2+X3,
  family = 'poisson',
  data=df1
)
fit
summary(fit)
y.resid=residuals(fit, type = "pearson")

# 查看残差的分布
hist(y.resid, n=30)





8. 负二项分布模型

      'negbinom' = NBResiduals(
        fmla = fmla,
        regression.mat = regression.mat,
        gene = x
      )

定义:
./seurat-4.1.0/R/preprocessing.R:3324:NBResiduals <- function(fmla, regression.mat, gene, return.mode = FALSE) {
./seurat-4.1.0/NAMESPACE:375:importFrom(MASS,glm.nb)


#
#' @importFrom stats residuals
#
NBResiduals <- function(fmla, regression.mat, gene, return.mode = FALSE) {
  # 
  fit <- 0
  
  try(
    fit <- glm.nb(
      formula = fmla,
      data = regression.mat
    ),
    silent = TRUE)
	
  if (is.numeric(x = fit)) {
    message(sprintf('glm.nb failed for gene %s; falling back to scale(log(y+1))', gene))
    resid <- scale(x = log(x = regression.mat[, 'GENE'] + 1))[, 1]
    mode <- 'scale'
  } else {
    resid <- residuals(fit, type = 'pearson')
    mode = 'nbreg'
  }
  
  do.return <- list(resid = resid, mode = mode)
  
  if (return.mode) {
    return(do.return)
  } else {
    return(do.return$resid)
  }
  
}


实例:
fit2=MASS::glm.nb(
  formula = Y~X1+X2+X3,
  data = df1
)
fit2
summary(fit2)

y.resid2 <- residuals(fit2, type = 'pearson')
# 查看残差的分布
hist(y.resid2, n=30)













========================================
|-- Seurat 4 R包源码解析 18: step8 线性降维 RunPCA() 主成分分析及数学原理
----------------------------------------

1. 调包侠
# step8 (PCA) Perform linear dimensional reduction
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))

# Examine and visualize PCA results a few different ways
#print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
# VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
DimPlot(pbmc, reduction = "pca")

# DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
# DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)


注:
本文以实战为主，顺便说一些必要的数学原理。
数学部分有不严谨的地方，欢迎留言批评指正。
本文仅讨论最核心的PCA计算过程，后面的可视化及涉及到的内部类放到下一篇。



(1) run PCA 可以指定基因列表，如果没有指定，则使用高变基因。
RunPCA(sce, features=c(......))

VariableFeatures() 函数在 源码解析 10 (2.6)中说过。
返回的就是 assay对象( pbmc_small@assays$RNA )的 var.features slot

> str(pbmc@assays$RNA@var.features )
chr [1:2000] "PPBP" "LYZ" "S100A9" "IGLL5"


RunPCA() 没有指定 features 则使用高变基因。
做PCA使用的数据是 scale.data。
features 必须在 scaled data 中，如果不在或者 variance=0 则舍弃，用其余的做PCA。



(2) 主力函数 #' @importFrom stats prcomp

(3) 主成分分析概述
主成分分析的主要思想，是选择变异最大的方向作为第一维，然后在垂直第一维的方向选择变异最大的第二维，然后再在垂直第1-2维的方向选择变异最大的方向作为第三维，以此类推。我们发现大部分方差都集中在前面几个新坐标轴中了。忽略其余坐标轴，就完成了数据的线性降维处理。
数学上，我们一般把数据中心化为A，然后求其协方差矩阵的特征值和特征向量 A.x=lambda.x 。特征向量构成的矩阵就是旋转矩阵，原始矩阵中心化后，点乘该旋转矩阵，就得到了新坐标系统里的位置，也就是embeding。特征根开平方根就是每个PC解释的方差。
为了简化运算，一般使用奇异值分解 SVD 代替特征值分解: A=U.D.V^T。
Seurat 使用奇异值/根号(细胞数-1) 最为对应主成分的方差，右奇异矩阵V作为旋转矩阵。左奇异矩阵u 点乘 奇异值对角矩阵 作为细胞的新坐标。
# object 是 gene*cell 矩阵，scale.data。
pca.results <- irlba(A = t(x = object), nv = npcs, ...) #转置后，对列(gene)奇异值分解
feature.loadings <- pca.results$v #右矩阵v是 gene 的loading
sdev <- pca.results$d/sqrt(max(1, ncol(object) - 1)) #特征根 / 根号(列数 - 1)
# 左奇异矩阵 u 是 cell embeddings，乘以 var 权重
cell.embeddings <- pca.results$u %*% diag(pca.results$d)




亮点：我们在本篇 3.3 手工实现了一个PCA函数，输出结果和 prcomp() 一致。感兴趣的可以看看，虽然简单但是大致功能都有了。






2. 源码解析
(1)直接使用的函数
- RunPCA
- DimPlot 以后再说 //todo
- DimHeatmap 下一篇说



(2)间接使用的函数
- LogSeuratCommand
- RowVarSparse: ./seurat-4.1.0/R/utilities.R:2345:RowVarSparse <- function(mat) {
	* row_var_dgcmatrix: ./seurat-4.1.0/R/RcppExports.R:120:row_var_dgcmatrix <- function(x, i, rows, cols) {
- RowVar, C 函数 ./seurat-4.1.0/R/RcppExports.R:64:RowVar <- function(x) {










3. R tips


(1) 近似PCA: irlba::irlba() 部分奇异值分解
Find a few approximate singular values and corresponding singular vectors of a matrix.


# 定义矩阵
A=matrix( c(2,1, 1,
            1, 2, 1,
            1, 1, 2), nrow=3, byrow = T);A




#1) eigen() 求特征值和特征向量
> Aeigen=eigen(A); Aeigen
eigen() decomposition
$values
[1] 4 1 1
# 文档说是降序排列的特征值 values: a vector containing the p eigenvalues of x, sorted in decreasing order, 

$vectors
           [,1]       [,2]       [,3]
[1,] -0.5773503  0.0000000  0.8164966
[2,] -0.5773503 -0.7071068 -0.4082483
[3,] -0.5773503  0.7071068 -0.4082483


# 检查 A*x = lambda*x
> A %*% Aeigen$vectors
          [,1]       [,2]       [,3]
[1,] -2.309401  0.0000000  0.8164966
[2,] -2.309401 -0.7071068 -0.4082483
[3,] -2.309401  0.7071068 -0.4082483
> Aeigen$values * Aeigen$vectors
           [,1]       [,2]       [,3]
[1,] -2.3094011  0.0000000  3.2659863
[2,] -0.5773503 -0.7071068 -0.4082483
[3,] -0.5773503  0.7071068 -0.4082483

# 检查2: A=U.B.U^-1
> Aeigen$vectors %*% diag(Aeigen$values) %*% solve(Aeigen$vectors)
     [,1] [,2] [,3]
[1,]    2    1    1
[2,]    1    2    1
[3,]    1    1    2





#2) svd() 奇异值分解 A=U.D.V^T
> rs=svd(A);rs
$d
[1] 4 1 1 #给的是特征值 = 奇异值的平方
# 文档说降序排列的奇异值: d: a vector containing the singular values of x, of length min(n, p), sorted decreasingly.

$u
           [,1]       [,2]          [,3]
[1,] -0.5773503  0.8164966 -5.041791e-17
[2,] -0.5773503 -0.4082483 -7.071068e-01
[3,] -0.5773503 -0.4082483  7.071068e-01

$v
           [,1]       [,2]       [,3]
[1,] -0.5773503  0.8164966  0.0000000
[2,] -0.5773503 -0.4082483 -0.7071068
[3,] -0.5773503 -0.4082483  0.7071068

# 还原矩阵
> rs$u %*% diag(rs$d) %*% t(rs$v)
     [,1] [,2] [,3]
[1,]    2    1    1
[2,]    1    2    1
[3,]    1    1    2






#3) 求部分奇异值，nv<min(nrow(A), ncol(A))
> pca.results <- irlba(A = A, nv = 2); pca.results
Warning in irlba(A = A, nv = 2) :
  You're computing too large a percentage of total singular values, use a standard svd instead.
$d
[1] 4 1 
# 帮助文档说d是近似奇异值 d: max(nu, nv) approximate singular values

$u
           [,1]       [,2]
[1,] -0.5773503  0.8164966
[2,] -0.5773503 -0.4082483
[3,] -0.5773503 -0.4082483

$v
           [,1]       [,2]
[1,] -0.5773503  0.8164966
[2,] -0.5773503 -0.4082483
[3,] -0.5773503 -0.4082483

$iter
[1] 0

$mprod
[1] 0


# 还原矩阵 U.B.V^T
> pca.results$u %*% diag(pca.results$d) %*% t(pca.results$v)
     [,1] [,2] [,3]
[1,]    2  1.0  1.0
[2,]    1  1.5  1.5
[3,]    1  1.5  1.5
有些元素还原的不好，毕竟缺了一个特征向量












(2) 精确PCA: prcomp()
pca.results <- prcomp(x = t(object), rank. = npcs, ...)

接上文。
> A
     [,1] [,2] [,3]
[1,]    2    1    1
[2,]    1    2    1
[3,]    1    1    2

> pca.results <- prcomp(x = A); pca.results 
Standard deviations (1, .., p=3):
[1] 7.071068e-01 7.071068e-01 1.586363e-16

Rotation (n x k) = (3 x 3):
            PC1        PC2       PC3
[1,]  0.8164966  0.0000000 0.5773503
[2,] -0.4082483 -0.7071068 0.5773503
[3,] -0.4082483  0.7071068 0.5773503

> pca.results$x
            PC1           PC2          PC3
[1,]  0.8164966  5.551115e-17 1.665335e-16
[2,] -0.4082483 -7.071068e-01 8.326673e-17
[3,] -0.4082483  7.071068e-01 1.110223e-16
> pca.results$rotation




2) 返回值 Value 
prcomp returns a list with class "prcomp" containing the following components:

# sdev 主成分的标准误差(协方差矩阵的特征根的开方，虽然这个实际上是用矩阵的奇异值计算的)
the standard deviations of the principal components (i.e., the square roots of the eigenvalues of the covariance/correlation matrix, though the calculation is actually done with the singular values of the data matrix).

# rotation 特征向量矩阵，每一列是一个特征向量。
the matrix of variable loadings (i.e., a matrix whose columns contain the eigenvectors). The function princomp returns this in the element loadings.

# x	如果 retx==T，返回旋转后的数据: center后的矩阵 * 旋转矩阵。所以协方差矩阵就是对角矩阵。
if retx is true the value of the rotated data (the centred (and scaled if requested) data multiplied by the rotation matrix) is returned. Hence, cov(x) is the diagonal matrix diag(sdev^2). For the formula method, napredict() is applied to handle the treatment of values omitted by the na.action.




3) 细节 Details
使用对center后矩阵的奇异值分解方法，而不是使用协方差矩阵的特征根。
这也是使数值更精确的推荐方法。
The calculation is done by a singular value decomposition of the (centered and possibly scaled) data matrix, not by using eigen on the covariance matrix. This is generally the preferred method for numerical accuracy. 

print和plot方法。
The print method for these objects prints the results in a nice format and the plot method produces a scree plot.

Unlike princomp, variances are computed with the usual divisor N - 1.

有零值或常数项时不能使用 scale=T。
Note that scale = TRUE cannot be used if there are zero or constant (for center = TRUE) variables.




4) 进一步对 iris 数据做主成分分析
> iris.pca=prcomp(iris[,1:4])
> iris.pca #对列求线性组合
Standard deviations (1, .., p=4):
[1] 2.0562689 0.4926162 0.2796596 0.1543862

Rotation (n x k) = (4 x 4):
                     PC1         PC2         PC3        PC4
Sepal.Length  0.36138659 -0.65658877  0.58202985  0.3154872
Sepal.Width  -0.08452251 -0.73016143 -0.59791083 -0.3197231
Petal.Length  0.85667061  0.17337266 -0.07623608 -0.4798390
Petal.Width   0.35828920  0.07548102 -0.54583143  0.7536574


> plot(iris.pca) #每个主成分的占比

可见，默认是对列进行的。
PC1=0.36*Sepal.Length -0.084*Sepal.Width +0.856*Petal.Length +0.35*Petal.Width
通过对 feature 线性组合，得到一系列新的 feature 组合，这解决了单细胞矩阵中的大面积0的问题。至于是不是应对 0-inflation 最好的解决方法，有待研究。//todo


从方差可见，第一个PC解释的变异最多。

注意：对于 Seurat 的默认输入 gene*cell 矩阵，我们打算对基因进行线性组合，就要先做转置再求PCA。

# 相当于旋转后的坐标系(特征向量组成的矩阵)
feature.loadings <- pca.results$rotation #见上文。



# 相当于每个细胞在各个新坐标系的坐标值
cell.embeddings <- pca.results$x

> head(iris.pca$x)
           PC1        PC2         PC3          PC4
[1,] -2.684126 -0.3193972  0.02791483  0.002262437
[2,] -2.714142  0.1770012  0.21046427  0.099026550
[3,] -2.888991  0.1449494 -0.01790026  0.019968390
[4,] -2.745343  0.3182990 -0.03155937 -0.075575817
[5,] -2.728717 -0.3267545 -0.09007924 -0.061258593
[6,] -2.280860 -0.7413304 -0.16867766 -0.024200858

对原矩阵做 center 后 * 旋转矩阵，得到每个观测值的新坐标
注: 是做PCA的矩阵，如果当时转置后做PCA，这里也要用转置后center。
默认 scale 函数是按照列 center(减去平均值) 和 scale(除以sd) 的。
> head( scale(iris[,1:4], scale = F) %*% iris.pca$rotation)
           PC1        PC2         PC3          PC4
[1,] -2.684126 -0.3193972  0.02791483  0.002262437
[2,] -2.714142  0.1770012  0.21046427  0.099026550
[3,] -2.888991  0.1449494 -0.01790026  0.019968390
[4,] -2.745343  0.3182990 -0.03155937 -0.075575817
[5,] -2.728717 -0.3267545 -0.09007924 -0.061258593
[6,] -2.280860 -0.7413304 -0.16867766 -0.024200858










(3) 用R全手工实现 PCA(对比 prcomp() )
不借助包，按照 《机器学习实战》P246的伪代码进行操作.

1减去平均数
2计算协方差矩阵
3计算协方差矩阵的特征值和特征向量
4将特征值从大到小排列
5保留最上面的N个特征值
6将数据转换到上述N个特征向量构建的新空间中。

例1: 针对iris数据集

head(iris)
df1=iris[,1:4]
#1) 减去平均值
df1=sweep(x=df1, 
          MARGIN=2, 
          STATS=apply(df1, 2, mean),
          FUN="-")
head(df1)
#2) 计算协方差矩阵
cor.df1=cov(df1)
#3) 计算协方差矩阵的特征值和特征向量
eigen.df1=eigen(cor.df1)
#4) 特征值默认降序
eigen.df1
#5) 保留最前面的几个特征值
#6) 原center后的坐标 * 旋转矩阵
coord.df1=as.matrix(df1) %*% eigen.df1$vectors
dim(coord.df1)
head(coord.df1)
# plot
coord.df1_=as.data.frame(coord.df1)
colnames(coord.df1_)=paste0("PC_", 1:4)
coord.df1_$type=iris$Species
library(ggplot2)
ggplot(coord.df1_, aes(PC_1, PC_2, color=type))+
  geom_point()

# prcomp() 做PCA
pca.iris=prcomp(iris[,1:4])
pca.iris

# 对比旋转矩阵
> pca.iris$rotation #prcomp()的计算结果
                     PC1         PC2         PC3        PC4
Sepal.Length  0.36138659 -0.65658877  0.58202985  0.3154872
Sepal.Width  -0.08452251 -0.73016143 -0.59791083 -0.3197231
Petal.Length  0.85667061  0.17337266 -0.07623608 -0.4798390
Petal.Width   0.35828920  0.07548102 -0.54583143  0.7536574

> eigen.df1$vectors #协方差矩阵的特征向量构成的矩阵
            [,1]        [,2]        [,3]       [,4]
[1,]  0.36138659 -0.65658877 -0.58202985  0.3154872
[2,] -0.08452251 -0.73016143  0.59791083 -0.3197231
[3,]  0.85667061  0.17337266  0.07623608 -0.4798390
[4,]  0.35828920  0.07548102  0.54583143  0.7536574


# 对比方差
# 主成分的标准差，文档说是 协方差矩阵的特征值的平方根，虽然是通过SVD分解实现的
# square roots of the eigenvalues of the covariance/correlation matrix
# though the calculation is actually done with the singular values of the data matrix
> pca.iris$sdev
[1] 2.0562689 0.4926162 0.2796596 0.1543862

> eigen.df1$values #特征根
[1] 4.22824171 0.24267075 0.07820950 0.02383509

#开方后确实等于 pca.iris$sdev
> sqrt(eigen.df1$values)
[1] 2.0562689 0.4926162 0.2796596 0.1543862






把 以上过程包装成我们自定义的PCA函数

#' 按列求CPA，结果模仿 prcomp
#'
#' @param df0 input a df, PCA on column
#' @param ndims the total eigenvalue to use
#'
#' @return
#' @export
#'
#' @examples
#' 
my_PCA=function(df0, ndims=NULL, scale=F){
  # check params
  if(!is.null(ndims)){
    ndims=min(ndims, ncol(df0));
  }else{
    ndims=ncol(df0)
  }
  
  #1) 减去平均值
  center=apply(df0, 2, mean)
  df1=sweep(x=df0, MARGIN=2, STATS=center, FUN="-")
  # whether scale?
  if(scale){
    df1=scale(df1)
  }
  #2) 计算协方差矩阵
  cor.df1=cov(df1)
  #3) 计算协方差矩阵的特征值和特征向量
  eigen.df1=eigen(cor.df1)
  #4) 特征值默认降序
  #eigen.df1
  #5) 保留最前面的几个特征值
  if(!is.null(ndims)){
    message(">> Use the first ", ndims, " PCs.");
    eigen.df1$values=eigen.df1$values[1:ndims]
    eigen.df1$vectors=eigen.df1$vectors[,1:ndims]
  }
  #6) 原center后的坐标 * 旋转矩阵
  coord.df1=as.matrix(df1) %*% eigen.df1$vectors
  
  # 对比旋转矩阵
  rotation=eigen.df1$vectors #协方差矩阵的特征向量构成的矩阵
  #
  colnames(rotation)=paste0("PC_", 1:ndims)
  rownames(rotation)= colnames(df1)
  #
  colnames(coord.df1)=colnames(rotation)
  rownames(coord.df1)=rownames(df0)

  #eigen.df1$values #特征根
  sdev=sqrt(eigen.df1$values) #开方后确实等于 pca.iris$sdev
  # return
  obj=list(
    sdev=sdev,
    rotation=rotation,
    center=center,
    scale=scale,
    x=coord.df1
  )
  class(obj)="my_PCA"
  return(obj)
}

# test
pca2.iris=my_PCA(iris[,1:4])
# prcomp() 做PCA
pca.iris=prcomp(iris[,1:4])

# compare result
str(pca.iris)
str(pca2.iris)


# test patial eigenvalue
my_PCA(iris[,1:4], ndims = 2)
prcomp(iris[,1:4], rank. = 2)

# plot 
coord.df1_=as.data.frame(pca2.iris$x)
colnames(coord.df1_)=paste0("PC_", 1:4)
coord.df1_$type=iris$Species
library(ggplot2)
ggplot(coord.df1_, aes(PC_1, PC_2, color=type))+
  geom_point()










(4) 半手工实现Seurat默认的PCA (pbmc_small)
默认走的是源码解析中标号 A3-B1 的代码。我们去掉验证判断部分，只保留干活的语句。

使用近似求解，部分奇异值，使用函数 irlba 做矩阵的 SVD 分解。
A=U.D.V^T 
使用 右奇异矩阵v 作为旋转矩阵;
使用 左矩阵u . 特征根对角矩阵 作为有var权重的 cell embeding 也就是点的坐标。


使用 pbmc_small 做测试。


#1) 使用R包计算
library(Seurat)
dim(pbmc_small) #230 gene * 80 cell
pbmc_small2=RunPCA(pbmc_small)
# 每个细胞的坐标
rs1=pbmc_small2@reductions$pca@cell.embeddings[1:4, 1:4]; rs1
#DimPlot(pbmc_small2, reduction = "pca")


#2) 手动计算
# 输入
object=pbmc_small2@assays$RNA@scale.data
dim(object) #20 80
npcs=50
npcs <- min(npcs, nrow(x = object) - 1) # 至少是 行数-1

set.seed(42)
pca.results <- irlba::irlba(A = t(x = object), nv = npcs) #转置后，奇异值分解
#feature.loadings <- pca.results$v #右矩阵v是 gene 的loading
#sdev <- pca.results$d/sqrt(max(1, ncol(object) - 1)) #特征根 / 根号(列数 - 1)
# 左奇异矩阵 u 是 cell embeddings * 特征值对角矩阵(var 权重)
cell.embeddings <- pca.results$u %*% diag(pca.results$d)
rownames(cell.embeddings) = colnames(object)

> cell.embeddings[1:4, 1:4] #手工计算的
                      [,1]       [,2]       [,3]       [,4]
ATGCCAGAACGACT -0.77403708  0.8996461  0.2493078 -0.5585948
CATGGCCTGTGCAT -0.02602702  0.3466795 -0.6651668 -0.4182900
GAACCTGATGAACC -0.45650250 -0.1795811 -1.3175907 -2.0137210
TGACTGGATTCTCA -0.81163243  1.3795340  1.0019320 -0.1390503

> rs1 #Seurat R包生成的细胞坐标
                      PC_1       PC_2       PC_3      PC_4
ATGCCAGAACGACT -0.77403708 -0.8996461 -0.2493078 0.5585948
CATGGCCTGTGCAT -0.02602702 -0.3466795  0.6651668 0.4182900
GAACCTGATGAACC -0.45650250  0.1795811  1.3175907 2.0137210
TGACTGGATTCTCA -0.81163243 -1.3795340 -1.0019320 0.1390503


# 为什么 PC_2-4 的符号和 Seurat R包计算的相反?
命名执行的是同样的语句!?

也有人遇到这个问题了，但是是和其他R包函数比较:
https://www.jianshu.com/p/887056e3123a
https://github.com/satijalab/seurat/issues/751

you can maybe try the following while computing PCA via stats::prcomp().

# Use Seurat's scaled data to compare prcomp and irlba outputs 
# using the same input matrix
pcaRes <-  prcomp(t(x = object@scale.data), center = F, scale. = F) 

Also, Seurat uses irlba::irlba() to compute PCA (links to paper(http://www.math.uri.edu/~jbaglama/papers/paper14.pdf) and package vignette). Typical output difference between prcomp and irlba with my data is that irlba results in PCs with lower cell embedding values (and a flip in the sign for some PCs) compared to prcomp.



作者认为有些PC发生符号翻转(sign flip)是正常的:
https://github.com/satijalab/seurat/issues/4848
We do not sort/order the matrix based on gene or cell names before running it so providing these in different orders could result in a sign flip for some PC embeddings




该包代码 https://github.com/bwlewis/irlba
# Fast truncated singular value decompositions
https://github.com/bwlewis/irlba/blob/master/R/irlba.R
这个函数太难了，不打算看了。 //todo








(5) 捕获输出到字符串或文件 capture.output()
Send Output to a Character String or File

实例1:
> txt=capture.output(print("Hello, world!"))
> txt
[1] "[1] \"Hello, world!\""
> message(txt)
[1] "Hello, world!"


实例2: 怎么接收返回 invisible() 的函数的输出？
fn2=function(x){
  txt=paste0("your input is:", x)
  return(invisible(txt))
}
fn2(20)
y2=capture.output(fn2(10))
y2 #没有
message(y2) #空
# 需要先print 出来
y3=capture.output(print(fn2(10)))

> y3
[1] "[1] \"your input is:10\""
> message(y3)
[1] "your input is:10"



ref:
https://www.bilibili.com/video/BV1ix411f7Yp?p=30
https://www.zhihu.com/question/41120789/answer/481966094
https://www.displayr.com/singular-value-decomposition-in-r/
https://www.zhihu.com/question/49959130/answer/119452063







========================================
|-- Seurat 4 R包源码解析 19: step8 RunPCA() - PCA 可视化 与 DimReduc 类
----------------------------------------
1. 调包侠
接上文。

# Examine and visualize PCA results a few different ways
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)



(1) DimHeatmap 是使用 scale.data 画热图的。

DimHeatmap(pbmc, dims=1, nfeatures = 30)
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)






2. 源码解析

DimHeatmap









3. R tips 

(1) 创建空矩阵
embeddings = new(Class = 'matrix')

> new(Class = 'matrix')
<0 x 0 matrix>





(2) 正则替换 regexec() 与 regmatches()
embeddings=data.frame(
  "PC_1"=c(1,2),
  "PC_2"=c(2,3),
  "PC_3"=c(3,3)
)
embeddings

key <- regmatches(
  x = colnames(x = embeddings),
  # 获取 字母数字开头，到下划线结尾的部分_
  m = regexec(pattern = '^[[:alnum:]]+_', text = colnames(x = embeddings))
)
key
key <- unique(x = unlist(x = key, use.names = FALSE))
key
# [1] "PC_"



# regexec: returns a list of the same length as text each element of which is either -1 if there is no match, or a sequence of integers with the starting positions of the match and all substrings corresponding to parenthesized subexpressions of pattern, with attribute "match.length" a vector giving the lengths of the matches (or -1 for no match). The interpretation of positions and length and the attributes follows regexpr.

> colnames(iris[,1:2])
[1] "Sepal.Length" "Sepal.Width" 

# 返回等长的一个list，不匹配则返回-1，匹配则返回起始位置和匹配长度match.length。
# 位置、长度、性质参考 regexpr。
> regexec("Wid", text=colnames(iris[,1:2]))
[[1]]
[1] -1
attr(,"match.length")
[1] -1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

[[2]]
[1] 7
attr(,"match.length")
[1] 3
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE


# regmatches(x, m) 从字符串x中拿出来m匹配的部分字符串。
rs=regmatches(
	x=colnames(iris[,1:2]), 
	m=regexec("Wid", text=colnames(iris[,1:2]))
)
rs
输出:
[[1]]
character(0)

[[2]]
[1] "Wid"

需要剥开list，会自动去掉空值。
> unlist(rs)
[1] "Wid"



(3) grepl()返回逻辑值：是否匹配

grepl(pattern = '^[[:alnum:]]+_$', x = "PC") #F
grepl(pattern = '^[[:alnum:]]+_$', x = "PC_") #T


(4) posix 字符串、正则表达式拼接
源码: else if (!all(grepl(pattern = paste0('^', key, "[[:digit:]]+$"), x = colnames(x = embeddings)))) {

这个例子说明，正则表达式也是字符串，可以像字符串一样拼接，可以使用变量。

POSIX 字符类：R中使用要加上两层方括号
	[:alnum:]任何一个字母或数字（等价于[a-ZA-Z0-9]）
	[:alpha:]任何一个字母（等价于[a-ZA-Z]）
	[:blank:]空格或制表符（等价于[\t ]） 注:t后面有一个空格
	[:cntrl:]ASCII控制字符（ASCII 0到31，再加上ASCII 127）
	[:digit:]任何一个数字（等价于[0-9])
	[:graph:]和[:print:]一样，但不包括空格
	[:lower:]任何一个小写字母（等价于[a-z])
	[:print:]任何一个可打印字符
	[:punct:]既不属于[:alnum:]，也不属于[:cntrl:]的任何一个字符
	[:space:]任何一个空格字符，包括空格（等价于[f\n\r\t\v ] 注:v后面有一个空格
	[:upper:]任何一个大写字母（等价于[A-Z])
	[:xdigit:]任何一个十六进制数字(等价于[a-fA-F0-9])

测试:
> colnames(x = iris)
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"

> key="S"

# 匹配S开头，后面是字母或数字，直到一个点号: 前2个符合
> grepl(pattern = paste0('^', key, "[[:alnum:]]+\\."), x = colnames(x = iris) )
[1]  TRUE  TRUE FALSE FALSE FALSE

# 匹配S开头，后面是字母或数字: 1,2,5符合
> grepl(pattern = paste0('^', key, "[[:alnum:]]+"), x = colnames(x = iris) )
[1]  TRUE  TRUE FALSE FALSE  TRUE





(5) 对数据框进行 MinMax 截断

MinMax <- function(data, min, max) {
  data2 <- data
  data2[data2 > max] <- max
  data2[data2 < min] <- min
  return(data2)
}

例子:
> A=matrix(1:12, nrow = 3);A
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> A[A<5]=5
> A
     [,1] [,2] [,3] [,4]
[1,]    5    5    7   10
[2,]    5    5    8   11
[3,]    5    6    9   12





(6) base::menu() 文字版菜单
源码:
menu(c("Continue with plotting", "Quit"), 
     title = "Plot(s) requested will likely take a while to plot.")


测试:
> menu(c("Continue with plotting", "Quit"), 
+      title = "Plot(s) requested will likely take a while to plot.")
Plot(s) requested will likely take a while to plot. 

1: Continue with plotting
2: Quit

Selection: 1
[1] 1




(7) 获取/设置图形参数 par()

# 前面设置参数
orig.par <- par()$mfrow
par(mfrow = c(nrow, ncol))


# 后面复原参数
par(mfrow = orig.par)




(8) 返回多个 ggplot2 对象的list
如果有多个图，可以在一个函数中画好，装到一个list中返回。
技巧就是，要新建list的list，否则一个普通的 ggplot2 对象本身就是一个list，会混淆分不清图数据之间的界限。

library(ggplot2)
library(patchwork)
draw2=function(dims=1:4, combine=F, ncol=2){
  plots <- vector(mode = 'list', length = length(x = dims)) #技巧的体现
  
  for(i in dims){
    df1=data.frame(
      x=iris$Sepal.Length,
      y=iris[,i],
      type=iris$Species
    )
    plots[[i]]=ggplot(df1, aes(x,y, color=type))+
      geom_point()+
      theme_classic()+
      ggtitle(colnames(iris)[i] )
  }

  # (A17) 如果要拼接，则拼接并返回
  if (combine) {
    plots <- wrap_plots(plots, ncol = ncol, guides = "collect")
  }
  return(plots)
}

# 返回ggplot2 对象list
rs1=draw2()
rs1[[2]] #单独画
wrap_plots(rs1, ncol=3) #画成3列

# 拼接成1个
rs2=draw2(combine = T)
rs2




(9) R原生画热图的函数 image()

par(mar = c(1, 1, 3, 3)) #c(bottom, left, top, right)

# 画热图
image( as.matrix(iris[,1:4]) )
image( as.matrix(iris[,1:4]), axes=F) #不要坐标轴


# 改变颜色
image( as.matrix(iris[,1:4]), axes=F,
       col=c("blue", "white", "red") ) #丑!只有三个颜色，没有梯度
# 使用渐变色
library(RColorBrewer)
myColors=c("blue", "white", "red")
image( as.matrix(iris[,1:4]), axes=F,
       col=colorRampPalette(colors = myColors, interpolate ="linear")( 100 ) )






(10) ggplot2 画热图的函数 geom_raster() and geom_tile()

源码:
raster=T; #默认参数
my_geom <- ifelse(test = raster, yes = geom_raster, no = geom_tile)

查文档，一共三个功能相同的函数:
geom_rect() and geom_tile() 功能相同，参数不同。
- geom_rect() 使用四个角作为参数
- geom_tile() 使用tile的中心和宽高。

当所有 tile 宽高一样的时候，geom_raster() 效率更高。

geom_rect() and geom_tile() do the same thing, but are parameterised differently: 
geom_rect() uses the locations of the four corners (xmin, xmax, ymin and ymax), 
while geom_tile() uses the center of the tile and its size (x, y, width, height). 

geom_raster() is a high performance special case for when all the tiles are the same size.



例子: 
# 依赖本文 3.11 的 Melt2()
df1=Melt2(iris[,1:4] )
head(df1)

limits=c(min(df1$vals), max(df1$vals))
library(RColorBrewer)
colors=colorRampPalette(colors = myColors, interpolate ="linear")( 100 )

library(ggplot2)
# fig1
ggplot(df1, aes(x=rows, y=cols, fill=vals))+
  geom_raster()+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())+ #去掉x轴文字、刻度
  scale_fill_gradientn(limits = limits, colors = colors, na.value = "white")+ #数值范围，渐变色
  labs(x = NULL, y = NULL, fill = 'Expression') #标签
# fig2
ggplot(df1, aes(x=rows, y=cols, fill=vals))+
  geom_tile()+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())+ #去掉x轴文字、刻度
  scale_fill_gradientn(limits = limits, colors = colors, na.value = "white")+ #数值范围，渐变色
  labs(x = NULL, y = NULL, fill = 'Expression') #标签
#
# 好像和 image() 的输出还是有点差异。




要想和 image() 的输出完全一样，还需要固定好行、列位置，就是转为因子。

df1=Melt2(iris[,1:4] )
head(df1)
# 增加这2行
df1$rows=factor(df1$rows, levels = rownames(iris[,1:4]))
df1$cols=factor(df1$cols, levels = colnames(iris[,1:4]))

limits=c(min(df1$vals), max(df1$vals))
library(RColorBrewer)
colors=colorRampPalette(colors = myColors, interpolate ="linear")( 100 )

library(ggplot2)
# fig1
ggplot(df1, aes(x=rows, y=cols, fill=vals))+
  geom_raster()+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())+ #去掉x轴文字、刻度
  scale_fill_gradientn(limits = limits, colors = colors, na.value = "white")+ #数值范围，渐变色
  labs(x = NULL, y = NULL, fill = 'Expression') #标签
# fig2
ggplot(df1, aes(x=rows, y=cols, fill=vals))+
  geom_tile()+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())+ #去掉x轴文字、刻度
  scale_fill_gradientn(limits = limits, colors = colors, na.value = "white")+ #数值范围，渐变色
  labs(x = NULL, y = NULL, fill = 'Expression') #标签
#










(11) 原生宽变长，unlist(df1) 把数据框按列展开

> df1=iris[1:2, 1:4]
> df1
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
> unlist(df1)
Sepal.Length1 Sepal.Length2  Sepal.Width1  Sepal.Width2 Petal.Length1 Petal.Length2 
          5.1           4.9           3.5           3.0           1.4           1.4 
 Petal.Width1  Petal.Width2 
          0.2           0.2 

我们观察发现，unlist()能把数据框按列展开，也就是数据框本质上还是 按列的list。
展开之后怎么把行名、列名信息保留呢？和数据同行，要新增2列。

行名，依次使用，用完了再循环一次：
> rep(rownames(df1), times=ncol(df1))
[1] "1" "2" "1" "2" "1" "2" "1" "2"

列名，一列是固定的，每个重复次数等于行数: 
> rep(colnames(df1), each=nrow(df1))
[1] "Sepal.Length" "Sepal.Length" "Sepal.Width"  "Sepal.Width"  "Petal.Length"
[6] "Petal.Length" "Petal.Width"  "Petal.Width"


写成函数，如下:
我修改了一行。
./seurat-4.1.0/R/utilities.R:2122:Melt <- function(x) {

# Melt a data frame
#
# @param x A data frame
#
# @return A molten data frame
#
Melt2 <- function(x) {
  # 融化数据，就是变长
  # 前置转为df
  if (!is.data.frame(x = x)) {
    x <- as.data.frame(x = x)
  }
  # 就是使用 unlist 解开df成 vals 列的
  # 然后添加2列：行名 列名
  return(data.frame(
    rows = rep.int(x = rownames(x = x), times = ncol(x = x)),
    # 作者貌似不知道 each 还有一个 each 参数
    cols = rep(colnames(x), each=nrow(x)),
    # cols = unlist(x = lapply(X = colnames(x = x), FUN = rep.int, times = nrow(x = x))),
    vals = unlist(x = x, use.names = FALSE)
  ))
}

# 测试 
> df1
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
> Seurat:::Melt(df1) #结果一样
> Melt2(df1)
  rows         cols vals
1    1 Sepal.Length  5.1
2    2 Sepal.Length  4.9
3    1  Sepal.Width  3.5
4    2  Sepal.Width  3.0
5    1 Petal.Length  1.4
6    2 Petal.Length  1.4
7    1  Petal.Width  0.2
8    2  Petal.Width  0.2








(12) 自定义 ggplot2 主题: 就是返回一个theme()函数。

./seurat-4.1.0/R/visualization.R:5292:WhiteBackground <- function(...) {
#

#' @importFrom ggplot2 theme element_rect
#' @export
#' @concept visualization
#'
#' @rdname SeuratTheme
#' @aliases WhiteBackground
#'
WhiteBackground <- function(...) {
  white.rect = element_rect(fill = 'white') #方框填充白色
  white.theme <- theme(
    # Make the plot, panel, and legend key backgrounds white
    plot.background = white.rect, #背景白色
    panel.background = white.rect, #每个面板
    legend.key = white.rect, #图例背景
    # Validate the theme
    validate = TRUE,
    ...
  )
  return(white.theme)
}

测试： 连坐标轴的线也没有了。
library(ggplot2)
ggplot(mtcars, aes(mpg, wt)) + geom_point()+
  WhiteBackground()





另一个主题 NoAxes()，也是返回一个theme() 函数，但是提供了更多选项。
./seurat-4.1.0/R/visualization.R:5118:NoAxes <- function(..., keep.text = FALSE, keep.ticks = FALSE) {

#' @param keep.text Keep axis text
#' @param keep.ticks Keep axis ticks
#'
#' @importFrom ggplot2 theme element_blank
#' @export
#' @concept visualization
#'
#' @rdname SeuratTheme
#' @aliases NoAxes
#'
#' @examples
#' # Generate a plot with no axes
#' library(ggplot2)
#' df <- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
#' p <- ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(mapping = aes(color = 'red'))
#' p + NoAxes()
#'
NoAxes <- function(..., keep.text = FALSE, keep.ticks = FALSE) {
  blank <- element_blank()
  
  # 没有坐标轴
  no.axes.theme <- theme(
    # Remove the axis elements
    axis.line.x = blank, #x轴线 不要
    axis.line.y = blank,
    # Validate the theme
    validate = TRUE, #//这个干什么的?
    ...
  )
  
  # 不要文字
  if (!keep.text) {
    no.axes.theme <- no.axes.theme + theme( #theme()函数可加
      axis.text.x = blank, #刻度文字
      axis.text.y = blank,
      axis.title.x = blank, #坐标轴标签
      axis.title.y = blank,
      validate = TRUE,
      ...
    )
  }
  
  # 不要刻度线
  if (!keep.ticks){
    no.axes.theme <- no.axes.theme + theme(
      axis.ticks.x = blank, #刻度线
      axis.ticks.y = blank,
      validate = TRUE,
      ...
    )
  }
  
  return(no.axes.theme)
}








(13) 画一层散点图，全透明，就是为了获得一个图例

SingleRasterMap() 源码片段:
if (!is.null(x = group.by)) {
  # 散点图，全透明，就是为了获得一个图例！? 骚操作
  plot2 <- plot + geom_point(
    mapping = aes_string(x = 'Cell', y = 'Feature', color = 'Identity'),
    alpha = 0.5
  ) +
    guides(color = guide_legend(override.aes = list(alpha = 1))) #一个 color的图例，代替fill的图例
}
plot2










###

() new(Class = 'JackStrawData')
jackstraw [ˈdʒækstrɔː] n. 稻草人；小木片（游戏用）
./seurat-object-4.0.4/R/jackstraw.R:24:JackStrawData <- setClass(
./seurat-object-4.0.4/R/jackstraw.R:25:  Class = "JackStrawData",












() 颜色，留给以后的专题
./seurat-4.1.0/R/visualization.R:4956:PurpleAndYellow <- function(k = 50) {









4. PR

(1) Top() 的去重有问题。

#
test2=function(n=5, top=3){
  message("0>>total gene:",n, ", selectTop:",top,"\n")
  data=data.frame(exp=1:n)
  rownames(data)=paste0("gene",1:nrow(data) )
  data
  num=top
  positive <- head(x = rownames(x = data), n = num);
  message("1>>positive:", paste0(positive,collapse = ",") )
  # 取后n个，并倒序
  negative <- rev(x = tail(x = rownames(x = data), n = num)); negative
  message("1>>negative:", paste0(negative,collapse = ","))
  # 去重复，值得怀疑 //todo
  # remove duplicates
  if (positive[num] == negative[num]) { #如果最后一个相等
    negative <- negative[-num] #则删掉 negative 的最后一个值
  }
  message("\n2>>negative:", paste0(negative,collapse = ","))
}
test2()
test2(4,3)
#不过好在这里99.99%的情况用不到，因为大家的基因数都至少上千，而要打印的不超过100
test2(1000,5)


> test2()
0>>total gene:5, selectTop:3

1>>positive:gene1,gene2,gene3
1>>negative:gene5,gene4,gene3

2>>negative:gene5,gene4


> test2(4,3)
0>>total gene:4, selectTop:3

1>>positive:gene1,gene2,gene3
1>>negative:gene4,gene3,gene2

2>>negative:gene4,gene3,gene2

> test2(1000,5)
0>>total gene:1000, selectTop:5

1>>positive:gene1,gene2,gene3,gene4,gene5
1>>negative:gene1000,gene999,gene998,gene997,gene996

2>>negative:gene1000,gene999,gene998,gene997,gene996








========================================
|-- Seurat 4 R包源码解析 20: step9 确定PC的维数-碎石图(选读:怎么求PC的p值?)
----------------------------------------
1. 调包侠
# step9 Determine the 'dimensionality' of the dataset

# 建议跳过这个，太慢!
# NOTE: This process can take a long time for big datasets, comment out for expediency. More
# approximate techniques such as those implemented in ElbowPlot() can be used to reduce
# computation time
pbmc <- JackStraw(pbmc, num.replicate = 100)
pbmc <- ScoreJackStraw(pbmc, dims = 1:20)
JackStrawPlot(pbmc, dims = 1:15)


# 推荐使用这个选择PC个数，速度很快!
ElbowPlot(pbmc) #取碎石图拐角处的PC个数





(1) [耗时!](可选步骤)为每个PC计算一个p值的步骤

# 第一个函数 JackStraw() 的影响范围
计算前
> pbmc@reductions$pca@jackstraw
A JackStrawData object simulated on 0 features for 0 dimensions.
 Scored for: 0 dimensions.

计算PC的p值
# rep=100时，根据我的测试，可能使用不带进度条的 apply 只需要不到1min。而这里需要7分钟。
# 选了 rep=325 这个不是很整的数，是为了验证几个猜测
> pbmc <- JackStraw(pbmc, num.replicate = 325)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=10m 14s
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  


计算后
> pbmc@reductions$pca@jackstraw
A JackStrawData object simulated on 2000 features for 20 dimensions.
 Scored for: 0 dimensions.

> slotNames(pbmc@reductions$pca@jackstraw)
[1] "empirical.p.values"      "fake.reduction.scores"   "empirical.p.values.full"
[4] "overall.p.values" 
每个PC的 p 值保存的位置 "overall.p.values" 



# 第二个函数 ScoreJackStraw() 影响范围:
> head(pbmc@reductions$pca@jackstraw@overall.p.values)
<0 x 0 matrix>
> pbmc <- ScoreJackStraw(pbmc, dims = 1:20) 
#计算后
> dim(pbmc@reductions$pca@jackstraw@overall.p.values)
[1] 20  2







(2) 算法(选读): 为每个PC计算一个p值的算法
求每个PC的p值的整个算法流程，分布在至少2个函数中(JackStraw, 与 ScoreJackStraw)。
结果保存在 内部对象 pbmc@reductions$pca@jackstraw 的 slot 中。


阅读R包文档:

JackStraw: Determine statistical significance of PCA scores.
Description:
Randomly permutes a subset of data, and calculates projected PCA scores for these 'random' genes. Then compares the PCA scores for the 'random' genes with the observed PCA scores to determine statistical signifance. End result is a p-value for each gene's association with each principal component.
文章: Inspired by Chung et al, Bioinformatics (2014)
这个文章谁找到了告诉我 //todo


ScoreJackStraw: Compute Jackstraw scores significance.
Description: 
Significant PCs should show a p-value distribution that is strongly skewed to the left compared to the null distribution. The p-value for each PC is based on a proportion test comparing the number of features with a p-value below a particular threshold (score.thresh), compared with the proportion of features expected under a uniform distribution of p-values.
作者 Author(s): Omri Wurtzel
这个作者在哪个文章/地方中贡献的这个函数? //todo



阅读源代码:

1) 按照数据处理步骤，求每个PC的p值的步骤如下:
- 1.抽样 HVG 的1%基因
- 2.对每一行洗牌，做PCA
- 3.记录各PC的loading matrix
	* 结果保存在 fake.reduction.scores，我感觉是不是应该有基因重复抽样?
- 4.重复以上1-3过程多次(几百上千次)
- 5.计数求经验p值: 
	* 对PC遍历，内层再对基因遍历: 某PC列中超过该基因原始loading(正规不打乱时的PCA)的个数 / 总观测数。
	* 结果保存在 empirical.p.values
- 6.对每列，求PC的打分: in ScoreJackStraw()
	* 经验p值 < 某个阈值的基因个数，与基于经验p值均匀分布时低于该阈值的基因个数(总个数*该阈值)，这两个数字的比例和1:1做卡方检验的p值，作为PC的总体p值。
	* 结果保存在 overall.p.values 中

> slotNames(pbmc@reductions$pca@jackstraw)
[1] "empirical.p.values"      "fake.reduction.scores"   "empirical.p.values.full"
[4] "overall.p.values" 

pbmc@reductions$pca@jackstraw 包含这几个 slot:
empirical.p.values  = jackStraw.empP, #比较PC列中，比每个基因的系数大的占总行数的比例，经验p值
fake.reduction.scores = fake.vals, #行乱序后的scaled.data做的PCA的loading矩阵，假得降维打分
empirical.p.values.full = matrix()



2) 再按照输出的数据，把以上求每个PC的p值的步骤再说一遍:

step1:对基因抽样，打乱同一个基因的细胞标签后做PCA，记录基因对每个PC的权重矩阵(loadings)。
> dim(pbmc@reductions$pca@jackstraw$fake.reduction.scores)
[1] 6500   20
> 2000*0.01*325 #HVG2000个，每次抽样1%，抽样次数325
[1] 6500
> pbmc@reductions$pca@jackstraw$fake.reduction.scores[1:2,1:3]
              [,1]          [,2]         [,3]
[1,] -0.0031335730 -0.0019125475 -0.004546701
[2,]  0.0001275733  0.0000134703  0.003276954


step2: 对于一个PC，对于每一个基因: 其权重的绝对值 大于该列绝对值的比例，作为经验p值
> dim(pbmc@reductions$pca@jackstraw$empirical.p.values)
[1] 2000   20 #注意这里，已经变成2000行了，和2层循环变量的个数一致。
> pbmc@reductions$pca@jackstraw$empirical.p.values[1:3,1:3]
               PC1         PC2          PC3
PPBP   0.000000000 0.010461538 0.0000000000
LYZ    0.000000000 0.001846154 0.0150769231
S100A9 0.000000000 0.000000000 0.0001538462


step3: 对 empirical.p.values 矩阵，取每列(某个PC): 小于某阈值的基因个数，基于经验p值均匀分布时的期望的基因个数(总基因个数*该阈值) 是否符合1:1做 prop.test()
新增一个slot: overall.p.values
> dim(pbmc@reductions$pca@jackstraw@overall.p.values)
[1] 20  2
> head(pbmc@reductions$pca@jackstraw@overall.p.values)
     PC         Score
[1,]  1 7.937110e-157
[2,]  2 6.165783e-105
[3,]  3  1.981211e-33


画图时，既看经验p值是否偏离对角线，向左偏的越远越好；
又看总体p值，越小越好。









2. 源码解析


## todo 

- LogSeuratCommand()
- CheckDots()
- IsSCT()
./seurat-4.1.0/R/utilities.R:1986:IsSCT <- function(assay) {
先跳过 sctransform()，后面有空再补上 //todo








3. R tips 

(1) 为 apply() 家族函数添加进度条。
建议不要加，太慢。

pbapply: Adding Progress Bar to '*apply' Functions
Adding progress bar to *apply functions, possibly leveraging parallel processing.
https://cran.r-project.org/web/packages/pbapply/index.html
https://peter.solymos.org/code/2016/09/16/how-to-add-pbapply-to-r-packages.html

在R包中使用: https://www.r-bloggers.com/2016/09/how-to-add-pbapply-to-r-packages-2/


测试了一下，确实可以添加进度条，缺点就是添加后太慢了！

# make data
set.seed(2021)
df1 <- matrix(runif(5e6), ncol = 5)

library(pbapply)
system.time({ #10.016s
  rs0=apply(df1, 1, sd)
})

system.time({ #111s 太慢了
  rs5=pbapply(df1, 1, sd)
})
# |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01m 51s

table(rs5 - rs0<1e-10) #all TRUE








(2) order(x1, x2)排序 的第二个参数

# order returns a permutation which rearranges its first argument into ascending or descending order, breaking ties by further arguments.
> a1=c(7,1,9);a1
[1] 7 1 9

# 一般给一个参数，返回该参数每个元素的下标位置编号
> a1.o=order(a1); a1.o #默认升序，第一个元素最小
[1] 2 1 3
> a1[a1.o] #根据下标位置，打印每个元素
[1] 1 7 9




# 还可以给出第二个参数，当第一个参数有相等元素的时候，按照第二个参数对应位置进行排序。
In the case of ties in the first vector, values in the second are used to break the ties. If the values are still tied, values in the later arguments are used to break the tie (see the first example). The sort used is stable (except for method = "quick"), so any unresolved ties will be left in their original ordering.

> a1=c(1,1,9);a1
[1] 1 1 9

> order(a1, c(2,1,0)) #前2个元素相等，则看第二个参数，第二个位置最小，则其下标为1；
[1] 2 1 3
> order(a1, c(2,1,10)) #第二个参数的 最后一个值不影响序号
[1] 2 1 3
> order(a1, c(2,10,10)) #如果第二个参数的前2个值顺序换了，第一个元素最小，则第一个元素的下标是1
[1] 1 2 3









(3) 对一个矩阵的每一行独立的随机洗牌: MatrixRowShuffle

主要思路: col()获取下标，然后 runif()打乱，最后order()排序

#1) col() Column Indexes
Description: Returns a matrix of integers indicating their column number in a matrix-like object, or a factor of column labels.
Usage: col(x, as.factor = FALSE)

> x=iris[1:3,1:4];x
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
3          4.7         3.2          1.3         0.2
> col(t(x))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3
[3,]    1    2    3
[4,]    1    2    3
> c(col(t(x)))
 [1] 1 1 1 1 2 2 2 2 3 3 3 3


#2) 随机数
> runif(n = length(x))
[1] 0.2922186 0.3220882 0.6291032 0.7704804

这个长度不够，df本质是成列的list，长度就是列数；而矩阵的length则是总的元素个数。
> class(x)
[1] "data.frame"
> x_=as.matrix(x)
> class(x_)
[1] "matrix" "array" 

> length(x)
[1] 4
> length(x_)
[1] 12

所以使用:
> runif(n = length( t(t(x)) ))
 [1] 0.03726171 0.69340549 0.14605814 0.24839075 0.26784137 0.58710378 0.27862248 0.24537888 0.82303043
[10] 0.75663306 0.47392544 0.13659220


#3) order() 排序，相等的元素之间，按照第二个元素排序。
ind=order(
  c(col(x = t(x))), 
  runif(n = length(x = t(x) ))
)
> ind
 [1]  1  4  2  3  7  8  5  6 12 11  9 10

#4) 然后恢复成矩阵形式
matrix(
  data=t(x)[ind],
  ncol=ncol(x),
  nrow=nrow(x),
  byrow=F
)
输出:
     [,1] [,2] [,3] [,4]
[1,]  5.1  1.4  4.9  1.3
[2,]  0.2  1.4  3.0  4.7
[3,]  3.5  0.2  0.2  3.2
> x #对比
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2
3          4.7         3.2          1.3         0.2




包装成函数 MatrixRowShuffle()
./seurat-4.1.0/R/utilities.R:2075:MatrixRowShuffle <- function(x) {

独立的把矩阵的每一行的元素打乱。
# Independently shuffle values within each row of a matrix
#
# Creates a matrix where correlation structure has been removed, but overall values are the same
#
# @param x Matrix to shuffle
#
# @return Returns a scrambled matrix, where each row is shuffled independently
#
#' @importFrom stats runif #使用 均匀分布函数
#
# @export
#
# @examples
# mat <- matrix(data = rbinom(n = 25, size = 20, prob = 0.2 ), nrow = 5)
# mat
# MatrixRowShuffle(x = mat)
#
MatrixRowShuffle <- function(x) {
  # x2 等于x
  x2 <- x #没啥用
  # x2又等于x的转置，那第一行可以删掉了。 //bug
  x2 <- t(x = x)

  # 获取每个元素的列编号，并在相等时按照第二个参数 对应位置排序
  ind <- order(c(col(x = x2)), runif(n = length(x = x2)))
  
  # 恢复矩阵形式
  x2 <- matrix(
    data = x2[ind],
    nrow = nrow(x = x),
    ncol = ncol(x = x),
    byrow = TRUE
  )
  return(x2)
}






(4) prop.test() 就是卡方检验？
prop.test( matrix(c(1,200,20,400), nrow=2) )
chisq.test( matrix(c(1,200,20,400), nrow=2) )

输出:
> prop.test( matrix(c(1,200,20,400), nrow=2) )

	2-sample test for equality of proportions with continuity correction

data:  matrix(c(1, 200, 20, 400), nrow = 2)
X-squared = 6.3174, df = 1, p-value = 0.01196
alternative hypothesis: two.sided
95 percent confidence interval:
 -0.4089409 -0.1624877
sample estimates:
    prop 1     prop 2 
0.04761905 0.33333333 

> chisq.test( matrix(c(1,200,20,400), nrow=2) )

	Pearson's Chi-squared test with Yates' continuity correction

data:  matrix(c(1, 200, 20, 400), nrow = 2)
X-squared = 6.3174, df = 1, p-value = 0.01196



文档给的例子
> prop.test(smokers, patients)

	4-sample test for equality of proportions without continuity correction

data:  smokers out of patients
X-squared = 12.6, df = 3, p-value = 0.005585
alternative hypothesis: two.sided
sample estimates:
   prop 1    prop 2    prop 3    prop 4 
0.9651163 0.9677419 0.9485294 0.8536585 






(5) 拼接、输出字符串: paste0(), sprintf()

源码:
data.plot$PC.Score <- rep(
	x = paste0("PC ", score.df[ ,"PC"], ": ", sprintf("%1.3g", score.df[ ,"Score"])),
	each = length(x = unique(x = data.plot$Contig))
)


测试:
# 1. sprintf() 类似C的打印功能，第一个是带替换字符的字符串，后面是按顺序的参数。
> sprintf("the height of this %s is %1.3g m", "dog", 0.805789 )
[1] "the height of this dog is 0.806 m"

# 2. paste0() 拼接字符串，支持输入向量
> paste0("metric of ", colnames(iris)[1:4])
[1] "metric of Sepal.Length" "metric of Sepal.Width"  "metric of Petal.Length" "metric of Petal.Width" 


# 3. 本文
> score.df=data.frame(
   PC=1:3,
   Score=c(0.1,0.22,0.333)
)
> score.df
  PC Score
1  1 0.100
2  2 0.220
3  3 0.333
> paste0("PC ", score.df[ ,"PC"], ": ", sprintf("%1.3g", score.df[ ,"Score"]))
[1] "PC 1: 0.1"   "PC 2: 0.22"  "PC 3: 0.333"









(6) 快速获取颜色列表: scales::hue_pal()(5)


测试:
> scales::hue_pal()(5)
[1] "#F8766D" "#A3A500" "#00BF7D" "#00B0F6" "#E76BF3"

> n=5; barplot(rep(1,n), col=scales::hue_pal()(n))




scales::hue_pal是一个返回函数的函数:

> scales::hue_pal
function (h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1) 
{
    stopifnot(length(h) == 2)
    stopifnot(length(c) == 1)
    stopifnot(length(l) == 1)
    force_all(h, c, l, h.start, direction)
	
	# 最后返回的是下面这个函数，但是可以用母函数的参数等变量: 
    function(n) {
        if (n == 0) {
            stop("Must request at least one colour from a hue palette.", 
                call. = FALSE)
        }
        if ((diff(h)%%360) < 1) {
            h[2] <- h[2] - 360/n
        }
        hues <- seq(h[1], h[2], length.out = n)
        hcl <- cbind(hues, c, l)
        pal <- farver::encode_colour(hcl, from = "hcl")
        if (direction == -1) {
            rev(pal)
        }
        else {
            pal
        }
    }
}
<bytecode: 0x55923a23b630>
<environment: namespace:scales>


这个就是返回的函数，只要一个传入参数了，但是可以使用母函数的参数，这就叫闭包(enclosure)。
# https://www.r-bloggers.com/2015/03/using-closures-as-objects-in-r/
> scales::hue_pal()
function (n) 
{
    if (n == 0) {
        stop("Must request at least one colour from a hue palette.", 
            call. = FALSE)
    }
    if ((diff(h)%%360) < 1) {
        h[2] <- h[2] - 360/n
    }
    hues <- seq(h[1], h[2], length.out = n)
    hcl <- cbind(hues, c, l)
    pal <- farver::encode_colour(hcl, from = "hcl")
    if (direction == -1) {
        rev(pal)
    }
    else {
        pal
    }
}
<bytecode: 0x55923a2420d0>
<environment: 0x5591d0bd0a50>








(7) 检验参数个数，不达标报错
源码:
stopifnot(length(h) == 2)


测试:
fn1=function(h=c(1,2)){
  stopifnot(length(h) == 2)
  return(h)
}
fn1()
fn1( c(1)) #报错
fn1( c(1,2,3)) #报错






(8) 使用 ggplot2 画QQ-plot

# 输入参数 sample 是一列经验p值，然后使用 stat_qq(distribution = qunif) 设置均匀分布。
gp <- ggplot(data = data.plot, mapping = aes_string(sample = 'Value', color = 'PC.Score')) +
	stat_qq(distribution = qunif) +

	# 其他绘图参数
	labs(x = "Theoretical [runif(1000)]", y = "Empirical") +
	scale_color_manual(values = cols) +
	xlim(0, ymax) +
	ylim(0, xmax) +
	coord_flip() + #交换x、y坐标及标签
	geom_abline(intercept = 0, slope = 1, linetype = "dashed", na.rm = TRUE) + #添加斜线，斜率1，过原点
	guides(color = guide_legend(title = "PC: p-value")) + #修改图例标题
	theme_cowplot() #设置主题
	#





========================================
|-- Seurat 4 R包源码解析 21: step10 细胞聚类 FindNeighbors()
----------------------------------------
1. 调包侠
# step10 Cluster the cells
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)

# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)

table(pbmc$seurat_clusters)



(1) FindNeighbors() 的影响范围 

pbmc <- FindNeighbors(pbmc, dims = 1:10) # 的影响范围是 pbmc@graphs

> names(pbmc@graphs)
 [1] "RNA_nn"  "RNA_snn"
> class(pbmc@graphs$RNA_nn)
[1] "Graph"


# nn是一个0-1矩阵，一行一个细胞，一行内规定 k 个最近邻的点为1，其他都是0.
# 该矩阵是通过 C++ 函数求出来的近似KNN算法，具体实现是 Annoy 。
> dim(pbmc@graphs$RNA_nn) 
[1] 2638 2638


# snn 是对 (nn矩阵) 计算得来的，记录着细胞间的 Jacard 相似度，交集/并集，不重叠为0，重叠为1。也就是值越大越相似。
# 低于 某个值(默认是1/15=0.06666667)的 统一设定为0.
> dim(pbmc@graphs$RNA_snn)
[1] 2638 2638


(2) KNN 算法
KNN就是最近邻算法，最朴素的暴力求距离法，对于高纬度数据速度太慢。有人基于二叉树提出了 KDTree, BallTree， Annoy等方法。Seurat4使用的是Annoy算法实现。


其中机器学习领域常用的距离度量方法，有欧式距离、余弦距离、曼哈顿距离、dot内积等
Seurat 4 中KNN算法中几种可选距离，euclidean(默认), cosine, manhattan, and hamming。

主流的近邻算法都支持上述不同的距离度量。其中n维特征空间的a、b向量的欧式距离: 差的平方和再开方，体现数值上的绝对差异；
而余弦距离基于余弦相似度（两个向量间夹角的余弦值），体现方向上的相对差异。
如果对向量做归一化处理，二者的结果基本是等价的。

具体实现步骤看本文 4-1。


(3) SNN 算法
Jacard 相似度: 交集大小/并集大小。没有交集时0，完全重合时1。

可以根据每个细胞的最近邻细胞的重合情况，计算细胞间两两的 Jarcard 相似度。

具体实现步骤看本文 4-2。







2. 源码解析 

直接使用的函数:
- FindNeighbors 本文。
- FindClusters 下一篇再说。







3. R tips

(1) 函数参数列表中，可以直接引用其并列的参数，比如取反

fn1=function(a1=F, a2=!a1){
  print(a2)
}
fn1(T) #F
fn1(F) #T


fn2=function(a2=!a1, a1=F){
  print(a2)
}
fn2(a1=T) #F
fn2(a1=F) #T


fn3=function(x, y=x+10){
  print(y)
}
fn3(5) #15




(2) 画细胞的 snn 图: igraph 包擅长画各种网络图
# 源码见: FindNeighbors.Seurat 的 A7 部分。下文是可以运行的代码

https://igraph.org/
igraph is a collection of network analysis tools with the emphasis on efficiency, portability and ease of use. 
igraph is open source and free. 
igraph can be programmed in R, Python, Mathematica and C/C++.
R 版本文档: https://igraph.org/r/html/latest/



# 导入 pbmc 3k 分类好的数据，要带 tSNE坐标，过程略。

library(igraph)
#graph.adjacency: Create graphs from adjacency matrices
net <- graph.adjacency( 
  adjmatrix = as.matrix(x = pbmc@graphs$RNA_snn),
  mode = "undirected",
  weighted = TRUE,
  diag = FALSE
)

# plot.igraph(): Plotting of graphs
plot.igraph(
  x = net,
  layout = as.matrix(x = Embeddings(object = pbmc[["tsne"]])),
  edge.width = E(graph = net)$weight,
  vertex.label = NA,
  vertex.size = 0
)


# 再画一个 UMAP 的版本
plot.igraph(
  x = net,
  layout = as.matrix(x = Embeddings(object = pbmc[["umap"]])),
  edge.width = E(graph = net)$weight,
  vertex.label = NA,
  vertex.size = 0
)



(3) 最近邻算法的种类，可选: rann, annoy //todo 
源码: FindNeighbors.default()




(4) 几种距离的计算，可选: euclidean, cosine, manhattan, and hamming //todo





(5) 什么是 L2 标准化?
https://blog.csdn.net/ningyanggege/article/details/82840233

# 源码 object <- L2Norm(mat = object)
# 定义: ./seurat-4.1.0/R/utilities.R:1692:L2Norm <- function(mat, MARGIN = 1){

# L2 normalize the columns (or rows) of a given matrix # L2标准化一个矩阵，按行或按列
# @param mat Matrix to cosine normalize #要进行 cosine 标准化的矩阵
# @param MARGIN Perform normalization over rows (1) or columns (2) #对行1、列2 进行标准化
#
# @return returns l2-normalized matrix
#
L2Norm <- function(mat, MARGIN = 1){
  normalized <- Sweep(
    x = mat,
    MARGIN = MARGIN, #默认是1，按行除以
    STATS = apply( #被除数: 默认是1，每行的 方差和开根号
      X = mat,
      MARGIN = MARGIN,
      FUN = function(x){
        sqrt(x = sum(x ^ 2))
      }
    ),
    FUN = "/"
  )
  # 如果出现 无穷大，则设置为0
  # 什么时候出现无穷大呢？ 被除数为0，也就是一行全为0的时候
  normalized[!is.finite(x = normalized)] <- 0
  return(normalized)
}



(6) `%iff%` 函数：如果x非空，则返回y

> `%iff%`
function (x, y) 
{
    if (!is_null(x = x)) { #如果x非空，则返回y
        return(y)
    }
    return(x)
}

源码: query <- query %iff% L2Norm(mat = query)
如果 query 有值，则进行 L2 标准化。





(7) sys.frame() 与 sys.nframe() 获取当前函数的参数列表，并解析出 ... 参数
源码 NNHelper(): args <- as.list(x = sys.frame(which = sys.nframe()))

fn1=function(x, ...){
  message(">>fn1:", x, "\t", sys.nframe())
  args <- as.list(x = sys.frame(which = sys.nframe()-1)) #穿透到上一层环境(上一个是函数内环境)
  print(args)
}

fn2=function(y){
  message(">>fn2:", y, "\t", sys.nframe())
  x=y+100
  fn1(x)
}

fn3=function(z){
  message(">>fn3:", z, "\t", sys.nframe())
  fn2(z+1)
}
fn3(5)

输出:
>>fn3:5	1
>>fn2:6	2
>>fn1:106	3
$x
[1] 106

$y
[1] 6



如果有 ... 参数，则还需要额外步骤来主动获取：
fn0=function(x, ...){
  message(">>fn0:", x, "\t", sys.nframe())
  args <- as.list(x = sys.frame(which = sys.nframe()))
  args2=c(args, ...)
  print(args)
  message("===")
  print(args2)
}
fn0(20, n=3)

输出: 
>>fn0:20	1
$x
[1] 20

===
$x
[1] 20

$n
[1] 3






(8) 获取任意函数的参数列表，不解析 ... 参数 

接上例: 

> formals(fn0)
$x
$...




(9) 获取2个函数的参数的交集：在一个函数内，获取其输入参数和另一个函数的参数的交集

AnnoyNN_my=function(arr=c(), x=1, n=5){}
fn1=function(arr=c(1,3,5), ...){
  # 当前函数的参数
  args <- as.list(x = sys.frame(which = sys.nframe()))
  args=c(args, ...)
  # 获取本函数的参数，和AnnoyNN_my()的参数的交集，及其值
  args <- args[intersect(x = names(x = args), y = names(x = formals(fun = AnnoyNN_my)))]
  print(args)
}
fn1(arr=1:5, x=3)

输出:
$arr
[1] 1 2 3 4 5

$x
[1] 3




(10) on.exit() 退出时执行，有利于重置绘图参数或者进行其他清理工作。
This is useful for resetting graphical parameters or performing other cleanup actions.


library(future)
fn1=function(x){
  if (!inherits(x = plan(), what = "multicore")) {
    # 则记录现在是单核，退出时恢复这个单核状态。
    oplan <- plan(strategy = "sequential")
    on.exit(plan(oplan), add = TRUE) #退出函数时执行这个设置
  }
  plan(strategy = "multicore", workers=5)
  message("fn1>>how many cores can use now: ", nbrOfWorkers())

  return(x)
}
#
plan(strategy = "sequential")
message("outside>>how many cores can use now: ", nbrOfWorkers()) #1
fn1(150) #5 仅再函数内为多核状态，函数前后都是单核
message("outside>>how many cores can use now: ", nbrOfWorkers()) #1
#
plan(strategy = "multicore", workers=2)
message("outside>>how many cores can use now: ", nbrOfWorkers()) #2



(11) 把数据框按行展开成数组 as.numeric(t(x))
as.numeric(x) 能把x按列展开成数组。
所以把x先转置，再按列展开，就相当于把原始df按行展开。


> iris[1:2,1:4]
  Sepal.Length Sepal.Width Petal.Length Petal.Width
1          5.1         3.5          1.4         0.2
2          4.9         3.0          1.4         0.2

> t(iris[1:2,1:4])
               1   2
Sepal.Length 5.1 4.9
Sepal.Width  3.5 3.0
Petal.Length 1.4 1.4
Petal.Width  0.2 0.2

> as.numeric(x=t(iris[1:2,1:4]))
[1] 5.1 3.5 1.4 0.2 4.9 3.0 1.4 0.2






(12) 矩阵C++库: Eigen //todo
Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
https://eigen.tuxfamily.org/index.php?title=Main_Page
稀疏矩阵: https://eigen.tuxfamily.org/dox/group__TutorialSparse.html

大型矩阵只能使用C++库计算，否则R本身太慢。









######################################
######################################
# 牵涉到的函数
FindNeighbors.Seurat
	* CheckDots()
	* FindNeighbors.Assay()
	* LogSeuratCommand

FindNeighbors.default
	* L2Norm()
	* NNHelper()
		* nn2()
		* AnnoyNN() 默认
			* AnnoyBuildIndex()
				* RcppAnnoy::AnnoyEuclidean()
				* RcppAnnoy::AnnoyAngular()
				* RcppAnnoy::AnnoyManhattan()
				* RcppAnnoy::AnnoyHamming()
			* AnnoySearch()
		* RcppAnnoy 包。KNN的 Annoy 核心包
	* Indices()
	* ComputeSNN()



4. 算法 

(1) 求最近邻的k个细胞的方法: KNN 的 annoy 实现 

#1 使用10个PC
a=new(Class = RcppAnnoy::AnnoyEuclidean, f=10)
#class(a)
#str(a)

#2 求距离的输入数据为每个细胞的RNA表达量的前10个PC
data=pbmc@reductions$pca@cell.embeddings[,1:10]
for(ii in seq(nrow(data)) ){
  a$addItem(ii-1, data[ii,])
}

#3 建立树的索引，默认建立50棵树
a$build(50) 

# check
#class(a)
#a
#str(a)
#

#4 对于每个细胞，求其前k个最近邻细胞
index=a #第3中建立的索引
query=data #要搜索的数据，就是每个细胞的PC矩阵
k=20 #最近邻的几个点？

#5 例子: 第一行，也就是求这个细胞的前k个最近邻点
x=1
search.k=-1 #不限制搜索次数
include.distance=T #是否返回距离

res <- index$getNNsByVectorList(query[x, ], k, search.k, include.distance) //todo 这个函数怎么定义的？怎么实现的？
res
res2=list(res$item + 1, res$distance) #C++下标是0-based，变为R的1-based
sort(res2[[1]])
# [1]    1  293  422  512  619  964 1149 1265 1332 1339 1386 1505 1574 1992 2015 2080 2297 2318 2548 2602

# 测试 pbmc 数据的第一行中1的下标都是多少？
grep(1, pbmc@graphs$RNA_nn[1,])
# [1]    1  293  422  512  619  964 1149 1265 1332 1339 1386 1505 1574 1992 2015 2080 2297 2318 2548 2602


写成循环，就可以计算每个细胞的k个最近邻细胞的下标了。
完成功能后，还可以尝试使用多线程加速。








==> 如何求出和原文一致的 NN 矩阵?

search.k=-1 #不限制搜索次数
include.distance=T #是否返回距离

nn = matrix(data=rep(0, nrow(data)**2), nrow=nrow(data), ncol=nrow(data))
dim(nn) #[1] 2638 2638

for(x in 1:nrow(data)){
  res <- index$getNNsByVectorList(query[x, ], k, search.k, include.distance)
  res2=list(res$item + 1, res$distance) #C++下标是0-based，变为R的1-based
  nn[x, res2[[1]]] = 1
}

rownames(nn)=rownames(data)
colnames(nn)=rownames(data)

table(nn[1,] - pbmc@graphs$RNA_nn[1,] ==0) #All T
table(nn - as.matrix(pbmc@graphs$RNA_nn)==0) #All T



> dim(nn)
[1] 2638 2638

> dim(pbmc@graphs$RNA_nn)
[1] 2638 2638










(2) SNN 算法
https://www.jianshu.com/p/72313d70d9ab
想一个简单情况，每行一个细胞，每行找2个最近邻的细胞，其下标位置为1，其他点则为0。

按照 Jaccard 相似度的定义 交集大小 / 并集大小。
#   1.该0-1矩阵乘以自己的转置
#   2.交集就是的每个位置的value，
#   3.并集就是 2*k-value
# 极端情况1: 没有交集，则 0/(2k-0)=0; 相似度位0
# 极端情况2: 完全重合, 则 2/(2k-2)=2/2=1; 相似度最高是1
# 中间状态: 重合一个元素, 则 1/(2k-1)=1/3;



SNN1=matrix(c(1,0,0,1,
              0,1,1,0,
              1,0,1,0,
              0,0,1,1), nrow=4, byrow = T)
SNN1

SNN2=SNN1 %*% t(SNN1)
SNN2

输出:
> SNN1
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    1
[2,]    0    1    1    0
[3,]    1    0    1    0
[4,]    0    0    1    1
> SNN2
     [,1] [,2] [,3] [,4]
[1,]    2    0    1    1
[2,]    0    2    1    1
[3,]    1    1    2    1
[4,]    1    1    1    2



# 计算点与点之间的 Jacard 相似度:
k=2 #每个细胞取2个最近邻细胞
SNN3=matrix(rep(0,16), nrow = 4, ncol = 4); SNN3
for(i in 1:nrow(SNN)){
  for(j in 1:ncol(SNN3)){
    val=SNN2[i,j]
    SNN3[i,j]=val/(2*k - val)
  }
}


> SNN3
          [,1]      [,2]      [,3]      [,4]
[1,] 1.0000000 0.0000000 0.3333333 0.3333333
[2,] 0.0000000 1.0000000 0.3333333 0.3333333
[3,] 0.3333333 0.3333333 1.0000000 0.3333333
[4,] 0.3333333 0.3333333 0.3333333 1.0000000


这个例子太平均了，没有交集。






==> 如何使用 nn矩阵 算出 snn矩阵?

nn2=nn %*% t(nn)
nn2

# 计算点与点之间的 Jacard 相似度:
k=20 #每个细胞取20个最近邻细胞
snn = matrix(data=rep(0, nrow(data)**2), nrow=nrow(data), ncol=nrow(data)); 

for(i in 1:nrow(snn)){
  for(j in 1:ncol(snn)){
    val=nn2[i,j]
    snn[i,j]=val/(2*k - val)
  }
}
snn[snn<1/15]=0
table(snn[1,] - pbmc@graphs$RNA_snn[1,] ==0) #All T
table(snn - as.matrix(pbmc@graphs$RNA_snn)==0) #All T


> dim(snn)
[1] 2638 2638

> dim(pbmc@graphs$RNA_snn)
[1] 2638 2638








ref:
https://www.jianshu.com/p/72313d70d9ab








========================================
|-- Seurat 4 R包源码解析 22: step10 细胞聚类 FindClusters()
----------------------------------------

1. 调包侠
# step10 Cluster the cells
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)

# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)

table(pbmc$seurat_clusters)


(1) 有4种算法 algorithm= 参数，默认是1

#' @param algorithm Algorithm for modularity optimization (
# 1 = original Louvain algorithm;  #原始鲁汶算法
# 2 = Louvain algorithm with multilevel refinement;  #多级细化的Louvain算法;
# 3 = SLM algorithm; 
# 4 = Leiden algorithm). Leiden requires the leidenalg python.

其中，smart local moving (SLM) algorithm[算法3] 是 2015 年提出的，原文用 java 写的。
该软件包还提供了 
* [算法1]the well-known Louvain algorithm for large-scale community detection developed by Blondel, Guillaume, Lambiotte, and Lefebvre (2008). 
* [算法2]An extension of the Louvain algorithm with a multilevel refinement procedure, as proposed by Rotta and Noack (2011)。


Louvain 算法的作者，推荐使用 Leiden algorithm[算法4]，说后者提供了多种改进。
Instead of the smart local moving algorithm, we recommend to use the Leiden algorithm. The Leiden algorithm offers various improvements to the smart local moving algorithm. 



==> 基于模块的大规模社群检测，也是一个重要的研究方向。//todo



参考：
* A smart local moving algorithm for large-scale modularity-based community detection http://www.ludowaltman.nl/slm/
* (作者答疑) Using the Leiden algorithm to find well-connected clusters in networks https://www.cwts.nl/blog?article=n-r2u2a4
* (论文)From Louvain to Leiden: guaranteeing well-connected communities https://www.nature.com/articles/s41598-019-41695-z




VOS Clustering 相关资料: 
Comparing Louvain method and VOS Clustering http://mrvar.fdv.uni-lj.si/pajek/community/LouvainVOS.htm 
Detecting Communities with Louvain Method and VOS Clustering http://mrvar.fdv.uni-lj.si/pajek/community/CommunityDrawExample.htm
java: https://github.com/dwslab/melt/blob/melt-3.2/matching-jena-matchers/src/main/java/de/uni_mannheim/informatik/dws/melt/matching_jena_matchers/multisource/clustering/ComputeErrDegree.java
https://dwslab.github.io/melt/javadoc_latest/de/uni_mannheim/informatik/dws/melt/matching_jena_matchers/multisource/clustering/VOSClusteringTechnique.html







(2) 输出
> pbmc <- FindClusters(pbmc, resolution = 0.5)
Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #C++代码的输出

Number of nodes: 2638
Number of edges: 95965

Running Louvain algorithm...
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
Maximum modularity in 10 random starts: 0.8723
Number of communities: 9
Elapsed time: 0 seconds








(3) 分辨率参数支持数组
#对象中使用最后一个参数的分组方式
pbmc=FindClusters(pbmc, resolution = c(0.2,0.8))
#查看 
head(pbmc@meta.data)

#修改分组方式:
Idents(pbmc)="RNA_snn_res.0.2"
#检查
DimPlot(tmp, label=T)






(4) 尝试用 Leiden 算法对细胞分群

Leiden 发文章时提供的是 Java 版本的实现: https://github.com/CWTSLeiden/networkanalysis
搞不定 Java 的编译，先跳过吧。

Seurat 4 中的 Leiden 是调用 python 包实现的。
不确定是不是这个(c++/py)，虽然名字一致: https://github.com/vtraag/leidenalg
这个repo和上文 Java 实现有一个共同的作者:Vincent Traag。

我推测下一个版本中，Seurat 会把 Leiden 的 Python 实现替换为 C++ 的实现。


> pbmc2=FindClusters(pbmc, algorithm = 4)
Error: Cannot find Leiden algorithm, please install through pip (e.g. pip install leidenalg).

$ pip3 install leidenalg
Successfully installed igraph-0.9.11 leidenalg-0.8.10 texttable-1.6.4

再次调用R函数还是报同样的错，可能是R使用的py路径不对。
按下面走应该就可以了。


1) 先安装2个python依赖包:
$ which python3
/home/wangjl/anaconda3/bin/python3
$ which python
/home/wangjl/anaconda3/bin/python

$ pip3 -V
pip 20.3.3 from /home/wangjl/anaconda3/lib/python3.7/site-packages/pip (python 3.7)
$ pip3 install leidenalg
$ pip3 install igraph

检查版本号
$ pip list | grep leidenalg
leidenalg                         0.8.10
$ pip list | grep igraph
igraph                            0.9.11




2) 在R中设置py环境: 
https://blog.csdn.net/weixin_30642029/article/details/95210474
https://blog.csdn.net/tandelin/article/details/88031770

# 先启动一个 R session
# 指定R上使用的python的环境 (有可能要求重启R 进程)
# reticulate::use_virtualenv("/home/wangjl/anaconda3/lib/python3.7/") #不行
library("reticulate")
use_python("/home/wangjl/anaconda3/bin/python", required = T) #设置要使用的 python
py_config()

# 检查py环境
py_discover_config(required_module = NULL, use_environment = NULL)

# 检查是否有这个包
py_module_available("igraph") #T
py_module_available("leidenalg") #T
#

注意
i) 每开启一个session，第一次设置生效，之后再使用这个命令不生效，需要重启session
ii) py_config()命令要放在最后，使设置生效



3) 开始调用 Leiden 算法对细胞分群[算法4]

library(Seurat)
library(dplyr)
library(ggplot2)

# 载入 Seurat 4 分析过的 pbmc 3k 数据集
pbmc=readRDS("/data/wangjl/r-pkg/data/pbmc3k_tutorial.rds")

# 分群和可视化
pbmc2=FindClusters(pbmc, algorithm = 4, resolution = 0.6) #使用算法4分群
table(pbmc2$seurat_clusters)
p1=DimPlot(pbmc2, label = T)+ggtitle("Leiden[4]")
#
p2=DimPlot(pbmc, label = T)+ggtitle("Louvain[1]")
pbmc_=pbmc
Idents(pbmc_)=pbmc_$seurat_clusters
p2_=DimPlot(pbmc_, label = T)+ggtitle("Louvain[1]")

p1+p2_+p2 #图形的比较


# 比较一下各个类的细微差别
> table(pbmc$seurat_clusters, pbmc2$seurat_clusters)
    1   2   3   4   5   6   7   8   9
  0 643  18   0   0  23   0   0   0   0
  1   0   0 480   0   0   1   0   0   0
  2   0 476   0   0   0   0   0   0   0
  3   0   0   0 344   0   0   0   0   0
  4   0   0   0   0 290   0   1   0   0
  5   0   0   0   0   0 162   0   0   0
  6   0   0   0   0   0   0 155   0   0
  7   0   0   0   0   0   0   0  32   0
  8   0   0   0   0   0   0   0   0  13


Leiden 和 Louvain 结果只有细微的差异，可能是因为顶点(3k)还是太少，如果细胞数达到20k-30k差异就明显了: 有些在UMAP上撕裂开的 cluster在Leiden下就真的分成2个 cluster了。
- Leiden 的分类是1-based。
- 和Louvain主体都在对角线上，只有在大团的交界处有一些不一致。














2. 源码解析 

* FindClusters.Seurat()
	* CheckDots() //todo 
	* names()
	* AddMetaData() //todo
	* levels()
	* LogSeuratCommand() //todo

* FindClusters.default()
	* RunModularityClustering() //todo  #R代码的尽头通常是C++，这里又出来了 java。
		* RunModularityClusteringCpp() #下一节看看 Rcpp 包怎么写。又不然被迫中断好几次了。
		* #include "ModularityOptimizer.h"
		* ModularityOptimizer.cpp 这个文件。 //todo
	* GroupSingletons()




intermediate [ˌɪntəˈmiːdiət] adj. 居中的，中间的；中等程度的，中级的
modularity [ˌmɒdjʊˈlærɪtɪ] n. [计] 模块性

()
./seurat-object-4.0.4/R/seurat.R:2466:names.Seurat <- function(x) {

()
./seurat-object-4.0.4/R/seurat.R:2240:levels.Seurat <- function(x) {







3. R tips 

(1) 创建空数据框，并添加每列(数据框的一列数据类型要一致)
gene=paste0("gene", 1:5)
df1=data.frame(row.names=gene) #创建空数据框，只有行名
df1 
# data frame with 0 columns and 5 rows

for(i in 1:3){
  df1[, paste0("cell", i)]=rep(i, 5)
}
df1
# 输出 
      cell1 cell2 cell3
gene1     1     2     3
gene2     1     2     3
gene3     1     2     3
gene4     1     2     3
gene5     1     2     3



(2) 找向量中只出现一次的元素

源码: singletons <- names(x = which(x = table(ids) == 1))


> arr1=c(1,2,2,3,3,3,4,5,5)
> table(arr1)
arr1
1 2 3 4 5 
1 2 3 1 2 
> which( table(arr1)==1 )
1 4 
1 4 
> names(which( table(arr1)==1 ))
[1] "1" "4"







ref:
https://www.jianshu.com/p/5b03302f5367





========================================
|-- 社区发现，模块度(modularity) 与 Louvain 算法
----------------------------------------

1. 社区发现 
https://blog.csdn.net/itplus/article/details/41348651

那些内部连接比较紧密的节点子集合对应的子图叫做社区（community）。
* 各社区节点集合彼此没有交集的称为非重叠型（disjoint）社区，
* 有交集的称为重叠型（overlapping）社区。

网络图中包含一个个社区的现象称为社区结构，社区结构是网络中的一个普遍特征。
给定一个网络图，找出其社区结构的过程叫做社区发现（community detection）。







2. modularity 的定义 

(1) 论文
paper: [Finding community structure in very large networks](http://ece-research.unm.edu/ifis/papers/community-moore.pdf)

模块度（Modularity）用来衡量一个社区的划分是不是相对比较好的结果。一个相对好的结果在社区内部的节点相似度较高，而在社区外部节点的相似度较低。

在进行每次划分的时候计算Q值，Q取值最大的时候则是此网路较理想的划分。Q值的范围在0-1之间，Q值越大说明网络划分的社区结构准确度越高，在实际的网络分析中，Q值的最高点一般出现在0.3-0.7之间。





3. 算法实现
(1) 论文
paper: [Fast unfolding of communities in large networks](http://antipaedo.lip6.fr/T12/communities.pdf) 这个公式多了一个2，可能不对。
	v2: https://arxiv.org/pdf/0803.0476v2.pdf #这个公式正确。

Louvain算法来自于Vincent等人发表的文章《Fast unfolding of communities in large networks》，是基于模块度（modularity）进行社区发现，该算法的优点在于速度快，可以在较短时间内实现大规模网络以不同粒度的社区划分。

基于R的图挖掘库igraph: https://cran.r-project.org/web/packages/igraph/igraph.pdf


(2)
算法解释: https://www.jianshu.com/p/3518fb2f7fd2
	https://wenku.baidu.com/view/248b721a5427a5e9856a561252d380eb629423bd.html
	算法图示: https://zhuanlan.zhihu.com/p/178790546
	https://www.jianshu.com/p/4ebe42dfa8ec
	Louvain 算法原理 及设计实现 https://blog.csdn.net/xsqlx/article/details/79078867
	https://mp.weixin.qq.com/s?__biz=MzAwMjI2MTQyNQ%3D%3D&idx=1&mid=2247483692&scene=21&sn=33973cada0f86460ee2cd2a5e606c288
单细胞中的使用: https://blog.csdn.net/AstreChen/article/details/105421544


参考实现1: https://github.com/xmweijh/CommunityDetection (.py 已经可以运行)
参考实现2: https://zenodo.org/record/35117#.YpN7L6hByUl (.h, .py,)
参考实现3: https://github.com/zzz24512653/CommunityDetection/blob/master/algorithm/graphx/Louvain/src/main/scala/Louvain.scala (Java 版)
参考实现4: https://github.com/liuzhiqiangruc/dml/blob/master/cls/louvain.c (C/C++ 版)

spark 版: https://github.com/Sotera/spark-distributed-louvain-modularity





(3) 主要读那2篇论文




最新进展见:
==> 知乎文章: https://zhuanlan.zhihu.com/p/522751212
==> github 尝试: https://github.com/DawnEve/bioToolKit/tree/master/Python/Louvain

==> 带分辨率参数的 Louvain 算法实现 C++版: https://github.com/satijalab/seurat/blob/master/src/ModularityOptimizer.cpp









==> 图神经网络 GNN
通俗版: https://baijiahao.baidu.com/s?id=1675371629861051208&wfr=spider&for=pc
图神经网络(GNN)的简介 https://baijiahao.baidu.com/s?id=1628693684916891399&wfr=spider&for=pc
图神经网络从入门到入门 https://zhuanlan.zhihu.com/p/136521625



==> Louvain vs Leiden:
描述 https://blog.csdn.net/weixin_39609500/article/details/111268529






========================================
|-- 如何写R包 1: 最简流程
----------------------------------------
https://zhuanlan.zhihu.com/p/524041227

当你需要 source() 的函数越来越多时，Rstudio 右上角进度条越来越细时，你想过怎么改善一下体验吗？写个R包吧，把这些函数丢进去即可。



本文主题: 怎么创建一个R包?
- 操作原则: 依赖 Rstudio，及尽可能少的R包，主要用命令。
- 本次测试的包都创建在目录 ~/data/r-pkg/ 下。
- 包的名字暂时叫 pkgS 后加上数字。


1. 新建工程
菜单 File - new project，点击 New Directory - R Package,
填写 包名 pkgS1
选择路径 ~/data/r-pkg
点击右下角 Create project

然后刷新后，就位于该 project 下了。
> getwd()
[1] "/data/wangjl/r-pkg/pkgS1"


目录结构如下
$ pwd
/data/wangjl/r-pkg/pkgS1

$ tree
.
├── DESCRIPTION #说明文档，主要修改该R包的信息，包括R包名title、版本号version、作者author等
├── man   #按F1时显示的帮助文档。手写太麻烦，现在一般自动生成该文件夹下的文档
│   └── hello.Rd
├── NAMESPACE  #命名空间，也基本依赖自动生成
├── pkgS1.Rproj #项目信息，一般不要修改
└── R #你的自定义函数，要严格按规定写注释，方便自动生成 man/ 下的帮助文档。
    └── hello.R

2 directories, 5 files



也可以使用纯脚本方式生成该R包目录结构
> library('devtools') # 开发 R 包黑魔法工具
> create('~/data/r_pkg/somePkg') # 建立 R 包的目录， somePkg 就是你想要的包的名称
> setwd('~/data/r_pkg/somePkg') # 把工作目录放到 R 包中的目录，开发 R 包过程中始终推荐这样做。
> dir() # 列出当前工作目录的文件和文件夹
# [1] "DESCRIPTION"   "NAMESPACE"     "R"             "somePkg.Rproj"




2. 写函数和注释
以上是自动生成的脚手架，接下来要自定义R包的代码和注释了。

最简单的R包，只需要 R/文件夹和 DESCRIPTION 即可。
但是没有注释的大函数确实没法用~~有位名人说过“代码不写注释是万恶之源”。

所以，我们主要精力都花在 R/ 目录下，努力写函数及其注释。
我们新建R包时，系统默认帮我们新建了一个模板示例文件 R/hello.R，可以忽略或删除或改写。
内容如下:
# Hello, world!
#
# This is an example function named 'hello' 
# which prints 'Hello, world!'.
#
# You can learn more about package authoring with RStudio at:
#
#   http://r-pkgs.had.co.nz/
#
# Some useful keyboard shortcuts for package authoring:
#
#   Install Package:           'Ctrl + Shift + B'
#   Check Package:             'Ctrl + Shift + E'
#   Test Package:              'Ctrl + Shift + T'

hello <- function() {
  print("Hello, world!")
}

这里给出了大神的 如何写R包的书，电子版全文免费阅读：http://r-pkgs.had.co.nz/



我们新建一个文件 比如 R/calc.R，里面可以包含很多函数。
比如对数字加100的函数
add100=function(x){
	x+100
}


tips: 光标放在函数名上，使用 Ctrl+Shift+Alt+R 快捷键即可生成一个基本模板，我们根据需要进行相应修改即可。

#' Title
#'
#' @param x 
#'
#' @return
#' @export
#'
#' @examples
add100=function(x){
  x+100
}

注意，这些注释都是有格式化要求的，开头三个字符是固定的 "#' "。
第一行Title 换成函数的一句话说明，更详细的说明可以空一行 "#' " 后接着写更多说明。
@param x 必须在后面写该输入参数的说明
@return 必须在后面写返回值类型说明
@export 这一行表明该函数是暴露出去的，用户library()该包后直接使用该函数。
	如果没有这一行，用户 使用 包名::函数名() 找不到该函数，必须使用 包名:::函数名() 才能找到。
@examples 的下一行要至少给出一个可执行的例子，或者把这一行去掉。

比如，我们的函数添加注释后是

#' Add 100 to the given number
#'
#' @param x a number, float or int
#'
#' @return a number
#' @export
#'
#' @examples
#' add100(5)
#' add100(-90)
add100=function(x){
  x+100
}





3. 继续写函数和注释
我们按照这个方式，继续在 R/ 下添加文件，在文件中添加函数及注释。

我们不新建文件了，直接在 R/calc.R 中添加第二个函数，计算一列数字的百分比:

#' Get the proportion of each number in an array
#'
#' @param x an array of numbers
#'
#' @return an array of proportions
#' @export
#'
#' @examples
#' prop(c(1,2,3,4,5))
prop=function(x){
  return(x/sum(x))
}



4. 测试
其实我们要边写边测试，把错误消灭在萌芽状态。
load_all() 函数很神奇地把包骨架文件夹中的 R 文件夹中的所有 .R 文件读进来了；
每一次你改进你的 *.R 文件，只要运行一次 load_all() 就会把最新的自创函数们拉进来，在 R 环境中就可以测试最新的代码是否正常。

> library('devtools')
> load_all()
> add100(2)
[1] 102
> prop(c(1,2,3,4))
[1] 0.1 0.2 0.3 0.4



5. 生成文档

devtools::document() 会在 man/ 文件夹下生成该函数的Rd文件。

首次执行会提示我们 Warning: The existing 'NAMESPACE' file was not generated by roxygen2, and will not be overwritten.
看来要先删除 NAMESPACE 这个文件了。
打开看，里面只要一行 exportPattern("^[[:alpha:]]+")，那就删了吧。

> devtools::document()
i Updating pkgS1 documentation
i Loading pkgS1
Writing NAMESPACE
Writing NAMESPACE

这一次正常，没有红字。

检查目录结构，发现 man/ 下确实多了几个文件:
$ tree
.
├── DESCRIPTION
├── man
│   ├── add100.Rd
│   ├── hello.Rd
│   └── prop.Rd
├── NAMESPACE
├── pkgS1.Rproj
└── R
    ├── calc.R
    └── hello.R


6. 修改DESCRIPTION
点击 DESCRIPTION 对模块进行修改。
这是包的描述文件，根据情况修改即可。

我就修改了 Title，Version，Author，其他没动

Package: pkgS1
Type: Package
Title: A R pkg test S1
Version: 0.1.1
Author: BioMooc
Maintainer: The package maintainer <yourself@somewhere.net>
Description: More about what it does (maybe more than one line)
    Use four spaces when indenting paragraphs within the Description.
License: What license is it under?
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.1.2


教训: 后续如果有依赖，则 Depends中>=后面要有一个空格。


7. 构建包

就是生成 R包 安装文件。

使用菜单 Rstudio -> Build，可构建源码包或者二进制包。
	源码包："/data/wangjl/r-pkg/pkgS1_0.1.1.tar.gz"
	二进制包: "/data/wangjl/r-pkg/pkgS1_0.1.1_R_x86_64-pc-linux-gnu.tar.gz"

或者使用命令 
> devtools::build()
✓  checking for file ‘/data/wangjl/r-pkg/pkgS1/DESCRIPTION’ ...
─  preparing ‘pkgS1’:
✓  checking DESCRIPTION meta-information ...
─  checking for LF line-endings in source and make files and shell scripts
─  checking for empty or unneeded directories
   Omitted ‘LazyData’ from DESCRIPTION
─  building ‘pkgS1_0.1.1.tar.gz’
   
[1] "/data/wangjl/r-pkg/pkgS1_0.1.1.tar.gz"

现在已经有R包文件了，可以发给被人使用了。


8. 安装R包，测试效果
收到该R包，然后安装该包，并测试。或在本机直接使用::测试函数。这里采用前者。
tips: 为了减少副作用，建议先重启R进程(菜单 Session - Restart R).

共三种安装方式:

1) Tool - Install pkgs, 选择 from: tar.gz, archive: 选择该包 pkgS1_0.1.0.tar.gz

2) 相当于语句
> install.packages("~/data/r-pkg/pkgS1_0.1.1.tar.gz", repos = NULL, type = "source")

3) 使用shell安装
$ cd ~/data/r_pkg/
$ R CMD INSTALL pkgS1_0.1.1.tar.gz


安装后就可以使用了：
> library(pkgS1)

> hello()
Error in hello() : could not find function "hello"
> pkgS1:::hello()
[1] "Hello, world!"

> add100(-80)
[1] 20

> ?prop
# 右侧显示了帮助文档。


9. 分享R包
可以把源文件上传到 github ，分享给大家了。



10. 进一步学习
- 如何依赖其他包?
- 如何使用 C/C++ 代码提速? 









附录: 如何上传到github
1. 准备文件
(1) 新建一个更合适的项目文件夹 (可选)
$ cd /home/wangjl/data/project/learn_R_pkg

把上一个R包源码移动到该新目录
$ mv  ~/data/r-pkg/pkgS1 .


(2) 设置忽略文件/文件夹 
这些中间文件/文件夹不会被git记录。
模仿 https://github.com/tidyverse/ggplot2

$ vim .gitignore
backup
dustbin
*.tar.gz

docs
.Rproj.user
.Rhistory
.RData
inst/doc
.httr-oauth
.*.Rnb.cached

man/.Rapp.history
.DS_Store
revdep/checks
revdep/library
revdep/checks.noindex
revdep/library.noindex
revdep/data.sqlite
revdep/cloud.noindex


(3) 添加许可证
比如我们可以选择 MIT 许可证，规定了如何授权给其他用户使用我们的代码。
$ vim LICENSE.md
MIT License
Copyright (c) 2020 learn_R_pkg authors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(4) 添加 ReadMe
项目的说明文档:
$ vim ReadMe.md 

# Learn how to build R packages

- https://r-pkgs.org/
- https://github.com/hadley/r-pkgs
- Local: Y station:/home/wangjl/data/project/learn_R_pkg
- github: https://github.com/BioMooc/learn_R_pkg


# Examples

- pkgS1 the basic R package build process



一般我喜欢再加一个变更记录文件:
$ cat changeLog.txt 
v0.0.1 pkgS1 the basic R package build process



2. 开始用git记录第一版，并提交github
(1) 创建提交点
$ git init

设置用户名和邮箱
$ git config --global user.name "jimmy"
$ git config user.email  "JimmyMall@live.com" # 不建议加--global 


$ git add .
$ git status # 查看记录的文件是否符合预期

创建提交点
$ git commit -m 'v0.0.1 pkgS1 the basic R package build process'




(3) 配置 github 地址
由于Y station 有多个 账号信息，每个分别有自己的URL缩写，所以和官方给的略有差异。
$ cat ~/.ssh/config

### git remote add origin git@github.com:BioMooc/learn_R_pkg.git
$ git remote add origin git@eve:BioMooc/learn_R_pkg.git

$ git push origin master


========================================
|-- 如何写R包 2: 如何引用其他R包的函数？
----------------------------------------
https://zhuanlan.zhihu.com/p/524315994

1. 新建R包 
$ pwd
/data/wangjl/project/learn_R_pkg/pkgS2




2. 添加函数和注释

$ vim R/visual.R
#' Using a specific column of a data frame to plot a pie plot
#'
#' @param data a dataframe or tibble
#' @param ncol specific column, factor
#'
#' @return a figure as ggplot2 object
#' @export
#'
#' @importFrom ggplot2 ggplot geom_col theme aes element_text element_blank labs position_stack
#' @importFrom ggrepel geom_text_repel
#' @importFrom dplyr `%>%`
#'
#' @examples
#' my_pie(mtcars,ncol=2)
#' my_pie(diamonds,ncol=3)
#' my_pie(diamonds,ncol=3)+guides(fill="none")
my_pie <- function(data, ncol, title=""){
  plotdat <- as.data.frame(table(data[,ncol])) %>% dplyr::arrange(-Freq)
  plotdat$Label <- paste(plotdat$Var1, paste0("(",round(((plotdat$Freq/sum(plotdat$Freq))*100),2),"%)"))

  p <- ggplot(plotdat, aes (x="", y = Freq, fill = factor(Var1))) +
    geom_col(position = 'stack', width = 1) +
    geom_text_repel(aes(label = Label, x = 1.3),size=5,
                    position = position_stack(vjust = 0.5)) +
    theme_classic() +
    theme(plot.title = element_text(hjust=0.5),
          axis.line = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    labs(fill = "Category",x = NULL,y = NULL) +
    coord_polar("y")+ggtitle(title)
  return(p)
}





3. 生成函数文档 和 NAMESPACE 文件
$ rm NAMESPACE

> devtools::document()
生成文档 man/ 和 /NAMESPACE 文件。

注意到 /NAMESPACE 文件中，除了要暴露的函数:
export(my_pie)

还有从其他包引入的函数列表:
importFrom(dplyr,`%>%`)
importFrom(ggplot2,theme)
importFrom(ggrepel,geom_text_repel)





4.测试 
> devtools::load_all()

如果在函数的注释中添加 @importFrom 语句，且执行过 devtools::document()，则可以跳过以上 library() 语句。
否则，还需要加载要用到的包：
library(dplyr)
library(ggplot2)
library(ggrepel)


画图:
> my_pie(mtcars,ncol=2)






5. 修改包说明 DESCRIPTION
修改标题
Title: Pie plot depend on ggplot2

末尾添加
Depends:
	R(>= 3.6.0)
Suggest:
	roxygen2
Imports:
	dplyr,
	ggplot2,
	ggrepel

教训: Depends中>=后面要有一个空格。



6. 构建 R 包 
> devtools::build()
## "/data/wangjl/project/learn_R_pkg/pkgS2_0.1.0.tar.gz"


7. 测试 

重启R session: 菜单 Session - Restart R;
使用菜单安装该R包: 
> install.packages("../pkgS2_0.1.0.tar.gz", repos = NULL, type = "source")

> library(pkgS2)
> pkgS2::my_pie(mtcars, 2)
报错 Error in theme_classic() : could not find function "theme_classic"
说明没有完全引入这些包中的函数，是不是应该直接引用包本身？

> library(ggplot2)
> my_pie(mtcars, 2)








8. 改进的 @Import 注释符

当只用一个或少量一个函数时，使用 #' @importFrom 包名 函数名1 函数名2 的形式。
当使用的较多时，不如直接使用 #' @import ggplot2


新增函数:
$ vim R/visual.R

#' Using a specific column of a data frame to plot a pie plot-v2
#'
#' @param data a dataframe or tibble
#' @param ncol specific column, factor
#'
#' @return a figure as ggplot2 object
#' @export
#'
#' @import ggplot2
#' @importFrom ggrepel geom_text_repel
#' @importFrom dplyr `%>%`
#'
#' @examples
#' my_pie2(mtcars,ncol=2)
#' my_pie2(diamonds,ncol=3)
#' my_pie2(diamonds,ncol=3)+guides(fill="none")
#my_pie2 = function(...){
#  my_pie(...);
#}
my_pie2=my_pie


同理，在放入一个和 pkgS1 同名的函数:
$ vim R/calc.R 
#' Add 100 to the given number
#'
#' @param x a number, float or int
#'
#' @return a number
#' @export
#'
#' @examples
#' add100(5)
#' add100(-90)
add100=function(x){
  message("This is pkgS2")
  x+100
}



生成文档
> devtools::document()
发现 NAMESPACE 多了一行: 
import(ggplot2)


重启R session(shift+ctrl+F10)

测试:
> devtools::load_all()
> my_pie(mtcars, 2)
> my_pie2(mtcars, 2)
> add100(30)
This is pkgS2
[1] 130


修改版本号: 
$ vim DESCRIPTION
Version: 0.1.3
License: MIT


生成R安装包
> devtools::build()
## "/data/wangjl/project/learn_R_pkg/pkgS2_0.1.3.tar.gz"


安装使用: 
> install.packages("../pkgS2_0.1.3.tar.gz", repos = NULL, type = "source")

重启R session: 快捷键 ctrl+shift+F10
> library(pkgS2)
> my_pie(mtcars, 2)
> add100(6)
This is pkgS2
[1] 106











9. DESCRIPTION 中的关键词

(1) 影响范围
说法1: DESCRIPTION主要影响软件包的安装，而不是运行时的行为。
说法2: Imports and depends are identical for the purpose of installation - they only differ in their package-load-time behaviour.


(2) 书写示例: 可以指定最低版本号，也可以不指定。
参考权威包，似乎都可以避免在 Depends 中添加东西:
	https://github.com/satijalab/seurat/blob/master/DESCRIPTION
	https://github.com/tidyverse/ggplot2/blob/main/DESCRIPTION

Depends:
    R (>= 4.0.0),
    methods
Imports:
	ggplot2 (>= 3.3.0),
	grid,
	leiden (>= 0.3.1),
	knitr (>= 1.13),
	rmarkdown (>= 1.0)
Suggests:
    enrichR,
    mixtools,
    ggrastr

永远不要在一个包中使用require()或library()，相反， 应该在 DESCRIPTION 的 Depends 或 Imports 字段部分填入包名。



(3) 那么，Imports与Depends部分到底有什么区别呢？什么时候该使用它们呢？

Imports和Depends包部分会确保你所需要的依赖包被安装，主要的区别是Imports中的包仅仅会被导入，而Depends中的包会被绑定，没有其他的区别了。

假设你开发的包需要dplyr，你把它列到了Depends，那么载入你开发的包的用户它会发现dplyr也被载入了，而且能够直接使用里面的函数。
而写在Imports的话，dplyr里面的函数用户是不可以直接使用的。


举例：使用 Imports 的包只能该包使用，用户不能直接使用
> ggplot(mtcars, aes(mpg, cyl))+geom_point()
Error in ggplot(mtcars, aes(mpg, cyl)) : could not find function "ggplot"

而如果是  Depends 里写 ggplot2，则导入包后，包的函数可以用，用户也可以直接使用该包，就像 library() 过该 Depends 包一样。





10. 一个github 仓库包含多个R包怎么安装？

卸载R包
> remove.packages("pkgS2", lib="~/R/x86_64-pc-linux-gnu-library/4.1")

注: 也可以把几个包都保存到一个目录下，然后把该目录推送到github的一个repo中，然后这样安装:
##devtools::install_github("userName/repoName/subDir")
> devtools::install_github("BioMooc/learn_R_pkg/pkgS2")







========================================
|-- 如何写R包 3: 如何使用 .C() 接口调用 C 代码？
----------------------------------------
https://zhuanlan.zhihu.com/p/525123593

前置知识：读者要理解C语言基础及其编译运行。

主要包括4步:
- 编写并调试 C 代码;
- 生成动态链接库 .so 文件: $ R CMD SHLIB xx.c
- 载入动态链接库: > dyn.load("xx.so")
- R 中调用: > .C("c_func_names", para_1=, para_2=)



1. 新建R包项目 pkgS3 
参考第一篇，创建R包目录结构。



2. 计算累加的函数 addTo(x): R 函数版
$ vim R/calc.R 
#' Add to number x
#'
#' @param x an int
#'
#' @return an int
#' @export
#'
#' @examples
#' addTo(100)
#' addTo(10)
addTo=function(x){
  sum=0
  for(i in 1:x){
    sum=sum+i;
  }
  return(sum)
}


生成文档:
$ rm NAMESPACE

> devtools::document()


测试:
> devtools::load_all()
> addTo(100)
[1] 5050




3. 计算累加的函数 addTo(x): C 函数版

(1) 先写好C代码: 最简单的 x+y 函数
不能使用返回值，只能使用指针。

$ cat src/func2.c
#include<stdio.h>
void add(int* x, int* y){
	*x = *x + *y;
}

int main(){
	int a=1, b=2, a0;
	a0=a;
	add(&a,&b);
	printf("Hello R, from C, %d+%d=%d\n", a0, b, a);
    return 0;
}


查看编译器版本
$ gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


$ gcc src/func2.c -o src/func2.out
$ ./src/func2.out
Hello R, from C, 1+2=3


2) 编译写好的c/c++代码为 a shared library (.dll in Windows and .so (.o) in linux)
win下安装 Rtools、mingw并配置环境; linux下不需要。

## 在RStudio中运行
## setwd("/data/wangjl/project/learn_R_pkg/pkgS3/") #设置c文件的路径
system("R CMD SHLIB src/func2.c") #编译c文件

## 或者直接在shell下编译
$ R CMD SHLIB src/func2.c

输出2个文件
$ ls -lth src/
total 52K
-rwxr-xr-x 1 wangjl wangjl  20K Jun  4 16:34 func2.so
-rw-r--r-- 1 wangjl wangjl 7.9K Jun  4 16:34 func2.o


3) 加载共享库
load the shared library by dyn.load("LIBNAME"), 在R中载入.dll文件(win)/.so(linux), 
> dyn.load('src/func2.so')


4) 调用C文件的函数
call the compiled C function by .C("FUNNAME",...). 
Here LIBNAME is the name of the shared library file and FUNNAME is the name of the C function.

# y = .C("massdisttest", x = as.double(xtrunc), xmass = as.double(tau[trunc]/sum(tau[trunc])), nx = nx, xlo = as.double(lo), xhi = as.double(up),y = double(2 * n), ny = as.integer(n))$y

> y = .C("add", a=as.integer(100), b=as.integer(123) )$a
> y #223


(2) R包装函数
R Wrapper Functions
It is considered user-friendly to wrap the call to .C in an R function.
为了方便使用R风格的代码，把.C包装到R函数中。

#' add two number by C
#'
#' @param x int
#' @param y int
#'
#' @return int
#' @export
#'
#' @examples
#' addNum(20, 35)
addNum=function(x, y){
  message("this was calc by C function 'add'")
  y = .C("add", a=as.integer(x), b=as.integer(y) )$a
  return(y)
}

清空工作区，并重启R session(shift+ctrl+F10).
手动载入该函数：光标放到函数上，ctrl+Enter；
> dyn.load('src/func2.so')
> addNum(20, 35)
this was calc by C function 'add'
[1] 55




(3) 但是怎么自动加载该 so 文件呢？

参考例子: https://r-pkgs.org/src.html
#' @useDynLib mypackage add_
add <- function(x, y) .Call(add_, x, y)
它会在执行 devtools::document() 时，自动在 NAMESPACE 中生成一行: useDynLib(mypackage, add_)


可以在R包装函数的注释中添加 #' @useDynLib pkgS3
它会在执行 devtools::document() 时，自动在 NAMESPACE 中生成一行: useDynLib(pkgS3)


#' add two number by C
#'
#' @param x int
#' @param y int
#'
#' @return int
#' @export
#' @useDynLib pkgS3
#'
#' @examples
#' addNum(20, 35)
addNum=function(x, y){
  message("this was calc by C function 'add'")
  y = .C("add", a=as.integer(x), b=as.integer(y) )$a
  return(y)
}


清空工作区，并重启R session(shift+ctrl+F10).

> devtools::document() #自动生成的名字是 包名.so; 并更新到了 NAMESPACE 中
> devtools::load_all()
> addNum(20, 35)
this was calc by C function 'add'
[1] 55




(4) 完成 C 语言版的 addTo() 函数

1) 编写C并测试
$ vim src/addTo.c
#include<stdio.h>

void addTo(int* x, int* y){
  int i=0;
  *y=0;
  for (i=0; i<=*x; i++){
    *y += i;
  }
}

int main(){
  int a=100, b=0;
  addTo(&a, &b);
  printf("Hello R, from C, add 1+2+...+%d=%d\n", a, b);
  return 0;
}

编译并运行:
$ gcc src/addTo.c -o src/addTo.out

$ ls -lth src/*
-rwxr-xr-x 1 wangjl wangjl  17K Jun  4 17:19 src/addTo.out

$ ./src/addTo.out
Hello R, from C, add 1+2+...+100=5050



2) 先用R编译
$ R CMD SHLIB src/addTo.c
在R中调用
> dyn.load("src/addTo.so")
> .C("addTo", a=as.integer(100), b=as.integer(0) )$a
[1] 100
> .C("addTo", a=as.integer(100), b=as.integer(0) )$b
[1] 5050


3) 写R包装函数
#' Add to number from 1 to x, in C
#'
#' @param x an int
#'
#' @return an int
#' @export
#' @useDynLib pkgS3
#'
#' @examples
#' addTo_wrapper(100)
#' addTo_wrapper(10)
addTo_wrapper=function(x){
  if (!is.numeric(x)){ stop("argument x must be numeric") }
  message("this was calc by C function 'addTo'")
  y=0
  out = .C("addTo", a=as.integer(x), b=as.integer(y) )
  return(out$b)
}

> devtools::document() #自动生成的名字是 包名.so; 并更新到了 NAMESPACE 中
报错了，不能有两个 main 函数，那就注释掉第二个的main函数。

目前该文件相当于只有 addTo() 一个C函数：
$ cat src/addTo.c 
#include<stdio.h>

void addTo(int* x, int* y){
  int i=0;
  *y=0;
  for (i=0; i<=*x; i++){
    *y += i;
  }
}

/*
int main(){
  int a=100, b=0;
  addTo(&a, &b);
  printf("Hello R, from C, add 1+2+...+%d=%d\n", a, b);
  return 0;
}
*/





清空工作区，并重启R session(shift+ctrl+F10).
> devtools::document()
> devtools::load_all()
> addNum(20, 35)
this was calc by C function 'add'
[1] 55
> addTo_wrapper(100)
this was calc by C function 'addTo'
[1] 5050

> addTo_wrapper("100")
Error in addTo_wrapper("100") : argument x must be numeric





4. 怎么支持数组输入呢？
Calling C with different vector types
这里只使用最简单的

$ vim src/func2.c #添加函数
/* useC2.c */
void useC2(int *i, double *d, char **c, int *l) {
  i[0] = 11;
  d[0] = 2.333;
  c[1] = "g";
  l[0] = 0;
}

> devtools::document()
> .C("useC2", 
	a = as.integer(1:4), 
	b=as.double(3.1415926), 
	c=as.character( c("this", "is", "a string") ), 
	d=c(T, F) )
输出:
$a
[1] 11  2  3  4

$b
[1] 2.333

$c
[1] "this"     "g"        "a string"

$d
[1] FALSE FALSE

不用管C的形式参数名字，传入相同类型的实参即可。
其他R对象也能传入.C()，但是最好使用其他接口。






5. 怎么在加载R包时进行启动设置？
参考 .onLoad() 等命名空间钩子函数。
见本文的 R/zzz.R。


# 这是启动函数，可以用于初始化设置，包参数设置等 https://oomake.com/question/213412
# .onLoad 是命名空间钩子，细节 F1 查看

.onLoad=function(lib, pkg){
  message("===>>> This is the function called when loading this pkg. \
          Very suit to load .so file here.")
  message("libName:",lib)
  message("pkgName:",pkg)
}





6. 当前目录结构
$ tree
.
├── DESCRIPTION
├── man
│   ├── addNum.Rd
│   ├── addTo.Rd
│   ├── addTo_wrapper.Rd
│   └── hello.Rd
├── NAMESPACE
├── pkgS3.Rproj
├── R
│   ├── calc.R
│   ├── hello.R
│   └── zzz.R
└── src
    ├── addTo.c
    ├── addTo.o
    ├── func2.c
    ├── func2.o
    └── pkgS3.so



结论：.C() 这个接口学不会就算了，有疑问也可以不提... 因为现在的R主要用 .Call() 接口调用 C/C++ 函数。

著名的 data.table 就是用纯C写的R扩展，没有用到C++。用 .Call() 接口调用的C函数。
那么，C和C++的区别是什么呢？



ref: https://r-pkgs.org/src.html






========================================
|-- 如何写R包 4: 使用更高级的 .Call() 接口调用 C 代码(熟悉 SEXP 类型 )
----------------------------------------
https://zhuanlan.zhihu.com/p/525648754

我们新建R包项目 pkgS4，生成文件结构。


1. .Call() 接口时更高级、现在更常用的接口

(1) 区别
.C()
	allows you to write simple C code that knows nothing about R
	only simple data types can be passed
	all argument type conversion and checking must be done in R
	all memory allocation must be done in R
	all arguments are copied locally before being passed to the C function (memory bloat)

.Call()
	allows you to write simple R code
	allows for complex data types
	allows for a C function return value
	allows C function to allocate memory
	does not require wasteful argument copying
	requires much more knowledge of R internals
	is the recommended, modern approach for serious C programmers

To allow readers to compare for themselves how difficult or easy it is to switch from .C() to .Call() we will re-implement our three “Hello World!” examples using the .Call() interface.

简单说， .Call()可以传递更复杂的数据类型，允许返回值，传递参数时不复制。
但是 .Call() 需要对 R 的内部结构有一些了解，因为需要加 R的 .h 头文件。



(2) R 的.h 头文件 

R 语言本身就是C写的，所以自己也带了好几个C语言特有的头文件。

$ R RHOME
/data/public/R-4.1.1/lib/R

继续看这个目录的 include/ 子目录
$ ls -1 `R RHOME`/include
Rconfig.h    # various configuration flags
Rdefines.h   # lots of macros of interest, includes Rinternals.h
Rembedded.h  # function declarations for embedding R in C programs
R_ext      # directory of include files for specific data types, etc.
R.h        # includes all the files found in R_ext
Rinterface.h  # provides hooks for external GUIs
Rinternals.h  # core R data structures (重点)
Rmath.h     # math constants and function declarations
Rversion.h  # version string components
S.h       # macros for S/R compatibility



(3) C函数的参数和返回值必须是 SEXP 类型

使用 .Call() 接口，C函数的返回值必须是 SEXP 类型，参数也必须是 SEXP 类型。
SEXP 类型是一种指向 SEXPREC(Simple EXPression RECord)的指针类型，在 Rinternals.h 中定义。也可能是 S-expression 的简写。它是R语言和C语言之间变量传递的纽带。
可以在代码中引用 R.h 和 Rdefines.h (包含了 Rinternals.h) 来获取 SEXP 等的定义。

$ vim src/helloA1.c
#include <R.h>
#include <Rdefines.h>
#include <stdio.h>

SEXP helloA1() {
  printf("Hello World!\n");
  return(R_NilValue);
}
//虽然返回值是 R_NilValue 也就是 NULL，但是函数类型依旧是 SEXP ，它只能是这一个类型。参数也只能是这个类型。

int main(){
  SEXP helloA1();
  return 0;
}









(4) 如何调试C/C++代码 

==> 尝试1：使用 gcc 编译，局限在C/C++范围内，不牵涉R。
$ gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -UNDEBUG -Wall -pedantic -g -O0 -fdiagnostics-color=always -c src/helloA1.c -o src/helloA1_.o

$ gcc -shared -L/data/public/R-4.1.1/lib/R/lib -L/usr/local/lib -o src/pkgS4_.so src/helloA1_.o -L/data/public/R-4.1.1/lib/R/lib -lR

$ ./src/pkgS4_.so 
Segmentation fault (core dumped)
失败，难道无法在C/C++范围内单独调试？就是不进入R而是使用shell命令行测试？ //todo

只能载入编译后的文件，然后在R中测试？
> dyn.load("src/pkgS4_.so")
> .Call("helloA1")
NULL
Hello World!


貌似调试R的C代码确实不容易: 
	https://www.maths.ed.ac.uk/~swood34/RCdebug/RCdebug.html
	https://contributions.bioconductor.org/debugging-cc-code.html





==> 尝试2: 编译动态链接库，在R中调用调试。
编译
$ R CMD SHLIB src/helloA1.c

在R中调用 
# wrapper function to invoke helloA1
> dyn.load("src/helloA1.so")
> helloA1 <- function() {
  result <- .Call("helloA1")
}

> greeting <- helloA1()
Hello World!
> class(greeting)
[1] "NULL"





我们可以把该函数写到 R 文件中，后面我们从略。

该步骤由R包帮我们自动完成编译、连接、加载C语言部分。
$ vim R/hello.R 
#' test1: func must be SEXP type
#'
#' @return null
#' @export
#' @useDynLib pkgS4
#'
#' @examples
#' helloA1()
helloA1 <- function() {
  result <- .Call("helloA1")
}

清空工作区，重启R session，删除 NAMESPACE 文件。
> devtools::document() #查看 NAMESPACE 中添加了一行 useDynLib(pkgS4)
> devtools::load_all()
> helloA1()
Hello World!





(5) 在C函数中分配内存，对抗垃圾回收机制

R会自动回收垃圾，这是很有用的。
为了防止C的数据被回收，需要标记一下，就是函数 PROTECT 和 UNPROTECT。


$ vim src/helloB1.cpp #添加代码
#include <R.h>
#include <Rdefines.h>
SEXP helloB1() {
  SEXP result;
  PROTECT(result = NEW_CHARACTER(1));
  SET_STRING_ELT(result, 0, mkChar("Hello World!"));
  UNPROTECT(1);
  return(result);
}


为一个字符串向量分配内存使用的是 NEW_CHARACTER(长度)。
我们看看这个宏是怎么定义的:


$ R RHOME
/data/public/R-4.1.1/lib/R

$ grep -n NEW_ /data/public/R-4.1.1/lib/R/include/*.h
/data/public/R-4.1.1/lib/R/include/Rdefines.h:93:#define NEW_LOGICAL(n)		Rf_allocVector(LGLSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:94:#define NEW_INTEGER(n)		Rf_allocVector(INTSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:95:#define NEW_NUMERIC(n)		Rf_allocVector(REALSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:96:#define NEW_CHARACTER(n)	Rf_allocVector(STRSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:97:#define NEW_COMPLEX(n)		Rf_allocVector(CPLXSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:98:#define NEW_LIST(n)		Rf_allocVector(VECSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:99:#define NEW_STRING(n)		NEW_CHARACTER(n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:100:#define NEW_RAW(n)		Rf_allocVector(RAWSXP,n)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:166:/* NEW_OBJECT is recommended; NEW is for green book compatibility */
/data/public/R-4.1.1/lib/R/include/Rdefines.h:167:#define NEW_OBJECT(class_def)	R_do_new_object(class_def)

在R中也能获取该路径:
> rinternals <- file.path(R.home("include"), "Rinternals.h")
> rinternals
[1] "/data/public/R-4.1.1/lib/R/include/Rinternals.h"
> file.show(rinternals)

也就是说，我们可以使用 allocVector(STRSXP,1) 而不是 NEW_CHARACTER(1)，且前者使用挺多的。
	搜索发现，allocVector 是一个 C++ 函数。
	更多 Rf_allocVector 函数示例: https://www.itcodet.com/cpp/cpp-rf_allocvector-function-examples.html


还有两个没见过的: SET_STRING_ELT 和 mkChar，接着匹配
$ grep -n _ELT /data/public/R-4.1.1/lib/R/include/*.h
/data/public/R-4.1.1/lib/R/include/Rdefines.h:142:#define SET_ELEMENT(x, i, val)	SET_VECTOR_ELT(x, i, val)
/data/public/R-4.1.1/lib/R/include/Rinternals.h:504:#define VECTOR_ELT(x,i)	((SEXP *) DATAPTR(x))[i]
/data/public/R-4.1.1/lib/R/include/Rinternals.h:715:   The function STRING_ELT is used as an argument to arrayAssign even
/data/public/R-4.1.1/lib/R/include/Rinternals.h:789://SEXP (STRING_ELT)(SEXP x, R_xlen_t i);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:790:SEXP (VECTOR_ELT)(SEXP x, R_xlen_t i);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:791:void SET_STRING_ELT(SEXP x, R_xlen_t i, SEXP v); ## 这一行
...


$ grep -n mkChar /data/public/R-4.1.1/lib/R/include/*.h
/data/public/R-4.1.1/lib/R/include/Rdefines.h:193:#define COPY_TO_USER_STRING(x)	mkChar(x)
/data/public/R-4.1.1/lib/R/include/Rdefines.h:194:#define CREATE_STRING_VECTOR(x)	mkChar(x)
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1177:SEXP Rf_mkChar(const char *);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1178:SEXP Rf_mkCharLen(const char *, int);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1250:SEXP Rf_mkCharCE(const char *, cetype_t);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1251:SEXP Rf_mkCharLenCE(const char *, int, cetype_t);
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1642:#define mkChar			Rf_mkChar #这一行
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1643:#define mkCharCE		Rf_mkCharCE
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1644:#define mkCharLen		Rf_mkCharLen
/data/public/R-4.1.1/lib/R/include/Rinternals.h:1645:#define mkCharLenCE		Rf_mkCharLenCE


值的花时间好好研读 Rinternals.h 和 Rdefines.h.
R的源码: https://svn.r-project.org/R/
Github 的只读备份(updated hourly): https://github.com/wch/r-source


编译
$ R CMD SHLIB src/helloB1.c #教训，之前命名为 .cpp ，结果后面调用找不到该函数。

测试
# wrapper function to return a greeting.
> dyn.load("src/helloB1.so")
> helloB1 <- function() {
  result <- .Call("helloB1")
  return(result)
}

> greeting <- helloB1()
> greeting
[1] "Hello World!"
> class(greeting)
[1] "character"




(6) SEXP 数据类型

R语言中的变量必须以SEXP变量类型传递给C函数，C函数的返回值类型必须以SEXP类型返回给R语言。实际上，SEXP是一个结构体的指针。

其中包含了具体的变量类型，与R中数据类型的对应关系如下：

REALSXP: 实数向量
INTSXP : 整数向量
LGLSXP : 逻辑向量
STRSXP : 字符向量
VECSXP : 列表
CLOSXP : 函数
ENVSXP : 环境变量


$ vim /data/public/R-4.1.1/lib/R/include/Rinternals.h
...
#define NILSXP       0    /* nil = NULL */
#define SYMSXP       1    /* symbols */
#define LISTSXP      2    /* lists of dotted pairs */
#define CLOSXP       3    /* closures */
#define ENVSXP       4    /* environments */
#define PROMSXP      5    /* promises: [un]evaluated closure arguments */
#define LANGSXP      6    /* language constructs (special lists) */
#define SPECIALSXP   7    /* special forms */
#define BUILTINSXP   8    /* builtin non-special forms */
#define CHARSXP      9    /* "scalar" string type (internal only)*/
#define LGLSXP      10    /* logical vectors */
/* 11 and 12 were factors and ordered factors in the 1990s */
#define INTSXP      13    /* integer vectors */
#define REALSXP     14    /* real variables */
#define CPLXSXP     15    /* complex variables */
#define STRSXP      16    /* string vectors */
#define DOTSXP      17    /* dot-dot-dot object */
#define ANYSXP      18    /* make "any" args work.
                             Used in specifying types for symbol
                             registration to mean anything is okay  */
#define VECSXP      19    /* generic vectors */
#define EXPRSXP     20    /* expressions vectors */
#define BCODESXP    21    /* byte code */
#define EXTPTRSXP   22    /* external pointer */
#define WEAKREFSXP  23    /* weak reference */
#define RAWSXP      24    /* raw bytes */
#define S4SXP       25    /* S4, non-vector */

/* used for detecting PROTECT issues in memory.c */
#define NEWSXP      30    /* fresh node created in new page */
#define FREESXP     31    /* node released by GC */

#define FUNSXP      99    /* Closure or Builtin or Special */

...
typedef struct SEXPREC *SEXP;
...


/* The standard node structure consists of a header followed by the
   node data. */
typedef struct SEXPREC {
    SEXPREC_HEADER;
    union {
        struct primsxp_struct primsxp;
        struct symsxp_struct symsxp;
        struct listsxp_struct listsxp;
        struct envsxp_struct envsxp;
        struct closxp_struct closxp;
        struct promsxp_struct promsxp;
    } u;
} SEXPREC;














(7) 数据类型映射(SEXP 对象与其他数据类型之间)
Casting about in the R header files 

怎么把 字符串映射为 SEXP 对象，把 SEXP 对象映射为 整数等。
这个是有限的组合，但数量不少，可以参考上文链接，及 http://dirk.eddelbuettel.com/papers/uofc_acm_feb2010.pdf

例子展示，Rdefines.h 定义的R宏怎么从向量中提取元素，怎么把向量转为字符和整数，怎么 UNPROTECT 你之前 PROTECT  放堆中的元素，保证个数一致？

$ vim src/helloC1.c
#include <R.h>
#include <Rdefines.h>
#include <string.h>

SEXP helloC1(SEXP greeting) {
  int i, vectorLength, stringLength;
  SEXP result;

  PROTECT(greeting = AS_CHARACTER(greeting)); //获取字符串
  vectorLength = LENGTH(greeting); //数组长度
  PROTECT(result = NEW_INTEGER(vectorLength)); //新建整数
  for (i=0; i<vectorLength; i++) { //遍历 数组元素
    stringLength = strlen(CHAR(STRING_ELT(greeting, i))); //字符串元素长度
    INTEGER(result)[i] = stringLength;
  }
  UNPROTECT(2); //参数个数要和 PROTECT 个数一致。
  return(result);
}

$ R CMD SHLIB src/helloC1.c


# wrapper function to invoke helloC1 
> dyn.load("src/helloC1.so")
> helloC1 <- function(greeting) {
  result <- .Call("helloC1", greeting)
  return(result)
}

> helloC1( c("this is me!", "morning") )
[1] 11  7




(8) GetRNGstate() PutRNGstate(); //todo



https://vimsky.com/examples/detail/cpp-ex-----PutRNGstate-function.html









2. 更多例子

(1) 返回输入值的二倍

$ vim src/helloC1.c 
//#include <R.h>
//#include <Rdefines.h>
SEXP double_me2(SEXP x) {
  // Doubles the value of the first integer element of the SEXP input
  SEXP result;
  PROTECT(result = NEW_INTEGER(1)); // i.e., a scalar quantity
  INTEGER(result)[0] = INTEGER(x)[0] * 2;
  UNPROTECT(1); // Release the one item that was protected
  return result;
}

$ R CMD SHLIB src/helloC1.c

> dyn.load("src/helloC1.so")
> double_me_R <- function(x) {
  result <- .Call("double_me", x)
  return(result)
}
> double_me_R(1) #看来R中整数默认是 double，要强制转换类型 as.integer()
Error: INTEGER() can only be applied to a 'integer', not a 'double'

> double_me_R(as.integer(5))
[1] 10





(2) 向量卷积
2个列向量的卷积，就是 a.b^T 得到的矩阵，按垂直于主对角线画线，把连线上的元素相加得到的向量。

$ vim src/helloC1.c
//#include <R. h>
//#include <Rdefines . h>
//extern "C" SEXP convolve2(SEXP a , SEXP b)
SEXP convolve2(SEXP a , SEXP b)
{
  int i, j, na, nb, nab;
  double *xa, *xb, *xab;
  SEXP ab;

  PROTECT( a = AS_NUMERIC( a ) );
  PROTECT( b = AS_NUMERIC( b ) );
  na = LENGTH( a ); nb = LENGTH( b ); nab = na + nb - 1;

  PROTECT( ab = NEW_NUMERIC( nab ) );
  xa = NUMERIC_POINTER ( a );
  xb = NUMERIC_POINTER ( b );
  xab = NUMERIC_POINTER ( ab );
  for ( i = 0; i < nab; i++)
    xab[i] = 0.0; //初始化为0

  for ( i = 0; i < na; i++)
    for ( j = 0; j < nb; j++)
      xab [i+j] += xa[i] * xb[j];

  UNPROTECT(3);
  return(ab);
}



$ R CMD SHLIB src/helloC1.c
> dyn.load("src/helloC1.so")
> convolve2_R <- function(arr1, arr2) {
  result <- .Call("convolve2", arr1, arr2)
  return(result)
}
> convolve2_R(1:3, 1:10)
[1]  1  4 10 16 22 28 34 40 46 52 47 30







(3) 加法

$ vim src/helloC1.c
// 两个数的加法
SEXP add2(SEXP a, SEXP b) {
  SEXP result = PROTECT(allocVector(REALSXP, 1));
  REAL(result)[0] = asReal(a) + asReal(b);
  UNPROTECT(1);

  return result;
}

$ R CMD SHLIB src/helloC1.c
> dyn.load("src/helloC1.so")
> .Call("add2", 10, 20)
[1] 30

> .Call("add2", c(1,10), c(2, 20)) # 默认写法不支持向量
[1] 3



> devtools::document()
> .Call("add2", 10, 20, PACKAGE = "pkgS4") #这个适合使用 devtools::document() 后的代码
[1] 30




(4) 整体编译测试
- 清空工作区，并重启R session;
- 更新 DESCRIPTION 中的版本号;

> devtools::document()
> devtools::load_all()
> .Call("add2", 10, 20)
[1] 30
> convolve2_R(1:3, 1:4)
[1]  1  4 10 16 17 12



> devtools::document()
> devtools::build()
[1] "/data/wangjl/project/learn_R_pkg/pkgS4_0.1.1.tar.gz"
> install.packages("~/data/project/learn_R_pkg/pkgS4_0.1.1.tar.gz", repos = NULL, type = "source")

重启R session(shift+ctrl+F10)
> library(pkgS4)
> pkgS4::convolve2_R(1:2, 1:3)
[1] 1 4 7 6




3. 进一步学习 

- C/C++ 基础: 精简版Rcpp教程 https://teuder.github.io/rcpp4everyone_en/

- 值的花时间好好研读 Rinternals.h 和 Rdefines.h. 里面有很多 #define 宏定义;
	* 1853  7544 63180 /data/public/R-4.1.1/lib/R/include/Rinternals.h
	* 201  831 6791 /data/public/R-4.1.1/lib/R/include/Rdefines.h
	#define isS4                    Rf_isS4



个人感觉: 这些非标准的 C/C++ 代码（R定义的数据类型、宏和函数）真头疼，他们不是常见的 C/C++ 代码，有很多怪异的用法需要记忆，比如数据类型声明和强制转换函数。

https://github.com/BioMooc/learn_R_pkg/tree/master/pkgS4



ref:
https://zhuanlan.zhihu.com/p/362328760






========================================
|-- 如何写R包 5: 使用更便捷的 Rcpp包 调用 C/C++ 代码
----------------------------------------
https://zhuanlan.zhihu.com/p/527549223



Rcpp 的作者: Dirk Eddelbuettel http://dirk.eddelbuettel.com/
	https://dirk.eddelbuettel.com/code/rcpp.html
Rcpp 作者的广告片: 
	https://dirk.eddelbuettel.com/papers/rcpp_rfinance_may2012.pdf
	https://www.r-project.org/conferences/useR-2010/slides/Eddelbuettel+Francois.pdf

据作者的某个ppt中的数据，Rcpp 是被引用最多的R包，远远超过第二名 ggplot2.


0. 相关资料
https://gallery.rcpp.org/
https://www.rcpp.org/
https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-introduction.pdf
https://dirk.eddelbuettel.com/code/rcpp.html
http://adv-r.had.co.nz/C-interface.html
http://adv-r.had.co.nz/Rcpp.html


book: https://link.springer.com/content/pdf/10.1007/978-1-4614-6868-4.pdf
ebook: https://teuder.github.io/rcpp4everyone_en/
Rcpp 需要的C++ 知识: https://zhuanlan.zhihu.com/p/150630210

精简版Rcpp教程: https://teuder.github.io/rcpp4everyone_en/

作者的大会报告: https://dirk.eddelbuettel.com/papers/useR2019_rcpp_tutorial.pdf P35
http://dirk.eddelbuettel.com/papers/uofc_acm_feb2010.pdf P24


Rcpp 简单用法: https://zhuanlan.zhihu.com/p/149975938
Rcpp 数据类型 https://blog.csdn.net/weixin_41929524/article/details/81975484
Rcpp 更多总结 https://blog.csdn.net/iamsuperman2/article/details/73251928
(矩阵库) RcppArmadillo简明手册 https://blog.csdn.net/iamsuperman2/article/details/73143393
	http://arma.sourceforge.net/docs.html




1. 尝试使用 Rcpp

使用 .Call() 接口可以直接访问复杂的R数据类型(vectors, matrices, lists, ...)，不用再传一个维度参数。
使用 C++ 的类，我们就不用直接操作 SEXP 对象了。



新建R包项目 pkgS5，过程参考 R 包第一篇;

(1) 默认示例
菜单 File - New File - C++ File，保存为 src/simple.cpp，该文件内容如下:

$ cat src/simple.cpp
#include <Rcpp.h>
using namespace Rcpp;

// This is a simple example of exporting a C++ function to R. You can
// source this function into an R session using the Rcpp::sourceCpp
// function (or via the Source button on the editor toolbar). Learn
// more about Rcpp at:
//
//   http://www.rcpp.org/
//   http://adv-r.had.co.nz/Rcpp.html
//   http://gallery.rcpp.org/
//

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}


// You can include R code blocks in C++ files processed with sourceCpp
// (useful for testing and development). The R code will be automatically
// run after the compilation.
//

/*** R
timesTwo(42)
*/


测试 
> library(Rcpp)
> sourceCpp("src/simple.cpp") #引入cpp文件到R中
# 自动完成C/C++代码的编译、连接、引入到R。可以看到Rstudio右上角工作区出现函数名。
输出 
#> timesTwo(42)
#[1] 84
> timesTwo(2:5) #支持数组
[1]  4  6  8 10
> timesTwo(2:5+0.2) #支持实数
[1]  4.4  6.4  8.4 10.4


示例说明：
- 第一行要加入Rcpp 头文件 #include <Rcpp.h>
- 然后命名空间  using namespace Rcpp;
- 接着就是添加函数，注意：每个暴露给R的函数前都要加一行 “// [[Rcpp::export]]”，否则无法访问到。




(2) 末尾的R代码

我们看到一行注释: 说这里的R代码会被 sourceCpp 处理，然后在C/C++编译后自动执行。
You can include R code blocks in C++ files processed with sourceCpp (useful for testing and development). 
The R code will be automatically run after the compilation.


尝试编译后确实能自动运行这里的R代码。
不过，我们还是直接删掉这几行吧，写到这里明显不合适。
/*** R
timesTwo(42)
*/



(3) 在代码中使用 Rcpp 推荐使用 cppFunction() 函数 
cppFunction("double getMax(NumericVector v) {
  int n = v.size(); // vectors are describing
  double m = v[0]; // initialize
  for (int i=0; i<n; i++) {
    if (v[i] > m) {
      m = v[i];
      Rcpp::Rcout << \"Now \" << m << std::endl;
    }
  }
  return(m);
}")

> getMax(c(4,5,22,8))
Now 5
Now 22
[1] 22


这是一个很好的测试形式，能迅速给出答案，适合调试、探索。

还可以逐句执行C++代码
> evalCpp("NAN == 1")
[1] FALSE
> Rcpp::evalCpp("1+10")
[1] 11











2. 尝试在R包中使用Rcpp

刚才我们可以在R代码中使用Rcpp，怎么在R包中使用呢？


(1) 自动编译并生成文档
1) 清空工作区:> rm(list=ls()); 重启R session: shift+ctrl+F10;

2) 注意：这时不能删除 NAMESPACE 文件，否则会报错，这和我们之前的经验并不一致。
> devtools::document()
报错：
Error in Rcpp::compileAttributes(path, verbose = !quiet) : 
  pkgdir must refer to the directory containing an R package


> devtools::document()
报错
 simple.cpp:1:10:fatal error: h: No such file or directory
       1 | #include <Rcpp.h>
         |          ^~~~~~~~



(2) [特别注意] 在 DESCRITION 文件默认添加一行，否则会编译失败: LinkingTo: Rcpp (>= 0.11.0)

看一下 Seurat 4 的 DESCRITION 文件这一行的内容: https://github.com/satijalab/seurat/blob/master/DESCRIPTION
LinkingTo: Rcpp (>= 0.11.0), RcppEigen, RcppProgress

The LinkingTo declaration indicates that the client package needs to use header files exposed by Rcpp.



编译并生成文档:
> devtools::document()
i Updating pkgS5 documentation #生成文档
First time using roxygen2. Upgrading automatically...
i Loading pkgS5
Exports from /data/wangjl/project/learn_R_pkg/pkgS5/src/simple.cpp: #导出2个函数签名
   NumericVector timesTwo(NumericVector x)
   int double_me(int x)

/data/wangjl/project/learn_R_pkg/pkgS5/src/RcppExports.cpp updated. #更新 src/RcppExports.cpp
/data/wangjl/project/learn_R_pkg/pkgS5/R/RcppExports.R updated.     #更新 R/RcppExports.R
Re-compiling pkgS5    #再 编译
─  installing *source* package ‘pkgS5’ ...
   ** using staged installation
   ** libs

   ## 编译为.o 文件
   g++ -std=gnu++14 -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG  -I'/data/public/R-4.1.1/lib/R/library/Rcpp/include' -I/usr/local/include   -fpic  -g -O2  -UNDEBUG -Wall -pedantic -g -O0 -fdiagnostics-color=always -c RcppExports.cpp -o RcppExports.o

   ## 编译为 .o 文件
   g++ -std=gnu++14 -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG  -I'/data/public/R-4.1.1/lib/R/library/Rcpp/include' -I/usr/local/include   -fpic  -g -O2  -UNDEBUG -Wall -pedantic -g -O0 -fdiagnostics-color=always -c simple.cpp -o simple.o

   ##连接为 .so 文件 
   g++ -std=gnu++14 -shared -L/data/public/R-4.1.1/lib/R/lib -L/usr/local/lib -o pkgS5.so RcppExports.o simple.o -L/data/public/R-4.1.1/lib/R/lib -lR
   installing to /tmp/RtmpMR9xJx/devtools_install_930cc30508d27/00LOCK-pkgS5/00new/pkgS5/libs
   ** checking absolute paths in shared objects and dynamic libraries
─  DONE (pkgS5)
Warning: The existing 'NAMESPACE' file was not generated by roxygen2, and will not be overwritten.


警告说 NAMESPACE 不是自动维护的版本，所以没有修改。



(3) 删掉 NAMESPACE 再生成一次

> unlink("NAMESPACE")
> devtools::document()
i Updating pkgS5 documentation
First time using roxygen2. Upgrading automatically...
i Loading pkgS5
Writing NAMESPACE


测试 
> devtools::load_all()
i Loading pkgS5
> timesTwo(1:3)
Error in .Call("_pkgS5_timesTwo", PACKAGE = "pkgS5", x) : 
  "_pkgS5_timesTwo" not available for .Call() for package "pkgS5"

应该是无法找到 pkgS5.so 文件，怎么办？



(4) 怎么在R包中导入C/C++ 编译后的文件？
参考 Seurat 的做法，它为一个NULL添加了函数注释，内容如下
seurat-4.1.0/R/objects.R:8:#' @useDynLib Seurat

#' @include reexports.R
#' @include generics.R
#' @importFrom Rcpp evalCpp
#' @importFrom Matrix colSums rowSums colMeans rowMeans
#' @importFrom methods setClass setOldClass setClassUnion slot
#' slot<- setMethod new signature slotNames is setAs setValidity .hasSlot
#' @importClassesFrom Matrix dgCMatrix
#' @useDynLib Seurat
#'
NULL

我们也照着做:
$ vim R/hello.R #开头部分添加
#' @useDynLib pkgS5
#' @import Rcpp
#'
NULL


测试
清空工作区，并重启R session;
> devtools::document()
> devtools::load_all()
> timesTwo(4)
[1] 8
> hello()
[1] "Hello, world!"
> timesTwo(1:4)
[1] 2 4 6 8


查看文件:
$ cat NAMESPACE
import(Rcpp)
useDynLib(pkgS5)





(5) 生成安装包
> devtools::build()
## "/data/wangjl/project/learn_R_pkg/pkgS5_0.1.0.tar.gz"

把这个文件分发给想使用这个R包的人即可，最简单的就是把源码上传 github。


(6) 安装测试 
> install.packages("~/data/project/learn_R_pkg/pkgS5_0.1.0.tar.gz", repos = NULL, type = "source")

清空工作区，并重启R session;
> library(pkgS5)
> timesTwo(3)
Error in timesTwo(3) : could not find function "timesTwo"
> pkgS5:::timesTwo(3)
[1] 6

说明这些函数都没有暴露出来，都只能内部使用。
想要暴露，只能使用R包装函数，再包一层，然后在这个函数的注释中添加 @export 声明。

Seurat 4 也确实很多内部函数，它有没有暴露出来C/C++函数呢？怎么做的？
	目前看到的是，Seurat 4 的R使用 RunModularityClustering() 调用 C++函数 RunModularityClusteringCpp();
	// 看到了再来补充。
	补充: 我确实看到直接暴露的方法 (https://r-pkgs.org/src.html)，在C++函数前加一行注释: //' @export

//' Multiply a number by two
//' 
//' @param x A single integer.
//' @export
// [[Rcpp::export]]
int timesTwo(int x) {
   return x * 2;
}






3. Rcpp 到底做了什么？

目录结构:
$ tree
.
├── DESCRIPTION
├── man
│   └── hello.Rd
├── NAMESPACE
├── pkgS5.Rproj
├── R
│   ├── hello.R
│   └── RcppExports.R
└── src
    ├── pkgS5.so
    ├── RcppExports.cpp
    ├── RcppExports.o
    ├── simple.cpp
    └── simple.o

我们注意到执行 devtools::document() 后，新生成2个文件，分别是:
	R/RcppExports.R #R包装函数
	src/RcppExports.cpp #数据格式映射

这两个文件都是自动生成的。
特别是第二个文件，数据格式映射，可能是使用 .Call() 接口最棘手的地方，Rcpp帮我们自动完成了。
我们只需要聚精会神把 C++ 代码写好调试好。

这两个文件似乎不重要，反正是自动生成的，不让修改，不妨先跳过。



(1) R/目录下的Rcpp 输出文件
$ cat R/RcppExports.R
# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

timesTwo <- function(x) {
    .Call('_pkgS5_timesTwo', PACKAGE = 'pkgS5', x)
}

这是一个普通的R包装函数，在R代码中使用.Call() 接口调用 C/C++ 函数。
注意，我们在C中定义的函数名是 timesTwo，而这里 .Call() 调用的却加了R包名字前缀。原始的C函数名字不能调用了。
这是在哪一步调整的函数名？老函数名又是怎么不可访问的？都在 src/RcppExports.cpp 中完成的。

> devtools::document()
> dyn.load("src/pkgS5.so")
> .Call("timesTwo", 20)
Error in .Call("timesTwo", 20) : 
  C symbol name "timesTwo" not in load table
> .Call("_pkgS5_timesTwo", 20)
[1] 40






(2) src/目录下的Rcpp 输出文件

$ cat src/RcppExports.cpp
// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// timesTwo
NumericVector timesTwo(NumericVector x);  //函数声明，其定义 timesTwo() 在 src/simple.cpp 中。

RcppExport SEXP _pkgS5_timesTwo(SEXP xSEXP) {  //把该函数暴露出去，函数名加R包前缀：_pkgS5_timesTwo

BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;  //定义返回值类型
    Rcpp::RNGScope rcpp_rngScope_gen; // ?
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP); //输入值
    rcpp_result_gen = Rcpp::wrap(timesTwo(x)); //调用 老函数名
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {  //定义一个数组，R调用时函数映射关系
    {"_pkgS5_timesTwo", (DL_FUNC) &_pkgS5_timesTwo, 1}, //字符串，函数名，参数个数
    {NULL, NULL, 0}
};


RcppExport void R_init_pkgS5(DllInfo *dll) {  // 初始化载入该包时。固定2行。
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}







4. 数据类型映射 

向量->向量；向量->矩阵；标量->矩阵等等
	https://adv-r.hadley.nz/rcpp.html
	http://adv-r.had.co.nz/Rcpp.html


http://gallery.rcpp.org
	相当于一个搜索库，要使用Rcpp进行矩阵运算、并行计算、常用算法等操作，直接在里面进行搜索，就可以看到大神写的一些相应代码，
	同时知道该调用哪些库中的函数。


Basic C and C++: Scalar
	• int
	• double
	• char[]; std::string
	• bool
	• complex

Rcpp Vectors
	• IntegerVector
	• NumericVector
	• CharacterVector
	• LogicalVector
	• ComplexVector

IntegerMatrix	整型矩阵
NumericMatrix	数值型矩阵(元素的类型为double)
Function	函数型
List	列表；lists;类似于R中列表，其元素可以使任何数据类型
DataFrame	数据框；data frames；在Rcpp内部，数据框其实是通过列表实现的




5. 关于对矩阵以及数据框的一些基础操作与常用函数
操作	描述
[n]	对于向量类型或者列表，访问第n个元素。对于矩阵类型，首先把矩阵的下一列接到上一列之下，从而构成一个长列向量，并访问第n个元素。不同于R，n从0开始。
(i,j)	对于矩阵类型，访问第(i,j)个元素。不同于R，i和j从0开始。不同于向量，此处用圆括号。
List["name1"]	访问List中名为name1的元素。
DataFrame["name2"]	访问DataFrame中，名为name2的列。
X.size()	返回X的长度；适用于向量或者矩阵，如果是矩阵，则先向量化
X.push_back(a)	将a添加进X的末尾；适用于向量
X.push_front(b)	将b添加进X的开头；适用于向量
X.ncol()	返回X的列数
X.nrow()	返回X的行数









6. 更多实例: 向量

(1) 求数组中元素的最大值
$ vim src/get_max.cpp
#include <Rcpp.h>
using namespace Rcpp;


// [[Rcpp::export]]
double getMaxCpp(NumericVector v) {
  int n = v.size(); // vectors are describing
  double m = v[0]; // initialize
  for (int i=0; i<n; i++) {
    if( v[i] > m ){
      Rcpp::Rcout << "Now " << m << std::endl;
      m = v[i];
    }
  }
  return(m);
}

在R中添加包装函数
$ vim R/hello.R 
#' Get max of an array
#'
#' @param x an array of numbers
#'
#' @return a number
#' @export
#'
#' @examples
#' getMax(1:10)
getMax=function(x){
  return(getMaxCpp(x))
}

清空工作区，并重启R session;
> devtools::document()
> devtools::load_all()
> getMax(c(5,10,12,-6))
Now 5
Now 10
[1] 12


C++ 数组的标准写法是 std::vector<T> ，其中T可以是任何支持的类型。
> cppFunction("double getMax2(std::vector<double> v) {
	int n = v.size(); // vectors are describing
	double m = v[0]; // initialize
	for (int i=0; i<n; i++) {
	if (v[i] > m) {
			m = v[i];
		}
	}
	return(m);
}")
> getMax2(c(4,5,2))
[1] 5

解释:
	* STL 数组广泛使用，Rcpp也支持；
	* 这对访问其他C++代码或库很有帮助；
	* 一个警告: Rcpp 向量 reuse R 内存，所以 不复制；
	* STL 向量有不同的支持，所以 复制；
	* 但是不用担心，除非：巨大的数据结构，或者很多很多的调用;


==> 有一些边缘反例，需要特别注意:
cppFunction("void setSecond(Rcpp::NumericVector v) {
	v[1] = 42;
}")
v <- c(1,2,3); setSecond(v); v # as expected
## [1] 1 42 3

v <- c(1L,2L,3L); setSecond(v); v # different
## [1] 1 2 3

是什么导致的上述问题呢？ //todo 
> class(c(1,2,3))
[1] "numeric"

> class(c(1L,2L,3L))
[1] "integer"



==> 语法糖：Rcpp 数据结构中，有很多对 C++代码的函数，和对应的R函数名字和功能一致。
	* 注意：需要 Rcpp 数组，而不是 STL 。
> cppFunction("
double getMax3(NumericVector v) {
	return( max( v ) );
}
")

> getMax3(1:6)
[1] 6






(2) 求每一列的和

$ vim src/vectors.cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
Rcpp::NumericVector colSumsCpp(Rcpp::NumericMatrix mat) {
  size_t cols = mat.cols();
  Rcpp::NumericVector res(cols);
  for (size_t i=0; i<cols; i++) {
    res[i] = sum(mat.column(i));
  }
  return(res);
}

解释：
	* NumericMatrix and NumericVector 都是针对浮点数的；
	* 使用 Rcpp:: 前缀，明确命名空间
	* 获取维度 .rows() and .cols()
	* 返回值的长度，就是输入矩阵的列数
	* column(i) 获取一列，然后 sum() 求和
	* 最后的 sum() 函数内部实现了向量化，不用再循环了。


包装函数
$ vim R/hello.R 
#' Get sums of each column
#'
#' @param mat a matrix
#'
#' @return a vector
#' @export
#'
#' @examples
#' colSums2(mtcars)
colSums2=function(mat){
  mat=as.matrix(mat)
  return( colSumsCpp(mat) )
}


清空工作区，并重启R session;
> devtools::document()
> devtools::load_all()
> colSums2(mtcars)
 [1]  642.900  198.000 7383.100 4694.000  115.090  102.952  571.160   14.000   13.000  118.000   90.000

系统默认的
> colSums(mtcars)
     mpg      cyl     disp       hp     drat       wt     qsec       vs       am     gear     carb 
 642.900  198.000 7383.100 4694.000  115.090  102.952  571.160   14.000   13.000  118.000   90.000 




(3) 一个基本的循环

$ vim src/loop.cpp

#include <Rcpp.h>
#include <numeric> // for std::partial_sum
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector cumsum1(NumericVector x){
	double acc = 0; // init an accumulator variable
	NumericVector res(x.size()); // init result vector
	for(int i = 0; i < x.size(); i++){
		acc += x[i];
		res[i] = acc;
	}
	return res;
}


// An STL variant:
// [[Rcpp::export]]
NumericVector cumsum2(NumericVector x){
	// initialize the result vector
	NumericVector res(x.size());
	std::partial_sum(x.begin(), x.end(), res.begin());
	return res;
}


//Or just Rcpp sugar:
// [[Rcpp::export]]
NumericVector cumsum_sug(NumericVector x){
	return cumsum(x); // compute + return result vector
}


> devtools::document()
> devtools::load_all()
> cumsum1(1:5)
[1]  1  3  6 10 15
> cumsum2(1:5)
[1]  1  3  6 10 15
> cumsum_sug(1:5)
[1]  1  3  6 10 15



(4) 在 C++ 中调用 R 函数 

$ vim src/callR_from_cpp.cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector callFunction(NumericVector x, Function f) {
	NumericVector res = f(x);
	return res;
}

> devtools::document()
> devtools::load_all()
> callFunction(x=1:5, fivenum)
[1] 1 2 3 4 5
> callFunction(x=1:5, cumsum1)
[1]  1  3  6 10 15



(5) 取子集 

$ vim src/subsetting.cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector positives(NumericVector x) {
	return x[x > 0];
}

// [[Rcpp::export]]
List first_three(List x) {
	IntegerVector idx = IntegerVector::create(0, 1, 2);
	return x[idx];
}

// [[Rcpp::export]]
List with_names(List x, CharacterVector y) {
	return x[y];
}

> devtools::document()
> devtools::load_all()

> positives(-5:5)
[1] 1 2 3 4 5

> first_three(-5:5)
[[1]]
[1] -5

[[2]]
[1] -4

[[3]]
[1] -3

> x=-5:5; names(x)=x; with_names(x, c(1,3,4))
$`1`
[1] 1

$`3`
[1] 3

$`4`
[1] 4










7. 更多实例: 矩阵


(1) 矩阵的乘法 RcppArmadillo 库
做矩阵计算等线性代数，使用 Armadillo: C++ library for linear algebra & scientific computing
http://arma.sourceforge.net/
https://github.com/RcppCore/RcppArmadillo
R语言科学计算RcppArmadillo简明手册 https://blog.csdn.net/buduoduoorg/article/details/121185266


特点:
	* C++ 线性代数库，平衡速度和好用
	* 语法类似 matlab
	* 支持整数、浮点数和复数，向量、矩阵、立方体和场的常规运算
	* 延迟计算:
	* 研究 to 生产，如果考虑 C++ 的话，因为速度和整合能力
	* 文档齐全，论文: http://arma.sourceforge.net/arma_spmat_icms_2018.pdf
	* 现代代码
	* 积极维护

要点： 
	* 有 Rcpp 就能用
	* 使用简单，添加 LinkingTo: RcppArmadillo, Rcpp to DESCRIPTION
	* 通过Rcpp后确实简单
	* 经常更新，使用广泛，超过 600 个 CPAN 包使用；


1)先安装
> install.packages("RcppArmadillo")


2)在 DESCRIPTION 中添加 LinkingTo: Rcpp, RcppArmadillo
https://gallery.rcpp.org/articles/armadillo-eigenvalues/


3) 写代码

$ vim src/arma.cpp
#include <RcppArmadillo.h>
using namespace Rcpp;
//using namespace arma;

// [[Rcpp::depends(RcppArmadillo)]]  // 告诉 g++ 要加头文件

#define CONDIT 1000  //宏定义

// [[Rcpp::export]]
arma::rowvec colSums(arma::mat mat) {
  size_t cols = mat.n_cols; //获取维度 n_rows and n_cols，类似功能，不同包的名字略有不同
  arma::rowvec res(cols);
  for (size_t i=0; i<cols; i++) {
    res[i] = sum(mat.col(i));
  }
  return(res);
}


// [[Rcpp::export]]
RObject getRndMt(){
  arma::cube A(3,4,5,arma::fill::randu);
  std::cout<<CONDIT<<std::endl;
  return wrap(A);
}

/*
// 总是报错，原因未知 //todo
// [[Rcpp::export]]
arma::vec getEigenValues(arma::mat M) {
  return arma::eig_sym(M);
}
*/


// another simple example: outer product of a vector,
// returning a matrix
//
// [[Rcpp::export]]
arma::mat rcpparma_outerproduct(const arma::colvec & x) {
  arma::mat m = x * x.t();
  return m;
}

// and the inner product returns a scalar
//
// [[Rcpp::export]]
double rcpparma_innerproduct(const arma::colvec & x) {
  double v = arma::as_scalar(x.t() * x);
  return v;
}



编译
> devtools::document()
> devtools::load_all()
> pkgS5::positives(-5:3)
[1] 1 2 3

> pkgS5:::colSums(as.matrix(mtcars))
      [,1] [,2]   [,3] [,4]   [,5]    [,6]   [,7] [,8] [,9] [,10] [,11]
[1,] 642.9  198 7383.1 4694 115.09 102.952 571.16   14   13   118    90

> rcpparma_outerproduct( matrix(1:4, nrow=2) )
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    2    4    6    8
[3,]    3    6    9   12
[4,]    4    8   12   16

> rcpparma_innerproduct( matrix(1:4, nrow=2) )
[1] 30




(2) 矩阵的乘法 RcppEigen 库
优点
	成熟，Seurat 4 广泛使用这个库进行矩阵计算 https://github.com/RcppCore/RcppEigen
	Rcpp 作者早期作品 https://dirk.eddelbuettel.com/code/rcpp.eigen.html
	CRAN 包 质量有保证 https://cran.rstudio.com/web/packages/RcppEigen/index.html
	论文 https://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/RcppEigen/vignettes/RcppEigen-Intro.pdf?revision=3274&root=rcpp&pathrev=3274

https://www.jb51.net/article/227483.htm

R object type  | Eigen class typedef
------------ ------------ ------------ 
numeric matrix | MatrixXd
integer matrix | MatrixXi
complex matrix | MatrixXcd
numeric vector | VectorXd
integer vector | VectorXi
complex vector | VectorXcd
Matrix::dgCMatrix | SparseMatrix<double>


$ vim src/get_max.cpp
#include <Rcpp.h>
using namespace Rcpp;

//' @export
// [[Rcpp::export]]
double getMaxCpp(Rcpp::NumericVector v) {
  int n = v.size(); // vectors are describing
  double m = v[0]; // initialize
  for (int i=0; i<n; i++) {
    if( v[i] > m ){
      Rcpp::Rcout << "Now " << m << std::endl;
      m = v[i];
    }
  }
  return(m);
}

提示: C++函数前面添加 //' @export 就能把该函数暴露到R包外部。

编译找不到某个头文件了，赶紧到 DESCRIPTION 中添加 LinkingTo: Rcpp (>= 0.11.0), RcppArmadillo, RcppEigen




==> (这段可以跳过)Rstudio 异常出现4个红叉，无解，不过编译正常: https://github.com/rstudio/rstudio/issues/11364
貌似这两个矩阵库不兼容，那就先去掉一个。
LinkingTo: Rcpp (>= 0.11.0), RcppArmadillo, RcppEigen #会出现各种莫名其妙的输出，虽然还不算报错的级别。
那就只保留一个: LinkingTo: Rcpp (>= 0.11.0), RcppEigen
同时把使用 RcppArmadillo 库的cpp文件改名字: $ mv src/arma.cpp src/arma.cppWJL

很奇怪，只要加上 RcppEigen 就出现很多错误提示。
可能是 Rstudio 的bug，已经给 Rstudio 提交了 issue，大神的建议是在R包的 src/Makevars 中添加一行 PKG_CXXFLAGS = -DEIGEN_DONT_VECTORIZE
别人的解释: https://www.5axxw.com/questions/content/6cwm5k
感觉这仅仅是IDE的问题，我又把文件改回去了：DESCRIPTION 的 LinkingTo 行加入 RcppArmadillo; 文件名 src/arma.cpp;




接着可以正常编译:

> devtools::document()  #
> devtools::load_all()
> getMaxCpp( c(10,50,3,60))
Now 10
Now 50
[1] 60
> callFunction(1:10, min)
[1] 1
> callFunction(1:10, max)
[1] 10


修改 DESCRIPTION 文件中的版本号，生成R包并安装:
> devtools::build()
[1] "/data/wangjl/project/learn_R_pkg/pkgS5_0.1.1.tar.gz"
> install.packages("~/data/project/learn_R_pkg/pkgS5_0.1.1.tar.gz", repos = NULL, type = "source")
重启R session: shift+ctrl+F10;
> library(pkgS5)
> pkgS5::callFunction(1:3, max) #暴露出去的C++函数
[1] 3
> pkgS5:::timesTwo(-1:3) #内有暴露出去的C++函数
[1] -2  0  2  4  6






8. 进一步学习

- 两本书: Effective C++ and Effective STL.

- 几个自带的 短篇教程:
Additional features of attributes including specifying default arguments, linking in external C++ dependencies, and exporting C++ interfaces from packages. These features and more are covered in the Rcpp attributes vignette, vignette("Rcpp-attributes").

Automatically creating wrappers between C++ data structures and R data structures, including mapping C++ classes to reference classes. A good introduction to this topic is Rcpp modules vignette, vignette("Rcpp-modules")

The Rcpp quick reference guide, vignette("Rcpp-quickref"), contains a useful summary of Rcpp classes and common programming idioms.




9. 小结
R包制作，到这一步差不多走完主线了。
其余的细节还有很多，比如怎么把R包上传到 CRAN、 Bioconductor 等。

按照能看懂 Seurat 的标准来判断，接下来可以死扣一下 Louvain 函数的 C++ 实现，既学习算法，又巩固刚学的Rcpp。












========================================
|-- Seurat 4 R包源码解析 23: step11 非线性降维 RunUMAP()
----------------------------------------
https://zhuanlan.zhihu.com/p/533447633

1. 调包侠

# step 11 Run non-linear dimensional reduction (UMAP/tSNE)
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages = 'umap-learn')
pbmc <- RunUMAP(pbmc, dims = 1:10)

# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap")

# saveRDS(pbmc, file = "../output/pbmc_tutorial.rds")


本文只看 RunUMAP() 的R源码。
UMAP是一种高维到低维映射的方法，可以看做一种降维方法，也可以用作可视化方法。
它比tSNE更有优势：1.速度快；2.不仅能保留局部结构，还能兼顾全局结构。也就是UMAP的距离是有一定意义的。




(1) umap是调用python包执行的还是调用 R 包执行的？
UMAP 全称是 Uniform Manifold Approximation and Projection.
Finds a low dimensional embedding of the data that approximates an underlying manifold.
原作者提供的是py实现。


测试当前系统是否安装该py包
$ pip3 list | grep -i umap
umap-learn                        0.5.2


R 中调用py的依赖包是: reticulate, 版本 1.21。





==> try1. 默认是用R 原生的 uwot 包实现的 UMAP，我当前使用的版本是  uwot 0.1.10。

> pbmc1 <- RunUMAP(pbmc, dims = 1:10) #默认参数 umap.method = "uwot", metric = "cosine",
Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric
To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'
# 默认使用R原生的 UWOT 使用 cosine 距离，而不是 用 reticulate 包调用 python 包 UMAP。
# 如果想 通过 reticulate 调用 Python UMAP 包，可以设置 umap.method='umap-learn', metric='correlation'

This message will be shown once per session
# 本提醒每个R session 只显示一次。

14:32:22 UMAP embedding parameters a = 0.9922 b = 1.112 # UMAP 嵌入参数a,b
14:32:22 Read 2638 rows and found 10 numeric columns    # 读入 2638 行(细胞)，发现10列(PC)
14:32:22 Using Annoy for neighbor search, n_neighbors = 30       #使用 Annoy 找到最近的 n_neighbors=30个细胞
14:32:22 Building Annoy index with metric = cosine, n_trees = 50 #使用 metric=cosine 距离，构建 n_trees=50 棵树
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
14:32:22 Writing NN index file to temp file /tmp/RtmpMbVSJL/file3bf4611d337478 #写入NN 索引到临时文件
14:32:22 Searching Annoy index using 1 thread, search_k = 3000 #单线程搜索 Annoy 索引，search_k = 3000
14:32:23 Annoy recall = 100%
14:32:23 Commencing smooth kNN distance calibration using 1 thread #使用单线程平滑化 KNN 距离。
14:32:24 Initializing from normalized Laplacian + noise            # 标准化过的 Laplacian + 噪音
14:32:24 Commencing optimization for 500 epochs, with 105124 positive edges  # 遍历 500 epochs, 有 105124 条正边。
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
14:32:26 Optimization finished #优化结束。







==> try2. 尝试调用 py UMAP包:
> pbmc2 <- RunUMAP(pbmc, dims = 1:10, umap.method='umap-learn', metric='correlation')
Epochs completed: 100%| ██████████ 500/500 [00:03]UMAP(angular_rp_forest=True, local_connectivity=1, metric='correlation', min_dist=0.3, n_neighbors=30, random_state=RandomState(MT19937) at 0x7FEDD6687258, verbose=True)
Fri Jun 24 14:34:10 2022 Construct fuzzy simplicial set #构建模糊简化集合
Fri Jun 24 14:34:12 2022 Finding Nearest Neighbors      #KNN 找最近邻
Fri Jun 24 14:34:12 2022 Finished Nearest Neighbor Search
Fri Jun 24 14:34:12 2022 Construct embedding     #构建嵌入
Fri Jun 24 14:34:16 2022 Finished embedding


运行 RunUMAP() 后，在 pbmc@reductions 这个list中放入新的名字为 umap 的DimReduc对象。
> names(pbmc@reductions)
[1] "pca"
> names(pbmc1@reductions)
[1] "pca"  "umap"
> names(pbmc2@reductions)
[1] "pca"  "umap"
> class(pbmc2@reductions$umap)
[1] "DimReduc"
attr(,"package")
[1] "SeuratObject"


目测UMAP的坐标数值，不一致，也看不出来个所以然：
> head(Embeddings(pbmc1, reduction = "umap"))
                    UMAP_1    UMAP_2
AAACATACAACCAC-1 -3.304555 -3.914703
AAACATTGAGCTAC-1 -5.620712 10.682330
AAACATTGATCAGC-1 -5.630144 -6.400627
AAACCGTGCTTCCG-1  9.145644  5.535673
AAACCGTGTATGCG-1 -5.354362  2.053312
AAACGCACTGGTAC-1 -3.218432 -6.085276

> head(Embeddings(pbmc2, reduction = "umap"))
                     UMAP_1     UMAP_2
AAACATACAACCAC-1 -2.1560519 -1.8735013
AAACATTGAGCTAC-1  0.3027341 12.8482037
AAACATTGATCAGC-1 -1.4721704  1.8719281
AAACCGTGCTTCCG-1 14.9450207  0.7575974
AAACCGTGTATGCG-1  3.1465802 -4.9975662
AAACGCACTGGTAC-1 -3.4616749  0.2224449


同时拿到umap坐标和cluster编号：
> head(FetchData(pbmc1, vars=c("UMAP_1", "UMAP_2", "seurat_clusters")))
                    UMAP_1    UMAP_2 seurat_clusters
AAACATACAACCAC-1 -3.304555 -3.914703               2
AAACATTGAGCTAC-1 -5.620712 10.682330               3
AAACATTGATCAGC-1 -5.630144 -6.400627               2
AAACCGTGCTTCCG-1  9.145644  5.535673               1
AAACCGTGTATGCG-1 -5.354362  2.053312               6
AAACGCACTGGTAC-1 -3.218432 -6.085276               2




可视化查看效果，貌似 py版的坐标范围更大，cluster7 分的更开。
tips: 以后似乎可以试试 Py 版的 UMAP 实现，理论上更标准。
> library(ggplot2)
> p1=DimPlot(pbmc1, reduction = "umap", label=T)+ggtitle("R:uwot | cosine")
> p2=DimPlot(pbmc2, reduction = "umap", label=T)+ggtitle("Py:umap-learn | correlation")
> p1+p2

# fig here:





==> try3: umap.method = "uwot-learn" 参数已经作废了，尝试确实和p1图一致。
> pbmc3 <- RunUMAP(pbmc, dims = 1:10, umap.method = "uwot-learn")
最后有一个警告
Warning message:
In RunUMAP.default(object = data.use, reduction.model = reduction.model,  :
  'uwot-learn' is deprecated. Set umap.method = 'uwot' and return.model = TRUE #按这个提示再来一遍，看返回的是个啥。

> p3=DimPlot(pbmc3, reduction = "umap", label=T)+ggtitle("R:umap-learn | cosine")
> p1+p3 #一致



==> try3B: umap.method = "uwot", return.model = TRUE
pbmc3_2 <- RunUMAP(pbmc, dims = 1:10, umap.method = "uwot", return.model = TRUE)

p3_2=DimPlot(pbmc3_2, reduction = "umap", label=T)+ggtitle("R:uwot return | cosine")
p1+p3_2 #还是一致


到底模型返回到哪里了？有啥用？
根据函数 RunUMAP.default() 最后一行知道保存位置。
> class(pbmc3_2@reductions$umap@misc$model)
[1] "list"
> names(pbmc3_2@reductions$umap@misc$model)
 [1] "embedding"            "scale_info"           "n_neighbors"          "search_k"            
 [5] "local_connectivity"   "n_epochs"             "alpha"                "negative_sample_rate"
 [9] "method"               "a"                    "b"                    "gamma"               
[13] "approx_pow"           "metric"               "norig_col"            "pcg_rand"            
[17] "pca_models"

> names(pbmc3@reductions$umap@misc$model) 输出同上。
> names(pbmc2@reductions$umap@misc$model) #NULL
> names(pbmc1@reductions$umap@misc$model) #NULL

用处？可能就是备查当时umap模型的各种参数吧？比如 
> pbmc3_2@reductions$umap@misc$model$a
        a 
0.9921756 






==> try4: UMAP 的最新版本是 densmap，可以尝试
> pbmc4 <- RunUMAP(pbmc, dims = 1:10, umap.method = "umap-learn", densmap=T)
Epochs completed: 100%| ██████████ 700/700 [00:06]UMAP(angular_rp_forest=True, densmap=True, local_connectivity=1, metric='cosine', min_dist=0.3, n_neighbors=30, random_state=RandomState(MT19937) at 0x7FEDD6687258, verbose=True)
Fri Jun 24 14:29:06 2022 Construct fuzzy simplicial set
Fri Jun 24 14:29:09 2022 Finding Nearest Neighbors
Fri Jun 24 14:29:10 2022 Finished Nearest Neighbor Search
Fri Jun 24 14:29:12 2022 Construct embedding
Fri Jun 24 14:29:12 2022 Computing original densities
Fri Jun 24 14:29:35 2022 Finished embedding

> p4=DimPlot(pbmc4, reduction = "umap", label=T)+ggtitle("Py:umap-learn densmap")
> p2+p4 #densMAP figure



# 使用 metric='correlation'
> pbmc4_2 <- RunUMAP(pbmc, dims = 1:10, umap.method = "umap-learn", densmap=T, metric='correlation')
> p4_cor=DimPlot(pbmc4_2, reduction = "umap", label=T)+ggtitle("Py:umap-learn densmap | correlation")
> p2+p4_cor #基本一致


densMap 适合哪些场景呢？至少不适合pbmc，是否细胞过万会好点？ //todo






(2) UMAP的输入可以是PC还可以是基因集
可以设置 dims=1:30 使用PCA的某些维度作为UMAP的输入。
还可以设置 features=someGenes 使用这些基因作为UMAP的输入。默认使用的 slot="data"。

HVG=pbmc@assays$RNA@var.features
length(HVG) #2000
head(HVG) #"PPBP"   "LYZ"    "S100A9" "IGLL5"  "GNLY"   "FTL" 
pbmc5 <- RunUMAP(pbmc, #dims = 1:10, 
                 features = HVG,
                 umap.method = "umap-learn", metric='correlation')
library(ggplot2)
DimPlot(pbmc5)+ggtitle("RunUMAP using HVGs, not dims")


# fig here








(3) 目前 umap-learn py包支持的距离

# 版本号:
$ pip3 list | grep -i umap
umap-learn                        0.5.2


# 目前支持的距离
$ python3
>>> import umap
>>> help(umap.UMAP)

* euclidean
* manhattan
* chebyshev
* minkowski
* canberra
* braycurtis
* mahalanobis
* wminkowski
* seuclidean
* cosine
* correlation
* haversine
* hamming
* jaccard
* dice
* russelrao
* kulsinski
* ll_dirichlet
* hellinger
* rogerstanimoto
* sokalmichener
* sokalsneath
* yule

定义另外补充。
效果见下图，如果没画出来。




# 有些距离能画，有些报错。过半效果很差。其他效果类似。
dist.defines=c("euclidean", "manhattan", "chebyshev", "minkowski", "canberra", "braycurtis",
               "mahalanobis", "wminkowski", "seuclidean", "cosine", "correlation", "haversine",
               "hamming", "jaccard", "dice", "russelrao", "kulsinski", "ll_dirichlet",
               "hellinger", "rogerstanimoto", "sokalmichener", "sokalsneath", "yule")
length(dist.defines) #23
library(ggplot2)
figs=list()
#for(i in 1:length(dist.defines)){

i=0
{
  i=i+1
  dist=dist.defines[i]
  message(">>[", i, "/", length(dist.defines), "] ", dist)
  #
  if( !(i %in% c(4, #minkowski too slow
                 8,  #wminkowski too slow
                 9,  #seuclidean Error ZeroDivisionError: division by zero
                 12, #ValueError: haversine is only defined for 2 dimensional data
                 # have warnings:13, 14, 15, 17,21,
                 16, #russelrao: ValueError: metric is neither callable nor a recognised string
                 19, #hellinger:ValueError: Metric 'hellinger' does not support negative values
                  -1) ) ){
    pbmc5 <- RunUMAP(pbmc, dims = 1:10, umap.method = "umap-learn", metric=dist)
    p1=DimPlot(pbmc5, label=T)+
      ggtitle(dist)
    figs[[i]]=list(p1)
  }
}
#}

length(figs)
class(figs[[1]][[1]])

#fig1
pics=list()
j=0
for(i in 1:length(figs)){
  #if("gg" %in% class(figs[[i]][[1]]) ){
  if( inherits(figs[[i]][[1]], what=c("ggplot")) ){
    j=j+1
    pics[[j]]=figs[[i]][[1]]+theme(legend.position = "none")
  }else{
    print(i)
  }
}
length(pics) #17
library(patchwork)
plots1 = wrap_plots(pics, ncol = 5)
plots1 #fig1


#fig2: only first 8 figs
pics=list()
j=0
for(i in 1:length(figs)){
  #if("gg" %in% class(figs[[i]][[1]]) ){
  if( inherits(figs[[i]][[1]], what=c("ggplot")) ){
    j=j+1
    pics[[j]]=figs[[i]][[1]]+theme(legend.position = "none")
    if(j>8) break;
  }else{
    print(i)
  }
}
length(pics) #17
library(patchwork)
plots2 = wrap_plots(pics, ncol = 3)
plots2 #fig2












2. 源码解析 

// todo 
RunUMAP
	* RunUMAP.Graph 
	* RunUMAP.Neighbor






3. R tips


(1) 手动调用R包做UMAP

准备数据: pbmc 3k 数据集，做好PCA后，取前10个PC。
> data.use <- Embeddings(pbmc[['pca']])[, 1:10]
> dim(data.use) #[1] 2638   10
> data.use[1:3,1:4]
                       PC_1       PC_2      PC_3      PC_4
AAACATACAACCAC-1 -4.7296855 -0.5184265 -0.762322 -2.315679
AAACATTGAGCTAC-1 -0.5174029  4.5918957  5.909192  6.911886
AAACATTGATCAGC-1 -3.1891063 -3.4695154 -0.831371 -2.001998

> is.list(data.use)
[1] FALSE

> class(data.use)
[1] "matrix" "array" 


> library(future)
> nbrOfWorkers()
[1] 1




==> 关于umap的更多参数的意义，见源码解析 2.2 RunUMAP.Seurat() 参数解释部分。
UMAP可以设置的主要参数如下：
n_neighbors：这决定了在流形结构的局部近似中使用的相邻点的数量。较大的值将导致在丢失详细的局部结构的情况下保留更多的全局结构。一般来说，这个参数应该经常在 5 到 50 的范围内，选择 10 到 15 是一个合理的默认值。Seurat 默认是 30。

min_dist：这控制嵌入允许将点压缩在一起的紧密程度。较大的值确保嵌入点分布更均匀，而较小的值允许算法更准确地针对局部结构进行优化。合理的值在 0.001 到 0.5 的范围内，0.1 是合理的默认值。Seurat 默认是 0.3。

metric：这决定了用于测量输入空间中距离的度量的选择。已经编码了各种各样的度量标准，并且可以传递用户定义的函数，只要它已经通过 numba 进行了 JITd。




library(uwot)
result=umap(
	X = data.use, #矩阵: 前dims个PC列
	n_threads = nbrOfWorkers(), #线程数
	n_neighbors = as.integer(x = 30), #默认30
	n_components = as.integer(x = 2), #默认2
	metric = 'cosine', #这个参数
	n_epochs = NULL,
	learning_rate = 1,
	min_dist = 0.3,
	spread = 1,
	set_op_mix_ratio = 1,
	local_connectivity = 1,
	repulsion_strength = 1,
	negative_sample_rate = 5,
	a = NULL,
	b = NULL,
	fast_sgd = F, #uwot.sgd
	verbose = T,
	ret_model = F #return.model
)

输出:
16:28:32 UMAP embedding parameters a = 0.9922 b = 1.112
16:28:32 Read 2638 rows and found 10 numeric columns
16:28:32 Using Annoy for neighbor search, n_neighbors = 30
16:28:32 Building Annoy index with metric = cosine, n_trees = 50
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
16:28:33 Writing NN index file to temp file /tmp/RtmpMbVSJL/file3bf46128949cc1
16:28:33 Searching Annoy index using 1 thread, search_k = 3000
16:28:33 Annoy recall = 100%
16:28:33 Commencing smooth kNN distance calibration using 1 thread
16:28:34 Initializing from normalized Laplacian + noise
16:28:34 Commencing optimization for 500 epochs, with 105124 positive edges
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
**************************************************|
16:28:36 Optimization finished


> class(result)
[1] "matrix" "array" 
> head(result)
          [,1]      [,2]
[1,] -3.304555 -3.914703
[2,] -5.620712 10.682330
[3,] -5.630144 -6.400627
[4,]  9.145644  5.535673
[5,] -5.354362  2.053312
[6,] -3.218432 -6.085276
> dim(result)
[1] 2638    2


> result2=as.data.frame(result)
> colnames(result2)=c("umap1", "umap2")
> head(result2, n=2)
      umap1     umap2
1 -3.304555 -3.914703
2 -5.620712 10.682330


> library(ggplot2)
> ggplot(result2, aes(umap1, umap2))+geom_point()
> result2$cluster=pbmc$seurat_clusters
> p_r=ggplot(result2, aes(umap1, umap2, color=cluster))+
	geom_point(size=0.5)+
	theme_classic()+ggtitle("R uwot pkg")
> p1+p_r #和之前的 DimPlot(pbmc1) 结果一样。





(2) 使用R调用py函数: reticulate R包

很值得参考的R调用py包的源码:

library(reticulate)
...
#' @importFrom reticulate py_module_available py_set_seed import
...
  umap.output <- switch(
    EXPR = umap.method,

    #(B1) 执行py包 umap-learn (可选)
    'umap-learn' = {
      # 检查几个py包: umap, sklearn
      if (!py_module_available(module = 'umap')) {
        stop("Cannot find UMAP, please install through pip (e.g. pip install umap-learn).")
      }
      if (!py_module_available(module = 'sklearn')) {
        stop("Cannot find sklearn, please install through pip (e.g. pip install scikit-learn).")
      }

      # 设置随机数种子
      if (!is.null(x = seed.use)) {
        py_set_seed(seed = seed.use)
      }

      # n.epochs 默认为空，跳过
      if (typeof(x = n.epochs) == "double") {
        n.epochs <- as.integer(x = n.epochs)
      }

      # import umap, sklearn
      umap_import <- import(module = "umap", delay_load = TRUE)
      sklearn <- import("sklearn", delay_load = TRUE)

      # 检查版本号，如果是 densmap，则需要 umap-learn >=0.5.0
      if (densmap &&
          numeric_version(x = umap_import$pkg_resources$get_distribution("umap-learn")$version) <
          numeric_version(x = "0.5.0")) {
        stop("densmap is only supported by versions >= 0.5.0 of umap-learn. Upgrade umap-learn (e.g. pip install --upgrade umap-learn).")
      }

      # 随机数种子
      random.state <- sklearn$utils$check_random_state(seed = as.integer(x = seed.use))

      # umap 参数列表
      umap.args <- list(
        n_neighbors = as.integer(x = n.neighbors),
        n_components = as.integer(x = n.components),
        metric = metric,
        n_epochs = n.epochs,
        learning_rate = learning.rate,
        min_dist = min.dist,
        spread = spread,
        set_op_mix_ratio = set.op.mix.ratio,
        local_connectivity = local.connectivity,
        repulsion_strength = repulsion.strength,
        negative_sample_rate = negative.sample.rate,
        random_state = random.state,
        a = a,
        b = b,
        metric_kwds = metric.kwds,
        angular_rp_forest = angular.rp.forest,
        verbose = verbose
      )

      # 如果版本号大于 0.5.0 ，还可以加入 densmap 参数
      if (numeric_version(x = umap_import$pkg_resources$get_distribution("umap-learn")$version) >=
          numeric_version(x = "0.5.0")) {
        umap.args <- c(umap.args, list(
          densmap = densmap,
          dens_lambda = dens.lambda,
          dens_frac = dens.frac,
          dens_var_shift = dens.var.shift,
          output_dens = FALSE
        ))
      }
      # 执行umap: 参数、执行
      umap <- do.call(what = umap_import$UMAP, args = umap.args)
      umap$fit_transform(as.matrix(x = object))
    },
...


官网教程: https://rstudio.github.io/reticulate/index.html
# install.packages("reticulate")

> library(reticulate)
# use_python("/usr/local/bin/python") # 设置使用哪个python

> Sys.which("python")
                             python 
"/home/wangjl/anaconda3/bin/python" 

# 调用py的模块
> os <- import("os")
> os$listdir(".") #同 dir()
> os$getcwd() #同 getwd()

> time = import("time")
> time$time() #[1] 1656060594


> py_module_available(module = 'sklearn') #查看py包是否可用
[1] TRUE

> sklearn <- import("sklearn", delay_load = TRUE)
> sklearn$show_versions()
System:
    python: 3.7.0 (default, Jun 28 2018, 13:22:42)  [GCC 7.2.0]
...




==> 还可以在R中引入 py 脚本，直接使用py函数。
$ vim a1.py 
import pandas
def read_flights(file):
	flights = pandas.read_csv(file)
	flights = flights[flights['dest'] == "ORD"]
	flights = flights[['carrier', 'dep_delay', 'arr_delay']]
	flights = flights.dropna()
	return flights

import time
def now():
	return time.strftime("%Y/%m/%d %H:%M:%S", time.localtime())

# in R 
> source_python("a1.py")
> # flights <- read_flights("flights.csv")
> now() #测试效果，符合预期
[1] "2022/06/24 17:01:20"



==> 可以在 R markdown 中使用python
```{pyhton}
import time;
print(time.time())
```



==> 在R console 中交互式运行py和R
> repl_python () #进入 Python 环境
>>> a=[1,2,3]
>>> print(len(a))
>>> exit #退出 Python 环境，好像不好使，要用快捷键 Ctrl+D 
> 



==> R 中运行一行py命令，貌似无法获取返回值
> py_run_string("a = [1, 2, 3]; b = [2, 3, 4]; c = list(zip(a, b)); print(c)") #好像无法获取返回值
[(1, 2), (2, 3), (3, 4)]



==> 随机数
> py_set_seed(seed = seed.use) #为py和numpy设置随机数种子
等价于 
import os
os.environ["PYTHONHASHSEED"] = "0"
import random 
random.seed(5)

# 如果有 numpy 
import numpy as np
np.random.seed(5)


> sklearn$utils$check_random_state(seed = as.integer(x = seed.use))






(3) 比较两个R包版本号的大小 
这是两个问题：怎么获取R包版本号，怎么比较版本号。

> numeric_version
function (x, strict = TRUE) 
.make_numeric_version(x, strict, .standard_regexps()$valid_numeric_version)
<bytecode: 0x55d6a1974110>
<environment: namespace:base>

> numeric_version(x = "0.5.0") 
[1] ‘0.5.0’

> class(numeric_version(x = "0.5.0") )
[1] "numeric_version"

> numeric_version(x = "0.5.0") > numeric_version(x = "1.3.0")
[1] FALSE

> packageVersion("Seurat")
[1] ‘4.1.0’

> if( packageVersion("Seurat") > numeric_version(x = "3") ){ print("Greater than 3")}
[1] "Greater than 3"





(4) 使用 py 调用 UMAP
在R中导出数据到文件，在py中读入数据并计算umap坐标，然后用R画图。

> dim(data.use)
[1] 2638   10
> data.use[1:2,1:4]
                       PC_1       PC_2      PC_3      PC_4
AAACATACAACCAC-1 -4.7296855 -0.5184265 -0.762322 -2.315679
AAACATTGAGCTAC-1 -0.5174029  4.5918957  5.909192  6.911886

> write.table(data.use, "backup/dims.data.txt",quote = F)




在Py中
# pip install umap-lear
# pip install scikit-learn

import umap 
import sklearn

# 设置随机数
import os
os.environ["PYTHONHASHSEED"] = "0"
import random 
import sklearn
random.seed(42)

# 如果有 numpy 
import numpy as np
np.random.seed(42)


random.state = sklearn.utils.check_random_state(seed = 42)

model=umap.UMAP(
	n_neighbors = 30,
	n_components = 2,
	metric = "correlation",
	n_epochs = None,
	learning_rate = 1,
	min_dist = 0.3,
	spread = 1,
	set_op_mix_ratio = 1,
	local_connectivity = 1,
	repulsion_strength = 1,
	negative_sample_rate = 5,
	random_state = random.state,
	a = None,
	b = None,
	metric_kwds = None, #metric.kwds,
	angular_rp_forest = None, #angular.rp.forest,
	verbose = True
)

dat=np.loadtxt("backup/dims.data.txt",delimiter=" ", skiprows=1, usecols=[x for x in range(1,11)])
print(dat.shape) #(2638, 10)

result=model.fit_transform(dat)
print(result.shape) #(2638, 2)

# output 
np.savetxt("backup/umap_output.py.txt", result)


# 使用R画图
> umap.py=read.table("backup/umap_output.py.txt")
> umap.py$cluster=pbmc1$seurat_clusters
> library(ggplot2)
> ggplot(umap.py, aes(V1, V2, color=cluster))+geom_point()













========================================
|-- Seurat 4 R包源码解析 24: step11 降维可视化 DimPlot()
----------------------------------------
1. 调包侠 
# step 11 Run non-linear dimensional reduction (UMAP/tSNE)
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages = 'umap-learn')
pbmc <- RunUMAP(pbmc, dims = 1:10)

# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap")

# saveRDS(pbmc, file = "../output/pbmc_tutorial.rds")

本文看 DimPlot(). 


(1) cols= 参数
颜色向量，对应着 ident 分类。 
也可以是一个字符串或数字，对应着 RColorBrewer::brewer.pal.info，对数字支持不好，不建议使用。详情见本文 3.8.
默认使用 ggplot2 的颜色。
本包也提供了5个颜色板，DiscretePalette 回车查看。

library(RColorBrewer)
dim(RColorBrewer::brewer.pal.info) #35 3
RColorBrewer::brewer.pal.info
RColorBrewer::brewer.pal.info[1,]
barplot( rep(1,11), col=RColorBrewer::brewer.pal(11, "BrBG") )

# 颜色
g1=DimPlot(pbmc)
g2=DimPlot(pbmc, cols='Set1')+ggtitle("cols='Set1'") #使用R内置颜色版(35个)
# brewer.pal.info
# rownames(brewer.pal.info)

g3=DimPlot(pbmc, cols=1)+ggtitle("cols=1") #seq 系列的第1个(Blues)
# 不建议使用数字，函数写的不完善，不支持 type 参数

g4=DimPlot(pbmc, cols='alphabet', )+ggtitle("cols='alphabet'") #Seurat 内置颜色版(5个)
# c('alphabet', 'alphabet2', 'glasbey', 'polychrome', 'stepped')

(g1+g2)/(g3+g4)

图fa1







(2) group.by=分组，默认是 ident 分组

1) 看基因数高的细胞在哪里？
DimPlot(pbmc)
# Fig1 添加一列 isGeneNumHigh: 细胞表达的基因书是否超过1000个?
pbmc$isGeneNumHigh=pbmc$nFeature_RNA>1000
pbmc$isGeneNumHigh=factor(pbmc$isGeneNumHigh, levels = c(T,F))
table(pbmc$isGeneNumHigh)
# TRUE FALSE
# 524  2114
DimPlot(pbmc, group.by = "isGeneNumHigh", cols = c("red", "grey"))
# 图


2) 看基因数高、counts数高的细胞在哪里？
# fig2 再添加一列 isCountsHigh: 细胞表达的基因书是否超过1000个?
pbmc$isCountsHigh=pbmc$nCount_RNA>2500
pbmc$isCountsHigh=factor(pbmc$isCountsHigh, levels = c(T,F))
table(pbmc$isCountsHigh)
#TRUE FALSE
#932  1706
#当有2个group.by时，变为分面
DimPlot(pbmc, group.by = c("isGeneNumHigh", "isCountsHigh"),
        cols = c("red", "grey"))
# 图






(3) CellSelector() 手工圈起来一部分细胞
显示到 Rstudio 的 Viewer 选项卡，而不是 Plots 选项卡。这是一个支持js的画图设备。

./seurat-4.1.0/R/visualization.R:4154:CellSelector <- function(plot, object = NULL, ident = 'SelectedCells', ...) {

# CellSelector
p1=DimPlot(pbmc); p1
# Follow instructions in the terminal to select points
cells.located <- CellSelector(plot = p1)
cells.located #返回细胞id
# [1] "ACGTCGCTCCTGAA-1" "ACTTCAACAAGCAA-1" "CACCGGGACTTCTA-1" "CGATACGACAGGAG-1" "CGCAGGTGGGAACG-1"
# [6] "GCCCATACAGCGTT-1" "GCCTCAACTCTTTG-1" "GTATTAGAAACAGA-1"


# Automatically set the identity class of selected cells and return a new Seurat object
pbmc2 <- CellSelector(plot = p1, object = pbmc, ident = 'SelectedCells')
> table(pbmc2@meta.data$seurat_clusters) #没变
  0   1   2   3   4   5   6   7   8 
684 481 476 344 291 162 155  32  13

> table(pbmc2@active.ident) #新增一类
SelectedCells             0             1             2             3             4             5 
           36           681           480           476           344           291           162 
            6             8 
          155            13

> levels(pbmc2) #新增一类
[1] "SelectedCells" "0"             "1"             "2"             "3"             "4"            
[7] "5"             "6"             "8" 






(4) HoverLocator() 鼠标悬停可见细胞id及其它 meta.data
显示到 Rstudio 的 Viewer 选项卡，而不是 Plots 选项卡。这是一个支持js的画图设备。

./seurat-4.1.0/R/visualization.R:4575:HoverLocator <- function(
p1=DimPlot(pbmc); p1
HoverLocator(p1)
HoverLocator(plot = p1, information = FetchData(object = pbmc, vars = 'percent.mt'))  #细胞的其他信息
HoverLocator(plot = p1, information = FetchData(object = pbmc, vars = c('percent.mt', "CD79A") )) #更多信息





(5) 高亮显示一部分细胞
DimPlot(pbmc, label=T)
DimPlot(pbmc, cells.highlight=5) #一个细胞
DimPlot(pbmc, cells.highlight=WhichCells(pbmc, idents=5)) #一群细胞，method1
DimPlot(pbmc, cells.highlight=WhichCells(pbmc, idents=5),
        cols.highlight = "blue" ) #指定高亮细胞的颜色
DimPlot(pbmc, cells.highlight=WhichCells(pbmc, idents=5),
        cols.highlight = "blue",
        sizes.highlight = 2) #指定高亮细胞的大小

DimPlot(pbmc, cells.highlight=WhichCells(pbmc, expression = CD79A>3)) #一群细胞，method2
# 取子集后，取细胞名字
DimPlot(pbmc, #group.by = "isExpHigh", #该参数在高亮显示时不影响显示
        cells.highlight=Cells(subset(pbmc, subset=isExpHigh==T)) ) #一群细胞，method3

# 多群细胞
DimPlot(pbmc,
        cells.highlight=list(
          c5=WhichCells(pbmc, idents=5),
          c8=WhichCells(pbmc, idents=8),
          c2=WhichCells(pbmc, idents=2)
        ),
        sizes.highlight = c(4.5, 1.5, 0.5), #这就很奇怪了，尺寸和出现的对应
        #cols.highlight=list(c5="red", c8="orange")
        cols.highlight=c("orange", "blue", "purple") #颜色对应关系总是不对
        # 貌似它总是按照order(listNames)的顺序染色
)
# 此处有bug，而且不容忽视的bug: 多个高亮细胞list时刻，和指定颜色对应不上。 //todo 见本文 4.1









2. 源码解析 

函数:
DimPlot |ok;
	DefaultDimReduc | ok;
		* FilterObjects |had in 3;
	SingleDimPlot | ok;
	LabelClusters | ok,  需要更深入的理解 ggplot2.
		* GetXYAesthetics |详解 15-2.10
		* GeomSpatial
		* layer_scales
		* coord_fixed
	cowplot::theme_cowplot | ok 3.10
	FacetTheme | ok 3.16
	CenterTitle | ok 3.16
	
	HoverLocator | todo
	CellSelector | todo
	
	SetHighlight //再看一遍 ./seurat-4.1.0/R/visualization.R:6716:SetHighlight <- function(










3. R tips 

(1) 按列名取数据框子集，列名为NULL时

# 添加一列
df1=mtcars[1:4, 1:2]; df1
newCol='xx0'
df1[, newCol]=1:4; df1

# 取列名为null的一列
df1[, c("mpg", newCol)]
split.by=NULL
df1[, c('mpg', newCol, split.by)] #列名为NULL时就相当于不存在
#                mpg xx0
#Mazda RX4      21.0   1
#Mazda RX4 Wag  21.0   2
#Datsun 710     22.8   3
#Hornet 4 Drive 21.4   4






(2) rlang::`!!` 注入表达式功能（较难）
如果读不懂，可以跳过。后面会再开一篇细说。

源码: facets = vars(!!sym(x = split.by)),

> library(rlang)
> `!!`
function (x) 
{
    abort("`!!` can only be used within a defused argument.", 
        call = caller_env())
}
<bytecode: 0x55cf5a0a5cd8>
<environment: namespace:rlang>

defuse / diːˈfjuːz / vt. 平息；去掉……的雷管；使除去危险性


示例1:
> sym("x")  #字符串 转为 符号
x
> class(sym("x"))
[1] "name"
> x=3
> eval(sym("x")) #求值，使用环境中的变量值
[1] 3
> eval(sym("x"), data.frame(x=50)) #求值，在指定环境中寻找值
[1] 50

注入表达式: 把一个表达式注入到另一个中，实现组装表达式效果。
> a1=quo(exp(x))
> a2=quo( (1-!!a1)/(1+!!a1) )
> a2
<quosure>
expr: ^(1 - (^exp(x))) / (1 + (^exp(x)))
env:  global

求值:
> eval_tidy(a2, data.frame(x=0))
[1] 0
> eval_tidy(a2, data.frame(x=100))
[1] -1
> eval_tidy(a2, data.frame(x=-100))
[1] 1



示例2: 从函数参数传入公式。
mean_in_data_rl <- function(data, expr) {
  quosure0 <- enquo(expr)           # capture user expression
  print(quosure0)
  quosure <- quo(mean(!!quosure0))  # wrap it in `mean`
  print(quosure)
  eval_tidy(quosure, data)
}

l.per.cubic.i <- 2.54^3 / 1000
> mean_in_data_rl(mtcars, disp * l.per.cubic.i)
<quosure> #第一个捕获传入的表达式
expr: ^disp * l.per.cubic.i
env:  global
<quosure>  #第二个，把第一个表达式注入到第二个表达式中，相当于变量替换
expr: ^mean(^disp * l.per.cubic.i)
env:  0x5612f0ee7f70
[1] 3.780854

实质上就是如下计算，只不过实现了把公式传入函数。
> mean(mtcars$disp * 2.54^3 / 1000 ) 
[1] 3.780854



(3) match(x, table) 返回x在table中的编号
> match(c(1,5), -5:5) 
[1]  7 11


(4) 修改数据框的某几个列名
tmp=iris[1:2,]
colnames(tmp)[ c(2,3) ]=c("x2", "x3") #修改第2和第三个列名
> tmp
  Sepal.Length  x2  x3 Petal.Width Species
1          5.1 3.5 1.4         0.2  setosa
2          4.9 3.0 1.4         0.2  setosa



(5) 栅格化点图 scattermore::geom_scattermore()
栅格化能显著降低密集点图的文件大小。

> scattermore::geom_scattermore
function (mapping = NULL, data = NULL, stat = "identity", position = "identity", 
    ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, 
    interpolate = FALSE, pointsize = 0, pixels = c(512, 512)) 
{
    ggplot2::layer(data = data, mapping = mapping, stat = stat, 
        position = position, geom = GeomScattermore, show.legend = show.legend, 
        inherit.aes = inherit.aes, params = list(na.rm = na.rm, 
            interpolate = interpolate, pointsize = pointsize, 
            pixels = pixels, ...))
}
<bytecode: 0x55b5a01b3988>
<environment: namespace:scattermore>

R文档例子:
library(ggplot2)
library(scattermore)
set.seed(2022)
ggplot(data.frame(x=rnorm(100000), y=rexp(100000))) +
  geom_scattermore(aes(x,y,color=x),
                   pointsize=3,
                   alpha=0.1,
                   pixels=c(1000,1000),
                   interpolate=TRUE) +
  scale_color_viridis_c()


源码:
	plot=ggplot(data=data)
    
	plot + geom_scattermore(
      mapping = aes_string(
        x = dims[1],
        y = dims[2],
        color = paste0("`", col.by, "`"), #
        shape = shape.by,
        alpha = alpha.by
      ),
      pointsize = pt.size,
      pixels = raster.dpi
    )




(6) 放大 ggplot2 图例的点，修改图例的标题
library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+
  theme_bw()+ggtitle("Fig1")
g1 #原图
g2=g1+guides(color = guide_legend(override.aes = list(size = 3)))+ #图例放大
  ggtitle("Fig2"); g2
g3=g2+labs(color = NULL, title = "Fig3") #修改图例的标题
g3
g1+g2+g3

图6


(7) R语言布尔运算的性质
问题: if (length(x = cols) == 1 && (is.numeric(x = cols) || cols %in% rownames(x = brewer.pal.info))) {}
这个布尔运算是怎么结合的？
盲猜：从左到右依次进行。

验证: 前2个为T，则与第三个无关
> 1 && 1 || 0
[1] TRUE
> 1 && 1 || 1
[1] TRUE

验证2: 前2个为F，则看第三个
> 1 && 0 || 0
[1] FALSE
> 1 && 0 || 1
[1] TRUE


布尔运算中，一个&是按向量分别求布尔值:
> c(1,1) & c(1,0)
[1]  TRUE FALSE

两个&&则是只看第一个元素的运算结果:
> c(1,1) && c(1,0)
[1] TRUE
> c(0,1) && c(1,0)
[1] FALSE
> c(0,1) && c(1,1)
[1] FALSE





(8) ggplot2 使用色板: scale_color_brewer(palette =)
源码: scale_color_brewer(palette = cols, na.value = na.value)

函数原型:
scale_colour_brewer(
  ...,
  type = "seq",
  palette = 1,
  direction = 1,
  aesthetics = "colour"
)

重点是 palette	参数
If a string, will use that named palette. 
If a number, will index into the list of palettes of appropriate type. 
The list of available palettes can found in the Palettes section.

使用字符串时，毫无争议，是从 brewer.pal.info 的名字中选一个:
> library(RColorBrewer)
> rownames(x = brewer.pal.info)
 [1] "BrBG"     "PiYG"     "PRGn"     "PuOr"     "RdBu"     "RdGy"     "RdYlBu"   "RdYlGn"  
 [9] "Spectral" "Accent"   "Dark2"    "Paired"   "Pastel1"  "Pastel2"  "Set1"     "Set2"    
[17] "Set3"     "Blues"    "BuGn"     "BuPu"     "GnBu"     "Greens"   "Greys"    "Oranges" 
[25] "OrRd"     "PuBu"     "PuBuGn"   "PuRd"     "Purples"  "RdPu"     "Reds"     "YlGn"    
[33] "YlGnBu"   "YlOrBr"   "YlOrRd" 


使用数字时，根据参数 type='seq' 索引到 brewer.pal.info 中的一个。
type: One of seq (sequential), div (diverging) or qual (qualitative)
Palettes: The following palettes are available for use with these scales:
Diverging: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral
Qualitative: Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3
Sequential: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd
Modify the palette through the palette argument.


library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+theme_classic(); g1

# palette=字符串
brewer.pal.info #查看全部调色板
rownames(x = brewer.pal.info)
g2=g1+scale_color_brewer(palette = 'Set2')+
  labs(color="Gear")+
  ggtitle("palette='Set2'")
g2

# palette=数字时，在 type(共三个，默认'seq') 的调色板名字中索引
g3=g1+scale_color_brewer(type=c('seq', 'div','qual')[3], palette = 7)+
  labs(color="Gear")+
  ggtitle("type='qual',palette=1");g3
g1+g2+g3

图 8








(9) DiscretePalette(n, palette = NULL) 获取Seurat 定义的色板

> DiscretePalette
function (n, palette = NULL) 
{
    palettes <- list(
		alphabet = c("#F0A0FF", "#0075DC", "#993F00", 
			"#4C005C", "#191919", "#005C31", "#2BCE48", "#FFCC99", 
			"#808080", "#94FFB5", "#8F7C00", "#9DCC00", "#C20088", 
			"#003380", "#FFA405", "#FFA8BB", "#426600", "#FF0010", 
			"#5EF1F2", "#00998F", "#E0FF66", "#740AFF", "#990000", 
			"#FFFF80", "#FFE100", "#FF5005"), 
		alphabet2 = c("#AA0DFE", 
			"#3283FE", "#85660D", "#782AB6", "#565656", "#1C8356", 
			"#16FF32", "#F7E1A0", "#E2E2E2", "#1CBE4F", "#C4451C", 
			"#DEA0FD", "#FE00FA", "#325A9B", "#FEAF16", "#F8A19F", 
			"#90AD1C", "#F6222E", "#1CFFCE", "#2ED9FF", "#B10DA1", 
			"#C075A6", "#FC1CBF", "#B00068", "#FBE426", "#FA0087"), 
		glasbey = c("#0000FF", "#FF0000", "#00FF00", "#000033", 
			"#FF00B6", "#005300", "#FFD300", "#009FFF", "#9A4D42", 
			"#00FFBE", "#783FC1", "#1F9698", "#FFACFD", "#B1CC71", 
			"#F1085C", "#FE8F42", "#DD00FF", "#201A01", "#720055", 
			"#766C95", "#02AD24", "#C8FF00", "#886C00", "#FFB79F", 
			"#858567", "#A10300", "#14F9FF", "#00479E", "#DC5E93", 
			"#93D4FF", "#004CFF", "#F2F318"), 
		polychrome = c("#5A5156", 
			"#E4E1E3", "#F6222E", "#FE00FA", "#16FF32", "#3283FE", 
			"#FEAF16", "#B00068", "#1CFFCE", "#90AD1C", "#2ED9FF", 
			"#DEA0FD", "#AA0DFE", "#F8A19F", "#325A9B", "#C4451C", 
			"#1C8356", "#85660D", "#B10DA1", "#FBE426", "#1CBE4F", 
			"#FA0087", "#FC1CBF", "#F7E1A0", "#C075A6", "#782AB6", 
			"#AAF400", "#BDCDFF", "#822E1C", "#B5EFB5", "#7ED7D1", 
			"#1C7F93", "#D85FF7", "#683B79", "#66B0FF", "#3B00FB"), 
		stepped = c("#990F26", "#B33E52", "#CC7A88", "#E6B8BF", 
			"#99600F", "#B3823E", "#CCAA7A", "#E6D2B8", "#54990F", 
			"#78B33E", "#A3CC7A", "#CFE6B8", "#0F8299", "#3E9FB3", 
			"#7ABECC", "#B8DEE6", "#3D0F99", "#653EB3", "#967ACC", 
			"#C7B8E6", "#333333", "#666666", "#999999", "#CCCCCC")
	)
	# 如果没有指定色板名，则根据n确定
    if (is.null(x = palette)) {
        if (n <= 26) {
            palette <- "alphabet"
        }
        else if (n <= 32) {
            palette <- "glasbey"
        }
        else {
            palette <- "polychrome"
        }
    }
    palette.vec <- palettes[[palette]] #根据色板名字获取颜色
	# 如果长度不够，给警告
    if (n > length(x = palette.vec)) {
        warning("Not enough colours in specified palette")
    }
	# 取出该长度的颜色字符
	# 如果n长度超了，则返回NA: c("A", "b")[1:4] #[1] "A" "b" NA  NA
    palette.vec[seq_len(length.out = n)]
}
<bytecode: 0x55b5b2ecdcc0>
<environment: namespace:Seurat>
这个函数也太简陋了。。。


每个色板的长度:
alphabet  alphabet2    glasbey polychrome    stepped 
      26         26         32         36         24 

测试效果:
# ggplot2 使用色板
library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+theme_classic(); g1

# palette=字符串
brewer.pal.info #查看全部调色板
rownames(x = brewer.pal.info)
g2=g1+scale_color_brewer(palette = 'Set2')+
  labs(color="Gear")+
  ggtitle("palette='Set2'")
g2

# palette=数字时，在 type(共三个，默认'seq') 的调色板名字中索引
g3=g1+scale_color_brewer(type=c('seq', 'div','qual')[3], palette = 7)+
  labs(color="Gear")+
  ggtitle("type='qual',palette=1");g3
g1+g2+g3


# Color list in Seurat
pname=c('alphabet', 'alphabet2', 'glasbey', 'polychrome', 'stepped')
nArr=c(26, 26, 32, 36, 24)
par(mfrow=c(5,1), mar=c(0,0,1.5,0))
for(i in 1:5 ){
  title=sprintf( "%s(n=%s)", pname[i], nArr[i] )
  message(i, " | ", title)
  colors=Seurat::DiscretePalette(n=nArr[i], pname[i])
  barplot( rep(1, length(colors)), col=colors, main=title,
           yaxt='n', space=0, border = NA )
}

图9





(10) 大佬钟爱的 ggplot2 主题: cowplot::theme_cowplot

> cowplot::theme_cowplot
function (font_size = 14, font_family = "", line_size = 0.5, 
          rel_small = 12/14, rel_tiny = 11/14, rel_large = 16/14) 
{
  half_line <- font_size/2
  small_size <- rel_small * font_size
  theme_grey(base_size = font_size, base_family = font_family) %+replace% 
    theme(
      line = element_line(color = "black", size = line_size, linetype = 1, lineend = "butt"), 
      rect = element_rect(fill = NA, color = NA, size = line_size, linetype = 1), 
      text = element_text(family = font_family, face = "plain", color = "black", size = font_size, 
                          hjust = 0.5, vjust = 0.5, angle = 0, lineheight = 0.9, 
                          margin = margin(), debug = FALSE), 
      axis.line = element_line(color = "black", size = line_size, lineend = "square"), 
      axis.line.x = NULL, axis.line.y = NULL, 
      axis.text = element_text(color = "black", size = small_size), 
      axis.text.x = element_text(margin = margin(t = small_size/4), vjust = 1), 
      axis.text.x.top = element_text(margin = margin(b = small_size/4), vjust = 0), 
      axis.text.y = element_text(margin = margin(r = small_size/4), hjust = 1), 
      axis.text.y.right = element_text(margin = margin(l = small_size/4), hjust = 0), 
      axis.ticks = element_line(color = "black", size = line_size), 
      axis.ticks.length = unit(half_line/2, "pt"), 
      axis.title.x = element_text(margin = margin(t = half_line/2), vjust = 1), 
      axis.title.x.top = element_text(margin = margin(b = half_line/2), vjust = 0), 
      axis.title.y = element_text(angle = 90, margin = margin(r = half_line/2), vjust = 1), 
      axis.title.y.right = element_text(angle = -90, margin = margin(l = half_line/2), vjust = 0), 
      legend.background = element_blank(), 
      legend.spacing = unit(font_size, "pt"), 
      legend.spacing.x = NULL, legend.spacing.y = NULL, 
      legend.margin = margin(0, 0, 0, 0), 
      legend.key = element_blank(), 
      legend.key.size = unit(1.1 * font_size, "pt"), 
      legend.key.height = NULL, legend.key.width = NULL, 
      legend.text = element_text(size = rel(rel_small)), 
      legend.text.align = NULL, 
      legend.title = element_text(hjust = 0), 
      legend.title.align = NULL, legend.position = "right", 
      legend.direction = NULL, 
      legend.justification = c("left", "center"), 
      legend.box = NULL, 
      legend.box.margin = margin(0, 0, 0, 0), 
      legend.box.background = element_blank(), 
      legend.box.spacing = unit(font_size, "pt"), 
      panel.background = element_blank(), 
      panel.border = element_blank(), panel.grid = element_blank(), 
      panel.grid.major = NULL, panel.grid.minor = NULL, 
      panel.grid.major.x = NULL, panel.grid.major.y = NULL, 
      panel.grid.minor.x = NULL, panel.grid.minor.y = NULL, 
      panel.spacing = unit(half_line, "pt"), panel.spacing.x = NULL, 
      panel.spacing.y = NULL, panel.ontop = FALSE, 
      strip.background = element_rect(fill = "grey80"), 
      strip.text = element_text(size = rel(rel_small), 
                                margin = margin(half_line/2, half_line/2, half_line/2, half_line/2)), 
      strip.text.x = NULL, strip.text.y = element_text(angle = -90), 
      strip.placement = "inside", 
      strip.placement.x = NULL, strip.placement.y = NULL, 
      strip.switch.pad.grid = unit(half_line/2, "pt"), 
      strip.switch.pad.wrap = unit(half_line/2, "pt"), 
      plot.background = element_blank(), 
      plot.title = element_text(face = "bold", size = rel(rel_large), hjust = 0, vjust = 1, margin = margin(b = half_line)), 
      plot.subtitle = element_text(size = rel(rel_small), 
                                   hjust = 0, vjust = 1, margin = margin(b = half_line)), 
      plot.caption = element_text(size = rel(rel_tiny), 
                                  hjust = 1, vjust = 1, margin = margin(t = half_line)), 
      plot.tag = element_text(face = "bold", hjust = 0, vjust = 0.7), 
      plot.tag.position = c(0, 1), 
      plot.margin = margin(half_line, half_line, half_line, half_line), 
      complete = TRUE
    )
}
<bytecode: 0x55cf5c04f048>
<environment: namespace:cowplot>


重点1: 使用后面的主题条目替换前面的 theme(1) %+replace% theme(2)
	我的测试表明，没啥区别，是不是哪里不对？ //todo 

重点2: 文章的图片要求使用大号字体，该函数规定了基本字体、相对大号和小号(14, 16, 11/12)

# 使用后面的主题条目替换前面的。
library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+ggtitle("g1"); g1

g2=g1+cowplot::theme_cowplot()+ggtitle("g4")+labs(color="gear");g2

# + 与 %+replace% 貌似没有区别??
g3=g1+ theme_grey() %+replace% theme(
  panel.background = element_blank()
)+ggtitle("g2");g3
g4=g1+ theme(
  panel.background = element_blank()
)+ggtitle("g3");g4

library(patchwork)
(g1+g2)/(g3+g4)

图 10



(11) lapply循环执行正则匹配，并忽略大小写 grep(, ignore.case = T)
# 2个向量的匹配
> index=lapply(
  X = c('umap', 'tsne', 'pca'), #遍历，并作为FUN的参数1
  FUN = grep,
  x = c("umap", "tsne"), #FUN 的参数2，可选
  ignore.case = TRUE     #FUN 的参数3，可选
)
> index
[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
integer(0)

# 每一个循环实际执行的语句：
> grep('umap', c("umap", "tsne"), ignore.case = T)
[1] 1


# R循环提倡使用apply家族函数，而不是for
lapply(
  X=c(-1,0,5), #遍历其中的每个元素
  FUN=function(param1, p2, p3=""){
    return( paste(param1, p2, p3, sep = "_"))
  },
  p2="gene1",
  p3="sample1"
)
输出:
[[1]]
[1] "-1_gene1_sample1"

[[2]]
[1] "0_gene1_sample1"

[[3]]
[1] "5_gene1_sample1"








(12) 由 ggplot2 对象，获取其x和y轴的变量名
> library(ggplot2)
> g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+ggtitle("g1"); g1
> g1$mapping$x
<quosure>
expr: ^mpg
env:  global


x轴的变量名
> as_label(g1$mapping$x)
[1] "mpg"


数据集也在ggplot2对象中:
> head(g1$data)
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1











(13) df 本质上是按列的list

> tmp = iris[1:3, ]
> tmp

> lapply(tmp, function(x){
  x
})

$Sepal.Length
[1] 5.1 4.9 4.7

$Sepal.Width
[1] 3.5 3.0 3.2

$Petal.Length
[1] 1.4 1.4 1.3

$Petal.Width
[1] 0.2 0.2 0.2

$Species
[1] setosa setosa setosa
Levels: setosa versicolor virginica





(14) 求类别标注的坐标: RANN::nn2() Nearest Neighbour Search

源码: nearest.point <- nn2(data = group.data[, 1:2], query = as.matrix(x = x[c(1,2)]), k = 1)$nn.idx

使用 kd-tree 找距离某个点最近的p个点。优点是快，时间复杂度是 O(n log n)。
Uses a kd-tree to find the p number of near neighbours for each point in an input/output dataset. The advantage of the kd-tree is that it runs in O(M log M) time.

Usage
nn2(data, query = data, k = min(10, nrow(data)), treetype = c("kd", "bd"), searchtype = c("standard", "priority", "radius"), radius = 0, eps = 0)
第一个参数是数据库，M行d列；
第二个参数是要查询的点，N行d列；
第三个参数是k，最近的几个点？默认是 min(10, M)
然后返回值是一个list，包含2个元素：
nn.idx, N行k列，每个查询点一行，k个最近的点的下标。
nn.dists, N行k列，每个查询点一行，k个最近的点的距离。


例子: 尝试为 iris 标记群体名
df1=data.frame(
  x=iris$Petal.Length,
  y=iris$Petal.Width,
  type=iris$Species
)
head(df1)
index=match(df1$type, c("setosa", "versicolor", "virginica"))
colors=c("#4A9D47", "#5F9BBE", "#F5B375")


###################
# 画图：主图
plot(df1$x, df1$y, col=colors[index],
     main="Fig1",
     pch=19)

# 求A点最近的5个点
indexA=99
set.seed(2022)
p1.ann=RANN::nn2(data=df1[, 1:2], query=df1[indexA, 1:2], k=10); p1.ann
df1[p1.ann$nn.idx,] #目测，有重叠的点
# 画图: 标记点A
points(df1$x[indexA], df1$y[indexA], col="#ff000055",  pch=18, cex=3)
# 画图: 标记点A周围最近的5个点
pos=as.numeric( p1.ann$nn.idx )
points(df1$x[pos], df1$y[pos], col="red", pch=21, cex=2)



###################
## fig2:
#1.获取每类的median
data.medians=lapply(
    X=as.character( unique(df1$type) ),
    FUN=function(x){
      data.use=df1[which(df1$type==x), ,drop=F]
      medians=apply(data.use[, 1:2],2, median)
      medians=as.data.frame(t(medians))
      medians$type=x
      return(medians)
    }
  )
data.medians #list 格式的数据
labels.loc=do.call(rbind, data.medians);
labels.loc #df格式

# 画图: 主体
plot(df1$x, df1$y, col=colors[index],
     main="Fig2",
     pch=19)
# 画图：标记这些点的位置
points(labels.loc$x, labels.loc$y, col="#FF000099", pch=17, cex=1.5)
# 画图：标记文字
text(labels.loc$x, labels.loc$y, labels=labels.loc$type, col="#FF0000")

#2.获取每个类median的最近的点坐标 nearest
# 输入list，函数获取的每个x都是一个list
set.seed(2022)
data.medians2=lapply( data.medians, function(x){
  group.data=df1[which(as.character(df1$type)==as.character(x[3])),]
  nearest.point=RANN::nn2(data=group.data[,1:2], query=as.matrix(x = x[c(1,2)]), k=1 )$nn.idx
  #坐标更新
  x[1:2] <- group.data[nearest.point, 1:2]
  return(x)
});data.medians2
labels.loc2=do.call(rbind, data.medians2); #list to df
labels.loc2

# 画图：标记这些点的位置
points(labels.loc2$x, labels.loc2$y, col="#0000FFaa", pch=21, cex=2, lwd=3)
# 画图：标记文字, 有重叠，不画了
#text(labels.loc2$x, labels.loc2$y, labels=labels.loc2$type, col="#0000FF")
图14_0




# ggplot2 演示
library(ggplot2)
g1=ggplot(mtcars, aes(mpg, disp, color= factor(gear) ))+
  geom_point()+ggtitle("g1"); g1
g1=DimPlot(pbmc)+ggtitle("g1"); g1
head(g1$data)
g2=LabelClusters(g1, id='ident')+ggtitle("g2");g2 #加文字标注
g3=LabelClusters(g1, id='ident', box=T)+ggtitle("g3");g3 #文字标注加方框
g4=LabelClusters(g1, id='ident', box=T, position="nearest")+ggtitle("g4");g4
(g1+g2)/(g3+g4)


图14






(15) 类别标注文字是否加背景框? geom_label vs geom_text
geom_text 标注的是文字，没有背景框。
geom_label 标注的标签，有背景框。



# 加标签背景盒子
df1=data.frame(
  x=iris$Petal.Length,
  y=iris$Petal.Width,
  type=iris$Species
)
library(ggplot2)
g1=ggplot(df1)+ #为了防止 aes() 对其他图层的影响，把aes放到每层自身的语句中
  geom_point(aes(x, y, color= type ))+
  theme_classic()+
  ggtitle("g1"); g1
# 从图形获取颜色值
pb <- ggplot_build(plot = g1)
df1$color=pb$data[[1]][[1]]

#1.获取每类的median
data.medians=lapply(
  X=as.character( unique(df1$type) ),
  FUN=function(x){
    data.use=df1[which(df1$type==x), ,drop=F]
    medians=apply(data.use[, 1:2],2, median)
    medians=as.data.frame(t(medians))
    medians$type=x
    medians$color=data.use$color[1]
    return(medians)
  }
)
data.medians #list
labels.loc=do.call(rbind, data.medians);
labels.loc
# 排序，按照type列，给color列排序
labels.loc$color[order(labels.loc[, 'type'])]

# 加外框
g2=g1 +  geom_label(
  data = labels.loc,
  aes(x,y, label=type, fill=type),
  show.legend = F
)+
  scale_fill_manual(values=labels.loc$color[order(labels.loc[, 'type'])] )+
  ggtitle("g2 geom_label");g2

# 不要外框 -- 失败！ geom_label 一直有框
g3=g1 +  geom_label(
  data = labels.loc,
  aes(x,y, label=type),
  show.legend = F
)+ggtitle("g3 geom_label");g3

# 不要外框 -- 成功！ geom_text 没有框
g4=g1 +  geom_text(
  data = labels.loc,
  aes(x,y, label=type),
  show.legend = F
)+ggtitle("g4 geom_text");g4
(g1+g2)/(g3+g4)

图 15







(16) ggplot2 主题的创建：返回一个 theme() 函数。

1) 分面主题
# Make a theme for facet plots
#
# @inheritParams SeuratTheme
# @export
#
# @rdname SeuratTheme
# @aliases FacetTheme
#
FacetTheme <- function(...) {
  return(theme(
    strip.background = element_blank(), #分面的标题空白，文字粗体
    strip.text = element_text(face = 'bold'),
    # Validate the theme
    validate = TRUE,
    ...
  ))
}



2) 标题居中

#' @importFrom ggplot2 theme element_text
#'
#' @rdname SeuratTheme
#' @export
#' @concept visualization
#'
#' @aliases CenterTitle
#'
CenterTitle <- function(...) {
  return(theme(plot.title = element_text(hjust = 0.5), validate = TRUE, ...))
}







4. bugs

(1) bug: 多群细胞高亮时颜色经常对不上 //todo
低频
DimPlot(pbmc,
        cells.highlight=list(
          c5=WhichCells(pbmc, idents=5),
          c8=WhichCells(pbmc, idents=8),
          c2=WhichCells(pbmc, idents=2)
        ),
        sizes.highlight = c(4.5, 1.5, 0.5), #这就很奇怪了，尺寸和出现的对应
        #cols.highlight=list(c5="red", c8="orange")
        cols.highlight=c("orange", "blue", "purple") #颜色对应关系总是不对
        # 貌似它总是按照order(listNames)的顺序染色
)
# 此处有bug，而且不容忽视的bug: 多个高亮细胞list时刻，和指定颜色对应不上。 //todo



highlight.info=Seurat:::SetHighlight(
  cells.highlight=list(
    c5=WhichCells(pbmc, idents=5),
    c8=WhichCells(pbmc, idents=8),
    c2=WhichCells(pbmc, idents=2)
  ),
  cells.all=Cells(pbmc),
  sizes.highlight = c(4.5, 1.5, 0.5),
  cols.highlight = c("orange", "blue", "purple"),
  col.base="#C3C3C3"
)
str(highlight.info)
#List of 4
#$ plot.order: chr [1:4] "c2" "c5" "c8" "Unselected"
#$ highlight : Factor w/ 4 levels "c2","c5","c8",..: 1 4 1 4 4 1 4 4 4 2 ...
#$ size      : num [1:2638] 0.5 1 0.5 1 1 0.5 1 1 1 4.5 ...
#$ color     : chr [1:4] "#C3C3C3" "orange" "blue" "purple"
order <- highlight.info$plot.order
data=FetchData(pbmc, vars=c("UMAP_1", 'UMAP_2', "seurat_clusters"))
data$highlight <- highlight.info$highlight
col.by <- 'highlight'
pt.size <- highlight.info$size
cols <- highlight.info$color

unique(data$highlight)








========================================
|-- Seurat 4 R包源码解析 25: step12 找差异(标记)基因 FindMarkers()
----------------------------------------
1. 调包侠
(1) 找到1个cluster的marker基因

# step 12 Finding differentially expressed features (cluster biomarkers)
# find all markers of cluster 3
> cluster3.markers <- FindMarkers(pbmc, ident.1 = 3, min.pct = 0.25)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
> head(cluster3.markers, n = 5)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270
LINC00926 2.397625e-272   2.842677 0.564 0.009 3.288103e-268
TCL1A     9.481783e-271   3.591579 0.622 0.022 1.300332e-266

可见明显是B细胞的marker基因。




默认检验方法是 wilcox， 还可以使用其他检验方法:
> cluster3.markers_b <- FindMarkers(pbmc, ident.1 = 3, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
> cluster3.markers_b |> head()
         myAUC avg_diff power avg_log2FC pct.1 pct.2
CD74     0.983 2.024653 0.966   2.920957 1.000 0.821
CD79A    0.965 2.987583 0.930   4.310172 0.936 0.041
HLA-DRA  0.961 1.915271 0.922   2.763152 1.000 0.494
CD79B    0.944 2.413475 0.888   3.481908 0.916 0.142
HLA-DPB1 0.931 1.626958 0.862   2.347204 0.985 0.449
HLA-DQA1 0.921 2.119572 0.842   3.057896 0.890 0.118





(2) 比较2组获取其marker基因

# find all markers distinguishing cluster 5 from clusters 0 and 2
> cluster4_02.markers <- FindMarkers(pbmc, ident.1 = 4, ident.2 = c(0, 2), min.pct = 0.25)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  
> head(cluster4_02.markers, n = 10)
              p_val avg_log2FC pct.1 pct.2     p_val_adj
NKG7  8.832883e-207  4.7855418 0.966 0.142 1.211342e-202
CCL5  4.682476e-168  3.2778855 0.983 0.228 6.421547e-164
CST7  2.192927e-167  3.1370484 0.797 0.082 3.007380e-163
GZMA  5.859426e-166  2.9389163 0.818 0.088 8.035616e-162
GZMK   2.708088e-97  2.7933755 0.577 0.074  3.713872e-93
GZMH   1.958415e-96  3.3831076 0.419 0.018  2.685771e-92
CTSW   6.289194e-96  2.2004576 0.818 0.278  8.625001e-92
PRF1   2.101949e-77  2.0932993 0.488 0.068  2.882613e-73
B2M    3.277785e-73  0.6040478 1.000 1.000  4.495155e-69
HLA-C  3.944756e-68  0.9230342 0.997 0.991  5.409839e-64





(3) 还可以使用其他分组方式
Take all cells in cluster 2, and find markers that separate cells in the 'g1' group (metadata variable 'group')
使用 cluster2的所有细胞，找能区分查 g1 组的marker

1)取子集 subset.ident = "2"
2)分组 group.by = 'groups',
3)按分组找 ident.1 = "g1" 的marker 基因

> markers <- FindMarkers(pbmc_small, ident.1 = "g1", group.by = 'groups', subset.ident = "2")
> head(x = markers)
               p_val avg_log2FC pct.1 pct.2 p_val_adj
GSTP1     0.01601528   2.539192   0.7 0.111         1
LINC00936 0.02048683   4.090856   0.5 0.000         1
TPM4      0.02048683   4.381751   0.5 0.000         1
LGALS2    0.04515259   4.300590   0.4 0.000         1
IFI30     0.04515259   4.676111   0.4 0.000         1
RHOC      0.04515259   3.933927   0.4 0.000         1





(4) 还可以传入 cell id list 

先熟悉函数 WhichCells() 的用法，见 解析 10-2.4
> table(pbmc$seurat_clusters)
  0   1   2   3   4   5   6   7   8 
684 481 476 344 291 162 155  32  13 
> WhichCells(pbmc, idents = c(3)) |> length()
[1] 344
> WhichCells(pbmc, idents = c(8, 7)) |> length()
[1] 45
> WhichCells(pbmc, idents = c(3)) |> head(n=5)
[1] "AAACATTGAGCTAC-1" "AAACTTGAAAAACG-1" "AAAGGCCTGTCTAG-1" "AAAGTTTGATCACG-1" "AAAGTTTGGGGTGA-1"



> rs1 <- FindMarkers(pbmc, ident.1 = WhichCells(pbmc, idents = c(3)), min.pct = 0.25)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
> head(rs1)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270







(5) 传入一个树 //不理解 //todo
Pass 'clustertree' or an object of class phylo to ident.1 and a node to ident.2 as a replacement for FindMarkersNode
传入 'clustertree' 作为个

if (requireNamespace("ape", quietly = TRUE)) {
  pbmc_small2 <- BuildClusterTree(object = pbmc_small)
  markers2 <- FindMarkers(object = pbmc_small2, ident.1 = 'clustertree', ident.2 = 5)
  head(x = markers2)
}




> pbmc2=BuildClusterTree(pbmc)

# 通过手动分析 str(pbmc) 和 str(pbmc2)，发现后者多了一个 tools slot:
> str(pbmc@tools)
 list()
> str(pbmc2@tools)
List of 1
 $ BuildClusterTree:List of 4
  ..$ edge       : int [1:16, 1:2] 10 10 11 12 12 11 13 14 14 16 ...
  ..$ edge.length: num [1:16] 485 180 174 131 131 ...
  ..$ tip.label  : chr [1:9] "0" "1" "2" "3" ...
  ..$ Nnode      : int 8
  ..- attr(*, "class")= chr "phylo"
  ..- attr(*, "order")= chr "cladewise"

> ape::plot.phylo(pbmc2@tools$BuildClusterTree)
> DimPlot(pbmc2,label=T)
# 图略







(6) 某个基因在某个类中的表达百分比 pct.1？

# FoldChange.default():
pct.1 <- round(
    x = rowSums(x = object[features, cells.1, drop = FALSE] > thresh.min) /
      length(x = cells.1),
    digits = 3
  )


测试: 

dat=pbmc@assays$RNA@data
features=rownames(pbmc)
cells.1=WhichCells(pbmc, idents = 3)

> rs1=rowSums( dat[features, cells.1, drop=F] >0 ) / length(cells.1)
> rs2=FindMarkers(pbmc, ident.1 = 3) 

> head(rs2)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270
LINC00926 2.397625e-272   2.842677 0.564 0.009 3.288103e-268
TCL1A     9.481783e-271   3.591579 0.622 0.022 1.300332e-266
HLA-DQA1  2.942395e-266   3.057896 0.890 0.118 4.035201e-262

> rs1[rownames(rs2)] |> head()
    MS4A1     CD79A     CD79B LINC00926     TCL1A  HLA-DQA1 
0.8546512 0.9360465 0.9156977 0.5639535 0.6220930 0.8895349 

这就是rs2$pct.1 列的值。






(7) 某基因在2类中的倍数变化 log2FC
# FoldChange.default():
data.1 <- mean.fxn(object[features, cells.1, drop = FALSE])

# FoldChange.Assay()
mean.fxn <- mean.fxn %||% switch(
	EXPR = slot,
	'data' = function(x) {
		return(log(x = rowMeans(x = expm1(x = x)) + pseudocount.use, base = base))
	},
	'scale.data' = rowMeans,
	function(x) {
	  return(log(x = rowMeans(x = x) + pseudocount.use, base = base))
	}
)

默认我们是使用 data，所以函数就是
mean.fxn = function(x) {
	return(log(x = rowMeans(x = expm1(x = x)) + pseudocount.use, base = base))
}


1) expm1(x) computes exp(x) - 1 accurately also for |x| << 1.
这个倍数变化，是使用 log后的 data 再取 exp(x)-1 变回 counts 数据。

2) 回顾 解析13-1.1。counts to data 的变换过程 Seurat是用C++实现的，我们用R实现结果一致，就是速度慢点:
# data=apply(counts, 2, function(x){ log( x/sum(x)*1e4 +1 ) })


对数公式: log(x/y)=log(x) - log(y)
所以 log2( (m1+1)/(m2+1)) = log2(m1+1) - log2(m2+1)


3) 回到现在，这里按行求基因的平均表达量，使用的是 x/sum(x)*1e4 +1 水平的平均值，然后对平均值 log(row_means, base)
这也合理，直接使用counts可能有不同细胞测序深度的变异，标准化到1万个reads后，再用来求平均表达量。
而log仅仅用于可视化时，防止最值差异过大导致渐变色不明显。



4) 问题: 在标准化后log前求平均（Seurat 4的选择），和在标准化和log后求平均有啥区别？

> dat=pbmc@assays$RNA@data
> cell.1 = WhichCells(pbmc, idents = 3)
> cell.2 = setdiff(colnames(pbmc), cell.1)

> meanFnA = function(x) {
	return(x = rowMeans(x = expm1(x = x)))
}
> mA1=meanFnA(dat[, cell.1]);
> mA2=meanFnA(dat[, cell.2]);
> log2fcA= log2( (mA1+1) / (mA2+1) )

调用Seurat的函数:
> bench3=FindMarkers(pbmc, ident.1 = 3)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=05s  
> head(bench3)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270
LINC00926 2.397625e-272   2.842677 0.564 0.009 3.288103e-268
TCL1A     9.481783e-271   3.591579 0.622 0.022 1.300332e-266
HLA-DQA1  2.942395e-266   3.057896 0.890 0.118 4.035201e-262


> head(log2fcA[rownames(bench3)])
    MS4A1     CD79A     CD79B LINC00926     TCL1A  HLA-DQA1 
 3.378150  4.310172  3.481908  2.842677  3.591579  3.057896
我们计算的结果 log2fcA 和 Seurat 的输出列 avg_log2FC 一致。







直接调用函数 FoldChange.default 时:
cid1=WhichCells(pbmc, idents=3);
cid2=setdiff(colnames(pbmc), cid1)
pseudocount.use=1
base=2
fn1=function(x) {
	return(log(x = rowMeans(x = expm1(x = x)) + pseudocount.use, base = base))
}
> fc.results = FoldChange(pbmc@assays$RNA@data, cells.1=cid1, cells.2= cid2, mean.fxn=fn1, fc.name="log2FC")
> fc.results[rownames(bench3),] |> head()
            log2FC pct.1 pct.2
MS4A1     3.378150 0.855 0.053
CD79A     4.310172 0.936 0.041
CD79B     3.481908 0.916 0.142
LINC00926 2.842677 0.564 0.009
TCL1A     3.591579 0.622 0.022
HLA-DQA1  3.057896 0.890 0.118







测试方案B: 标准化和log后求平均表达量，Seurat 没有采用的方案。
> meanFnB = rowMeans
> mB1=meanFnB(dat[, cell.1]);
> mB2=meanFnB(dat[, cell.2]);
> log2fcB= log2( (mB1+1) / (mB2+1) )
> head(log2fcB[rownames(bench3)])
    MS4A1     CD79A     CD79B LINC00926     TCL1A  HLA-DQA1 
 1.536073  1.828888  1.544665  1.175558  1.408089  1.483866 

值都有所降低，倍数变化显得小了。










(8) 最大的探讨空间是 差异基因的 统计学检验方法: 默认 test.use="wilcox"
test.use: Denotes which test to use. Available options are:

"wilcox" : Identifies differentially expressed genes between two groups of cells using a Wilcoxon Rank Sum test (default)

"bimod" : Likelihood-ratio test for single cell gene expression, (McDavid et al., Bioinformatics, 2013)

"roc" : Identifies 'markers' of gene expression using ROC analysis. For each gene, evaluates (using AUC) a classifier built on that gene alone, to classify between two groups of cells. An AUC value of 1 means that expression values for this gene alone can perfectly classify the two groupings (i.e. Each of the cells in cells.1 exhibit a higher level than each of the cells in cells.2). An AUC value of 0 also means there is perfect classification, but in the other direction. A value of 0.5 implies that the gene has no predictive power to classify the two groups. Returns a 'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially expressed genes.

"t" : Identify differentially expressed genes between two groups of cells using the Student's t-test.

"negbinom" : Identifies differentially expressed genes between two groups of cells using a negative binomial generalized linear model. Use only for UMI-based datasets

"poisson" : Identifies differentially expressed genes between two groups of cells using a poisson generalized linear model. Use only for UMI-based datasets

"LR" : Uses a logistic regression framework to determine differentially expressed genes. Constructs a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test.

"MAST" : Identifies differentially expressed genes between two groups of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST package to run the DE testing.

"DESeq2" : Identifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial distribution (Love et al, Genome Biology, 2014).This test does not support pre-filtering of genes based on average difference (or percent detection rate) between cell groups. However, genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups. To use this method, please install DESeq2, using the instructions at https://bioconductor.org/packages/release/bioc/html/DESeq2.html



1) 哪些做差异表达分析的方法使用counts?

# 见 FindMarkers.Assay()
  data.slot <- ifelse(
    test = test.use %in% DEmethods_counts(),
    yes = 'counts',
    no = slot
  )

> Seurat:::DEmethods_counts
function () 
{
    c("negbinom", "poisson", "DESeq2")
}
<bytecode: 0x55b94f4a0738>
<environment: namespace:Seurat>

> Seurat:::DEmethods_counts()
[1] "negbinom" "poisson"  "DESeq2"



2) 对于不需要过滤基因的DEG检测方法
# FindMarkers.default()
> Seurat:::DEmethods_noprefilter() 
[1] "DESeq2"



3) 有些方法需要用到 latent 变量?
# PerformDE():
> Seurat:::DEmethods_latent()
[1] "negbinom" "poisson"  "MAST"     "LR"  



4) 不需要p值矫正的算法
> Seurat:::DEmethods_nocorrect
function () 
{
    c("roc")
}
<bytecode: 0x55e8c74da468>
<environment: namespace:Seurat>

> Seurat:::DEmethods_nocorrect()
[1] "roc"




5) 如果不是这3个，则需要检查...参数
> Seurat:::DEmethods_checkdots()
[1] "wilcox" "MAST"   "DESeq2"












(9) Seurat 4 怎么做 wilcox 秩和检验的?

cid1=WhichCells(object = pbmc, idents = 3);
cid2=setdiff(colnames(pbmc), cid1)
dat=pbmc@assays$RNA@data


1) 使用 PerformDE 函数
> deg0=Seurat:::PerformDE(dat, cid1, cid2, 
                         features=rownames(pbmc),  test.use="wilcox",
                         verbose=T, latent.vars=NULL, densify=F)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01m 49s



2) PerformDE 是调用更底层的 WilcoxDETest 函数
> deg= Seurat:::WilcoxDETest(dat, cells.1 = cid1, cells.2 =cid2)
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01m 49s
#
> head(bench3)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270
LINC00926 2.397625e-272   2.842677 0.564 0.009 3.288103e-268
TCL1A     9.481783e-271   3.591579 0.622 0.022 1.300332e-266
HLA-DQA1  2.942395e-266   3.057896 0.890 0.118 4.035201e-262

> head(deg0[rownames(bench3), , drop=F])
                  p_val
MS4A1      0.000000e+00
CD79A      0.000000e+00
CD79B     2.655974e-274
LINC00926 2.397625e-272
TCL1A     9.481783e-271
HLA-DQA1  2.942395e-266

> head(deg[rownames(bench3), , drop=F])
                  p_val
MS4A1      0.000000e+00
CD79A      0.000000e+00
CD79B     2.655974e-274
LINC00926 2.397625e-272
TCL1A     9.481783e-271
HLA-DQA1  2.942395e-266





3) 手工使用 R自带的函数其p值
data.use <- pbmc@assays$RNA@data[, c(cid1, cid2), drop = FALSE]
x=grep("CD79B", rownames(pbmc))
# View data
data.use[x, 1:5, drop=F]
j=1:length(cid1)
> wilcox.test(data.use[x, cid1], data.use[x, cid2])$p.value
[1] 2.655974e-274



4) Seurat的 WilcoxDETest 中引用的其实是 limma 的函数:
作者认为 limma 那个速度更快。 //todo 看limma该函数源码，怎么实现的？
> rs=limma::rankSumTestWithCorrelation(index = j, statistics = data.use[x, ]);rs
         less       greater 
 1.000000e+00 1.327987e-274 
> 2*min(rs, 1) #Seurat 4使用的这个p值，和R wilcox是一致的。
[1] 2.655974e-274




5) 耗时测试: 单核，R原生函数和 limma 函数的耗时
# R 自带的 stat::wicox.test 函数
system.time(
  p_val_A1 <- sapply(
    X = 1:nrow(x = data.use), 
    FUN = function(x) {
      return(
        wilcox.test(data.use[x, cid1], data.use[x, cid2])$p.value
      )
    }
  )
)
#  user  system elapsed 
#147.376   0.497 147.481 


# limma 函数
system.time(
  p_val_A2 <- sapply(
    X = 1:nrow(x = data.use), 
    FUN = function(x) {
      return(
        min(
          2 * min(limma::rankSumTestWithCorrelation(index = j, statistics = data.use[x, ])), 
          1)
      )
    }
  )
)
#   user  system elapsed 
#109.211   0.519 109.241 

> head(p_val_A1)
[1] 0.2447831 0.5026493 0.0731235 0.5026493 0.6455354 0.2763674

> head(p_val_A2)
[1] 0.2447831 0.5026493 0.0731235 0.5026493 0.6455354 0.2763674

> table( abs( p_val_A1-p_val_A2 )< 1e-10 )
TRUE 
13713

> nrow(data.use)
[1] 13714

结论: 
* R自带函数和limma函数结果一致(误差在1e-10以内)。
* 但是计算13714各p值，limma 函数比R自带函数节省了 (147-109)/147=25% 的时间。



# 另一种调用 wilcox.test 的方法，使用公式: value ~ group
group.info=c( rep("A", length(cid1)), rep("B", length(cid2)));
# group.info <- factor(x = group.info) #这一句对结果无影响，对耗时也无影响。
> wilcox.test(data.use[x,]~ group.info)$p.value
[1] 2.655974e-274

system.time(
  p_val_A1_group <- sapply(
    X = 1:nrow(x = data.use), 
    FUN = function(x) {
      return(
        wilcox.test(data.use[x,]~ group.info)$p.value
      )
    }
  )
)
#   user  system elapsed 
#190.818   0.854 190.912  #这个貌似耗时更久

> head(p_val_A1_group)
[1] 0.2447831 0.5026493 0.0731235 0.5026493 0.6455354 0.2763674

> table( abs( p_val_A1_group-p_val_A2 )< 1e-10 )
 TRUE 
13713






6) 怎么做p值矫正的？

做p值矫正: 使用 "bonferroni" 法，一个严格的方法。
因为作者过滤掉的很多低表达基因没有做检验，它们p值按1算
# FindMarkers.default()
    de.results$p_val_adj = p.adjust(
      p = de.results$p_val,
      method = "bonferroni",
      n = nrow(x = object)
    )

> head(bench3)
                  p_val avg_log2FC pct.1 pct.2     p_val_adj
MS4A1      0.000000e+00   3.378150 0.855 0.053  0.000000e+00
CD79A      0.000000e+00   4.310172 0.936 0.041  0.000000e+00
CD79B     2.655974e-274   3.481908 0.916 0.142 3.642403e-270
LINC00926 2.397625e-272   2.842677 0.564 0.009 3.288103e-268
TCL1A     9.481783e-271   3.591579 0.622 0.022 1.300332e-266
HLA-DQA1  2.942395e-266   3.057896 0.890 0.118 4.035201e-262


手工计算:
> length(p_val_A1)
[1] 13714
> rs=data.frame(p_val_A1, row.names = rownames(data.use))
> rs2=rs[rownames(bench3), ,drop=F]
> rs2$p_val_adj = p.adjust(
	  p = rs2$p_val,
	  method = "bonferroni",
	  n = nrow(x = data.use) #n为所有要检验的结果，存疑?  //todo 难道做1个检验也要乘以基因总数？
	  # 最终结果中我们过滤了 pct 太低的，log2FC 为负的。检验数小于基因总数的。
	)
> head(rs2)
               p_val_A1     p_val_adj
MS4A1      0.000000e+00  0.000000e+00
CD79A      0.000000e+00  0.000000e+00
CD79B     2.655974e-274 3.642403e-270
LINC00926 2.397625e-272 3.288103e-268
TCL1A     9.481783e-271 1.300332e-266
HLA-DQA1  2.942395e-266 4.035201e-262


















2. 源码解析

(1) FindMarkers()
../seurat-4.1.0/R/generics.R:143:FindMarkers <- function(object, ...) {
../seurat-4.1.0/R/differential_expression.R:909:FindMarkers.Seurat <- function(
../seurat-4.1.0/R/differential_expression.R:611:FindMarkers.Assay <- function(


../seurat-4.1.0/R/differential_expression.R:492:FindMarkers.default <- function(
../seurat-4.1.0/R/differential_expression.R:793:FindMarkers.DimReduc <- function(
../seurat-4.1.0/R/differential_expression.R:690:FindMarkers.SCTAssay <- function(





函数list
* FindMarkers()
	- BuildClusterTree() //todo
	- Idents<-
* FindAllMarkers()



* VlnPlot 见解析 8
* FeaturePlot //todo
* DoHeatmap //todo






//todo


()"Idents<-"
$ find . | grep "R$" | grep -v "testthat" | xargs grep -in "Idents<-" 2>/dev/null --color=auto
./seurat-object-4.0.4/R/generics.R:409:"Idents<-" <- function(object, ..., value) {
./seurat-object-4.0.4/R/seurat.R:1305:"Idents<-.Seurat" <- function(object, cells = NULL, drop = FALSE, ..., value) {




() Tool() //todo 以后再说。
IdentsToCells() 中: Tool(object = object, slot = 'BuildClusterTree')

$ find . | grep "R$" | grep -v "testthat" | grep -v "notes" | xargs grep -n "^\s*Tool" 2>/dev/null --color=auto
./seurat-object-4.0.4/R/generics.R:795:Tool <- function(object, ...) {
./seurat-object-4.0.4/R/seurat.R:1764:Tool.Seurat <- function(object, slot = NULL, ...) {

./seurat-4.1.0/R/tree.R:146:  Tool(object = object) <- data.tree
./seurat-4.1.0/R/differential_expression.R:1619:      Tool(object = object, slot = 'BuildClusterTree')
./seurat-4.1.0/R/mixscape.R:857:  Tool(object = object) <- gv.list
./seurat-4.1.0/R/preprocessing.R:154:  Tool(object = object) <- info



() Command() // todo 以后再说 
能记录Seurat执行过的命令和参数，相当于是对象自带的重要日志记录系统















3. R tips 

(1) 一个参数默认值为NULL，怎么判断是否传入值？

fn1=function(ident.1=NULL){
	if (length(x = ident.1) == 0) {
		stop("At least 1 ident must be specified in `ident.1`")
	}
}

> fn1()
Error in fn1() : At least 1 ident must be specified in `ident.1`
> fn1(2)
>
> length(NULL)
[1] 0




(2) 判断传入的对象是否属于某个类 is(obj, className)

setClass('Book', slots = list(name="character", price="numeric") )
b1=new("Book", name="R intro", price=20)

> is(b1, "list")
[1] FALSE
> is(b1, "Book")
[1] TRUE

> is(b1)
[1] "Book"





(3) 集合运算: 取差集 A-B: setdiff(A, B)

> setdiff(1:5, c(1,3))
[1] 2 4 5




(4) 在函数体中为函数参数设置默认值

# 辅助函数，如果第一个参数为 NULL，则返回第二个参数。用于设置默认值
`%||2%` = function (x, y) {
    if (is.null(x)) 
        y
    else x
}

fn0=function(x=NULL){
	x =x %||2% 10; print(x)
}

> fn0(-5)
[1] -5
> fn0(1)
[1] 1
> fn0()  #如果没有提供该参数，则在函数内给出默认值
[1] 10




(5) switch() 第一个是字符串时，怎么设置默认分支？

参数1是数字的，无法设置默认分支。
参数1是字符串的，没有名字的那个就是某人分支，位置无关紧要，一般放在最后一个(还可以放一个stop()报错语句)。


实例1: 
> switch(EXPR="bad", "bad"=2, "good"=100, "default"=-10)
[1] 2
> switch(EXPR="go", "bad"=2, "good"=100, "default"=-10)
> switch(EXPR="go", "bad"=2, "good"=100, -10)
[1] -10


默认分支是没有名字的，与是否放在最后无关。
> switch(EXPR="go", "bad"=2, "good"=100, -10, "default"=0)
[1] -10
> switch(EXPR="default", "bad"=2, "good"=100, -10, "default"=0)
[1] 0


设置默认分支为报错:
> switch(EXPR="too", "bad"=2, "good"=100, "default"=0, stop("must be in c(good, bad, default)" )  )
Error: must be in c(good, bad, default)
> switch(EXPR="good", "bad"=2, "good"=100, "default"=0, stop("must be in c(good, bad, default)" )  )
[1] 100



实例2: 
fn1=function(fname) {
	switch(EXPR=fname, 
		"plus"=function(x,y){x+y},
		"multi"=function(x,y){x*y},
		function(x,y){x/y}
	)
}

测试:
> fn1("multi")
function(x,y){x*y}
<bytecode: 0x5643fc140120>
<environment: 0x5643fbd0f208>

> fn1("plus")
function(x,y){x+y}
<environment: 0x5643fd525550>

> fn1("plus2")  #走了默认
function(x,y){x/y}
<bytecode: 0x5643fbd41eb8>
<environment: 0x5643fd4c77e0>







(6) pmax() 是什么函数？给出2个向量每个下标处的最大值

> a1=1:5
> a2=c(10,-2,5,-3,0)

> pmax(a1, a2) #按向量求最大值，每个位置给出一个值
[1] 10  2  5  4  5
> pmax(a2, a1)
[1] 10  2  5  4  5


也支持多余2个向量
> rs=pmax(iris[,1], iris[,2], iris[,3], iris[,4])
> head(rs)
[1] 5.1 4.9 4.7 4.6 5.0 5.4

rs2=c()
for(i in 1:nrow(iris)){
  rs2=c(rs2, max(iris[i, 1:4]) );
}

> head(rs2)
[1] 5.1 4.9 4.7 4.6 5.0 5.4

> table(rs - rs2)
  0 
150 





(7) 对于named vector，按值过滤并获取其name

例: 值=基因表达百分比，name=基因名
features <- names(x = which(x = alpha.min >= min.pct))


> a1=1:5
> names(a1)=paste0("gene", 1:5)
> a1
gene1 gene2 gene3 gene4 gene5 
    1     2     3     4     5 

> a1>=3
gene1 gene2 gene3 gene4 gene5 
FALSE FALSE  TRUE  TRUE  TRUE 

> which(a1>=3)
gene3 gene4 gene5 
    3     4     5 

> names(which(a1>=3))
[1] "gene3" "gene4" "gene5"










(8) 如何用R代码检查某R包是否安装了 PackageCheck()?

> print(PackageCheck("limma", error = FALSE))
limma 
 TRUE 

> print(PackageCheck("ggplot2", "GEB", error = FALSE))
ggplot2     GEB 
   TRUE   FALSE 


$ find . | grep "R$" | grep -v "testthat" | grep -v "notes" | xargs grep -n "^\s*PackageCheck" 2>/dev/null --color=auto
./seurat-object-4.0.4/R/utils.R:335:PackageCheck <- function(..., error = TRUE) {

#' Check the existence of a package
#'
#' @param ... Package names
#' @param error If true, throw an error if the package doesn't exist
#'
#' @return Invisibly returns boolean denoting if the package is installed
#'
#' @export
#'
#' @examples
#' PackageCheck("SeuratObject", error = FALSE)
#'
PackageCheck <- function(..., error = TRUE) {
  # 获取每个参数，不要名字，只要值: 包名
  pkgs <- unlist(x = c(...), use.names = FALSE)
  # 对每个R包名，加载其命名空间，要求返回值是 logical 类型，长度为1
  package.installed <- vapply(
    X = pkgs,
    FUN = requireNamespace,
    FUN.VALUE = logical(length = 1L),
    quietly = TRUE
  )
  
  # 如果允许报错，且至少有一个没安装，则报错
  if (error && any(!package.installed)) {
    stop(
      "Cannot find the following packages: ",
      paste(pkgs[!package.installed], collapse = ', '),
      ". Please install"
    )
  }
  # 返回R包安装情况，是一个 named vector
  invisible(x = package.installed)
}




(9) 可以建立一个空的只有行名的数据框

> head(cid1, n=2)
[1] "AAACATTGAGCTAC-1" "AAACTTGAAAAACG-1"
> group.info=data.frame(row.names = c(cid1, cid2))
> group.info
data frame with 0 columns and 2638 rows

# 添加一列，根据行名填充分组
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
> head(group.info)
                  group
AAACATTGAGCTAC-1 Group1
AAACTTGAAAAACG-1 Group1
AAAGGCCTGTCTAG-1 Group1



(10) 指定行名、把单列数据转为数据框
# WilcoxDETest():
data.frame(p_val, row.names = rownames(x = data.use))


> p_val=seq(0,1, length.out=5)
> data.frame(p_val, row.names = paste0("gene", 1:5))
      p_val
gene1  0.00
gene2  0.25
gene3  0.50
gene4  0.75
gene5  1.00
















========================================
|-- Seurat 4 R包源码解析 26: step12 找差异基因 FindAllMarkers(), FeaturePlot()
----------------------------------------
1. 调包侠

(1) 找marker
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC)

# find markers for every cluster compared to all remaining cells, report only the positive ones
> pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
Calculating cluster 0
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  
Calculating cluster 1
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
Calculating cluster 2
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  
Calculating cluster 3
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  
Calculating cluster 4
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  
Calculating cluster 5
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
Calculating cluster 6
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=02s  
Calculating cluster 7
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=03s  
Calculating cluster 8
  |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% elapsed=01s  


> head(pbmc.markers)
              p_val avg_log2FC pct.1 pct.2     p_val_adj cluster  gene
RPS12 1.273332e-143  0.7298951 1.000 0.991 1.746248e-139       0 RPS12
RPS6  6.817653e-143  0.6870694 1.000 0.995 9.349729e-139       0  RPS6
RPS27 4.661810e-141  0.7281575 0.999 0.992 6.393206e-137       0 RPS27
RPL32 8.158412e-138  0.6196246 0.999 0.995 1.118845e-133       0 RPL32
RPS14 5.177478e-130  0.6252832 1.000 0.994 7.100394e-126       0 RPS14
RPS25 3.244898e-123  0.7496479 0.997 0.975 4.450053e-119       0 RPS25


> pbmc.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC)
# A tibble: 27 × 7
# Groups:   cluster [9]
       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene  
       <dbl>      <dbl> <dbl> <dbl>     <dbl> <fct>   <chr> 
 1 3.75e-112       1.09 0.912 0.592 5.14e-108 0       LDHB  
 2 9.57e- 88       1.36 0.447 0.108 1.31e- 83 0       CCR7  
 3 1.35e- 51       1.08 0.342 0.103 1.86e- 47 0       LEF1  
 4 0               5.57 0.996 0.215 0         1       S100A9
 5 0               5.48 0.975 0.121 0         1       S100A8
 6 3.89e-268       4.55 1     0.516 5.34e-264 1       LYZ   
 7 1.06e- 86       1.27 0.981 0.643 1.45e- 82 2       LTB   
 8 3.44e- 59       1.22 0.651 0.245 4.71e- 55 2       CD2   
 9 2.97e- 58       1.23 0.42  0.111 4.07e- 54 2       AQP3  
10 0               4.31 0.936 0.041 0         3       CD79A 
# … with 17 more rows
#  Use `print(n = ...)` to see more rows




(2) 该包内置的4个可视化函数： VlnPlot/FeaturePlot/DoHeatmap/DotPlot
# fig1
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))

# you can plot raw counts as well
VlnPlot(pbmc, features = c("NKG7", "PF4"), slot = "counts", log = TRUE)
VlnPlot(pbmc, features = c("NKG7", "PF4"), pt.size = 0)


# fig2：默认使用 slot=data 的数据。
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
                               "CD8A"))
#2.2 除了基因，还可以画 PC_1, UMAP_1，及 meta.data 表头: head(pbmc@meta.data)
FeaturePlot(object = pbmc, features = c('PC_1', "UMAP_1", "nFeature_RNA", "percent.mt"), 
            cols = c("#eeeeee", "red") )

#2.3 对于2个基因，还支持blend=T模式
FeaturePlot(pbmc, features = c("CD4", "CD8A"), blend = T)
#2.4 order=T 防遮挡
FeaturePlot(pbmc, features = c("CD4", "CD8A"), blend = T, order = T)

#2.5 使用 split.by 参数分面
pbmc$gene_high=ifelse(pbmc$nFeature_RNA>1500, T, F)
FeaturePlot(object = pbmc, features = c('PC_1', "CD3G"), 
            split.by = "gene_high",
            cols = c("#eeeeee", "red") )
#2.6 标记 ident ，并指定颜色、字号
FeaturePlot(pbmc, features = c("CD4"), label = T, label.size = 5, label.color = "red")


# fig3 heatmap
top5 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_log2FC)
DoHeatmap(pbmc, features = top5$gene, label = T)  #+ NoLegend()


DotPlot(pbmc, features = unique(top5$gene)) + RotatedAxis()



(3) tree 分析 //todo
pbmc_tree <- BuildClusterTree(object = pbmc)
Seurat::PlotClusterTree(pbmc_tree)
all.markers <- FindAllMarkers(object = pbmc_tree, node = 14)

top5 <- all.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_log2FC)
head(top5)
# fig4
DotPlot(pbmc, features = unique(top5$gene), cluster.idents = T) + RotatedAxis()



(4) 其他可刷资源
Seurat 可视化 https://www.jianshu.com/p/bbc7a7b4644f
Seurat 可视化 自定义 https://www.jianshu.com/p/a2fe2549cea1








2. 源码解析

函数列表

中间tree的分析跳过 FindAllMarkers: A3-B2;

- VlnPlot 见 解析8
- FeaturePlot 本文。
	* shape.by 参数，split.by 参数，
	* IFeaturePlot //todo
	* SetQuantile;
	* RandomName
	* BlendMatrix //todo
	* BlendExpression //todo
	* BlendMap //跳过
	* LabelClusters 解析24-2(4) 很神奇的函数
	问题
		* pallete 调色板调用失败

- DoHeatmap //todo 
- DotPlot //todo






3. R tips 
(1) setNames(object=nm, nm)函数，使用参数2个参数1命名，为vector增加name属性。

> setNames( 1:3, c("foo", "bar", "baz") )
foo bar baz 
  1   2   3 

是下面这个写法的缩写
> tmp <- 1:3
> names(tmp) <-  c("foo", "bar", "baz")
> tmp
foo bar baz 
  1   2   3 


特殊写法：对于字符串数组，自己给自己命名：
> setNames(nm = c("First", "2nd"))
  First     2nd 
"First"   "2nd"

setNames()一般用于函数结尾，创造named vector并返回。



相关功能的函数是 unname()，去掉vector的name属性。
> str(tmp)
 Named int [1:3] 1 2 3
 - attr(*, "names")= chr [1:3] "foo" "bar" "baz"
> tmp
foo bar baz 
  1   2   3 
> unname(tmp)
[1] 1 2 3





(2) 检测某个包是否安装？
源码
if (!PackageCheck('ape', error = FALSE)) {
  stop(cluster.ape, call. = FALSE)
}


核心函数:
> PackageCheck("ape")
> print(PackageCheck("ape"))
 ape 
TRUE

请回顾 源码解析8-3-(13).




(3) ggplot2 坐标轴处理 scale_y_continuous()：双坐标轴，并删除右侧y轴的竖线、刻度、刻度文字
前提是把y轴显示到y轴右侧。


#设置主题
# Set a theme to remove right-hand Y axis lines
# Also sets right-hand Y axis text label formatting
library(ggplot2)
no.right <- theme(
  axis.line.y.right = element_blank(),
  axis.ticks.y.right = element_blank(),
  axis.text.y.right = element_blank(),
  axis.title.y.right = element_text(
    face = "bold",
    size = 14,
    margin = margin(r = 7)
  )
)

# 实例1: y坐标轴显示到右侧
ggplot(diamonds, aes(carat, price, color=color))+
  geom_point()+ 
  scale_y_continuous(position = "right") + #y轴显示到右侧
  theme_bw() +
  no.right #使用主题


# 实例2: 右侧新增一条y坐标轴
ggplot(diamonds, aes(carat, price, color=color))+
  geom_point()+ 
  scale_y_continuous(
    sec.axis = dup_axis(name = "gene1"),#定义第二个y轴的名字（右侧y轴）
    ) + 
  theme_bw() +
  no.right #使用主题


注意: FeaturePlot() 写了很多 双坐标轴的，又隐藏，这些句子反复覆盖。
	scale_y_continuous(
	  sec.axis = dup_axis(name = features[[idx]]),
	  limits = ylims
	)




(4) formals() 获取函数的参数列表，进而拿到参数默认值

源码: 
default.colors <- eval(expr = formals(fun = FeaturePlot)$cols)


> formals(fun = FeaturePlot)$cols
if (blend) {
    c("lightgrey", "#ff0000", "#00ff00")
} else {
    c("lightgrey", "blue")
}

> blend=T
> eval(expr = formals(fun = FeaturePlot)$cols)
[1] "lightgrey" "#ff0000"   "#00ff00"


实例2:
> myadd=function(x, y=2){x+y}
> myadd(10, 20)
[1] 30
> myadd(10)
[1] 12

获取参数
> formals(myadd)
$x


$y
[1] 2

> class(formals(myadd)) #这是参数的特殊格式：配对列表
[1] "pairlist"

> str(formals(myadd))
Dotted pair list of 2
 $ x: symbol 
 $ y: num 2

获取参数的具体值
> formals(myadd)$x

> formals(myadd)$y
[1] 2
> class(formals(myadd)$x)
[1] "name"
> class(formals(myadd)$y)
[1] "numeric"





(5) mapply(fun, ...) 是 apply 的多参数版本
* 第一个是函数，后面是其参数。

> mapply(function(x, y){
+   ifelse(x>y, x, y)
+ }, c(1,2,3), c(-10,100,0))
[1]   1 100   3


拆分：
fn1=function(x, y){
  ifelse(x>y, x, y)
}
fn1(1,30) #30
fn1(c(1,0), c(-1, 20)) # 1 20
a1=1:3
a2=c(-10,100,0)
mapply(fn1, a1, a2) #  1 100   3


* 重点：函数对df参数的每一列给出一个返回值。对list中每个参数给出一个返回值。

> mapply(mean, mtcars[1:4])
      mpg       cyl      disp        hp 
 20.09062   6.18750 230.72188 146.68750



源码：
mapply(FUN = function(cutoff, feature) {
    return(ifelse(test = is.na(x = cutoff), yes = min(data[, 
      feature]), no = cutoff))
  }, cutoff = min.cutoff, feature = features)

合理设置个初始值，运行一下:
> cutoff=NA
> features=c("CD4", "CD8A")
> data=FetchData(pbmc, vars = c("UMAP_1","ident", features))
> head(data, n=2)
                   UMAP_1 ident CD4     CD8A
AAACATACAACCAC-1 2.864640     2   0 1.635873
AAACATTGAGCTAC-1 5.019568     3   0 0.000000
> mapply(FUN = function(cutoff, feature) {
+   return(ifelse(test = is.na(x = cutoff), yes = min(data[, feature]), no = cutoff))
+ }, cutoff = min.cutoff, feature = features)
[1] 1 1




(6) vapply可以定义每个返回值的类型和数量
每个列对应一个返回值列/向量。


features=c("CD4", "CD8A")
min.cutoff=c(0,10)
max.cutoff=c(10, 20)
vapply(
  X = list(features, min.cutoff, max.cutoff),
  FUN = length,
  FUN.VALUE = numeric(length = 1) #vapply可以定义每个返回值的类型：这里是长度为1的数字
)

#test1: 如果返回值类型不符合预期呢？
vapply(
  X = list(features, min.cutoff, max.cutoff),
  FUN = length,
  FUN.VALUE = character(length = 1) #vapply可以定义每个返回值的类型：这里是长度为1的字符串
)
#报错：
#Error in vapply(X = list(features, min.cutoff, max.cutoff), FUN = length,  : 
#values must be type 'character',
#but FUN(X[[1]]) result is type 'integer'


#test2: 长度不符合预期呢？
vapply(
  X = list(features, min.cutoff, max.cutoff),
  FUN = length,
  FUN.VALUE = numeric(length = 2) #vapply可以定义每个返回值的类型：这里是长度为2的数字向量
)
# 报错
#Error in vapply(X = list(features, min.cutoff, max.cutoff), FUN = length,  : 
#values must be length 2,
#but FUN(X[[1]]) result is length 1




(7) 取分位数 stats::quantile(0:10)

> stats::quantile(0:10)
  0%  25%  50%  75% 100% 
 0.0  2.5  5.0  7.5 10.0 

> stats::quantile(0:10, probs=0.25)
25% 
2.5 


参考上文第二部分: Seurat::SetQuantile() 函数。
> Seurat::SetQuantile("q25", 0:10) #为什么不一致？因为Seurat只取费0值的分位数
[1] 3.25
# 相当于：
> stats::quantile(1:10, probs=0.25)
 25% 
3.25 

# 不符合 q开头后面1-2个数字的，直接返回第一个参数
> Seurat::SetQuantile(25, 0:10)
[1] 25

# q后三个数字也不符合正则
> Seurat::SetQuantile("q100", 0:10)
[1] NA
Warning message:
In Seurat::SetQuantile("q100", 0:10) : NAs introduced by coercion
> Seurat::SetQuantile("q99", 0:10)
[1] 9.91





(8) 把该列数据按照 颜色个数切分，并转为因子
源码：
# 否则，把该列数据按照 颜色个数切分，并转为因子
as.numeric(x = as.factor(x = cut(
  x = as.numeric(x = data.feature),
  breaks = brewer.gran
))


尝试运行：
data.feature=0:10
brewer.gran=3
# cut返回的本来就是factor，所以这个as.factor 冗余。
as.numeric(x = as.factor(x = cut(
  x = as.numeric(x = data.feature),
  breaks = brewer.gran
) ) )
# 去掉 as.factor 后
tmp=as.numeric(x = cut(
  x = as.numeric(x = data.feature),
  breaks = brewer.gran
) ); tmp

# 作用，就是根据数值大小给不同颜色，类似热图
colors.m1=c("blue", "grey", "red")
plot(data.feature, col=colors.m1[tmp], pch=19)





(9) 获取RColorBrewer包某个调色盘的颜色个数

> library(RColorBrewer)
> cols=1
> brewer.pal.info[cols, ]$maxcolors
[1] 11

> brewer.pal.info[cols, ]
     maxcolors category colorblind
BrBG        11      div       TRUE

> brewer.pal(11, "BrBG") #获取颜色
 [1] "#543005" "#8C510A" "#BF812D" "#DFC27D" "#F6E8C3" "#F5F5F5" "#C7EAE5" "#80CDC1" "#35978F" "#01665E"
[11] "#003C30"






(10) sapply 返回的值确实没有列名

> data=mtcars[1:3, ]
> head(data)
               mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1

> tmp=sapply(
+   X=1:4,
+   FUN=function(index){
+     data.feature=data[, index]
+     return(data.feature)
+   }
+ )

> tmp
     [,1] [,2] [,3] [,4]
[1,] 21.0    6  160  110
[2,] 21.0    6  160  110
[3,] 22.8    4  108   93

> class(tmp)
[1] "matrix" "array" 


# 添加列名
> colnames(x = tmp)[1:ncol(x = tmp)] <- colnames(mtcars)[1:ncol(tmp)]
> tmp
      mpg cyl disp  hp
[1,] 21.0   6  160 110
[2,] 21.0   6  160 110
[3,] 22.8   4  108  93





(11) 生成随机名字

> RandomName
function (length = 5L, ...) 
{
    CheckDots(..., fxns = "sample")
    return(paste(sample(x = letters, size = length, ...), collapse = ""))
}
<bytecode: 0x55fe520eccf8>
<environment: namespace:SeuratObject>
> RandomName()
[1] "njgio"


分解运行：
> sample(x = letters, size = 5L)
[1] "e" "b" "j" "l" "o"

> paste(sample(x = letters, size = 5L), 
+       collapse = "")
[1] "atcfj"





(12) 创建一个内容是list的向量
> tmp=vector( mode = "list", length=2)
> tmp
[[1]]
NULL

[[2]]
NULL

> class(tmp)
[1] "list"
> str(tmp)
List of 2
 $ : NULL
 $ : NULL






(13) 修改源码式调试 //todo 
希望找一个java类似的调试方法，无侵入式的打断点，暂时没找到怎么做。

参考: 
https://www.coder.work/article/6812496

折中方法是，编辑源码，添加 输出 语句
> edit(FeaturePlot)

第143行添加 print(data$split);
点击确定后，复制出控制台的函数定义，重新输入
FeaturePlot2= 刚修改后的函数定义

然后执行 
FeaturePlot2(object = pbmc, features = c('PC_1', "CD3G"), 
            #split.by = "gene_high", pt.size = 1,
            cols = c("#eeeeee", "red") )
发现那一行有输出：Levels: wknrs






(14) 因子和字符串是否相等的比较，建议先把因子转为字符串，否则容易出现莫名其妙的错误，还不报错。
源码：
data.plot <- data[as.character(x = data$split) == ident, , drop = FALSE]


因子要先转为字符串，再和字符串比较，否则容易出错
> tmp=mtcars[, 1:3];
> tmp$brand=paste0("brand", 1:nrow(tmp))
> rownames(tmp)=tmp$brand
> tmp$brand=factor(tmp$brand)
> #tmp |> head()
> #str(tmp)
> select = tmp[which(tmp$mpg>32),]$brand
> select
[1] brand18 brand20
32 Levels: brand1 brand10 brand11 brand12 brand13 brand14 brand15 brand16 brand17 brand18 ... brand9
> tmp[select, ]
         mpg cyl  disp   brand
brand10 19.2   6 167.6 brand10
brand13 17.3   8 275.8 brand13
> tmp[as.character(select), ]
         mpg cyl disp   brand
brand18 32.4   4 78.7 brand18
brand20 33.9   4 71.1 brand20


# 错误的原因：factor 自动转为 数字，而不是字符串，然后取子集
> as.numeric(select)
[1] 10 13
> tmp[as.numeric(select), ]
         mpg cyl  disp   brand
brand10 19.2   6 167.6 brand10
brand13 17.3   8 275.8 brand13

预防错误的措施，避免非比较的factor变量！



单个使用的反例没有构建起来 //todo

> ident=levels(tmp$brand)[1]; ident
[1] "brand1"
> tmp[which( as.character(tmp$brand) == ident),]
       mpg cyl disp  brand
brand1  21   6  160 brand1
> tmp[which( tmp$brand == ident),]
       mpg cyl disp  brand
brand1  21   6  160 brand1







(15) 一个变量是否是数据框is.data.frame()？

> is.data.frame
function (x) 
inherits(x, "data.frame")
<bytecode: 0x55fe34924468>
<environment: namespace:base>

> is.data.frame(mtcars)
[1] TRUE
> is.data.frame(mtcars$mpg)
[1] FALSE



(16) ggplot2 设置x和y轴的范围
源码：
	scale_x_continuous(limits = xlims) +
	scale_y_continuous(limits = ylims) +
	theme_cowplot()

测试：
library(ggplot2)
library(cowplot)
ggplot(mtcars, aes(mpg, cyl))+
  geom_point()+
  #xlim(12, 40)
  scale_x_continuous(limits = c(12, 40))+ #效果同上
  theme_cowplot()

Seurat 作者很喜欢使用这个主题，让我们记住它: cowplot::theme_cowplot() //重要




(17) ggplot2 标题居中主题
ggplot2主题函数，就是直接返回 theme() 的函数。根据里面的功能命名函数名，增强代码的可读性。

> CenterTitle
function (...) 
{
    return(theme(plot.title = element_text(hjust = 0.5), validate = TRUE, 
        ...))
}
<bytecode: 0x55fe81af1b30>
<environment: namespace:Seurat>


使用：
library(ggplot2)
library(cowplot)
ggplot(mtcars, aes(mpg, cyl))+
  geom_point()+
  theme_cowplot()+
  ggtitle("This is title")+CenterTitle() #标题居中





(18) ggplot2直接使用变量名绘图：aes_string() 代替 aes()
# 常规写法 aes()
library(ggplot2)
ggplot(mtcars, aes(mpg, cyl))+
  geom_point()

# 另一种写法aes_string()：使用变量，而不是列名本身
x="mpg"
y="cyl"
ggplot(mtcars, aes_string(x, y))+
  geom_point()





(19) ggplot2 添加第二条坐标轴
源码: scale_y_continuous(sec.axis = dup_axis(name = ""), limits = ylims)


library(ggplot2)
plot=ggplot(mtcars, aes(mpg, cyl))+
  geom_point()

ident="1"
ylims=c(2, 10)
# 方法：在scale_y_continous()中添加一个sec_axis的函数，设定第二条y轴
plot +
  scale_y_continuous(
    sec.axis = dup_axis(name = ident),
    limits = ylims
  )

大佬不建议使用双Y轴，认为会干扰人的判断。
More： https://blog.csdn.net/weixin_39618597/article/details/109920011




(20) ggplot2 去掉左侧的y轴，底部的x轴
library(ggplot2)
plot=ggplot(mtcars, aes(mpg, cyl))+
  geom_point()+
  cowplot::theme_cowplot()
plot

plot + theme(
  axis.line.y = element_blank(), #y轴
  axis.ticks.y = element_blank(), #y轴刻度
  axis.text.y = element_blank(),  #y轴刻度文字
  axis.title.y.left = element_blank() #y轴标题
)

同理，去掉x轴的方法：
plot + theme(
  axis.line.x = element_blank(),
  axis.ticks.x = element_blank(),
  axis.text.x = element_blank(),
  axis.title.x = element_blank()
)




(21) ggplot2 使用RColorBrewer包的调色板

library(ggplot2)
library(RColorBrewer)
plot1=ggplot(mtcars, aes(mpg, cyl, color=factor(carb) ))+
  geom_point()+
  cowplot::theme_cowplot()
plot1

两种用法：
plot1 + scale_color_brewer(palette = "Set2") #使用名字
plot1 + scale_color_brewer(palette = 1) #使用序号





(22) ggplot2 渐变色设置 scale_color_gradientn()

library(ggplot2)
library(RColorBrewer)
plot2=ggplot(mtcars, aes(mpg, cyl, color=carb ))+
  geom_point()+
  cowplot::theme_cowplot()
plot2

例1: 基本使用
plot2 + scale_color_gradientn(
  colors = c("lightgrey", 'red'),
  guide = "colorbar"
)
#guide: 两个取值， colorbar 连续型，legend 离散型	
#Type of legend. Use "colourbar" for continuous colour bar, or "legend" for discrete colour legend.



例2: 设置渐变色对应的数值的范围，低于最低的按颜色1，高于最高值的按颜色2.
min.feature.value = min(mtcars$carb) #1
max.feature.value = max(mtcars$carb) #8
plot2 & scale_color_gradientn(
  colors = c("lightgrey", 'red'),
  #limits = c(min.feature.value, max.feature.value)
  limits = c(3, 4)
)






(23) ggplot2 固定x和y轴的比例

plot + coord_fixed()




(24) 高阶函数 Filter 过滤列表

源码  plots <- Filter(f = Negate(f = is.null), x = plots)

分析 
> plots=vector(mode = "list", length=4)
> plots[[2]]=200; plots[[4]]=400
> plots
[[1]]
NULL

[[2]]
[1] 200

[[3]]
NULL

[[4]]
[1] 400


Filter过滤：保留 T的，舍弃F的
Negate(f)是对函数取反
> plots <- Filter(f = Negate(f = is.null), x = plots)
> plots
[[1]]
[1] 200

[[2]]
[1] 400






(25) 图形排布：获取矩阵最后一行的编号，用行列总数(n行，m列)表示

features=c("CD4", "CD8A") #默认一个基因一行
nsplits=3 #3列
# 打印最后一行的序号：上一行结尾+1，这一行结尾
for (i in (length(x = features) * (nsplits - 1) + 1):(length(x = features) * nsplits)) {
  print(i)
}

输出:
[1] 5
[1] 6





(26) 图形排布：获取最顶行图形

features=c("CD4", "CD8A")
plots=1:6
for (i in which(x = 1:length(x = plots) %% length(x = features) == 1)) {
  print(i);  
}
输出:
[1] 1
[1] 3
[1] 5



#分解
length(x = plots) #6
length(x = features) #2

(1:6) %% 2 #[1] 1 0 1 0 1 0
1:6 %% 2   #[1] 1 0 1 0 1 0
(1:6) %% 2 == 1 #TRUE FALSE  TRUE FALSE  TRUE FALSE
which((1:6) %% 2 == 1) #[1] 1 3 5

x = 1:length(x = plots) %% length(x = features) == 1
x #[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE

which(x = 1:length(x = plots) %% length(x = features) == 1)
# 1 3 5





(27) 对list中的小图排序（经典代码）

源码:
plots <- plots[c(do.call(
	what = rbind,
	args = split(
			x = 1:length(x = plots), 
			f = ceiling(x = seq_along(along.with = 1:length(x = plots)) / length(x = features))
		)
))]

这段代码压缩度很高，使用了很多高阶函数，值得反复学习。
主要功能：对list进行排序。



分解:
> # 假设2个基因，3个split，共6个小图
> seq_along(along.with = 1:6) #共1-6个小图
[1] 1 2 3 4 5 6
> seq_along(along.with = 1:6) / 2 #每行2个基因
[1] 0.5 1.0 1.5 2.0 2.5 3.0
> ceiling(seq_along(along.with = 1:6) / 2) #向上取整，表示所在的行数
[1] 1 1 2 2 3 3



# 把x=1:6按照f进行分组
> split(
+   x = 1:6, 
+   f = ceiling(x = seq_along(along.with = 1:6) / 2)
+ )
$`1`
[1] 1 2

$`2`
[1] 3 4

$`3`
[1] 5 6



# 调用函数rbind，对列表进行合并：按行合并
> do.call(
+   what = rbind,
+   args = split(
+     x = 1:6, 
+     f = ceiling(x = seq_along(along.with = 1:6) / 2)
+   )
+ )
  [,1] [,2]
1    1    2
2    3    4
3    5    6

# 矩阵转向量，默认是按照列展开的
> tmp=c(
+   do.call(
+     what = rbind,
+     args = split(
+       x = 1:6, 
+       f = ceiling(x = seq_along(along.with = 1:6) / 2)
+     )
+   )
+ )
> tmp
[1] 1 3 5 2 4 6



# 模拟小图list
> plots=list(1,"2-apple",3,4,"5-orange",6)
> plots
[[1]]
[1] 1

[[2]]
[1] "2-apple"

[[3]]
[1] 3

[[4]]
[1] 4

[[5]]
[1] "5-orange"

[[6]]
[1] 6



# 对小图list排序
> plots[tmp]
[[1]]
[1] 1

[[2]]
[1] 3

[[3]]
[1] "5-orange"

[[4]]
[1] "2-apple"

[[5]]
[1] 4

[[6]]
[1] 6



(28) ggplot2 字体设置主题: FontSize() 【good】十分好用的函数

源码: baseplot + FontSize(x.title = 20, y.title = 20) + NoLegend()

实现:
#' @param x.text,y.text X and Y axis text sizes
#' @param x.title,y.title X and Y axis title sizes
#' @param main Plot title size
#'
#' @importFrom ggplot2 theme element_text
#' @export
#' @concept visualization
#'
#' @rdname SeuratTheme
#' @aliases FontSize
#'
FontSize <- function(
  x.text = NULL, #刻度文字
  y.text = NULL,
  x.title = NULL, #轴的标题
  y.title = NULL,
  main = NULL,
  ...
) {
  font.size <- theme( #这个等号<-及其左侧都是多余的
    # Set font sizes
    axis.text.x = element_text(size = x.text),
    axis.text.y = element_text(size = y.text),
    axis.title.x = element_text(size = x.title),
    axis.title.y = element_text(size = y.title),
    plot.title = element_text(size = main),
    # Validate the theme
    validate = TRUE,
    # Extra parameters
    ...
  )
}


测试: 
library(ggplot2)
ggplot(mtcars, aes(mpg, disp))+
  geom_point()+
  theme_classic()+
  Seurat::FontSize(
    x.title = 20, y.title = 20,
    x.text = 15, y.text = 15
  )
这个字体大小简直太完美了。



(29) globalVariables() 干啥的？//todo
解析12-3.2 也提到，还是不很懂该函数的作用。

源码(摘出来仅仅是因为它紧邻我们关心的函数)
globalVariables(
  names = c('myAUC', 'p_val', 'avg_logFC'),
  package = 'Seurat',
  add = TRUE
)


查到了一些资料，但是还是不理解该函数干啥的？
https://rdrr.io/r/utils/globalVariables.html

使用的局部变量（函数中定义的瞬时变量）和语法糖（如“:=”）也要用全局变量函数GlobalVariables加以定义。比如“globalVariables(c(":=","!!",".",".SD"))”。









4. Bug 











========================================
|-- Seurat 4 R包源码解析 27: 计算每组的平均表达量 AverageExpression()
----------------------------------------
https://zhuanlan.zhihu.com/p/665586787


1. 调包侠
library(ggplot2)
library(Seurat)
library(dplyr)
library(patchwork)
pbmc=readRDS("D:\\xampp\\htdocs\\Seurat_source\\sources\\pbmc3k_final.rds")

DimPlot(pbmc, label = T)

dat=AverageExpression(pbmc, group.by = "seurat_clusters")$RNA
head(dat[,1:5])

library(pheatmap)
pheatmap(dat[VariableFeatures(pbmc),], border_color = NA,
         scale = 'row',
         clustering_method = "ward.D2",
         show_rownames = F,
         main="PBMC 3k")

gene.set=unique(c("PTPRC", "CD3D","CD3E", "CD3G","CD4", "CD8A", 
                  'CCR7','IL7R', 'S100A4', 'KLRG1',
                  'GZMK',
                  "GNLY", "NKG7", 
                  "CD14", "LYZ", 'CST3',
                  "CD79A", "CD79B", "MS4A1", 
                  "FCER1A", "FCGR3A", 
                  "PPBP", "PF4"))
pheatmap(dat[gene.set,], border_color = "white",
         scale = 'row',
         clustering_method = "ward.D2",
         show_rownames = T,
         main="PBMC 3k")


(2) 计算逻辑


# test2
exp(1)
exp(1)-1
expm1(1)


1) 原函数
system.time({
  dat1=AverageExpression(pbmc, group.by = "seurat_clusters")$RNA
})
dat1[1:3, 1:5]


2) 手工计算
system.time({
  dat2 = sapply( X=split(
      as.data.frame(t(expm1( as.data.frame (pbmc@assays$RNA@data))) ), 
      pbmc$seurat_clusters
    ), 
    FUN = function(x){
      colMeans(x) # 按列求平均
    })
})
dat2[1:3, 1:5]

table( abs(as.data.frame(dat1)- as.data.frame(dat2) ) < 1e-5)


3) 原始函数关键语句
system.time({
  data.use <- GetAssayData(object = pbmc, assay = 'RNA', slot = 'data')
  #data.use <- data.use[rownames(pbmc), ]
  data.use <- expm1(x = data.use)
  
  t1=FetchData(pbmc, vars=("ident"))
  
  category.matrix = Matrix::sparse.model.matrix(object=as.formula("~0+t1[,1]") )
  category.matrix = sweep(x = category.matrix, MARGIN = 2, STATS = colSums(x = category.matrix), FUN = "/")
  colnames(category.matrix) = gsub(pattern = "t1\\[, [1-9]*\\]", replacement = "", x = colnames(category.matrix))
  
  dat3 <- as.matrix(x = (data.use %*% category.matrix))
})
dat3[1:3, 1:5]
table( abs(as.data.frame(dat1)- as.data.frame(dat3) ) < 1e-5)




2. 源码



3. R tips

稀疏矩阵的初始化、计算方法。





========================================
|-- Seurat 4 R包源码解析 28: step12 差异基因可视化 VlnPlot/ FeaturePlot/ DoHeatmap/ DotPlot //todo
----------------------------------------
1. 调包侠

(4) 可视化-小提琴图
#* VlnPlot 见解析 8
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))

# you can plot raw counts as well
VlnPlot(pbmc, features = c("NKG7", "PF4"), slot = "counts", log = TRUE)


(5) 可视化-FeaturePlot
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
                               "CD8A"))

(6) 可视化-热图 heatmap
top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
DoHeatmap(pbmc, features = top10$gene, label = T)  #+ NoLegend()

(8) 可视化-dotplot 
DotPlot(pbmc, features = unique( top10$gene ) ) + RotatedAxis()
DotPlot(pbmc, features = unique( top10$gene ), cluster.idents = T ) + RotatedAxis() #对cluster进行聚类













========================================
|-- todo //日志类
----------------------------------------
总目录: https://zhuanlan.zhihu.com/p/465392721



查函数在哪个文件哪一行的shell语句:
$ find . | grep "R$" | grep -v "testthat" | grep -v "notes" | xargs grep -n "^\s*FoldChange" 2>/dev/null --color=auto



2. 
> Assays(pbmc)
[1] "RNA"

> UpdateKey()


查 S3 风格的方法的代码 
> getAnywhere("Key.Seurat") #用到了 vapply 


查 S4 风格的方法的代码 
> getMethod("show", signature="Seurat")
Method Definition:
function (object) 
{
    object <- UpdateSlots(object = object)
...


> DiscretePalette() 配色方案




()
# $ find . | grep "R$" | xargs grep -n "LogSeuratCommand" --color=auto
# seurat-object-4.0.4/R/command.R:59:LogSeuratCommand <- function(object, return.command = FALSE) {







# IsGlobal()
> slotNames(pbmc_small@reductions$pca)
[1] "cell.embeddings"            "feature.loadings"          
[3] "feature.loadings.projected" "assay.used"                
[5] "global"                     "stdev"                     
[7] "key"                        "jackstraw"                 
[9] "misc" 

> str(pbmc_small@reductions$pca@global)
 logi FALSE
> pbmc_small@reductions$pca@global
[1] FALSE









1. 多进程中的函数

$ find . | grep "R$" |xargs grep -n -i "Parenting" --color=auto
./seurat-4.1.0/R/utilities.R:2232:Parenting <- function(parent.find = 'Seurat', ...) {



> Seurat:::Parenting
function (parent.find = "Seurat", ...) 
{
    calls <- as.character(x = sys.calls())
    calls <- lapply(X = strsplit(x = calls, split = "(", 
        fixed = TRUE), FUN = "[", 1)
    parent.index <- grep(pattern = parent.find, x = calls)
    if (length(x = parent.index) != 1) {
        warning("Cannot find a parent environment called ", 
            parent.find, immediate. = TRUE, call. = FALSE)
    }
    else {
        to.parent <- list(...)
        if (length(x = to.parent) == 0) {
            warning("Nothing to parent", immediate. = TRUE, 
                call. = FALSE)
        }
        else if (is.null(x = names(x = to.parent))) {
            stop("All input must be in a key = value pair")
        }
        else if (length(x = Filter(f = nchar, x = names(x = to.parent))) != 
            length(x = to.parent)) {
            stop("All inputs must be named")
        }
        else {
            parent.environ <- sys.frame(which = parent.index)
            for (i in 1:length(x = to.parent)) {
                parent.environ[[names(x = to.parent)[i]]] <- to.parent[[i]]
            }
        }
    }
}
<bytecode: 0x0000000018191b28>
<environment: namespace:Seurat>





> cmd <- LogSeuratCommand(object = pbmc, return.command = TRUE)
Error: 'LogSeuratCommand' cannot be called at the top level


fn1=function(pbmc, a=100, b=-50){
	cmd <- LogSeuratCommand(object = pbmc, return.command = TRUE)
	return(cmd)
}
fn1() #报错




2. 表达式处理

@importFrom rlang is_quosure enquo eval_tidy


PCA: https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/Dimension%20Reduction.pdf
tSNE: https://distill.pub/2016/misread-tsne/




3. 测试用例
/tests/testthat/









========================================
准备工作: 开启 docker Rstudio
----------------------------------------
1. 启动一个 docker 学习R
$ docker run -d -p 8787:8787 -e PASSWORD=123456 rocker/rstudio:4.1.1

交互式
$ docker exec -it cd36 bash




2. win10 安装一个R

(1) 最新版是 R 4.1.3
https://mirrors.tuna.tsinghua.edu.cn/CRAN/
install.packages("Seurat")

(2) 更新 Rstudio
原来的 V 1.1.414

https://www.rstudio.com/products/rstudio/download/








========================================
----------------------------------------



========================================
----------------------------------------



========================================
*** 其他单细胞R包 ***
----------------------------------------



========================================
1.sc3包适合<5k cell的数据集
----------------------------------------
paper:Nat Methods. 2017 May;14(5):483-486. doi: 10.1038/nmeth.4236. Epub 2017 Mar 27.
SC3: consensus clustering of single-cell RNA-seq data.
https://www.ncbi.nlm.nih.gov/pubmed/28346451


A tool for unsupervised clustering and analysis of single cell RNA-Seq data.
该工具有很多聚类工具。




========================================
scran 包: Using scran to analyze single-cell RNA-seq data
----------------------------------------
1.
The scran package implements methods to perform low-level processing of scRNA-seq data, including 
- cell cycle phase assignment, 
- scaling normalization, 
- variance modelling and testing for corrrelated genes. 
This vignette provides brief descriptions of these methods and some toy examples to demonstrate their use.

http://bioconductor.org/packages/release/bioc/vignettes/scran/inst/doc/scran.html



========================================
Scater 包的使用
----------------------------------------
1. paper 
D.J. McCarthy, K.R. Campbell, A.T.L. Lun, Q.F. Wills
Scater: pre-processing, quality control, normalization and visualization of single-cell RNA-seq data in R
Bioinformatics (2017), Article btw777

(2) 用的paper


J Allergy Clin Immunol. 2021 Jun;147(6):2370-2380. doi: 10.1016/j.jaci.2020.11.028. Epub 2020 Dec 9.
Single-cell RNA sequencing of psoriatic skin identifies pathogenic Tc17 cell subsets and reveals distinctions between CD8 + T cells in autoimmunity and cancer
https://pubmed.ncbi.nlm.nih.gov/33309739/






2.
Scater需要利用SingleCellExperiment这个对象

## 创建 scater 要求的对象
sce <- SingleCellExperiment(
  assays = list(counts = as.matrix(counts)), 
  colData = meta
)





ref:https://www.jianshu.com/p/869590243d64




========================================
整合数据 integration
----------------------------------------
1. 文章

T. Stuart, A. Butler, P. Hoffman, C. Hafemeister, E. Papalexi, W.M. Mauck, et al.
Comprehensive integration of single-cell data
Cell, 177 (2019), pp. 1888-1902.e21





========================================
|-- harmony 包
----------------------------------------

https://github.com/immunogenomics/harmony






========================================
DiffusionMap R tips
----------------------------------------
1. list to vector, using sapply;
https://cloud.tencent.com/developer/article/1606694

> strsplit(colnames(iris), "\\.")
[[1]]
[1] "Sepal"  "Length"

[[2]]
[1] "Sepal" "Width"

[[3]]
[1] "Petal"  "Length"

[[4]]
[1] "Petal" "Width"

[[5]]
[1] "Species"

> sapply(strsplit(colnames(iris), "\\."), "[", 1)
[1] "Sepal"   "Sepal"   "Petal"   "Petal"   "Species"

> sapply(strsplit(colnames(iris), "\\."), "[[", 1)
[1] "Sepal"   "Sepal"   "Petal"   "Petal"   "Species"

关键：利用了 "[" 也是函数，后面是参数1
等价于 
> sapply(strsplit(colnames(iris), "\\."), function(x){ x[[1]]})
[1] "Sepal"   "Sepal"   "Petal"   "Petal"   "Species"

> sapply(strsplit(colnames(iris), "\\."), function(x){ x[1]})
[1] "Sepal"   "Sepal"   "Petal"   "Petal"   "Species"






========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------

