Seurat包是大一统的scRNAseq分析包

- 技巧与重回函数汇总

docker:
1. aertslab/pyscenic
https://hub.docker.com/r/aertslab/pyscenic

$ docker pull aertslab/pyscenic:0.11.0



2. 查看全部函数
library(help = "Seurat")







========================================
Seurat 包的安装
----------------------------------------
1. 安装 Seurat
(1) 安装 RcppTOML 老版本
> require(devtools)
> install_version("RcppTOML", version = "0.1.3")  #https://cran.rstudio.com/src/contrib/RcppTOML_0.1.7.tar.gz
# https://cran.rstudio.com//src/contrib/Archive/RcppTOML/RcppTOML_0.1.3.tar.gz


(2) 安装reticulate 老版本
> install.packages("reticulate")

trying URL 'https://cran.rstudio.com/src/contrib/reticulate_1.26.tar.gz'
ERROR: compilation failed for package ‘reticulate’

降级，安装老版本
> install_version("reticulate", version = "1.20")


(3) 再次尝试安装Seurat
install.packages("Seurat"); 
library("Seurat")



(4) 2023.10 在 Z server 安装 Seurat 

# 安装R包的方法：单细胞
# https://www.jianshu.com/p/bf01f4901ae8
# https://www.jianshu.com/p/bf01f4901ae8
# gcc 版本对照表 https://blog.csdn.net/qq_39974998/article/details/130396600

#options(BioC_mirror="https://mirrors.ustc.edu.cn/bioc/")
##指定镜像，这个是中国科技大学镜像
# 
options(BioC_mirror="https://mirrors.tuna.tsinghua.edu.cn/bioconductor/")

options("repos" = c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/")) 
##指定install.packages安装镜像，这个是清华镜像

install.packages("pheatmap")
install.packages("BiocManager")
install.packages("ggplot2")
install.packages("Seurat")


#BioConductor 的包
if (!requireNamespace("devtools"))
  install.packages("devtools")
#
devtools::install_github("TomKellyGenetics/leiden")

# ERROR: dependencies ‘leiden’, ‘RcppAnnoy’, ‘reticulate’, 
# ‘sctransform’, ‘uwot’ are not available for package ‘Seurat’

install.packages("leiden")


require(devtools)
install_version("RcppTOML", version = "0.1.3")
# BiocManager::install("RcppTOML")
# BiocManager::install("Seurat")
install_version("reticulate", version = "1.20")
install_version("RcppAnnoy", version = "0.0.19")
install_version("sctransform", version = "0.3.3")
install_version("spatstat.core", version = "2.4.4")
install_version("uwot", version = "0.1.11")
# ‘RcppAnnoy’, ‘sctransform’, ‘spatstat.core’, ‘uwot’ are not available for package ‘Seurat’
install_version("Seurat", version = "4.1.1")

library(Seurat)



BiocManager::install('Biobase')
install.packages('NMF')
library(NMF)




==> 使用Leiden时，需要在R中设置 py 资源。只能R第一次启动时设置，设置后不能修改；想修改就需要重启R session。
# set Python version you use in R
library("reticulate")
use_python("/home/wangjl/software/anaconda3/bin/python3", required = T)
py_config()
system("pip3 -V")
system("which pip3")

## Leiden algorithm ----
system("pip3 install leidenalg -i https://pypi.douban.com/simple/")
system("which pip3")

system("pip3 list | grep leidenalg")









2. 周边R包
(1) hdf5r 包
> install.packages("hdf5r")
- RPM-based (e.g Fedora): 'sudo yum install hdf5-devel'


==> try2 
$ sudo yum install hdf5-devel
Dependency Installed:
  hdf5.x86_64 0:1.8.12-13.el7 ...  libaec-devel.x86_64 0:1.0.4-1.el7

> install.packages("hdf5r")
configure: error: The version of hdf5 installed on your system is not sufficient. Please ensure that at least version 1.8.13 is installed
ERROR: configuration failed for package ‘hdf5r’



==> try3 卸载yum安装旧版本后，从官网下载 hdf5-1.10.5安装
$ wget https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.5/src/hdf5-1.10.5.tar.gz
$ tar xvf hdf5-1.10.5.tar.gz
$ cd hdf5-1.10.5
$ ./configure --prefix=/home/wangjl/
$ make -j 10
$ make install

然后在 这和 这发现 hdf5r 的安装依赖 h5cc,因为是自己安装的 hdf5，所以需要手动指定 h5cc 路径
> install.packages("hdf5r", configure.args="--with-hdf5=/home/wangjl/bin/h5cc")
Error: package or namespace load failed for ‘hdf5r’ in dyn.load(file, DLLpath = DLLpath, ...):
  unable to load shared object '/home/wangjl/R/x86_64-pc-linux-gnu-library/4.2/00LOCK-hdf5r/00new/hdf5r/libs/hdf5r.so':
  libhdf5_hl.so.100: cannot open shared object file: No such file or directory
  这表明加载包的时候不能识别 hdf5 的动态库,实际包已经安装好了，只是不能加载 hdf5 动态库,需要手动配置 hdf5 动态库 libhdf5_hl.so.100
在R中运行
> system("locate libhdf5_hl.so.100")
/data/wangjl/software/anaconda3/lib/libhdf5_hl.so.100

> dyn.load('/data/wangjl/software/anaconda3/lib/libhdf5_hl.so.100')
> install.packages("hdf5r", configure.args="--with-hdf5=/data/wangjl/software/anaconda3/bin/h5cc")
失败
> library(hdf5r)


在shell R中:
> dyn.load('/data/wangjl/software/anaconda3/lib/libhdf5_hl.so.100')
> install.packages("hdf5r", configure.args="--with-hdf5=/data/wangjl/software/anaconda3/bin/h5cc")
> library(hdf5r)
成功！
在Rstudio中也可以导入了。

似乎 anaconda 和 R 是冲突的。很多不好安装的R包都是因为 Rstudio 找不到 anaconda 下的 lib 库造成的错误。





(2) DoubletFinder 包
> install.packages("DoubletFinder") #无法安装
> BiocManager::install("DoubletFinder") #无法安装
直接从 install.packages 安装DoubletFinder会需要更新RcppTOML版本，所以选择从GitHub安装

> remotes::install_github('chris-mcginnis-ucsf/DoubletFinder', update=F)
> library("DoubletFinder")

成功！










========================================
|-- 下载 Seurat 官方网站镜像 (2022.4.15)
----------------------------------------
1. 当可以访问的时候 (2022.4.15)
备份以防万一: 
$ wget -m -L –reject = http://www.satijalab.org/seurat


(1) 进入工作站目录
$ cd /home/wangjl/data/web/docs/docs/satijalab.org/
$ mv seurat seurat-backup


换成
$ cd /home/wangjl/data/web/docs/docs/
$ rm -rf satijalab.org



(2)下载好久
$ wget -m --no-check-certificate https://satijalab.org/seurat/index.html #好多文件，应该是都下下来了！
16:37 --> 16:65
Downloaded: 1335 files, 531M in 2m 46s (3.20 MB/s)


压缩备份
$ tar -czvf seurat-docs-20220415.tar.gz satijalab.org

$ ls -lth seurat-docs-20220415.tar.gz
-rw-rw-r-- 1 wangjl wangjl 392M Apr 15 16:56 seurat-docs-20220415.tar.gz

$ du -sh satijalab.org/
535M	satijalab.org/
压缩到原来的 66%。



(3) 怎么本地化 js 文件呢? //todo













2. 使用 远程 docker 下载 (2021.9.23)
下载一个 nginx ，方便预览文件
总体计划: 使用远端 docker 下载需要的东西，使用 nginx 展示内容并下载
https://labs.play-with-docker.com/


$ docker pull nginx
$ docker run --rm -it nginx nginx -version
nginx version: nginx/1.21.3

还是使用带版本号的靠谱，后期可重复。
$ docker pull nginx:1.21
$ docker run --rm -it nginx:1.21 nginx -version
nginx version: nginx/1.21.3


$ cd /home/tom/
$ cat nginx.config  #注意改nginx监听的端口号了
server {
    listen       8008;
    listen  [::]:8008;
    server_name  localhost;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
		
        # list files
        autoindex on; 
        autoindex_exact_size on; 
        autoindex_localtime on; 
    }
}


把本地映射到docker内的web目录
$ docker run --rm -d -p 8000:8008 \
--mount type=bind,source=/home/tom/,target=/usr/share/nginx/html/ \
--mount type=bind,source=/home/tom/nginx.config,target=/etc/nginx/conf.d/default.conf \
nginx:1.21

下载命令: 约10Mb。
## curl https://www.dropbox.com/s/3dby3bjsaf5arrw/cell_cycle_vignette_files.zip -o test.zip -J -L -k

$ wget -r -p -np -k http://www.satijalab.org/seurat
内置的wget不好用，不支持-r参数！！





2. 重新搜一个 docker 版的 wget

$ docker pull mwendler/wget
$ alias wget='docker run -v $PWD:/work --workdir=/work --rm mwendler/wget' #把当前目录挂载到容器的工作目录


$ wget -r -p -np -k --no-check-certificate http://www.satijalab.org/seurat
参数解释:
-r, –recursive（递归） specify recursive download
-k, –convert-links（转换链接、将 HTML 页面中的链接转换为相对链接即本地链接）
	make links in downloaded HTML or CSS point to local files
-p, –page-requisites（下载所有的图片等页面显示所需的内容）
	 get all images, etc. needed to display HTML page
-np, –no-parent（不追溯至父级）
	don't ascend to the parent directory
–restrict-file-names=nocontrol 用来解决中文乱码问题（需要可以试试）




(2) 使用 wget 同步网站镜像
$ wget -m -L –reject = http://www.satijalab.org/seurat

一般情况下使用-m参数就可以：
$ wget -m --no-check-certificate https://www.satijalab.org/seurat #这个就下载一个首页文件。

$ wget -m --no-check-certificate https://satijalab.org/seurat/index.html #好多文件，应该是都下下来了！

参数解释：
-m,  --mirror      shortcut for -N -r -l inf --no-remove-listing
-L,  --relative    follow relative links only

可以设置正则表达式过滤链接
-R,  --reject=LIST               comma-separated list of rejected extensions
   --accept-regex=REGEX        regex matching accepted URLs
   --reject-regex=REGEX        regex matching rejected URLs
   --regex-type=TYPE           regex type (posix|pcre)

是否显示详细下载情况
  -v,  --verbose                   be verbose (this is the default)
  -nv, --no-verbose                turn off verboseness, without being quiet
       --report-speed=TYPE         output bandwidth as TYPE.  TYPE can be bits


(3) 下载过程中卡死了，仔细一看，js控制台报错了
打不开的js:
https://cdn.rawgit.com/zenorocha/clipboard.js/master/dist/clipboard.min.js 
已有的js，不知道怎么注入到当前页面中
https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js
javascript:(function(s){s.src='https://static.runoob.com/assets/clipboard.min.js';document.body.appendChild(s)})(document.createElement('script'));

不知道 墙 啥时候放行这个js文件。。。


(4) 先把已经下载的抓到本地
回到本地宿主机:
$ cd /home/wangjl/data/web/docs/docs/seurat/
$ wget -m --no-check-certificate http://ip172-18-0-69-c55t5u7njsv000dv7nk0-8000.direct.labs.play-with-docker.com/site/satijalab.org/seurat/index.html



最后因为404报错停下了。
HTTP request sent, awaiting response... 404 Not Found
2021-09-23 11:13:20 ERROR 404: Not Found.

FINISHED --2021-09-23 11:13:20--
Total wall clock time: 16m 35s
Downloaded: 516 files, 324M in 10m 39s (519 KB/s)


总共下载326M数据。
$ du -sh /home/wangjl/data/web/docs/docs/seurat/
326M	/home/wangjl/data/web/docs/docs/seurat/

最后去掉多余的文件夹外壳，保存在 webPan.py 上。
/home/wangjl/data/web/docs/docs/satijalab.org
访问地址: http://y.biomooc.com:8000/file/docs/satijalab.org/index.html


压缩:
$ tar -czvf seurat.tar.gz satijalab.org
-rw-rw-r-- 1 wangjl wangjl 216M Sep 23 14:09  seurat.tar.gz
加上日期 seurat-20210923.tar.gz

$ du -sh satijalab.org/
325M	satijalab.org/
压缩到原来的 66%。



(5) 缺一个文件，在线代理查看一下: 未解决
https://proxysite.page/en

https://satijalab.org/seurat/articles/install.html
https://satijalab.org/seurat/articles/pbmc3k_tutorial_files/header-attrs-2.10/header-attrs.js








========================================
|-- 构建和使用 docker 版的 Seurat 4.3.0 (Ubuntu20.04 + R4.2)
----------------------------------------
1. 准备构建资源

总思路： 下载 Seurat 官方镜像，安装 Rstudio server。

(1) 获取可用标签： 都不能打开
https://satijalab.org/seurat/articles/install_v5
https://hub.docker.com/r/satijalab/seurat

$ curl -L -s https://registry.hub.docker.com/v1/repositories/satijalab/seurat/tags



(2) 下载最新版本：最新的是 4.3.0，而不是 v5
$ docker pull satijalab/seurat:latest
$ docker images
REPOSITORY         TAG        IMAGE ID       CREATED         SIZE
ubuntu             20.04      18ca3f4297e7   2 weeks ago     72.8MB
satijalab/seurat   latest     fe258afe286e   11 months ago   3.93GB

查看其中的R和Seurat版本号：
$ docker run -it --rm --name test satijalab/seurat bash
root@dd0ca6330828:/# R --version
R version 4.2.0 (2022-04-22) -- "Vigorous Calisthenics"   #R版本 4.2
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

root@c85aad337520:/# apt --version #是一个 Ubuntu 系统
apt 2.0.9 (amd64)
root@c85aad337520:/# yum --version
bash: yum: command not found

root@c85aad337520:/# cat /proc/version #这又像一个CentOS系统？不对，这是host系统
Linux version 3.10.0-1160.76.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Aug 10 16:21:17 UTC 2022

# cat /etc/issue  #系统版本
Ubuntu 20.04.5 LTS \n \l

# R
> packageVersion("Seurat")  #Seurat 版本[1] ‘4.3.0’
> packageVersion("SeuratObject") # 4.1.3
> q()


$ gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0




(3) 所需要的 Rstudio 最新版本 for Ubuntu20
https://posit.co/download/rstudio-server/

$ cd /home/wangjl/Downloads/
$ sudo apt-get install gdebi-core
$ wget https://download2.rstudio.org/server/focal/amd64/rstudio-server-2023.12.1-402-amd64.deb
$ sudo gdebi rstudio-server-2023.12.1-402-amd64.deb

下载太慢，用193几秒下好，再远程传输：
$ scp rstudio-server-2023.12.1-402-amd64.deb wangjl@gate1.picb.ac.cn:/picb/jinlab/wangjl/


核对：
Size: 102.96 MB | SHA-256: 64044984 | Version: 2023.12.1+402 | Released: 2024-01-29
-rw-r--r--.  1 wangjl jinlab  99M Feb  7 18:05 rstudio-server-2023.12.1-402-amd64.deb
$ sha256sum rstudio-server-2023.12.1-402-amd64.deb
64044984a5791690586e21bf4411019ed3dccaf32a69e0838090762f3eba8da0  rstudio-server-2023.12.1-402-amd64.deb
大小不一致，但是sha256 一致。









2. 开始构建镜像
http://biomooc.dawneve.com/linux/docker_image_seurat4.0.html
采用节省时间的方法，手动构建法。

可用，到逐步好用。

(1) 第一步 更新

启动容器
$ docker run -it --rm --name seurat4.3a satijalab/seurat bash

更新：
# apt-get update && apt-get install -y gdebi-core  #17:34 -->17:35
# apt-get install -y psmisc sudo libclang-dev libpq5
# apt-get install -y vim

提交修改：
$ docker commit seurat4.3a satijalab/seurat:v4.3a

$ docker images
REPOSITORY          TAG        IMAGE ID       CREATED         SIZE
satijalab/seurat    v4.3a      b6d9f9388bd4   2 seconds ago   4.49GB
ubuntu              20.04      18ca3f4297e7   2 weeks ago     72.8MB
satijalab/seurat    latest     fe258afe286e   11 months ago   3.93GB



(2) 第二步 安装rstudio

复制Rstudio安装文件到镜像中：
$ docker cp ~/Downloads/rstudio-server-2023.12.1-402-amd64.deb seurat4.3a:/tmp/
Successfully copied 103MB to seurat4.3a:/tmp/

安装rstudio，在容器中执行
# gdebi /tmp/rstudio-server-2023.12.1-402-amd64.deb
# rm /tmp/rstudio-server-2023.12.1-402-amd64.deb

设置参数：
# vim /etc/rstudio/rserver.conf
# www-port=8787
auth-timeout-minutes=1800

重启服务后才生效
# service rstudio-server restart

提交修改：
$ docker commit seurat4.3a satijalab/seurat:v4.3b

$ docker images
REPOSITORY         TAG        IMAGE ID       CREATED              SIZE
satijalab/seurat   v4.3b      d1cd61d77a2e   About a minute ago   5.07GB




(3) 测试
$ port=8890   #奇怪 8087 就不行，浏览器打不开
$ docker run --name=Rs4.3b --rm -it -d -p ${port}:8787 \
--mount type=bind,source=/home/${USER}/picb/,target=/data/ \
satijalab/seurat:v4.3b

打开端口
$ sudo iptables -I INPUT -p tcp --dport ${port} -j ACCEPT


用户系统和外部uid，gid一致：
$ id
uid=5662(wangjl) gid=1210(jinlab) groups=1210(jinlab),996(docker) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ user=${USER} && uid=`id ${user} -u` && gid=`id ${user} -g`

$ docker exec -it Rs4.3b bash
新建组
# groupadd -g 1210 dockerGroup
新建用户
# useradd -s /bin/bash -d /home/wangjl2  -m wangjl2 -u 5662 -g 1210
# passwd wangjl2 # 16..
# su wangjl2
$ cd
$ ln -s /data/ ~/

启动服务
$ exit
# service rstudio-server start


登录网页版： 可正常登录
http://localhost:8890
测试发现，也能画图，也能保存结果。









========================================
Seurat FAQ: 宏观策略到参数细节
----------------------------------------

4. seurat包的UMAP图集群分布的影响因素
https://zhuanlan.zhihu.com/p/427166749

1).QC阶段（关键步骤），nUMI（nCount_RNA),nGene(nFeature_RNA),percent.ribo线粒体比例的筛选
2).多样本merge和integrate阶段，影响整合强度等参数的设置以及整合方法的选择（seurat自带的'FindIntegrationAnchors还是Harmony等方法）
3).ScaleData参数设置，输入的基因''features''(可变基因或全部基因），需要回归的因素''vars.to.regress''（UMI和percent.ribo）都会影响后期的UMAP结果
4).PCA数量的选择，选择合适的npca数量（elbow图的拐角处对应的参数，尝试多个npca作UMAP图找到最佳分群的npca）作为FindNeighbors的输入
5).FindClusters阶段，resolution参数（分辨率）的选择决定分群的数量，可以通过''clustree''包查看不同res的分群情况





5. 关于降维分析

Q: ElbowPlot 的拐点是指这个点后面基本持平了么？ / 請問如何判斷 elbow 拐點呢?為何不是在 3~4，而是在 9~10/ PC 拐点如何界定？
A： ElbowPlot 作图后，用肉眼观察，当曲线进入平台期，没有明显继续下降的趋势就可以了。ElbowPlot 默认显示 20 个 PC，如果发现 20 个 PC 还没有到达平台期，可以修改 ElbowPlot 函数的 ndims 参数。 RunPCA 函数默认计算 50 个 PC，如果想看更多的 PC，可以修改 RunPCA 的npcs 参数。

Q：请问 PCA 那页，是细胞和基因都做过 PCA 么？
A: 在 Seurat 中，我们是对细胞做 PCA 分析，也就是对细胞做降维分析，比如从 2000 维（基因）降到 50 维（ PC）。一般情况下，我们不会对基因做 PCA 分析。

Q： PCA 中的 embedding 可以再解释下么？
A：比如，原本每个细胞有 2000 个基因，每个基因在各个细胞中都有表达量，做了 PCA 分析后，每个细胞有 50 个 PC，每个 PC 在各个细胞中都有 embedding 值。为了便于理解，你可以把 PC 看成是整合了多个基因的 meta-gene，把 cell embedding 看成是这些 meta-gene 的表达量。

Q: 可不可以讲下 umap 和 tSNE 的主要原理？
A: UMAP 和 tSNE 都是非线性的降维方法，是把在高维空间中的点（我们人类肉眼无法观察）投射到二维平面上。这些高维空间中的点是有一定结构的，有些点彼此之间距离更近，有些点距离更远。我们在降维的过程要尽量保留这种结构，让在高维空间中更近的点，在二维平面上也更近，如果降维分析打乱了数据原有的结构，就毫无意义了。 tSNE 的目标是在降维的过程中尽量保留数据的局部结构，而 UMAP 除了能保留数据的局部结构，还能更好的保留全局结构。如果想更深入的了解它们的原理，需要一定的数学基础，我推荐两篇解释的相对简单一些的文章供你参考：

https://opentsne.readthedocs.io/en/latest/tsne_algorithm.html，

How UMAP Works - umap 0.4 documentation

Q: 我想问下数据降维为什么先做 PCA 然后再 UMAP 的降维 这俩不都是降维吗？ 不能直接 UMAP？
A： PCA 分析和 UMAP 分析的目的不同。 PCA 分析把高表达变异基因整合成若干个 PC。这样做一方面降维，一方面降低噪音。做聚类分析和 UMAP 分析的时候，使用的不是基因表达量，而是由 PCA 分析得到的 PC 的值。 UMAP 的主要作用是把高维度中距离接近的点映射到二维平面上距离相近的位置上。 UMAP 返回的结果只有两个维度（ UMAP_1 和 UMAP_2），只能用来做数据可视化。






6. 关于聚类分析

Q: cluster ID 为何从 0 开始？是否可以从 1 开始？从 0 开始是因为有什么‘算法’方面特殊的优势么？
A： 默认 clusterID 是从 0 开始，没有特殊的优势，可以使用 RenameIdents 函数重命名clusterID。


Q： 鉴定出来的细胞类群用 UMAP 绘图后发现聚类效果很差，大量 cluster 相互交叉， 同一类群细胞弥散分布是什么原因？聚类可视化和类群划分不匹配。
A： 首先要确保聚类和 UMAP 用的 dims 参数是一致的。可以适当降低一下 FindClusters 函数的resolution 参数，减少 cluster 数目，看看能不能把相互交叉的 cluster 聚成一个 cluster。 还可以尝试 FindClusters 函数中不同的 algorithm 参数，看看聚类效果会不会改进。


Q： 请问分群过程中，是否有设置邻居个数的函数和参数？
A： FinderNeighbors 函数的 k.param 参数是用来设置 KNN 算法中最近邻的个数。


Q： 请问 finder cluster 只能使用 SNN 进行聚类么？可以有其他选择吗？ / seurat 的聚类方式除了 KNN 外还有其他的选择吗？
A： Seurat 的聚类方法是基于 SNN 图和 Louvain 或 SLM 算法， FindNeighbors 函数返回的SNN 图是在 KNN 图的基础上得来的，不支持其他方法。




ref:
https://zhuanlan.zhihu.com/p/153404850







========================================
Seurat对象的slot和处理流程： 从Seurat对象中找可用的数据 str(scObj)
----------------------------------------
原始代码： https://github.com/satijalab/seurat/

扣数据 https://satijalab.org/seurat/seurat_clustering_tutorial_part2.html
https://github.com/satijalab/seurat/wiki/Seurat#slots


R Seurat 单细胞处理pipline 代码: https://www.cnblogs.com/shanyr/p/11683505.html

Data/Cell_2019/10X/analysis_10X.Rmd: 
	https://github.com/Martin-Villalba-lab/Data/blob/master/Cell_2019/10X/analysis_10X.Rmd
	VlnPlot(object = seurat_10X2 , features.plot = "Slc1a3" ,  do.return = TRUE) + scale_x_discrete( limits = celltypes_order )

scRNA-seq-SARS-CoV2-Viremia/Seurat_Analysis/COVID1_Seurat script.R:
	https://github.com/ArzinaJaffer/scRNA-seq-SARS-CoV2-Viremia/blob/main/Seurat_Analysis/COVID1_Seurat%20script.R
	VlnPlot(COVID1, features = 'CD19', group.by = 'seurat_clusters', sort = 'decreasing')


########## Seurat 3.2.3
> is(subT)
[1] "Seurat"
> isS4(subT)
[1] TRUE
> class(subT)
[1] "Seurat"
attr(,"package")
[1] "Seurat"

> slotNames(subT)
 [1] "assays"       "meta.data"    "active.assay" "active.ident" "graphs"      
 [6] "neighbors"    "reductions"   "images"       "project.name" "misc"        
[11] "version"      "commands"     "tools" 

> showMethods(classes="Seurat")

Function ".DollarNames":
 <not an S4 generic function>

Function "%&%":
 <not an S4 generic function>
...

> getMethod(f="show", signature="Seurat")
Method Definition:

function (object) 
{
    object <- UpdateSlots(object = object)
    assays <- FilterObjects(object = object, classes.keep = "Assay")
...







> str(pbmc2) # Seurat 3.0.1
Formal class 'Seurat' [package "Seurat"] with 12 slots
  ..@ assays      :List of 1
  .. ..$ RNA:Formal class 'Assay' [package "Seurat"] with 7 slots
  .. .. .. ..@ counts       :Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  .. .. .. .. .. ..@ i       : int [1:5760282] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. .. .. ..@ p       : int [1:226] 0 21406 44800 64936 90612 117543 134605 150609 173213 195146 ...
  .. .. .. .. .. ..@ Dim     : int [1:2] 478762 225
  .. .. .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..@ x       : num [1:5760282] 1447 3375 1469 451 1161 ...
  .. .. .. .. .. ..@ factors : list()
  .. .. .. ..@ data         :Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  .. .. .. .. .. ..@ i       : int [1:5760282] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. .. .. ..@ p       : int [1:226] 0 21406 44800 64936 90612 117543 134605 150609 173213 195146 ...
  .. .. .. .. .. ..@ Dim     : int [1:2] 478762 225
  .. .. .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..@ x       : num [1:5760282] 2.83 3.64 2.84 1.78 2.62 ...
  .. .. .. .. .. ..@ factors : list()
  .. .. .. ..@ scale.data   : num [1:478762, 1:225] -2.115 0.311 -0.89 -1.78 -0.189 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ key          : chr "rna_"
  .. .. .. ..@ var.features : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. ..@ meta.features:'data.frame':	478762 obs. of  5 variables:
  .. .. .. .. ..$ vst.mean                 : num [1:478762] 2956 2497 1841 1747 1100 ...
  .. .. .. .. ..$ vst.variance             : num [1:478762] 2894461 2351552 1304325 1759644 440198 ...
  .. .. .. .. ..$ vst.variance.expected    : num [1:478762] 2070517 1589088 991165 914030 454536 ...
  .. .. .. .. ..$ vst.variance.standardized: num [1:478762] 1.398 1.48 1.316 1.925 0.968 ...
  .. .. .. .. ..$ vst.variable             : logi [1:478762] TRUE TRUE TRUE TRUE FALSE TRUE ...
  .. .. .. ..@ misc         : NULL
  ..@ meta.data   :'data.frame':	225 obs. of  6 variables:
  .. ..$ orig.ident     : Factor w/ 1 level "BC_HeLa": 1 1 1 1 1 1 1 1 1 1 ...
  .. ..$ nCount_RNA     : num [1:225] 910697 991632 763838 1109857 1137588 ...
  .. ..$ nFeature_RNA   : int [1:225] 21406 23394 20136 25676 26931 17062 16004 22604 21933 14631 ...
  .. ..$ percent.mt     : num [1:225] 0 0 0 0 0 0 0 0 0 0 ...
  .. ..$ RNA_snn_res.0.5: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...
  .. ..$ seurat_clusters: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...


  .. ..## 这里可以放每个细胞的分类（来自于哪个病人(4/5/6); 来自于哪种类型的组织(B/T/N); 确定的细胞类型 ）
  .. ..$ location       : chr [1:4844] "CRCN" "CRCP" "CRCP" "CRCP" ...
  .. ..$ Tsample        : chr [1:4844] "CRC4" "CRC4" "CRC4" "CRC4" ...
  .. ..$ sample         : chr [1:4844] "CRC4N" "CRC4P" "CRC4P" "CRC4P" ...
  .. ..$ Tcelltype      : Factor w/ 9 levels "T cell","NK",..: 1 1 1 1 1 1 1 1 1 1 ...
  .. ..$ oldcluster     : chr [1:4844] "T cell-1" "T cell-1" "T cell-1" "T cell-1" ...
  
  ..@ active.assay: chr "RNA"
  ..@ active.ident: Factor w/ 3 levels "0","1","2": 3 3 3 3 3 3 3 3 3 3 ...
  .. ..- attr(*, "names")= chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  ..@ graphs      :List of 2
  .. ..$ RNA_nn :Formal class 'Graph' [package "Seurat"] with 6 slots
  .. .. .. ..@ i       : int [1:4500] 0 1 2 3 4 5 6 7 8 10 ...
  .. .. .. ..@ p       : int [1:226] 0 29 57 72 86 101 136 167 182 201 ...
  .. .. .. ..@ Dim     : int [1:2] 225 225
  .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ x       : num [1:4500] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. .. ..@ factors : list()
  .. ..$ RNA_snn:Formal class 'Graph' [package "Seurat"] with 6 slots
  .. .. .. ..@ i       : int [1:13115] 0 1 2 3 4 5 6 7 8 9 ...
  .. .. .. ..@ p       : int [1:226] 0 46 92 122 152 182 233 286 320 355 ...
  .. .. .. ..@ Dim     : int [1:2] 225 225
  .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. ..@ x       : num [1:13115] 1 0.818 0.29 0.29 0.29 ...
  .. .. .. ..@ factors : list()
  ..@ neighbors   : list()
  ..@ reductions  :List of 2
  .. ..$ pca :Formal class 'DimReduc' [package "Seurat"] with 8 slots
  .. .. .. ..@ cell.embeddings           : num [1:225, 1:50] 36 34.5 63.2 72.8 58.3 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..$ : chr [1:50] "PC_1" "PC_2" "PC_3" "PC_4" ...
  .. .. .. ..@ feature.loadings          : num [1:46386, 1:50] 0.0381 0.0379 0.0385 0.0378 0.0374 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. .. ..$ : chr [1:50] "PC_1" "PC_2" "PC_3" "PC_4" ...
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num [1:50] 20.5 19 18.3 17.7 17.3 ...
  .. .. .. ..@ key                       : chr "PC_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num [1:46386, 1:20] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. .. .. ..$ : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. .. .. .. ..$ : chr [1:20] "PC1" "PC2" "PC3" "PC4" ...
  .. .. .. .. .. ..@ fake.reduction.scores  : num [1:46300, 1:20] -0.001198 -0.00154 -0.00143 0.000949 -0.004263 ...
  .. .. .. .. .. ..@ empirical.p.values.full: logi [1, 1] NA
  .. .. .. .. .. ..@ overall.p.values       : num [1:20, 1:2] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. .. .. ..$ : NULL
  .. .. .. .. .. .. .. ..$ : chr [1:2] "PC" "Score"
  .. .. .. ..@ misc                      :List of 1
  .. .. .. .. ..$ total.variance: num 37923
  
  
  ## 这里也可以放置 tsne 的降维结果
  .. ..$ tsne:Formal class 'DimReduc' [package "Seurat"] with 9 slots
  .. .. .. ..@ cell.embeddings           : num [1:4844, 1:2] 24.9 17.4 31.5 30.1 16.9 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:4844] "CRCSZ04N_cell5925576" "CRCSZ04P_cell347880" "CRCSZ04P_cell841868" "CRCSZ04P_cell898327" ...
  .. .. .. .. .. ..$ : chr [1:2] "FIt_1" "FIt_2"
  .. .. .. ..@ feature.loadings          : num[0 , 0 ] 
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num(0) 
  .. .. .. ..@ key                       : chr "FIt_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num[0 , 0 ] 
  .. .. .. .. .. ..@ fake.reduction.scores  : num[0 , 0 ] 
  .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] 
  .. .. .. .. .. ..@ overall.p.values       : num[0 , 0 ] 
  .. .. .. ..@ misc                      : list()
  .. .. .. ..@ NA                        : NULL
  
  
  .. ..$ umap:Formal class 'DimReduc' [package "Seurat"] with 8 slots
  .. .. .. ..@ cell.embeddings           : num [1:225, 1:2] -9.07 -9.37 -9.85 -10.11 -9.73 ...
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:225] "c01ROW07" "c01ROW12" "c01ROW24" "c01ROW31" ...
  .. .. .. .. .. ..$ : chr [1:2] "UMAP_1" "UMAP_2"
  .. .. .. ..@ feature.loadings          : num[0 , 0 ] 
  .. .. .. ..@ feature.loadings.projected: num[0 , 0 ] 
  .. .. .. ..@ assay.used                : chr "RNA"
  .. .. .. ..@ stdev                     : num(0) 
  .. .. .. ..@ key                       : chr "UMAP_"
  .. .. .. ..@ jackstraw                 :Formal class 'JackStrawData' [package "Seurat"] with 4 slots
  .. .. .. .. .. ..@ empirical.p.values     : num[0 , 0 ] 
  .. .. .. .. .. ..@ fake.reduction.scores  : num[0 , 0 ] 
  .. .. .. .. .. ..@ empirical.p.values.full: num[0 , 0 ] 
  .. .. .. .. .. ..@ overall.p.values       : num[0 , 0 ] 
  .. .. .. ..@ misc                      : list()
  ..@ project.name: chr "BC_HeLa"
  ..@ misc        : list()
  ..@ version     :Classes 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 3 0 1
  ..@ commands    :List of 9
  .. ..$ NormalizeData.RNA       :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "NormalizeData.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-08-14 10:08:05"
  .. .. .. ..@ call.string: chr [1:2] "NormalizeData(pbmc, normalization.method = \"LogNormalize\", " "    scale.factor = 10000)"
  .. .. .. ..@ params     :List of 5
  .. .. .. .. ..$ assay               : chr "RNA"
  .. .. .. .. ..$ normalization.method: chr "LogNormalize"
  .. .. .. .. ..$ scale.factor        : num 10000
  .. .. .. .. ..$ margin              : num 1
  .. .. .. .. ..$ verbose             : logi TRUE
  .. ..$ FindVariableFeatures.RNA:Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindVariableFeatures.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:21:07"
  .. .. .. ..@ call.string: chr "FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 46386)"
  .. .. .. ..@ params     :List of 12
  .. .. .. .. ..$ assay              : chr "RNA"
  .. .. .. .. ..$ selection.method   : chr "vst"
  .. .. .. .. ..$ loess.span         : num 0.3
  .. .. .. .. ..$ clip.max           : chr "auto"
  .. .. .. .. ..$ mean.function      :function (mat, display_progress)  
  .. .. .. .. ..$ dispersion.function:function (mat, display_progress)  
  .. .. .. .. ..$ num.bin            : num 20
  .. .. .. .. ..$ binning.method     : chr "equal_width"
  .. .. .. .. ..$ nfeatures          : num 46386
  .. .. .. .. ..$ mean.cutoff        : num [1:2] 0.1 8
  .. .. .. .. ..$ dispersion.cutoff  : num [1:2] 1 Inf
  .. .. .. .. ..$ verbose            : logi TRUE
  .. ..$ ScaleData.RNA           :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "ScaleData.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:33:21"
  .. .. .. ..@ call.string: chr "ScaleData(pbmc, features = all.genes)"
  .. .. .. ..@ params     :List of 10
  .. .. .. .. ..$ features          : chr [1:478762] "chr19:50002945:+" "chr12:6647536:+" "chr5:180663951:-" "chr2:232577566:+" ...
  .. .. .. .. ..$ assay             : chr "RNA"
  .. .. .. .. ..$ model.use         : chr "linear"
  .. .. .. .. ..$ use.umi           : logi FALSE
  .. .. .. .. ..$ do.scale          : logi TRUE
  .. .. .. .. ..$ do.center         : logi TRUE
  .. .. .. .. ..$ scale.max         : num 10
  .. .. .. .. ..$ block.size        : num 1000
  .. .. .. .. ..$ min.cells.to.block: num 225
  .. .. .. .. ..$ verbose           : logi TRUE
  .. ..$ RunPCA.RNA              :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "RunPCA.RNA"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 17:33:33"
  .. .. .. ..@ call.string: chr "RunPCA(pbmc2, features = VariableFeatures(object = pbmc2))"
  .. .. .. ..@ params     :List of 11
  .. .. .. .. ..$ assay          : chr "RNA"
  .. .. .. .. ..$ features       : chr [1:46386] "chr22:38075803:+" "chr1:218023600:-" "chr6:153986769:+" "chr3:165950340:-" ...
  .. .. .. .. ..$ npcs           : num 50
  .. .. .. .. ..$ rev.pca        : logi FALSE
  .. .. .. .. ..$ weight.by.var  : logi TRUE
  .. .. .. .. ..$ verbose        : logi TRUE
  .. .. .. .. ..$ ndims.print    : int [1:5] 1 2 3 4 5
  .. .. .. .. ..$ nfeatures.print: num 30
  .. .. .. .. ..$ reduction.name : chr "pca"
  .. .. .. .. ..$ reduction.key  : chr "PC_"
  .. .. .. .. ..$ seed.use       : num 42
  .. ..$ JackStraw.RNA.pca       :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "JackStraw.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:25:16"
  .. .. .. ..@ call.string: chr "JackStraw(pbmc2, num.replicate = 100)"
  .. .. .. ..@ params     :List of 7
  .. .. .. .. ..$ reduction    : chr "pca"
  .. .. .. .. ..$ assay        : chr "RNA"
  .. .. .. .. ..$ dims         : num 20
  .. .. .. .. ..$ num.replicate: num 100
  .. .. .. .. ..$ prop.freq    : num 0.01
  .. .. .. .. ..$ verbose      : logi TRUE
  .. .. .. .. ..$ maxit        : num 1000
  .. ..$ ScoreJackStraw          :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "ScoreJackStraw"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:27:05"
  .. .. .. ..@ call.string: chr "ScoreJackStraw(pbmc2, dims = 1:20)"
  .. .. .. ..@ params     :List of 4
  .. .. .. .. ..$ reduction   : chr "pca"
  .. .. .. .. ..$ dims        : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. ..$ score.thresh: num 1e-05
  .. .. .. .. ..$ do.plot     : logi FALSE
  .. ..$ FindNeighbors.RNA.pca   :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindNeighbors.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:34:31"
  .. .. .. ..@ call.string: chr "FindNeighbors(pbmc2, dims = 1:10)"
  .. .. .. ..@ params     :List of 11
  .. .. .. .. ..$ reduction   : chr "pca"
  .. .. .. .. ..$ dims        : int [1:10] 1 2 3 4 5 6 7 8 9 10
  .. .. .. .. ..$ assay       : chr "RNA"
  .. .. .. .. ..$ k.param     : num 20
  .. .. .. .. ..$ compute.SNN : logi TRUE
  .. .. .. .. ..$ prune.SNN   : num 0.0667
  .. .. .. .. ..$ nn.eps      : num 0
  .. .. .. .. ..$ verbose     : logi TRUE
  .. .. .. .. ..$ force.recalc: logi FALSE
  .. .. .. .. ..$ do.plot     : logi FALSE
  .. .. .. .. ..$ graph.name  : chr [1:2] "RNA_nn" "RNA_snn"
  .. ..$ FindClusters            :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "FindClusters"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:34:33"
  .. .. .. ..@ call.string: chr "FindClusters(pbmc2, resolution = 0.5)"
  .. .. .. ..@ params     :List of 8
  .. .. .. .. ..$ graph.name    : chr "RNA_snn"
  .. .. .. .. ..$ modularity.fxn: num 1
  .. .. .. .. ..$ resolution    : num 0.5
  .. .. .. .. ..$ algorithm     : num 1
  .. .. .. .. ..$ n.start       : num 10
  .. .. .. .. ..$ n.iter        : num 10
  .. .. .. .. ..$ random.seed   : num 0
  .. .. .. .. ..$ verbose       : logi TRUE
  .. ..$ RunUMAP.RNA.pca         :Formal class 'SeuratCommand' [package "Seurat"] with 4 slots
  .. .. .. ..@ name       : chr "RunUMAP.RNA.pca"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2019-09-11 18:38:08"
  .. .. .. ..@ call.string: chr "RunUMAP(pbmc2, dims = 1:8)"
  .. .. .. ..@ params     :List of 18
  .. .. .. .. ..$ dims                : int [1:8] 1 2 3 4 5 6 7 8
  .. .. .. .. ..$ reduction           : chr "pca"
  .. .. .. .. ..$ assay               : chr "RNA"
  .. .. .. .. ..$ n.neighbors         : int 30
  .. .. .. .. ..$ n.components        : int 2
  .. .. .. .. ..$ metric              : chr "correlation"
  .. .. .. .. ..$ learning.rate       : num 1
  .. .. .. .. ..$ min.dist            : num 0.3
  .. .. .. .. ..$ spread              : num 1
  .. .. .. .. ..$ set.op.mix.ratio    : num 1
  .. .. .. .. ..$ local.connectivity  : int 1
  .. .. .. .. ..$ repulsion.strength  : num 1
  .. .. .. .. ..$ negative.sample.rate: int 5
  .. .. .. .. ..$ seed.use            : int 42
  .. .. .. .. ..$ angular.rp.forest   : logi FALSE
  .. .. .. .. ..$ verbose             : logi TRUE
  .. .. .. .. ..$ reduction.name      : chr "umap"
  .. .. .. .. ..$ reduction.key       : chr "UMAP_"
  
  
  ## 补充一个tsne的
  .. .. .. ..@ NA         : NULL
  .. ..$ RunTSNE                 :Formal class 'SeuratCommand' [package "Seurat"] with 5 slots
  .. .. .. ..@ name       : chr "RunTSNE"
  .. .. .. ..@ time.stamp : POSIXct[1:1], format: "2020-12-07 13:28:07"
  .. .. .. ..@ call.string: chr [1:3] "RunTSNE(Sdata, tsne.method = \"FIt-SNE\", dims = 1:50, initialization = PCAinit, " "    learning_rate = 1000, fast_tsne_path = \"/home/wangxf/data/tools/FIt-SNE-master/bin/fast_tsne\", " "    reduction.key = \"FIt_SNE\")"
  .. .. .. ..@ params     :List of 9
  .. .. .. .. ..$ reduction     : chr "pca"
  .. .. .. .. ..$ cells         : chr [1:62288] "CRCSZ04N_cell5925576" "CRCSZ04P_cell347880" "CRCSZ04P_cell841868" "CRCSZ04P_cell898327" ...
  .. .. .. .. ..$ dims          : int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
  .. .. .. .. ..$ seed.use      : num 1
  .. .. .. .. ..$ tsne.method   : chr "FIt-SNE"
  .. .. .. .. ..$ add.iter      : num 0
  .. .. .. .. ..$ dim.embed     : num 2
  .. .. .. .. ..$ reduction.name: chr "tsne"
  .. .. .. .. ..$ reduction.key : chr "FIt_SNE"
  .. .. .. ..@ NA         : NULL
  
  
  ..@ tools       : list()
#





1. Seurat 3.0.1
(1)#UMAP分类标签的位置
pbmc2@assays$RNA@scale.data
table(pbmc2@active.ident)

pbmc2@active.ident[pbmc2@active.ident==1]
c0=names(pbmc2@active.ident[pbmc2@active.ident==0]) #获取cluster0的cell ID

(2) 使用Idents函数
head(Idents(pbmc2), 5)
## c01ROW07 c01ROW12 c01ROW24 c01ROW31 c01ROW35 
##        2        2        2        2        2 
## Levels: 0 1 2



(3) 画dotplot，合并0和1为一个新的 cluster BC: 
# 合并0和1为BC，标记2为HeLa
pbmc11.2=pbmc11
pbmc11.2@meta.data$seurat_clusters=as.character(pbmc11.2@meta.data$seurat_clusters)
table(pbmc11.2@meta.data$seurat_clusters)
#0  1  2 
#87 82 56
pbmc11.2@meta.data$seurat_clusters[pbmc11.2@meta.data$seurat_clusters %in% c(0,1)]="BC"; # rep("BC", 87+82)
pbmc11.2@meta.data$seurat_clusters[pbmc11.2@meta.data$seurat_clusters %in% c(2)]="HeLa" #rep("HeLa", 56)
#
table(pbmc11.2@meta.data$seurat_clusters)
#BC HeLa 
#169   56
# 再覆盖一次active.ident，就可以继续画 dotplot 了
pbmc11.2@active.ident=pbmc11.2@meta.data$seurat_clusters

#
DotPlotPDF(BC_HeLa.scoreGenes,"13-BC_vs_HeLa---top5",width=10,height=4.5,pbmc=pbmc11.2) 





2. 常用查询
(1) 查HVG个数
length(VariableFeatures(pbmc2)) #6000


(2) 查feature个数
summary(pbmc2$nFeature_RNA)
#Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#2669    5664    6426    6368    7100   11619 













#######################
# 2.0版本的
#######################
1. slot raw.data原始count数据

> br5@raw.data[1:4,1:4]
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA               1               0             180               0
7SK                     0               0               5               0
A1BG                    2               0               1               0
A1BG-AS1                0               5               0               0



2. slot data 保存的normalization后的数据，其实就是CPM。
就是除以cell内总count，再乘以一个系数（默认是10000）
> br5@data[1:4,1:4]
4 x 4 sparse Matrix of class "dgCMatrix"
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA     0.003348308      .              0.428460466               .
7SK           .                .              0.014748829               .
A1BG          0.006685442      .              0.002967219               .
A1BG-AS1      .                0.01511409     .                         .

> 1/sum(br5@raw.data[,1])*1e4
[1] 0.00335392

> 5/sum(br5@raw.data[,2])*1e4
[1] 0.01522888



3. slot scale.data 是做过标准化后的数据，此后的分析都是基于缩放过的数据。
ScaleData(): Scaling the data and removing unwanted sources of variation。

> br5@scale.data[1:2,1:4]
          nonSync.c19.r28 nonSync.c16.r10 nonSync.c14.r27 nonSync.c19.r34
5_8S_rRNA      -0.5576100      -0.6386333       1.6995682      -0.3316566
7SK            -0.3512039      -0.3441605       0.7499054      -0.3786910








========================================
|-- 入门教程：Seurat - Guided Clustering Tutorial //todo
----------------------------------------
官方教程页 http://satijalab.org/seurat/get_started.html


1. Seurat包：单细胞测序的各个方面
http://hemberg-lab.github.io/scRNA.seq.course/seurat-chapter.html [作废 2019.12.24check]
https://scrnaseq-course.cog.sanger.ac.uk/website/index.html
功能包含QC, analysis, and exploration of scRNA-seq data。

(2). [10xG官方推荐]Seurat is an R package designed for QC, analysis, and exploration of single cell RNA-seq data. 
http://satijalab.org/seurat/
推荐页：https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/rkit




2. 安装
官网： https://satijalab.org/seurat/install.html

install.packages('devtools')
# Replace '2.3.0' with your desired version
devtools::install_version(package = 'Seurat', version = package_version('2.3.1'))
library(Seurat)

高版本的装不上：
configure: error: The version of hdf5 installed on your system is not sufficient. Please ensure that at least version 1.8.13 is installed


(2) 还可以使用 docker 版本的
https://hub.docker.com/repository/docker/dawneve/rstudio

$ docker run -d -p 5000:8787 -v /home/wangjl/data/dockerRstudio:/home/rstudio \
    -v /home/wangjl/data/dockerRstudio/R_lib_4.0:/home/rstudio/R/x86_64-pc-linux-gnu-library/4.0 \
    -e ROOT=TRUE \
    -e PASSWORD=yourpasswordhere dawneve/rstudio:Seurat




3. 教程
https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html

我自己的练手项目:
https://github.com/DawnEve/scRNAseqCode









========================================
|-- 获取细胞id: WhichCells(),
----------------------------------------
1. 返回细胞id
> head(WhichCells(pbmc, expression= seurat_clusters == 3))
[1] "AAACATTGAGCTAC-1" "AAACTTGAAAAACG-1" "AAAGGCCTGTCTAG-1" "AAAGTTTGATCACG-1"







========================================
|-- 多组数据的整合、批次效应: harmony
----------------------------------------
1. 使用方法
https://satijalab.org/seurat/v3.2/integration.html

(1) harmony算法与其他整合算法相比的优势：
- 整合数据的同时对稀有细胞的敏感性依然很好；
- 省内存；
- 适合于更复杂的单细胞分析实验设计，可以比较来自不同供体，组织和技术平台的细胞。


(2) 基本原理

我们用不同颜色表示不同数据集，用形状表示不同的细胞类型。首先，Harmony应用主成分分析（一文看懂PCA主成分分析）将转录组表达谱嵌入到低维空间中，然后应用迭代过程去除数据集特有的影响。

（A）Harmony概率性地将细胞分配给cluster，从而使每个cluster内数据集的多样性最大化。
（B）Harmony计算每个cluster的所有数据集的全局中心，以及特定数据集的中心。
（C）在每个cluster中，Harmony基于中心为每个数据集计算校正因子。
（D）最后，Harmony使用基于C的特定于细胞的因子校正每个细胞。由于Harmony使用软聚类，因此可以通过多个因子的线性组合对其A中进行的软聚类分配进行线性校正，来修正每个单细胞。
重复步骤A到D，直到收敛为止。聚类分配和数据集之间的依赖性随着每一轮的减少而减小。


(3) 示例

library(Seurat)
library(cowplot)
library(harmony)
load('data/pbmc_stim.RData') #加载矩阵数据
#在运行Harmony之前，创建一个Seurat对象并按照标准PCA进行分析。
pbmc <- CreateSeuratObject(counts = cbind(stim.sparse, ctrl.sparse), project = "PBMC", min.cells = 5) %>%
    Seurat::NormalizeData(verbose = FALSE) %>%
    FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>%
    ScaleData(verbose = FALSE) %>%
    RunPCA(pc.genes = pbmc@var.genes, npcs = 20, verbose = FALSE) 

pbmc@meta.data$stim <- c(rep("STIM", ncol(stim.sparse)), rep("CTRL", ncol(ctrl.sparse)))#赋值条件变量

# 未经校正的PC中的数据集之间存在明显差异
options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = pbmc, reduction = "pca", pt.size = .1, group.by = "stim")
p2 <- VlnPlot(object = pbmc, features = "PC_1", group.by = "stim", pt.size = .1)
plot_grid(p1,p2)


2) Run Harmony
运行Harmony的最简单方法是传递Seurat对象并指定要集成的变量。RunHarmony返回Seurat对象，并使用更正后的Harmony坐标（使用Harmony代替PCA）。将plot_convergence设置为TRUE，这样我们就可以确保Harmony目标函数在每一轮中都变得更好。

RunHarmony函数中主要参数：
- group.by.vars参数是设置按哪个分组来整合
- max.iter.harmony设置迭代次数，默认是10。运行RunHarmony结果会提示在迭代多少次后完成了收敛。
- ⚠️lambda 参数，默认值是1，决定了Harmony整合的力度。lambda值调小，整合力度变大，反之。（只有这个参数影响整合力度，调整范围一般在0.5-2之间）
- ⚠️theta 参数：Diversity clustering penalty parameter. Specify for each variable in group.by.vars. Default theta=2. theta=0 does not encourage any diversity. Larger values of theta result in more diverse clusters. 这个参数我常用默认值，但在不同文献中这个参数往往不同。
- ⚠️dims.use 参数：Which PCA dimensions to use for Harmony. By default, use all.
- sigma参数：Width of soft kmeans clusters. Default sigma=0.1. Sigma scales the distance from a cell to cluster centroids. Larger values of sigma result in cells assigned to more clusters. Smaller values of sigma make soft kmeans cluster approach hard clustering.


options(repr.plot.height = 2.5, repr.plot.width = 6)
pbmc <- pbmc %>% RunHarmony("stim", plot_convergence = TRUE) #Harmony converged after 8 iterations

Harmory运行后的结果储存在：
pbmc@reductions$harmony

> scObj@reductions$harmony[1:3,1:4]
             harmony_1   harmony_2  harmony_3   harmony_4
RP11-34P13.7  4822.785    581.2719  -1928.599    353.9254
FO538757.2   18815.930 -49360.2172 -21452.936  -8208.2729
AP006222.2   18817.910 -72234.6732 -46611.394 -12277.6396


使用Embeddings命令访问新的Harmony embeddings。
harmony_embeddings <- Embeddings(pbmc, 'harmony')
harmony_embeddings[1:5, 1:5]

> Embeddings(scObj, 'harmony')[1:3, 1:4]
                   harmony_1  harmony_2  harmony_3  harmony_4
AAACGGGCATGACGGA-1  24.96812  1.6123402  0.4014826 -10.221284
AAAGATGAGCAGACTG-1  28.14937  0.5829318  0.8305650 -16.066575
AAAGATGAGTGTACTC-1  25.97696 -1.7031176 -1.6094473  -8.406375


让我们查看确认数据集在Harmony运行之后的前两个维度中得到很好的整合。
options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = pbmc, reduction = "harmony", pt.size = .1, group.by = "stim")
p2 <- VlnPlot(object = pbmc, features = "harmony_1", group.by = "stim", pt.size = .1)
plot_grid(p1,p2)



3) Downstream analysis 下游分析: UMAP

许多下游分析是在低维嵌入而不是基因表达上进行的。要使用校正后的Harmony embeddings而不是PC，设置reduction ='harmony'。

pbmc <- pbmc %>%
    RunUMAP(reduction = "harmony", dims = 1:20) %>%
    FindNeighbors(reduction = "harmony", dims = 1:20) %>%
    FindClusters(resolution = 0.5) %>%
    identity()

在UMAP embedding中，我们可以看到更复杂的结构。由于我们使用harmony embeddings，因此UMAP embeddings混合得很好。
options(repr.plot.height = 4, repr.plot.width = 10)
DimPlot(pbmc, reduction = "umap", group.by = "stim", pt.size = .1, split.by = 'stim')


# tSNE
pbmc=RunTSNE(pbmc,reduction = "harmony", dims = 1:20)
TSNEPlot(object = pbmc, pt.size = 0.5, label = TRUE,split.by='stim') 

两样本合并的TSNE和UMAP图
DimPlot(pbmc, reduction = "umap",pt.size = .1,  label = TRUE)
TSNEPlot(pbmc, pt.size = .1, label = TRUE) 


4) 关于Harmony操作是否会对差异分析产生影响
Harmony输入的是 scRNA@reductions$pca 的数据，得出的结果储存在 scRNA@reductions$harmony 中。

而差异分析使用的是 scRNA@assays$RNA@counts 数据，互不影响。



4. 多样本批次矫正方法汇总
工具		/Batch-effect-corrected output	/方法
Seurat2	R	/Normalized canonical components	/Canonical correlation analysis and dynamic time warping
Seurat3	R	/Normalized gene expression matrix	/CCA and mutural nearest neighbors-anchors
Harmony	R	/Normalized feature reduction vectors	/Iterative clustering in dimensionally reduced space
MNN Correct	R	/Normalized gene expression matrix	/Mutual nearest neighbor in gene expression space
...








2. 使用时机：到细分亚群的时候才做 harmony，为什么不一开始就用呢？
https://mp.weixin.qq.com/s/dxJLVRXWhLnf3w1LRiONIA
http://www.bio-info-trainee.com/8728.html


《Single-cell transcriptomics reveals regulators underlying immune cell diversity and immune subtypes associated with prognosis in nasopharyngeal carcinoma》为例子，15个鼻咽癌样品，加上1个正常人样品。全部的样品的单细胞转录组数据整合后，如果不使用harmony等算法去除样品差异，默认的降维聚类分群
可以看到，效果还不错。

但是如果我们具体到每个样品，有如下所示的现象：每个亚群中按样本聚到一起。

上皮细胞大的亚群里面，每个病人独立成为小亚群，泾渭分明，这个符合预期，因为每个肿瘤病人都有自己的特异性。但是免疫细胞各个亚群里面，病人之间的界限就模糊很多。值得注意的是P07这个病人的样品，它主要是T细胞和髓系细胞，而且是独立成为一个亚群了，这就是单细胞转录组的样品差异，理论上是需要去除的！

(2) 如果我们在样品层面就开始使用harmony等算法去除样品差异，又会导致另外一个可怕的事情发生，如下所示
就是本来是应该是具备病人特异性的上皮细胞，这个时候被抹除了样品差异。
好好的上皮细胞，被拆分的七零八落

按病人样品染色：

这个算法真的是太可怕了，样品差异被抹除的干干净净了！这不是最可怕的，真正的问题是，这个上皮细胞被打散到了其它免疫细胞里面，因为这个harmony算法！
我们可以对上皮细胞的最重要的marker基因EPCAM进行可视化，并且使用harmony等算法去除样品差异前后可以对比看看。




(3) 我们做肿瘤研究的单细胞数据，一般来说会选择初步很粗狂的定义大的细胞亚群，比如我常用的 第一次分群是通用规则是：
immune (CD45+,PTPRC),
epithelial/cancer (EpCAM+,EPCAM),
stromal (CD10+,MME,fibo or CD31+,PECAM1,endo)







3. 头颈癌：Single-cell transcriptome profiling of the stepwise progression of head and neck cancer
https://pubmed.ncbi.nlm.nih.gov/36828832/
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE181919

Choi JH, Lee BS, Jang JY, Lee YS et al. Single-cell transcriptome profiling of the stepwise progression of head and neck cancer. Nat Commun 2023 Feb 24;14(1):1055. PMID: 36828832

(1) 背景
Head and neck squamous cell carcinoma (HNSCC) undergoes stepwise progression from normal tissue to metastasized tumors. 
To comprehensively delineate the heterogeneity of tumor cells and their interactions during the progression of HNSCC, we employed single-cell RNA-seq (scRNA-seq) profiling for the tissues of normal, leukoplakia, HNSCC, and metastasized HNSCC. 

We identified novel clones of malignant cells expressing LGALS7B and fibroblasts expressing CXCL8, and the abundance of these cells in the tumor tissue was associated with poorer prognostic outcomes. 

In addition, we demonstrated that fibroblasts in leukoplakia and tumor tissue express COL1A1, which interacts with CD44+ malignant cells, facilitating HNSCC progression. 

CD4+FOXP3+ regulatory T cells expand in leukoplakia and express LAIR2 with collagen stimulation, which may provide a favorable microenvironment for tumor progression. 

In conclusion, stromal and immune cell interactions play critical roles in the stepwise progression of HNSCC, and we have identified steps during HNSCC progression for possible therapeutic interventions


(2) 实验设计
Single-cell transcriptome profiling from 37 tissue specimens of 
non-tumoral surrounding normal tissue (NL, n = 9), 
leukoplakia (LP, n = 4), 
primary cancer (CA, n = 20), 
and metastatic tumors in lymph nodes (LN, n = 4)

按进展顺序 NL -> LP -> CA -> LN;


(3) 聚类 Processing and clustering of scRNA-seq data

Processing and clustering of scRNA-seq data The raw data of the gene expression matrix was filtered using the "Seurat" R package with the following criteria of the cells with > 200 genes and < 8000 genes, < 10% of mitochondrial gene expression in UMI counts, and the genes expressed in > 0.1% cells. 

The batch effects of the samples were corrected using 'RunHarmony' in the "Harmony" R package, 

dimension reduction was performed using UMAP with the 'RunUMAP' function (dims = 1:50), and the clustering was performed using a shared-nearest neighbor graph algorithm 'FindClusters’ function (resolution = 0.2). 

Subtyping of the malignant cells, cancer-associated fibroblasts (CAFs), and T cells were performed using the following parameters. 
For malignant cells, dims = 1:20, lambda = 1, theta = 0, and resolution = 0.05; 
for CAFs, dims = 1:10, lambda = 1, theta = 0, and resolution = 0.2; 
for T cells, dim = 1:50, lambda = 1, theta = 2, and resolution = 0.2.


(4) Cell typing, deconvolution, and gene set analyses

Cell typing was performed by manually examining the expression levels of the canonical marker genes for 

malignant cells (KRT14, KRT17, KRT6A, KRT5, KRT19, KRT8, KRT16, KRT18, KRT6B, KRT15, KRT6C, KRTCAP3, EPCAM, SFN), 
fibroblasts (FAP, PDPN, COL1A2, DCN, COL3A1, COL6A1), 
myocytes (ACTA1, ACTN2, MYL2, MYH2), 
T cells (CD2, CD3D, CD3E, CD3G), 
B/Plasma cells (SLAMF7, CD79A, BLNK, FCRL5), 
macrophages (CD14, CD163, CD68, FCGR2A, CSF1R), 
dendritic cells (CD40, CD80, CD83, CCR7), 
mast cells (CMA1, MS4A2, TPSAB1, TPSB2) and 
endothelial cells (PECAM1, VWF, ENG). 

Deconvolution of the bulk RNA-Seq data s was performed using “MuSiC” R package 1 . 

The proliferation index score was calculated as the sum of the S scores and G2M scores using the 'CellCycleScoring' function in the Seurat R package. 

The scores for 'tumor-infiltrating lymphocyte (TIL)' and 'dysfunctional T cell' were calculated as the average expression values of the marker genes, respectively 2, 3


(5) Harmony 就是代替 PCA 的，并且用于后续的非线性降维











========================================
|-- 细胞周期对聚类的影响: Cell-Cycle Scoring and Regression 细胞周期打分和回归
----------------------------------------
1. Cell-Cycle Scoring and Regression
#https://satijalab.org/seurat/cell_cycle_vignette.html
https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html

We demonstrate how to mitigate the effects of cell cycle heterogeneity in scRNA-seq data by calculating cell cycle phase scores based on canonical markers, and regressing these out of the data during pre-processing. 

两种策略，一种是完全regression，另一种是只针对 S和G2M 的差异回归。 


(2) Seurat 代码实现
## cell cycle score ----
scObj2b_2 <- CellCycleScoring(scObj2b_2, s.features = cc.genes$s.genes, g2m.features = cc.genes$g2m.genes, set.ident = TRUE)
RidgePlot(scObj2b_2, features = c("PCNA", "TOP2A", "MCM6", "MKI67", "PLK1",
                                  "CCNB1", "CCNB2", "CCNE1", "CCNE2"), ncol = 3)

head(scObj2b_2@meta.data)

#plot1
scObj2b_2@meta.data %>% ggplot( aes(x=S.Score, y=G2M.Score, color=seurat_clusters))+
  geom_point(size=0.5) + 
  theme_classic(base_size = 12)+LargeLegend(3)+
  facet_grid(~time)+
  theme(
    strip.background = element_blank()
  )
#
# plot2
DimPlot(scObj2b_2, group.by = "Phase", label=T)
DimPlot(scObj2b_2,  label=T, split.by = "Phase")
DimPlot(scObj2b_2, group.by = "Phase", label=F, split.by = "time", ncol = 3)
# plot3
pie( table(scObj2b_2$Phase), col = scales::hue_pal()(3) )
#
table2barplot( table(scObj2b_2$Phase, scObj2b_2$seurat_clusters) )
#







2.重点：周期相关基因list怎么找？https://www.biostars.org/p/364214/
List of Human Cell Cycle Stage Specific Genes() 
and this list from Qiagen.
(https://www.qiagen.com/it/resources/resourcedetail?id=0ee18e97-d445-4fd7-9aa4-0ef4bece124f&lang=en)


#########
paper提到的两篇重点参考文献http://science.sciencemag.org/content/352/6282/189
To characterize cycling cells more precisely, we used gene signatures that have previously been shown to denote G1/S or G2/M phases in both synchronization (20) and single-cell (16) experiments in cell lines. 

##[16]M. L. Whitfield, G. Sherlock, A. J. Saldanha, J. I. Murray, C. A. Ball, K. E. Alexander, J. C. Matese, C. M. Perou, M. M. Hurt, P. O. Brown, D. Botstein, Botstein, Identification of genes periodically expressed in the human cell cycle and their expression in tumors. Mol. Biol. Cell 13, 1977–2000 (2002). doi:10.1038/nrc1802 pmid:12058064 
高被引522次：https://www.ncbi.nlm.nih.gov/pubmed?linkname=pubmed_pubmed_citedin&from_uid=12058064
data: http://genome-www.stanford.edu/Human-CellCycle/Hela/

##[20]E. Z. Macosko, A. Basu, R. Satija, J. Nemesh, K. Shekhar, M. Goldman, I. Tirosh, A. R. Bialas, N. Kamitaki, E. M. Martersteck, J. J. Trombetta, D. A. Weitz, J. R. Sanes, A. K. Shalek, A. Regev, S. A. McCarroll, Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets. Cell 161, 1202–1214 (2015). doi:10.1016/j.cell.2015.05.002 pmid:26000488 
#########
[20]的补充材料“Cell Cycle Analysis of HEK and 3T3 Cells”写fig4是怎么做的。
https://ars.els-cdn.com/content/image/1-s2.0-S0092867415005498-mmc1.pdf

Gene sets reflecting five phases of the HeLa cell cycle (G1/S, S, G2/M, M and M/G1) were taken from
Whitfield et al. (Whitfield et al., 2002) (Table S2)


(1)BrdU:https://baike.baidu.com/item/BrdU/8395857?fr=aladdin
PI:https://baike.baidu.com/item/pi/4004256






refer
讨论细胞周期基因： https://www.cnblogs.com/leezx/p/8648363.html
R包ccRemover： https://cran.r-project.org/web/packages/ccRemover/vignettes/ccRemover_tutorial.html







========================================
|-- Seurat包取细胞群体的子集: subset()/FetchData()等函数
----------------------------------------
1. 取子集

https://stackoverflow.com/questions/60195840/how-to-make-a-subset-of-cells-expressing-certain-gene-in-seurat-r

Dbh.pos <- Idents(my.data, WhichCells(my.data, expression = Dbh > 0, slot = "data"))
Dbh.neg <- Idents(my.data, WhichCells(my.data, expression = Dbh == 0, slot = "data"))


(1)You can subset from the counts matrix, below I use pbmc_small dataset from the package, and I get cells that are CD14+ and CD14-:

> library(Seurat)
> CD14_expression = GetAssayData(	object = pbmc_small, assay = "RNA", slot = "data")["CD14",]
> head(CD14_expression,30)
ATGCCAGAACGACT CATGGCCTGTGCAT GAACCTGATGAACC TGACTGGATTCTCA AGTCAGACTGCACA 
      0.000000       0.000000       0.000000       0.000000       0.000000 
TCTGATACACGTGT TGGTATCTAAACAG GCAGCTCTGTTTCT GATATAACACGCAT AATGTTGACAGTCA 
      0.000000       0.000000       0.000000       0.000000       0.000000 
#

(2)Getting the ids can be done using which :
> pos_ids = names(which(CD14_expression>0))
> neg_ids = names(which(CD14_expression==0))


(3)Subsetting of the data can be done with:
> pos_cells = subset(pbmc_small,cells=pos_ids)
> neg_cells = subset(pbmc_small,cells=neg_ids)

2)
cd14.mono <- subset(immune.combined, idents = 'CD14 Mono')

scObject <- subset(x = scObject.all, idents = c("Endothelial"), invert = FALSE);

neu_colon <- subset(neu_colon, idents = c(1,2,3), invert=T) #选择除了1,2,3 之外的群。



(4)A bit dumb, but I guess this is one way to check whether it works:
> FeaturePlot(pos_cells,"CD14")
> FeaturePlot(neg_cells,"CD14")


(5)
> GEX = pbmc_small
I am getting the gene expression, then make a dataframe with two columns, and this information is directly added on the Seurat object.

> GENE="Cd8a"
> EXPR = GetAssayData(object=GEX,assay="RNA",slot="data")[GENE,]
> EXPR_df=data.frame( positive= EXPR > 0, negative = EXPR == 0)
> names(GEX)<-paste0( c("positive_","negative_"),GENE)
> GEX <- AddMetaData(GEX,metadata=EXPR_df)

This approach allows then to subset nicely, with more flexibility.

> GEX_subset <- subset(GEX, annot == "T cell" & negative_Cd8a)








2. 疑难杂症 
subset()不能放到函数function(){}中使用: https://github.com/satijalab/seurat/issues/4058

(1) 如果想每个样本取子集，使用 downsample 参数:
pbmc.small <- subset(pbmc3, downsample = 100) # Downsample to a maximum of 100 cells per identity class


(2) 如果非要在函数中取子集呢: https://github.com/satijalab/seurat/issues/1053#issuecomment-454512002

Much like R's subset function, subset.Seurat is designed for interactive use only. While we currently don't offer a programmatic way to subset Seurat objects based on feature expression, this can be accomplished relatively easily using which and FetchData

expr <- FetchData(object = object, vars = var1)
object[, which(x = expr > low & expr < high)]


2) 非交互式
var1 <- "GeneName"
expr <- FetchData(object = object, vars = var1)
object[, which(x = expr > low & expr < high)]


# 循环中不能直接用WhichCells/subset,可以用上面的方式
library(Seurat)
gene_cells = list()
items <-c( 'LGALS3', 'S100A11')
for (gene1 in items)
{
    if (gene1 %in% rownames(pbmc_small))
    {
        expr <- FetchData(object = pbmc_small, vars = gene1)
        gene_cells[[gene1]] <- pbmc_small[, which(x = expr >= 0.5)]
    }
}
gene_cells #两个 seurat 对象。






(3) 按基因表达量选择
# Can I create a Seurat object based on expression of a feature or value in object metadata?
subset(pbmc, subset = MS4A1 > 1)




ref:
https://satijalab.org/seurat/archive/v3.0/interaction_vignette.html
https://www.jianshu.com/p/99cb6dc8de45



========================================
|-- 添加打分列: AddMetaData 添加 ribo 列 / AddModuleScore 计算 disassociation induced genes (DIG) 打分
----------------------------------------
1.paper: Pan-cancer single-cell landscape of tumor-infiltrating T cells 补充材料

From the first run clustering, in multiple datasets, we identified clusters with marker genes associated with tissue dissociation operation including heat shock protein-encoding genes (50). Recurrent marker genes of these tissue dissociation-related clusters, i.e. those that showed 25 significant high expression in more than 40% tissue dissociation-related clusters, were defined as disassociation induced genes (DIG) and were included in the gene blacklist after the first run clustering.

To minimize the impact of those processes, the S phase score and G2M phase score were calculated with function CellCycleScoring, and the DIG score was calculated with function AddModuleScore. Then those scores were regressed out in the Seurat pipeline.




2. 或者使用 AddMetaData 添加一列。

(1) 片段1
rb.genes <- rownames(sce)[grep("^RP[SL]",rownames(sce))]
percent.ribo <- Matrix::colSums(C[rb.genes,])/Matrix::colSums(C)*100
sce <- AddMetaData(sce, percent.ribo, col.name = "percent.ribo")


(2) 片段2(zhang lab)
$ find . | xargs grep -i AddModuleScore --color=auto
./w.step2.FigureS14.CD8_Tex_score.Rmd:seu = AddModuleScore(seu, features=list(Tex.markers.sig50), name="Exhaust.Score")

详情:
# seu and calculate
seu = readRDS(sprintf("%s/../../data/expression/%s/integration/%s.thisStudy_10X.seu.rds", oDir, stype, stype))
seu = seu[,meta$cellID]
seu = AddModuleScore(seu, features=list(Tex.markers.sig50), name="Exhaust.Score")
meta$Exhaust.Score = seu$Exhaust.Score1

saveRDS(meta, sprintf("%s/%s_Tex.cellInfo_TexScore.tb.rds", oDir, stype))









3. 如果错了，想删掉某个 meta.data 列
https://github.com/satijalab/seurat/issues/1179


object$column.to.remove <- NULL
object[['column.to.remove']] <- NULL


批量删除
test.tc11@meta.data <- test.tc11@meta.data[, -which(colnames(test.tc11@meta.data) %in% 'time')]








========================================
Seurat 4.1.0 的 240 个函数名： ls("package:Seurat")
----------------------------------------

> ls("package:Seurat")
  [1] "AddAzimuthResults"               "AddMetaData"                     "AddModuleScore"                 
  [4] "AggregateExpression"             "AnnotateAnchors"                 "as.CellDataSet"                 
  [7] "as.Graph"                        "as.Neighbor"                     "as.Seurat"                      
 [10] "as.SingleCellExperiment"         "as.sparse"                       "Assays"                         
 [13] "AugmentPlot"                     "AutoPointSize"                   "AverageExpression"              
 [16] "BarcodeInflectionsPlot"          "BGTextColor"                     "BlackAndWhite"                  
 [19] "BlueAndRed"                      "BoldTitle"                       "BuildClusterTree"               
 [22] "CalcPerturbSig"                  "CalculateBarcodeInflections"     "CaseMatch"                      
 [25] "cc.genes"                        "cc.genes.updated.2019"           "CellCycleScoring"               
 [28] "Cells"                           "CellsByIdentities"               "CellScatter"                    
 [31] "CellSelector"                    "CenterTitle"                     "CollapseEmbeddingOutliers"      
 [34] "CollapseSpeciesExpressionMatrix" "ColorDimSplit"                   "CombinePlots"                   
 [37] "Command"                         "CreateAssayObject"               "CreateDimReducObject"           
 [40] "CreateSCTAssayObject"            "CreateSeuratObject"              "CustomDistance"                 
 [43] "CustomPalette"                   "DarkTheme"                       "DEenrichRPlot"                  
 [46] "DefaultAssay"                    "DefaultAssay<-"                  "DietSeurat"                     
 [49] "DimHeatmap"                      "DimPlot"                         "DiscretePalette"                
 [52] "Distances"                       "DoHeatmap"                       "DotPlot"                        
 [55] "ElbowPlot"                       "Embeddings"                      "ExpMean"                        
 [58] "ExpSD"                           "ExpVar"                          "FastRowScale"                   
 [61] "FeatureLocator"                  "FeaturePlot"                     "FeatureScatter"                 
 [64] "FetchData"                       "FilterSlideSeq"                  "FindAllMarkers"                 
 [67] "FindClusters"                    "FindConservedMarkers"            "FindIntegrationAnchors"         
 [70] "FindMarkers"                     "FindMultiModalNeighbors"         "FindNeighbors"                  
 [73] "FindSpatiallyVariableFeatures"   "FindSubCluster"                  "FindTransferAnchors"            
 [76] "FindVariableFeatures"            "FoldChange"                      "FontSize"                       
 [79] "GeneSymbolThesarus"              "GetAssay"                        "GetAssayData"                   
 [82] "GetImage"                        "GetIntegrationData"              "GetResidual"                    
 [85] "GetTissueCoordinates"            "GetTransferPredictions"          "GroupCorrelation"               
 [88] "GroupCorrelationPlot"            "HoverLocator"                    "HTODemux"                       
 [91] "HTOHeatmap"                      "HVFInfo"                         "Idents"                         
 [94] "Idents<-"                        "IFeaturePlot"                    "Images"                         
 [97] "Index"                           "Index<-"                         "Indices"                        
[100] "IntegrateData"                   "IntegrateEmbeddings"             "Intensity"                      
[103] "IsGlobal"                        "ISpatialDimPlot"                 "ISpatialFeaturePlot"            
[106] "JackStraw"                       "JackStrawPlot"                   "JS"                             
[109] "JS<-"                            "Key"                             "Key<-"                          
[112] "L2CCA"                           "L2Dim"                           "LabelClusters"                  
[115] "LabelPoints"                     "LinkedDimPlot"                   "LinkedFeaturePlot"              
[118] "Load10X_Spatial"                 "LoadAnnoyIndex"                  "Loadings"                       
[121] "Loadings<-"                      "LoadSTARmap"                     "LocalStruct"                    
[124] "LogNormalize"                    "LogSeuratCommand"                "LogVMR"                         
[127] "Luminance"                       "MappingScore"                    "MapQuery"                       
[130] "MetaFeature"                     "MinMax"                          "Misc"                           
[133] "Misc<-"                          "MixingMetric"                    "MixscapeHeatmap"                
[136] "MixscapeLDA"                     "MULTIseqDemux"                   "Neighbors"                      
[139] "NNPlot"                          "NoAxes"                          "NoGrid"                         
[142] "NoLegend"                        "NormalizeData"                   "PCAPlot"                        
[145] "PCASigGenes"                     "PCHeatmap"                       "PercentAbove"                   
[148] "PercentageFeatureSet"            "PlotClusterTree"                 "PlotPerturbScore"               
[151] "PolyDimPlot"                     "PolyFeaturePlot"                 "PredictAssay"                   
[154] "PrepLDA"                         "PrepSCTFindMarkers"              "PrepSCTIntegration"             
[157] "Project"                         "Project<-"                       "ProjectDim"                     
[160] "ProjectUMAP"                     "PurpleAndYellow"                 "Radius"                         
[163] "Read10X"                         "Read10X_h5"                      "Read10X_Image"                  
[166] "ReadMtx"                         "ReadParseBio"                    "ReadSlideSeq"                   
[169] "ReadSTARsolo"                    "Reductions"                      "RegroupIdents"                  
[172] "RelativeCounts"                  "RenameCells"                     "RenameIdents"                   
[175] "ReorderIdent"                    "RestoreLegend"                   "RidgePlot"                      
[178] "RotatedAxis"                     "RowMergeSparseMatrices"          "RunCCA"                         
[181] "RunICA"                          "RunLDA"                          "RunMarkVario"                   
[184] "RunMixscape"                     "RunMoransI"                      "RunPCA"                         
[187] "RunSLSI"                         "RunSPCA"                         "RunTSNE"                        
[190] "RunUMAP"                         "SampleUMI"                       "SaveAnnoyIndex"                 
[193] "ScaleData"                       "scalefactors"                    "ScaleFactors"                   
[196] "ScoreJackStraw"                  "SCTransform"                     "SCTResults"                     
[199] "SCTResults<-"                    "SelectIntegrationFeatures"       "SetAssayData"                   
[202] "SetIdent"                        "SetIntegrationData"              "SetQuantile"                    
[205] "SeuratAxes"                      "SeuratTheme"                     "SingleCorPlot"                  
[208] "SingleDimPlot"                   "SingleExIPlot"                   "SingleImageMap"                 
[211] "SingleRasterMap"                 "SingleSpatialPlot"               "SpatialDimPlot"                 
[214] "SpatialFeaturePlot"              "SpatiallyVariableFeatures"       "SpatialPlot"                    
[217] "SpatialTheme"                    "SplitObject"                     "StashIdent"                     
[220] "Stdev"                           "SubsetByBarcodeInflections"      "SVFInfo"                        
[223] "Tool"                            "Tool<-"                          "TopCells"                       
[226] "TopFeatures"                     "TopNeighbors"                    "TransferData"                   
[229] "TSNEPlot"                        "UMAPPlot"                        "UpdateSCTAssays"                
[232] "UpdateSeuratObject"              "UpdateSymbolList"                "VariableFeaturePlot"            
[235] "VariableFeatures"                "VariableFeatures<-"              "VizDimLoadings"                 
[238] "VlnPlot"                         "WhichCells"                      "WhiteBackground" 





========================================
|-- 并行运算：FindAllMarkers 多线程/ 多核
----------------------------------------
1. 可用版本
library(future)
plan(strategy = "multisession", workers=10) #多线程
bmmc.markersNMF <- FindAllMarkers(pbmc.nmf, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
plan(strategy = "sequential") #恢复单线程




2. 查看可用 线程数
library(future)
plan(strategy = "multisession", workers=10) #multi-core not supported in Rstudio
future::nbrOfWorkers() #10
bmmc.markersNMF <- FindAllMarkers(pbmc.nmf, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
plan(strategy = "sequential") #single core
future::nbrOfWorkers() #1


安装limma包后 # BiocManager::install('limma')
再次调用 FindAllMarkers 函数 报错：
MultisessionFuture (future_sapply-1) failed to call grmall() on cluster RichSOCKnode #7 (PID 131960 on localhost ‘localhost’). The reason reported was ‘error writing to connection’. Post-mortem diagnostic: No process exists with this PID, i.e. the localhost worker is no longer alive. The total size of the 7 globals exported is 8.92 MiB. The three largest globals are ‘data.use’ (8.91 MiB of class ‘S4’), ‘...future.FUN’ (14.94 KiB of class ‘function’) and ‘...future.elements_ii’ (672 bytes of class ‘list’)



========================================
|-- 保存 FindAllMarkers 计算结果到R对象
----------------------------------------

scObj_pA.markers <- FindAllMarkers(scObj_pA, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
scObj_pA.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_log2FC)


# (2)save ----
scObj_pA@misc[["markers"]] = scObj_pA.markers # 保存到对象中

saveRDS(scObj_pA, file = paste0(outputRoot, "PBMC_CD4T_activation_pA_count_matrix-v3.Rds") )




















========================================
算法细节
----------------------------------------

========================================
|-- counts / data / scale.data 怎么来的
----------------------------------------

1. counts 2 data
a1=sce@assays$RNA@counts
a2=sce@assays$RNA@data #counts 怎么变的 data?
a1[10:20,1:3]
a2[10:20,1:3]
a3=apply(a1, 2, function(x){
    log(x/sum(x) * 1e4 +1) #先按列标准化，扩大到1e4，加1，之后取自然对数。
})
a3[10:20,1:3] #和a2一样

# 测试
table( as.logical( (a2-a3)< 1e-10 ) ) #-10 all T; -20 hase F

# 测试
hist( apply(expm1(a2), 2, sum), n=100 )
hist( apply(expm1(a3), 2, sum), n=100 )


(2) 取平均表达量 - 按细胞

# 求平均，按列。求的是取对数前-1，也就是 counts的平均。
avg.exp <- apply(X = data.use, MARGIN = 2, FUN = function(x) {
  return(mean(x = expm1(x = x))) #expm1 是啥？ expm1(x) computes exp(x) - 1 accurately also for |x| << 1.
})


(3) 求平均表达量 - 按基因












========================================
|-- 什么时候使用expm1？
----------------------------------------

在上面归一化的处理中，我们应用了log1p做数值变化，以使基因的原始count去偏态，符合正态分布。那么，也引出来一个问题，我们什么时候使用expm1？

1. 场景1：在 AverageExpression() 源码中，对归一化的基因表达矩阵seurat_obj[['RNA']]@data进行expm1处理

这个怎么理解呢？我在网上也看到网友对此问题的疑惑，为什么“take un-log data when calculate average expression”。

data.use <- expm1(x = data.use)

toRet <- SetAssayData(object = toRet, assay = names(x = data.return)[i], 
                    slot = "data", new.data = log1p(x = as.matrix(x = data.return[[i]])))


(1) 函数计算
> t1=AverageExpression(scObj, group.by = "seurat_clusters")[['RNA']]
> dim(t1)
[1] 20000    19

> t1[1:4,1:5]
                        0           1           2           3           4
RP11-34P13.7  0.002931872 0.003326554 0.005790386 0.003155577 0.002494124
FO538757.2    0.382159160 0.249731641 0.267545334 0.222562765 0.196198151
AP006222.2    0.269136199 0.061290994 0.086654934 0.120747568 0.137966105
RP4-669L17.10 0.005504739 0.003823366 0.002833042 0.003918494 0.002222287

耗时
用户  系统  流逝 
4.270 1.878 6.142 



(2)手工计算: 很慢

计算过程: 
- log的标准化到1e4的表达值 data，行为gene，列为cell id;
- 转置为行名为cell id，列为gene;  按行 cell id 对应的 cluster 拆分；
- 每个小矩阵 按列求 均值，就是每个基因在该 cluster 的平均表达量。求平均使用 log 前的值，也就是 expm1(data)

t2 = sapply( split( as.data.frame(t(expm1(scObj@assays$RNA@data))), scObj$seurat_clusters), 
             function(x){
               colMeans(x) # 按列求平均
             })
Warning message: 警告 需要内存很大。怎么降低内存消耗呢？ 经过测试，把 expm1 放到 colMeans 中会更慢！
In asMethod(object) :
  sparse->dense coercion: allocating vector of size 8.1 GiB


如果报错，尝试 expm1 前多加一个 as.data.frame
system.time({
  dat2 = sapply( X=split(
      as.data.frame(t(expm1( as.data.frame (pbmc@assays$RNA@data))) ), 
      pbmc$seurat_clusters
    ), 
    FUN = function(x){
      colMeans(x) # 按列求平均
    })
})
dat2[1:3, 1:5]


> dim(t2)
[1] 20000    19

> t2[1:4,1:5]
                        0           1           2           3           4
RP11-34P13.7  0.002931872 0.003326554 0.005790386 0.003155577 0.002494124
FO538757.2    0.382159160 0.249731641 0.267545334 0.222562765 0.196198151
AP006222.2    0.269136199 0.061290994 0.086654934 0.120747568 0.137966105
RP4-669L17.10 0.005504739 0.003823366 0.002833042 0.003918494 0.002222287

耗时：比R包多用了10倍时间。
用户  系统  流逝 
42.975 21.957 64.887


验证2个手工计算和包计算的一致
> table(abs(t1-t2)<0.00001)
  TRUE 
380000 


(3) => 更快的方法: 读源码精简出来的

system.time({
    data.use <- GetAssayData(object = scObj, assay = 'RNA', slot = 'data')
    #data.use <- data.use[rownames(scObj), ]
    data.use <- expm1(x = data.use)


    t1=FetchData(scObj, vars=("ident"))
    category.matrix = Matrix::sparse.model.matrix(object=as.formula("~0+t1[,1]") )

    category.matrix = sweep(x = category.matrix, MARGIN = 2, STATS = colSums(x = category.matrix), FUN = "/")
    
    colnames(category.matrix) = gsub(pattern = "t1\\[, [1-9]*\\]", replacement = "", x = colnames(category.matrix))


    t3 <- as.matrix(x = (data.use %*% category.matrix))
})

> dim(t3)
[1] 20000    19

> t3[1:4,1:5]
                        0           1           2           3           4
RP11-34P13.7  0.002931872 0.003326554 0.005790386 0.003155577 0.002494124
FO538757.2    0.382159160 0.249731641 0.267545334 0.222562765 0.196198151
AP006222.2    0.269136199 0.061290994 0.086654934 0.120747568 0.137966105
RP4-669L17.10 0.005504739 0.003823366 0.002833042 0.003918494 0.002222287

耗时：
用户  系统  流逝 
2.924 0.172 3.094 


测试: 结果和R包函数一致
> table(abs(t1-t3)<0.00001)
  TRUE 
380000 



(4) 所以画热图时，这个还是要再取log的！

> max(t3)
[1] 4663.597
> min(t3)
[1] 0

log(t3 +1) 或者用函数 t2=log1p(t3)

> min(t2)
[1] 0
> max(t2)
[1] 8.447757









2. 场景2：在计算线粒体比例也用到了expm1

mito.genes <- grep("^MT-", rownames(pbmc@data), value = T)
percent.mito <- colSums(expm1(pbmc@data[mito.genes, ]))/colSums(expm1(pbmc@data))

#AddMetaData adds columns to object@data.info, and is a great place to stash QC stats
pbmc <- AddMetaData(pbmc, percent.mito, "percent.mito")
VlnPlot(pbmc, c("nGene", "nUMI", "percent.mito"), nCol = 3)







3. 在seurat的代码中会出现对已经log1p归一化的数值进行expm1，比如线粒体的占比和AverageExpression的处理，背后的逻辑怎么理解？

在网上找到一些零星的信息：

The expm1 does un-log the data, but the normalization persists (this would be lost in the counts slot)

expm1() transformed in order to recover normalized values not in log scale





ref:
https://www.jianshu.com/p/2203a20cb369




========================================
|-- t-SNE算法 //todo
----------------------------------------

https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&mid=2247484978&idx=1&sn=07b7f734ad0ad44562186c1ef3663057&scene=21#wechat_redirect









========================================
|-- Seurat包：multidimensional scaling (MDS)多维尺度分析分析
----------------------------------------
Seurat - Dimensional Reduction Vignette
https://satijalab.org/seurat/dim_reduction_vignette.html

MDS降维原理：
https://blog.csdn.net/yang_xian521/article/details/7301121
https://www.cnblogs.com/lochan/p/6627511.html


# Before running MDS, we first calculate a distance matrix between all pairs
# of cells.  Here we use a simple euclidean distance metric on all genes,
# using object@scale.data as input
pbmc=br10
d <- dist(x = t(x = pbmc@scale.data))
# Run the MDS procedure, k determines the number of dimensions
mds <- cmdscale(d = d, k = 2)
# cmdscale returns the cell embeddings, we first label the columns to ensure
# downstream consistency
colnames(x = mds) <- paste0("MDS", 1:2)
# We will now store this as a new dimensional reduction called 'mds'
pbmc <- SetDimReduction(object = pbmc, reduction.type = "mds", slot = "cell.embeddings", 
                        new.data = mds)
pbmc <- SetDimReduction(object = pbmc, reduction.type = "mds", slot = "key", 
                        new.data = "MDS")

# We can now use this as you would any other dimensional reduction in all
# downstream functions (similar to PCAPlot, but generalized for any
# reduction)
DimPlot(object = pbmc, reduction.use = "mds", pt.size = 2) #0.5
DimPlot(object = pbmc, pt.size = 2)

pop2=rep(0,28);pop2=c(pop2, rep(1,32));pop2
DimPlot(object = pbmc, reduction.use = "mds", pt.size = 2) + 
  geom_point(aes(colour=factor(pop2)) )
  
#






========================================
修改补充 Seurat对象 并绘图
----------------------------------------






========================================
|-- 修改 seurat 的分类列，后续按照新 Idents 进行比较marker、画热图等
----------------------------------------
1.

(1) add new column as cell identity
pbmc12@meta.data$cellType=cellInfo2[rownames( pbmc12@meta.data), ]$cellType
table(pbmc12@meta.data$seurat_clusters, pbmc12$cellType)
#   BC_0 BC_1 HeLa_normal HeLa_sync
#0   92    0           0         0
#1    0   73           0         0
#2    0    0          30        27
Idents(pbmc12) ="cellType"
sortIdent = factor(pbmc12$cellType,levels = c("BC_0","BC_1", "HeLa_normal",   "HeLa_sync"))
pbmc12@active.ident = sortIdent





(2) 对比：官方示例的方法：
new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
#*********

> head(Idents(scObj_known2), n=3)
AAACCCAAGAGCTTTC-1_1 AAACCCAGTAGTGGCA-1_1 AAACCCATCTTCACGC-1_1 
            Platelet             Platelet           Ccr2+ Mono




# 如果不小心标错了，怎么恢复会原来的数字编号？
#1) 最快的方式 Idents(object = scObj_colon) <-"RNA_snn_res.0.2"
#2) 需要使用 seurat_clusters 构建named vector 覆盖掉 active.ident 这个slot，然后重新来
scObj_known2@active.ident

> t1=scObj_known2@meta.data$seurat_clusters
> names(t1)=scObj_known2$cell #或 rownames(scObj_known2@meta.data)
> head(t1, n=3)
AAACCCAAGAGCTTTC-1_1 AAACCCAGTAGTGGCA-1_1 AAACCCATCTTCACGC-1_1
                   0                    2                    4
> scObj_known2@active.ident=t1







(3) 给meta.data 添加一列: monocle 的state列
p_data <- subset(pData(mycds),select='State')
scRNAsub2 <- subset(scRNAsub, cells=row.names(p_data))
scRNAsub2 <- AddMetaData(scRNAsub2, p_data, col.name = 'State')
#
head(scRNAsub2@meta.data)






2.
# 指定比较
# find all markers distinguishing cluster 5 from clusters 0,1 and 2
BC_HeLa.markers <- FindMarkers(pbmc12, ident.1 = c("BC_0","BC_1"), 
                               ident.2 = c("HeLa_normal",   "HeLa_sync"), min.pct = 0.25)
BC_HeLa.markers$gene=rownames(BC_HeLa.markers)
head(BC_HeLa.markers, n = 5)




# 两两比较
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc12, only.pos = F, min.pct = 0.25, logfc.threshold = 0.25, test.use = 'wilcox')
pbmc.markers %>% group_by(cluster) %>% filter(p_val_adj<0.05 & abs(avg_logFC)>log2(2) ) %>%  top_n(n = 3, wt = avg_logFC)







========================================
|-- DoHeatmap 自定义热图：指定颜色
----------------------------------------

1. 指定顶部颜色块：group.colors
DoHeatmap(pbmc12, features = rbind(gset1, gset2)$gene, 
          group.colors= c("#FF9ECE","#F81082", '#005FFF', '#98BEFD') )


指定热图颜色：蓝 白 红 
library(Seurat)
library(ggplot2)
pbmc<-readRDS(pbmc3k.rds)

DoHeatmap(pbmc)+scale_fill_gradientn(colors = c("blue", "white", "red"))




2. 调整文字字号大小
library(ggplot2)
DoHeatmap(pbmc.small, features = top10$gene, label = F) + theme(text = element_text(size = 12))



3. 多个图例 
https://github.com/satijalab/seurat/issues/2201





4. 图例放底部
https://github.com/satijalab/seurat/issues/3149





========================================
|-- 画DotPlot图：倾斜x轴基因名字
----------------------------------------
1. 更通用的画法 //todo

# options(repr.plot.width=8, repr.plot.height=7)
DotPlot(scRNA, features = rev( unique( c("CD3D","CD4","CD8A","CD8B","GZMB", "CCR7","ITGB1", "CCR10", "MKI67",
                                         "GAPDH", rownames(rs2)) ) ), 
            cols = c("lightgrey", "red"))+ #自定义颜色 白-> 红
    theme( axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1) ) #x坐标文字倾斜60度




2. 倾向于尺寸和绘图分离，尽量不要耦合到一个函数中。方便适配不同的数据。
####replot markergenes
# v2.0新增2个filter
# v2.1 新增可以设置 seurat 对象，方便从外部修改对象的ident后重新传入值
DotPlotPDF=function(genelist,prefix="",width=26,height=10, seurat_obj=br10){
  #filter1:保证基因唯一性
  genelist=unique(genelist)
  #filter2:保证基因在数据中存在
  gene.exist=rownames(seurat_obj@data)#有的基因名字
  #打印出不存在的基因
  gene.reserve=c()
  for(g in genelist){
    if(g %in% gene.exist){
      gene.reserve=c(gene.reserve, g)
    }else{
      print(g)
    }
  }
  #开始画图
  CairoPDF( paste0(prefix,"_DotPlot.pdf") , width = width, height = height)
  #控制x坐标循序，可以把x逆序，如rev(genelist)
  #怎么控制y坐标顺序？
  marker_dot_plot <- DotPlot(object = seurat_obj, genes.plot = gene.reserve, plot.legend = TRUE,
                             cols.use = c("black","red"), x.lab.rot = T,dot.scale = 10, do.return=T)
  marker_dot_plot <- marker_dot_plot + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1))
  print(marker_dot_plot)
  dev.off()
}


# 查看几个level，也就是几个分类
levels(br10@ident)
table(br10@ident)

getwd()
DotPlotPDF(rev(tmp$gene),"adjP0.05",width=28,height=4.5) #75个
DotPlotPDF(top5$gene,"top5",width=5,height=4.5) #5*4=20个

markers=readLines("marker_list/8.txt") #读取每行，生成数组
DotPlotPDF(markers,"top5",width=5,height=4.5)
#






========================================
|-- DimPlot()高亮显示某一类细胞
----------------------------------------
1. 使用 seurat 包的函数，指定 cells.highlight 参数

showCluster=function(obj, num, col="red"){
  DimPlot(obj, cells.highlight=WhichCells(obj, idents=num),
          cols.highlight = col)
}
showCluster(scObj, 5)


(1) WhichCells 函数获取cid
Idents(scRNA)="predicted.id"
sub1 <- WhichCells(scRNA, idents = c("CD8 Naive") ) #返回的是细胞cid
sub2 <- WhichCells(scRNA, idents = c( "CD4 TEM") )
p1=DimPlot(scRNA, label=T, group.by="predicted.id", cells.highlight= list(sub1, sub2), 
        cols.highlight = c("blue", 'red'), cols= "grey")


by_2="predicted.id"
# p1=DimPlot(scRNA, group.by=by_2, label=T)
p2=DimPlot(scRNA, group.by=by_2, label=T)

options(repr.plot.width=12, repr.plot.height=5)
p1+p2 +plot_layout(guides = 'collect')



(2) 从 meta.data 获取cid

DimPlot(neu_colon, label = F, group.by = "BL2", 
        cells.highlight = neu_colon@meta.data[which(neu_colon@meta.data$sample == "BL2Y"), "cell"], 
        cols.highlight = c("darkblue", "darkred"), cols = "grey")


(3) 分面: split.by=某指标作为因子，把图分成多个

DimPlot(object = neu_colon,reduction = "umap",label = F, split.by = "sample", ncol = 3)+NoLegend()




2. 自定义函数 
library(dplyr)

umap_tx = integrated@reductions$umap@cell.embeddings %>% 
	as.data.frame() %>% cbind(tx = so@meta.data$Treat)

ggplot(umap_tx, aes(x=UMAP_1, y=UMAP_2, color=tx)) + geom_point() + 
	scale_color_manual(values=c("group1_untreated" = "darkblue", "group1_treated" = "darkred"))



ref:
https://stackoverflow.com/questions/59101791/seurat-dimplot-highlight-specific-groups-of-cells-in-different-colours






========================================
|-- 画某细胞类之间的相关热图
----------------------------------------

1.
https://github.com/satijalab/seurat/issues/2486

Note that AverageExpression actually includes an add.ident argument that does exactly what Tim suggested above, so you could say

> avgexp = AverageExpression(immune.combined, return.seurat = T, add.ident = 'Genotype')

You can then treat this as a regular Seurat object to generate Heatmaps, plots, etc. on average data



(2) 实例:

avgexp = AverageExpression( subset(scRNA, idents = c( "Platelet", "ASDC" ), invert=T ), 
                           #add.ident = 'predicted.id'#名字后加一个后缀，比如区分样本: Microglia_KO, Microglia_WT, 
                           return.seurat = T ) 
dim(avgexp)
avgexp@assays$RNA@data[1:4,1:5]


cor_df2=cor( as.matrix(avgexp@assays$RNA@data) )

library(pheatmap)

# options(repr.plot.width=7, repr.plot.height=7) 
pheatmap(cor_df2, border_color = NA, 
         clustering_method="ward.D2",
         main="Cell type correlation")
#






========================================
|-- 常用图的增强: FeaturePlot, VlnPlot, DotPlot, DimPlot
----------------------------------------

1. FeaturePlot 函数
(1) FeaturePlot使用了split函数之后就没有legend了
FeaturePlot(object = obj, features = "Gene", split.by = "Meta_Name", order = T) & theme(legend.position = "right")

只是用+是不可以的，那样就只会只改split图中右边的那个图。使用&符号的时候是会两个都改的，是不是很神奇？
原来我以前只知道+，后来才发现还有&这个用法。



(2) 两个 FeaturePlot 左右放，右边的隐藏y轴。

m_featureplot <- FeaturePlot(M_Aggregated_seurat, features = "Lepr", reduction = "tsne",
                             split.by = "orig.ident", pt.size = 1.8, repel = F, label = F,
                             order = T, max.cutoff = 1)
m_featureplot <- m_featureplot & scale_x_continuous(breaks=seq(-30, 20, 10)) ## 改x轴刻度标签
m_featureplot <- m_featureplot & scale_y_continuous(breaks=seq(-30, 20, 10)) ## 改y轴刻度标签
m_featureplot <- m_featureplot +  theme(axis.text.y = element_blank()) +   ## 删去所有刻度标签
                                  theme(axis.ticks.y = element_blank()) +  ##则只删去 Y 轴的刻度线
                                  theme(axis.line.y = element_blank())
m_featureplot <- m_featureplot + ylab("")



(3) # Visualize co-expression of two features simultaneously
FeaturePlot(pbmc, features = c("MS4A1", "CD79A"), blend = TRUE)


(4) # Calculate feature-specific contrast levels based on quantiles of non-zero expression.
# Particularly useful when plotting multiple markers
FeaturePlot(pbmc3k.final, features = c("MS4A1", "PTPRCAP"), min.cutoff = "q10", max.cutoff = "q90")


(5) 分组 
# Split visualization to view expression by groups (replaces FeatureHeatmap)
FeaturePlot(pbmc3k.final, features = c("MS4A1", "CD79A"), split.by = "groups")



(6) order=T 把关心的基因显示到上层
FeaturePlot(scObj, features = c("PCF11"), cols =c("lightgrey", "red"), order = T)






2. VlnPlot 的堆叠小提琴图
VlnPlot 中有个stack = T
但是这里面有个bug
因为Seurat::VlnPlot有个bug就是当用split的时候 细胞数目小于3个的时候 就不会画出来
后面又自己想加其他数据所以弄得复杂了点
但是我发现个很好用的方法就是直接把p1$data <- final_data 直接替换成我们想画图的数据就可以直接修改图片了

https://www.jianshu.com/p/a2fe2549cea1

(2) # metadata and pass it to the split.by argument
VlnPlot(pbmc, features = "percent.mt", split.by = "groups")






3. DotPlot 图

(1) 
dotplot_f_data_1 <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),
                       group.by = "try",col.min=-2, col.max=2)$data
head(dotplot_f_data_1)
dim(dotplot_f_data_1)

dotplot_f_data_2 <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),
                            group.by = "try2",col.min=-2, col.max=2)$data
head(dotplot_f_data_2)
dim(dotplot_f_data_2)

dotplot_f_data <- rbind(dotplot_f_data_1, dotplot_f_data_2)
head(dotplot_f_data)
dim(dotplot_f_data)
table(dotplot_f_data$id)

p_dotplot_f <- DotPlot(F_Aggregated_seurat, features = rev(ImDEGs),col.min=-2, col.max=2)
p_dotplot_f$data <- dotplot_f_data
p_dotplot_f <- p_dotplot_f + coord_flip()
p_dotplot_f <- p_dotplot_f+ scale_color_gradient2(high="red",mid = "lightgrey",low ="darkblue", midpoint = 0) + theme_classic()+ 
  theme(axis.text.x = element_text(angle = -45,hjust = -0.1,vjust = 0.8)) 
p_dotplot_f$data$id <- factor(p_dotplot_f$data$id,
                              levels = c(levels_define[1:12], 
                                         "GABA_WT", "GABA_ob/ob",
                                         levels_define[13:18],
                                         "Glu_WT", "Glu_ob/ob"))
p_dotplot_f


(2) 分组
DotPlot(pbmc, features = features, split.by = "groups") + RotatedAxis()



(3) DotPlot 重绘，自定义分组的颜色

# 要提前设置号字符串的顺序：指定为因子顺序
scObj$tissue.type=factor(scObj$tissue.type, 
                         levels = c("NL", "LP",  'CA',    'LN'))


# named color
color.head=c('#617381', "#76AB9B", '#CE5A5B', "#EA7C5B");
names(color.head) =c("NL", "LP", "CA", "LN")
color.head

# draw with Seurat
g1=DotPlot(scObj, features = c("CD300LF"), group.by = "tissue.type", 
        cluster.idents = F)+labs(x="", y="") + NoLegend(); g1 #+ #+RotatedAxis() #+ coord_flip()
# >> get data from ggplot obj
head(g1$data)
#            avg.exp  pct.exp features.plot id avg.exp.scaled
#CD300LF  0.04571820 4.370236       CD300LF CA      1.0291080
#CD300LF1 0.03949094 4.144320       CD300LF LN      0.6632240

# re-plot with ggplot2
ggplot(g1$data, aes(x=features.plot, y=id, size=pct.exp, color=id))+
  geom_point(show.legend = F)+
  scale_color_manual(values=color.head)+
  theme_classic(base_size = 14)+
  labs(x="", y="")
#








4. DimPlot 

(1) 加上标题
baseplot <- DimPlot(pbmc, reduction = "umap")
# Add custom labels and titles
baseplot + labs(title = "Clustering of 2,700 PBMCs")

(2) 改变字体，去掉图例
# Chain themes together
baseplot + FontSize(x.title = 20, y.title = 20) + NoLegend()





5. 系统发育分析（Phylogenetic Analysis of Identity Classes）
pbmc<-BuildClusterTree(pbmc)
Tool(object = pbmc, slot = 'BuildClusterTree')





6. 平均表达谱函数AverageExpression
?AverageExpression

AverageExp<-AverageExpression(pbmc,features=unique(top10$gene))





7. # Ridge plots - from ggridges. Visualize single cell expression distributions in each cluster
RidgePlot(pbmc3k.final, features = features, ncol = 2)













100. 富集分析的底层代码： enrichplot 包

https://www.jianshu.com/p/03b94b2034d5






ref:
https://www.jianshu.com/p/a2fe2549cea1
https://www.jianshu.com/p/484762bb96c2
https://www.jianshu.com/p/03b94b2034d5
http://www.360doc.com/content/21/0715/15/76149697_986668012.shtml









========================================
重绘: 使用 R base, ggplot2
----------------------------------------


========================================
|-- 获取 Seurat 中默认颜色配方/ 配色提取
----------------------------------------
1. DimPlot中默认的配色方案
library(scales)
show_col(hue_pal()(16))



2. 提取DimPlot中画聚类时用到的颜色

library(scales)
p1 <- DimPlot(pbmc.nmf, group.by = "celltype_assign")
x<-ggplot_build(p1)
info = data.frame(colour = x$data[[1]]$colour, group = x$data[[1]]$group)
info <- unique((arrange(info, group)))
cols <- as.character(info$colour)

> cols
 [1] "#F8766D" "#EC823C" "#DD8D00" "#CA9700" "#B3A000" "#97A900" "#71B000" "#2FB600" "#00BB4B" "#00BF76" "#00C098" "#00C0B7"
[13] "#00BDD1" "#00B7E8" "#00AEFA" "#3DA1FF" "#8F91FF" "#BE80FF" "#DE71F9" "#F265E7" "#FE61CF" "#FF64B3" "#FF6C92"





ref:
https://www.jianshu.com/p/229af1b135b5


========================================
|-- 重绘 Seurat热图，标记细胞来源、Seurat分类
----------------------------------------

1. 原始代码： 

# 全部 find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc2, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)


top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
#DoHeatmap(pbmc2, features = top10$gene) + NoLegend()
DoHeatmap(pbmc2, features = top10$gene)





2. 自定义代码
########### 画heatmap，标记来源
library(pheatmap)
#来源标签
syncID=gsub("_","",readLines("/home/wangjl/data/apa/190530Mix/cluster2_syncHeLa.27L.cellID") ); head(syncID)
normalID=gsub("_","",readLines("/home/wangjl/data/apa/190530Mix/cluster2_HeLa_nonsyncHeLa.29R.cellID") ); head(normalID)
allID=colnames( pbmc2@assays$RNA ); head(allID) #没啥用
#

#添加UMAP分类标签
pbmc2@assays$RNA@scale.data
table(pbmc2@active.ident)
pbmc2@active.ident[pbmc2@active.ident==1]
c0=names(pbmc2@active.ident[pbmc2@active.ident==0])
c1=names(pbmc2@active.ident[pbmc2@active.ident==1])
c2=names(pbmc2@active.ident[pbmc2@active.ident==2])

#
pbmc2@assays$RNA[top10$gene,c("c01ROW24","c01ROW35")] #同步化 head
pbmc2@assays$RNA[top10$gene,c("c9ROW14","c9ROW15")] #同步化 tail
pbmc2@assays$RNA[top10$gene,c("c12ROW10","c12ROW16")] #normal head
#
pbmc2@assays$RNA[top10$gene[20:30], gsub("_","",syncID)]
pbmc2@assays$RNA[top10$gene[20:30], gsub("_","",normalID)]
#

# 构建列注释信息
annotation_col = data.frame(
  row.names = c(c0, c1, c2),
  cellType = rep("BC", length(allID)),
  UMAP_Cluster=rep(c(0,1,2),c(length(c0), length(c1), length(c2)))
)
annotation_col$cellType=as.character(annotation_col$cellType)
annotation_col$cellType[ rownames(annotation_col) %in% syncID]="syncHeLa"
annotation_col$cellType[ rownames(annotation_col) %in% normalID]='normalHeLa'
annotation_col
head(annotation_col)

# 自定义注释颜色
# 自定注释信息的颜色列表
ann_colors = list(
  #cellType = c("white", "firebrick"),
  cellType = c(BC="yellow", syncHeLa="#F8746B", normalHeLa="#00BDC2"),
  UMAP_Cluster = c('0' = "#F8766D", '1' = "#00BA38", '2' = "#619CFF" )
)
head(ann_colors)

# annotation_col参数添加列注释信息
#rna=pbmc2@assays$RNA
#matrix2=rna[top10$gene,allID]  #[1]  30 225
#class(matrix2)
matrix2=pbmc2@assays$RNA@scale.data[top10$gene,c(c0,c1,c2)] #[1] 478762    225
dim(matrix2) #[1]  30 225
pheatmap(matrix2, annotation_col = annotation_col, annotation_colors = ann_colors,
         cluster_cols=F,cluster_rows=F, #不聚类
         border=FALSE, # 去边框
         gaps_col = c(length(c0), length(c0)+length(c1),  length(c0)+length(c1)+length(c2)), #分组显示
         show_colnames = F) #不显示底下的名字
###########



========================================
|-- 重绘 PCA,tSNE, UMAP
----------------------------------------

1. 获取坐标
(1) 使用内置函数 Embeddings 获取坐标
> Embeddings(scRNA, "umap")
	UMAP_1	UMAP_2
AAACCCAGTATCGTAC	7.708623	-4.3380356
AAACCCAGTCGGTGAA	-5.678032	-0.3648236
AAACCCAGTTAGAAAC	7.154264	-1.0021027


> Embeddings(scRNA, "tsne")
	tSNE_1	tSNE_2
AAACCCAGTATCGTAC	-14.4581690	-7.5685762
AAACCCAGTCGGTGAA	5.1615386	27.4283348
AAACCCAGTTAGAAAC	-1.8349680	-27.0306493
AAACCCAGTTATCTTC	1.8384106	45.6578343


(2) 从对象中获取坐标
######## replot: PCA,tSNE,UMAP
getDimensionData=function(seuratObj){
  df=data.frame(
    cid=names(seuratObj@active.ident),
    PC_1=seuratObj@reductions$pca@cell.embeddings[,1],
    PC_2=seuratObj@reductions$pca@cell.embeddings[,2],
    PC_3=seuratObj@reductions$pca@cell.embeddings[,3],
    #umap
    UMAP_1=seuratObj@reductions$umap@cell.embeddings[,1],
    UMAP_2=seuratObj@reductions$umap@cell.embeddings[,2],
    #
    tSNE_1=seuratObj@reductions$tsne@cell.embeddings[,1],
    tSNE_2=seuratObj@reductions$tsne@cell.embeddings[,2],
    ident=unname(seuratObj@active.ident),
    row.names = 1
  )
  return( df)
}
pcaData=getDimensionData(pbmc2)
dim(pcaData) #328 5
head(pcaData)
ggplot(pcaData, aes(PC_1, PC_2, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(PC_1, PC_3, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(PC_2, PC_3, color=ident))+geom_point()+theme_classic()
#
ggplot(pcaData, aes(tSNE_1, tSNE_2, color=ident))+geom_point()+theme_classic()
ggplot(pcaData, aes(UMAP_1, UMAP_2, color=ident))+geom_point()+theme_classic()
#
library(rgl) #可以鼠标旋转的3D图
plot3d(pcaData$PC_1, pcaData$PC_2, pcaData$PC_3)
#############


(3) 把UMAP的坐标放到metadata中：
pbmc <- AddMetaData(pbmc, 
		pbmc@reductions$umap@cell.embeddings,
		col.name = colnames(pbmc@reductions$umap@cell.embeddings))

head(pbmc@meta.data)









2. 精细复原，并个性化定制

# Seurat包的UMAP图
DimPlot(scObj_known2, group.by = c("ident", 'sample'),reduction = "umap")
DimPlot(scObj_known2, group.by = c("ident"), reduction = "umap")
DimPlot(scObj_known2)


(1) 自己画
# step1: 获取数据
umap_data = scObj_known2@reductions$umap@cell.embeddings %>%  #坐标信息
  as.data.frame() %>% 
  cbind(cell_type = scObj_known2@meta.data$ident) # 注释后的 ident 信息 ，改为cell_type
head(umap_data)
#                        UMAP_1    UMAP_2   cell_type
#AAACCCAAGAGCTTTC-1_1  4.289865  2.376387    Platelet


# step2: 初步画图
allcolour=c("#DC143C","#0000FF","#20B2AA","#FFA500","#9370DB","#98FB98","#F08080","#1E90FF","#7CFC00","#FFFF00",
            "#808000","#FF00FF","#FA8072","#7B68EE","#9400D3","#800080","#A0522D","#D2B48C","#D2691E","#87CEEB","#40E0D0","#5F9EA0",
            "#FF1493","#0000CD","#008B8B","#FFE4B5","#8A2BE2","#228B22","#E9967A","#4682B4","#32CD32","#F0E68C","#FFFFE0","#EE82EE",
            "#FF6347","#6A5ACD","#9932CC","#8B008B","#8B4513","#DEB887")

p <- ggplot(umap, aes(x= UMAP_1 , y = UMAP_2 ,color = cell_type))+
  geom_point(size = 1 , alpha =1 )+
  scale_color_manual(values = allcolour)
p

找差异:
- 主题部分（去掉背景，去掉网格线） ；
- legend部分（调整legend，去掉背景灰色、title，调整字体） 
- 注释部分（坐标轴标到左下角，图中标示标签）三部分。


(2) 修饰提升: 去背景、去坐标轴
https://mp.weixin.qq.com/s?__biz=MzIyNDI1MzgzOQ==&mid=2650394998&idx=1&sn=3a37ee30062e880b70564633b51a87c8

p2 = p+theme_classic(base_size = 14)+
  theme(
    panel.border = element_blank(), #边框
    axis.title = element_blank(),  #轴标题
    axis.text = element_blank(),  #轴刻度文本
    axis.ticks = element_blank(), #轴刻度
    axis.line = element_blank() #去掉轴
  )
p2


# 参考:
p2_ <- p  +
  theme(panel.grid.major = element_blank(), #主网格线
        panel.grid.minor = element_blank(), #次网格线
        panel.border = element_blank(), #边框
        axis.title = element_blank(),  #轴标题
        axis.text = element_blank(), # 文本
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = 'white'), #背景色
        plot.background=element_rect(fill="white"))
p2_


(3) 修饰提升: 图例点变大
https://mp.weixin.qq.com/s?__biz=MzIyNDI1MzgzOQ==&mid=2650394998&idx=2&sn=a860fb6001d39dbe543a8a970b4a0675

p3=p2+
  theme(
    #legend.title = element_blank(), #去掉legend.title 
    #legend.key=element_rect(fill='white'), #
    #legend.text = element_text(size=20), #设置legend标签的大小
    #legend.key.size=unit(1,'cm')  # 设置legend标签之间的大小
  )+
  guides(color = guide_legend(override.aes = list(size=5))) #设置legend中 点的大小
p3


(4) 调整umap图 - annotation
坐标轴放到左下角可以通过ggplot2添加带箭头的线段和文本实现。
这一步可能需要根据数据调整位置，来获得最佳效果。

p4 <- p3 + 
  geom_segment(data=data.frame(), aes(x = min(umap_data$UMAP_1), y = min(umap_data$UMAP_2),
                   xend = min(umap_data$UMAP_1) +5, yend = min(umap_data$UMAP_2) ),
               colour = "black", #size=0.9,
               arrow = arrow(length = unit(0.3,"cm")))+ 
  geom_segment(data=data.frame(), aes(x = min(umap_data$UMAP_1), y = min(umap_data$UMAP_2),
                   xend = min(umap_data$UMAP_1), yend = min(umap_data$UMAP_2) + 5),
               colour = "black", #size=0.9,
               arrow = arrow(length = unit(0.3,"cm"))) +
  annotate("text", x = min(umap_data$UMAP_1) +2.5, y = min(umap_data$UMAP_2) -1.5, label = "UMAP_1",
           color="black", size = 3, fontface="bold") + 
  annotate("text", x = min(umap_data$UMAP_1) -1.5, y = min(umap_data$UMAP_2) + 2.5, label = "UMAP_2",
           color="black", size = 3, fontface="bold", angle=90)
p4
差不多是最终效果了，就差把细胞类型标注到点上了。



(5)  那如果想把注释加到点之上怎么办呢？
- 直接使用label 添加，需要先给每个cluster一个单独的坐标，本示例中使用此方法。
- text 根据cluster的位置，手动添加，需要尝试，倒是效果会好一些。


# 1) 计算每个cluster的median 坐标位置
cell_type_med <- umap %>%
  group_by(cell_type) %>%
  summarise(
    UMAP_1 = median(UMAP_1),
    UMAP_2 = median(UMAP_2)
  )

# 2) geom_label_repel 添加注释
library(ggrepel)
p4 + #白底标签标注
  geom_label_repel(data = cell_type_med, aes(label=cell_type), 
                   fontface="bold", alpha=0.8,#半透光
                   point.padding=unit(0.5, "lines"))

# 或者黑字标注
p4 +
  geom_text_repel(data = cell_type_med, aes(label=cell_type), 
                  #fontface="bold", 
                  color="black",
                  point.padding=unit(0.5, "lines"))

# 3) 去掉 legend 
p4 + #白底标签标注
  geom_label_repel(data = cell_type_med, aes(label=cell_type), 
                   fontface="bold", alpha=0.8,#半透光
                   point.padding=unit(0.5, "lines"))+
  theme(legend.position = "none")










3. 画法2

#' Draw UMAP, my method 2
#'
#' @param scObj 
#' @param group.by 
#'
#' @return
#' @export
#'
#' @examples
#' DimPlot_2(scObj_known2, "ident")
DimPlot_2 = function(scObj, group.by="seurat_clusters"){
  # (1)为了调用ggplot2我们把UMAP的坐标放到metadata中：
  pbmc<-AddMetaData(scObj,scObj@reductions$umap@cell.embeddings,col.name = colnames(scObj@reductions$umap@cell.embeddings))
  #head(pbmc@meta.data)
  
  # (2)读入一套我珍藏多年的颜色列表：
  allcolour=c("#DC143C","#0000FF","#20B2AA","#FFA500","#9370DB","#98FB98","#F08080","#1E90FF","#7CFC00","#FFFF00",
              "#808000","#FF00FF","#FA8072","#7B68EE","#9400D3","#800080","#A0522D","#D2B48C","#D2691E","#87CEEB","#40E0D0","#5F9EA0",
              "#FF1493","#0000CD","#008B8B","#FFE4B5","#8A2BE2","#228B22","#E9967A","#4682B4","#32CD32","#F0E68C","#FFFFE0","#EE82EE",
              "#FF6347","#6A5ACD","#9932CC","#8B008B","#8B4513","#DEB887")
  
  # (3) 开始画图
  df1= as.data.frame(pbmc@meta.data) #[, c("UMAP_1", "UMAP_2", group.by)]
  df1$cluster=as.data.frame(pbmc@meta.data)[, group.by]
  # colnames(df1)=c("UMAP_1", "UMAP_2","cluster")
  
  class_avg <-  df1%>%
    group_by(cluster) %>%
    summarise(
      UMAP_1 = median(UMAP_1),
      UMAP_2 = median(UMAP_2)
    )
  #print(head(class_avg))
  umap <-  ggplot(df1, aes(x=UMAP_1,y=UMAP_2))+
    geom_point(aes(color=cluster))+
    scale_color_manual(values = allcolour)+
    geom_text(aes(label = cluster), data = class_avg)+
    theme(text=element_text(family="Arial",size=18)) +
    theme(panel.background = element_rect(fill='white', colour='black'), 
          panel.grid=element_blank(), axis.title = element_text(color='black',
                                                                family="Arial",size=18),axis.ticks.length = unit(0.4,"lines"), 
          axis.ticks = element_line(color='black'), 
          #axis.ticks.margin = unit(0.6,"lines"), 
          #`axis.ticks.margin` is deprecated. Please set `margin` property of `axis.text` instead 
          
          axis.line = element_line(colour = "black"), 
          axis.title.x=element_text(colour='black', size=18),
          axis.title.y=element_text(colour='black', size=18),
          axis.text=element_text(colour='black',size=18),
          legend.title=element_blank(),
          legend.text=element_text(family="Arial", size=18),
          legend.key=element_blank())+
    #theme(plot.title = element_text(size=22,colour = "black",face = "bold"))  + 
    guides(colour = guide_legend(override.aes = list(size=5)))
  return(umap)
}







========================================
|-- 把细胞的 PC 画到 UMAP 图上：配合样本分类确定批次效应
----------------------------------------

作用：可能能看到哪个PC对哪个分类有贡献？
并去掉该 PC: 
	hpfall.remv1=RegressOut(hpfall,c("PC2","PC5","PC7"),do.scale = T)
	对于 Seurat 4，使用 ScaleData(, vars.to.regress=) 去掉这些变异





1. 获取数据
使用 PBMC 3k 数据。

# Defining the information in the seurat object of interest
columns <- c(paste0("PC_", 1:16),
             "seurat_clusters", "UMAP_1", "UMAP_2")

# Extracting this data from the seurat object
pc_data <- FetchData(pbmc, vars = columns)




2. 画图 

# 查看有几个类
ElbowPlot(pbmc3k)


(1) 单个画
# 每个类的核心坐标
umap_label_pos=FetchData(pbmc, vars = c("seurat_clusters", "UMAP_1", "UMAP_2")) %>% 
	group_by(seurat_clusters) %>%
	summarise(x=mean(UMAP_1), y=mean(UMAP_2))

# 画图
pc="PC_1"
ggplot(pc_data, aes(UMAP_1, UMAP_2)) +
  geom_point(aes_string(color=pc), alpha = 0.7, size=0.5) +
  scale_color_gradient2(#guide = TRUE,
    low = "blue",
    mid="white",
    high = "red")  +
  geom_text(data=umap_label_pos,
            aes(label=seurat_clusters, x, y)) +
  ggtitle(pc)+ theme_bw()



(2) 批量化
# Plotting a UMAP plot for each of the PCs
purrr::map(paste0("PC_", 1:16), function(pc){
  ggplot(pc_data, aes(UMAP_1, UMAP_2)) +
    geom_point(aes_string(color=pc), alpha = 0.7) +
    #scale_color_gradient(guide = FALSE, low = "grey90", high = "red")  +
    scale_color_gradient2(low = "blue", mid="white", high = "red")  +
    geom_text(data=umap_label_pos, aes(label=seurat_clusters, x, y)) +
    ggtitle(pc)+ theme_bw()
}) %>% 
  cowplot::plot_grid(plotlist = .)





3. 包装成函数


#' Plot cell PC score as color on UMAP plot
#'
#' @param sce Seurat object
#' @param nPCs an integer, total number of PC to plot;
#'
#' @return a ggplot2 merge obj, by cowplot::plot_grid
#' @export
#'
#' @examples
#' plot_PC_on_UMAP(pbmc)
plot_PC_on_UMAP=function(sce, nPCs=16){
  # Defining the information in the seurat object of interest
  columns <- c( paste0("PC_", 1:nPCs),  "seurat_clusters", "UMAP_1", "UMAP_2")
  
  # Extracting this data from the seurat object
  pc_data <- FetchData(sce, vars = columns)
  
  # Center of cluster on UMAP
  umap_label_pos=FetchData(sce, vars = c("seurat_clusters", "UMAP_1", "UMAP_2")) %>% 
    group_by(seurat_clusters) %>%
    summarise(x=mean(UMAP_1), y=mean(UMAP_2))
  
  # Plotting a UMAP plot for each of the PCs
  purrr::map(paste0("PC_", 1:nPCs), function(pc){
    ggplot(pc_data, aes(UMAP_1, UMAP_2)) +
      geom_point(aes_string(color=pc), alpha = 0.7) +
      #scale_color_gradient(guide = FALSE, low = "grey90", high = "red")  +
      scale_color_gradient2(low = "blue", mid="white", high = "red")  +
      geom_text(data=umap_label_pos, aes(label=seurat_clusters, x, y)) +
      ggtitle(pc)+ theme_bw()
  }) %>% 
    cowplot::plot_grid(plotlist = .)
}



如果有样本分组信息，自然是可以把这里的细胞类型换成分组信息了，开看哪些样本在哪个PC中高亮，进而推断其是不是特殊的batch，对应的PC以及基因是否需要去掉（或回归掉）。

最后我们再次强调单细胞数据分析的非线性过程，许多时候，如果看不到就不能判断是否需要做某个处理，所以需要一个反馈的过程。在单细胞数据科学中PCA分析是属于特征选择的过程，即，哪些特征拿来分析，这当然是值得谨慎处理的。单细胞数据分析的默认参数（default parameters）时代已经一去不复返了。





refer: https://www.jianshu.com/p/bcb0b520e056








========================================
|-- 3D扩展: 画PCA的3D散点图: 从R中生成png，在linux中合并为gif，如何添加表示分类的颜色？
----------------------------------------
3D图能很直观的理解类群，在PPT中效果比2D图好太多。
不过生成过程比较麻烦，建议：尽量在本地R中好好优化后再启动生成gif流程。


0.如果数据太大，下载不方便，则可以考虑只提取画图必要的部分。
#获取pca数据
df=data.frame(
  pc_1=pbmc9@dr$pca@cell.embeddings[,1],
  pc_2=pbmc9@dr$pca@cell.embeddings[,2],
  pc_3=pbmc9@dr$pca@cell.embeddings[,3],
  ident=pbmc9@ident
)
saveRDS(df, file = "10x_B116_TSENPlot_9_PC1-6_r0.6_DF.rds")





1. PCA 3d plot图，一般是黑白的
#########
# R中, win10
#########
setwd("D:\\Temp\\10xB116\\tmp_plot")
pbmc5=readRDS("10x_B116_TSENPlot_9_again.rds")

#获取pca数据
pc_1=pbmc5@dr$pca@cell.embeddings[,1]
pc_2=pbmc5@dr$pca@cell.embeddings[,2]
pc_3=pbmc5@dr$pca@cell.embeddings[,3]

library(rgl) #可以鼠标旋转的3D图
plot3d(pc_1, pc_2, pc_3)

#install.packages("magick")
library(magick) #生成gif图所需的原材料 若干png
movie3d(spin3d(axis=c(0,0,1),rpm=3), type = "gif",duration=3,fps=10,convert=F)
#位置在临时文件夹中 C:\Users\admin\AppData\Local\Temp\RtmpOqAa3k ，zip打包上传到linux中。
#注意：利用movie3d函数保存动画，其实是生成一些列的.png格式的图面文件，每个文件代表一帧，然后利用ImageMagick软件提供的convert命令将这些文件合并成为gif格式的动画文件。所以要想让动画动起来是一定要安装ImageMagick软件的。输出的动画会被放在一个临时文件夹中，地址名会在R窗口中输出。如果不想利用ImageMagick软件，可以设置convert=F，然后其他软件会将这一系列的.png文件转换为动画。



#########
# linux中,Ubuntu 18.04.1 LTS
#########
$ unzip RtmpOqAa3k.zip -d gif/
$ cd gif

convert -delay 0 *.png ~/web/a1.gif
convert ~/web/a1.gif -coalesce -reverse -quiet -layers OptimizePlus -loop 0 ~/web/a2.gif
convert ~/web/a1.gif ~/web/a2.gif ~/web/a3.gif






2.如果多个样本怎么用颜色或形状区分呢？
如何加上彩色？加上tSNE的分类颜色：1获取tSNE图的颜色；2.为PCA 3D图加上这些颜色。


#如何获取TSNEPlot中表示分类的颜色 https://github.com/satijalab/seurat/issues/257
identities <- levels(pbmc5@ident) # Create vector with levels of object@ident
require(scales)
my_color_palette <- hue_pal()(length(identities)) # Create vector of default ggplot2 colors
# Plot the tSNE plot with the default ggplot2 colors
#TSNEPlot(object = pbmc5, do.return = T) + 
#  scale_color_manual(values = my_color_palette)
#The colour codes can be found in my_color_palette.

#my_color_palette是一个长度为10的数组，怎么转换为一个factor的值？
ident=pbmc5@ident
t1=factor(ident,labels = my_color_palette)


#可以画3D图了
library(rgl) #可以鼠标旋转的3D图
plot3d(pc_1, pc_2, pc_3, col= t1,size=4)

接着使用movie3d函数生成一堆png，然后用linux下的convert生成gif文件。





========================================
|-- 用tsne画不同批次的细胞的点图
----------------------------------------

#
mef=br10

#分离分类变量
cn=colnames(mef@data)
end=regexpr('\\.',cn)
#end=unlist(end[1:60])
end;table(end)
#pop= sapply(cn,substr,rep(1,60),end,USE.NAMES=F)
pop=c()
for(i in c(1:60)){
  pop=c(pop,substr(cn[i], 1, end[i]-1))
}
pop
table(pop)


#TSNE plot for batches
#pop<-rep(1,28)#bc
#pop<-c(pop,rep(2,32))#mef
#pop
length(pop);table(pop)
#pop<-rep(1,73)
#pop<-c(pop,rep(2,26))
#pop<-c(pop,rep(3,76))

coordx<-mef@dr$tsne@cell.embeddings[,1]  # 新版本又更新了v3.0.1 mef@reductions$umap@cell.embeddings[,1]
coordy<-mef@dr$tsne@cell.embeddings[,2]
df1<-data.frame(coordx=coordx,coordy=coordy,pop=pop)
df1$pop<-as.factor(df1$pop)
#pdf(paste(path_out,"5.pdf",sep=""))
par(mai=c(1,1,0.2,0.5));
pl<-ggplot(data=df1,aes(x=coordx,y=coordy,colour=factor(pop)))+
  geom_point(size=2,alpha=1)+
  #   guides(fill=guide_legend(title="test1"))+
  labs(x="tSNE 1",y="tSNE 2")+theme_bw()+
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    #    panel.border = element_blank(),
    panel.background = element_blank())
#pl+scale_colour_discrete(name="sample",labels=c("bc","mef"))

pl+scale_color_discrete(name="Sample")
#dev.off()
############################






========================================
|-- 不同类的细胞数bar图: R原生myBarPlot() 及 ggplot
----------------------------------------
1. R base barplot

# bar plot for each column in meta.data
myBarPlot=function(scRNA, group.by="seurat_clusters",textPosY=-150, angle=60, isShow=F){
    # 1. data
    df1=table(scRNA@meta.data[[group.by]])
    df1=df1[order( -unname(df1) )] #order
    if(isShow){print(df1)}

    # 2. plot
    xPos = barplot( df1, xaxt="n",#xaxt="n"不要x坐标轴
                   col="#F07B05",
                   las=2, #坐标轴垂直与轴
                   ylab="Cell number",
                   border = NA) #bar不要边框
    # text on x axis
    # print(par("usr"))
    text(x=xPos, y= textPosY, labels=names(df1),
         cex=0.8, #字体是默认的倍数
         col="black",
         xpd=TRUE, #允许绘制在绘图区外
         adj=1, #adj=1右上对齐
         srt=angle) #倾斜
    # text on top of bar
    text(x=xPos, y=unname(df1)+50, labels=unname(df1),
         cex=0.5, #字体是默认的倍数
         col="black",
         xpd=TRUE, #允许绘制在绘图区外
         adj=0, #adj=1右上对齐
         srt=90) #倾斜
}


# options(repr.plot.width=8, repr.plot.height=4)
myBarPlot(scRNA, "predicted.id", textPosY=-50)


# options(repr.plot.width=8, repr.plot.height=4)
myBarPlot(scRNA, "seurat_clusters", textPosY=-50)








2. table2barplot from table
src: @X:20220

#' draw barplot, from a data.frame generated by table(para1, para2), colored by 1st parameter of table()
#' v2.1
#' v2.2 第一参数的空值跳过
#'
#' @param tbl1 data.frame, draw by each column
#' @param colors colors of each row(default NULL, auto-color)
#' @param scale whether scale to 1 or not(default T)
#' @param title the main title of the figure,(is main in the function)
#' @param legendY the position y of legend, adjust as needed, default -0.25
#' @param omit whether to omit some columns
#' @param ... 
#'
#' @return NULL
#' @export
#'
#' @examples
#' 
table2barplot = function(tbl1, colors=NULL,levels=NULL, scale=T, title="", 
                       omit=NULL, xlab="", ylab="", legendTitle=NULL){
  tbl1= tbl1[, which(colSums(tbl1)>0)] #remove all 0 columns
  tbl1= tbl1[which(rowSums(tbl1)>0), ] #remove all 0 rows
  # remove some columns by column names
  if(!is.null(omit)){
    tbl1=tbl1[, setdiff( colnames(tbl1), as.character( omit ) ) ]
  }
  # table to data.frame(wide to long)
  df2=as.data.frame(tbl1)
  if(!is.null(levels)){
    df2$Var1=factor(df2$Var1, levels =levels )#change order
  }
  if(""==ylab){ ylab=ifelse(scale, "Freq", "Count") }
  if(""==xlab){ xlab="Index" }
  
  # draw
  g1=ggplot(df2, aes(x=Var2, y=Freq, fill=Var1))+
    geom_bar(stat="identity", position=ifelse(scale, "fill","stack") )+
    labs(x=xlab, y=ylab, title=title)+
    theme_classic(base_size = 14)+
    theme(axis.text.x=element_text(angle=60, hjust=1,size=rel(1.2)) )
  if(is.null(colors)){
    return (g1 + scale_fill_discrete( ifelse(is.null(legendTitle), "", legendTitle) ) )
  }else{
    return( g1+scale_fill_manual(legendTitle, values = colors) )
  }
}

if(0){
  table2barplot(
    as.table(t(
      apply(
        table(scObj$time, scObj$seurat_clusters), 
        1, 
        function(x){ x/sum(x) * 1e4})
    )),
    colors = c("0h"="#FFA500", "18h"="#FF1493", "48h"="#4876FF"),
    title="time"
  )
}






========================================
衔接
----------------------------------------




========================================
|-- seurat与其他工具的衔接: LOOM /scanpy /bioconductor //todo
----------------------------------------
https://satijalab.org/seurat/v3.2/conversion_vignette.html


Seurat Wrappers
https://github.com/satijalab/seurat-wrappers/wiki/Submission-Process




========================================
Monocle 画涂抹heatmap的函数: plot_pseudotime_heatmap
----------------------------------------
url: https://github.com/cole-trapnell-lab/monocle-release
url: https://github.com/cole-trapnell-lab/monocle3


1. 下载、解压、进入文件夹
3.0版本没有这个函数。

$ find . | xargs grep "plot_pseudotime_heatmap" --color=auto 2>/dev/null


if(is.null(hmcols)) {
    bks <- seq(-3.1,3.1, by = 0.1)
    hmcols <- blue2green2red(length(bks) - 1)
  }
  else {
    bks <- seq(-3.1,3.1, length.out = length(hmcols))
  }
#



(2) 算了，还是安装吧，安装好，ctrl+单击函数名，
# fn1
table.ramp = function (n, mid = 0.5, sill = 0.5, base = 1, height = 1) {
  x <- seq(0, 1, length.out = n)
  y <- rep(0, length(x))
  sill.min <- max(c(1, round((n - 1) * (mid - sill/2)) + 1))
  sill.max <- min(c(n, round((n - 1) * (mid + sill/2)) + 1))
  y[sill.min:sill.max] <- 1
  base.min <- round((n - 1) * (mid - base/2)) + 1
  base.max <- round((n - 1) * (mid + base/2)) + 1
  xi <- base.min:sill.min
  yi <- seq(0, 1, length.out = length(xi))
  i <- which(xi > 0 & xi <= n)
  y[xi[i]] <- yi[i]
  xi <- sill.max:base.max
  yi <- seq(1, 0, length.out = length(xi))
  i <- which(xi > 0 & xi <= n)
  y[xi[i]] <- yi[i]
  height * y
}

# fn2
rgb.tables=function (n, red = c(0.75, 0.25, 1), green = c(0.5, 0.25, 1),  blue = c(0.25, 0.25, 1)) {
  rr <- do.call("table.ramp", as.list(c(n, red)))
  gr <- do.call("table.ramp", as.list(c(n, green)))
  br <- do.call("table.ramp", as.list(c(n, blue)))
  rgb(rr, gr, br)
}

# fn3
blue2green2red=function (n) {
	rgb.tables(n, red = c(0.8, 0.2, 1), green = c(0.5, 0.4, 0.8), blue = c(0.2, 0.2, 1))
}

bks <- seq(-3.1,3.1, by = 0.1)
hmcols <- blue2green2red(length(bks) - 1)

# view the effect
barplot(rep(1, length(hmcols)), col=hmcols, border = NA, space=0, axes=F)








2. 更多代码细节见: https://tool.biomooc.com/R_scripts/#t9








========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

