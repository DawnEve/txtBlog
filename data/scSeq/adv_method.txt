单细胞进阶分析主要是
	- 拟时序分析：
	- 细胞通讯分析：
	- SCENIC转录因子分析：
	- RNA Velocity 分析：
	- 数据整合

https://github.com/DawnEve/scRNAseqCode

视频讲解 单细胞RNA测序分析图解读： https://www.bilibili.com/video/BV1ev41177i4?




========================================
进阶分析方法概述
----------------------------------------

单细胞分析十八般武艺
https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyMzMwNDQ2MA==&action=getalbum&album_id=1593332494622359552







========================================
NMF 非负矩阵降维 && RunUMAP 使用NMF代替PCA聚类，使用 Leiden 算法
----------------------------------------
这里只是代码，解释见 R/R05-MachineLearning.txt 机器学习

- 5000个细胞的测试时间可能超过10个小时。
- 30k cells: 5days!!

#2. cluster with NMF----
scObj = NormalizeData(scObj) %>% FindVariableFeatures() %>% ScaleData()
	
	* 是否可以使用 ScaleData(center=F)
	* 或者使用 normalize的数据，这样没有负数

vm <- scObj@assays$RNA@scale.data
vm[vm < 0] <- 0
dim(vm)

vm <- vm[apply(vm, 1, var) > 0, ]
dim(vm)


library(NMF)
if(0){
  res <- nmf(vm, rank=15, 
             nrun=1,
             method = "snmf/r", seed = 'nndsvd')
  saveRDS(res, file=paste0(outputRoot, "/data/BMMC_04_NMF_res_noPost.list.Rds"), compress = F)
  Sys.time()
}else{
  res = readRDS( file=paste0(outputRoot, "/data/BMMC_04_NMF_res_noPost.list.Rds") )
}
res


## add to Seurat obj ----
scObj <- RunPCA(scObj)
scObj@reductions$nmf <- scObj@reductions$pca
scObj@reductions$nmf@cell.embeddings <- t(coef(res))
scObj@reductions$nmf@feature.loadings <- basis(res)  
#
#
colnames(scObj@reductions$nmf@cell.embeddings) = paste0("NMF_", 1:ncol(scObj@reductions$nmf@cell.embeddings))
scObj@reductions$nmf@key="NMF_"


## UMAP based on NMF ----
set.seed(2023)
scObj.nmf <- RunUMAP(scObj, reduction = 'nmf', dims = 1:15) %>% 
  FindNeighbors(reduction = 'nmf', dims = 1:15)
#


## Leiden algorithm ----
# system("pip3 install leidenalg -i https://pypi.douban.com/simple/")

# set Python version
library("reticulate")
use_python("/home/wangjl/software/anaconda3/bin/python3", required = T)
py_config()
system("pip3 -V")
system("which pip3")
system("pip3 list | grep leidenalg")

# Leiden
scObj.nmf = FindClusters(scObj.nmf, resolution = 0.5, algorithm=4) #1 分出来， 0.45差不多
DimPlot(scObj.nmf, label = T, raster = T, pt.size = 1.5)+ggtitle("NMF res=0.5 Leiden")
ggsave( paste0(outputRoot, "04_NMF_UMAP.pdf"), width=4.8, height=4, useDingbats = F)

showCluster(scObj.nmf, 19)

DotPlot(scObj.nmf, features = unique( c( "PLK1",
  grep("^SOCS", rownames(scObj.nmf), value=T),
  grep("^CCN", rownames(scObj.nmf), value=T)
) ) )+RotatedAxis()








========================================
|-- 实例：对 pbmc3k 数据用 NMF 做分群
----------------------------------------

(1) 基于PCA分解的降维聚类
library(Seurat)
library(tidyverse)
library(NMF)
rm(list = ls())
 
## 创建seurat对象
pbmc <- Read10X_h5("pbmc.h5")
pbmc <- CreateSeuratObject(pbmc, project = "pbmc", min.cells = 3, min.features = 500)
pbmc$percent.mt <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, percent.mt<20)
pbmc <- NormalizeData(pbmc) %>% FindVariableFeatures() %>% ScaleData(do.center = F)
 
## 使用pca的分解结果降维聚类
pbmc <- RunPCA(pbmc)
set.seed(219)
pbmc.pca <- RunUMAP(pbmc, dims = 1:15) %>% FindNeighbors(dims = 1:15) %>% FindClusters()
 
## 结果可视化
p <- DimPlot(pbmc.pca, label = T)   ggsci::scale_color_igv()
ggsave("pbmc_pca.png", p, width = 9, height = 6)
p <- FeaturePlot(pbmc.pca, features = c('CD3D', 'CD3E', 'MS4A1', 'CD79A', 'GNLY', 'NKG7', 'CD14', 
                                        'FCGR3A', 'PPBP', 'FCER1A', 'CD4', 'CD8A'), ncol = 4)
ggsave("pbmc_pca_markers.png", p, width = 12, height = 8)



(2) 基于NMF分解的降维聚类
## 高变基因表达矩阵的分解
# pbmc大体可分成T，B，NK，CD14 Mono，CD16 Mono，DC，Platelet等类型，考虑冗余后设置rank=10
vm <- pbmc@assays$RNA@scale.data

## ==> 直接做 NMF 会报错，因为 起始矩阵有负数。
# 错误: NMF::nmf - Input matrix x contains some negative entries.
# 过滤
vm[vm < 0] <- 0 #负数设置为 0
dim(vm)
vm <- vm[apply(vm, 1, var) > 0, ] #全是0的行去掉
dim(vm)


res <- nmf(vm, 10, method = "snmf/r", seed = 'nndsvd')  #这一步大约20-60min
# 其他例子中用到的参数： nmf(data, rank = r, nrun = 1, seed = 'ica', method = 'nsNMF') #nsNMF更慢，需要2个小时
# # 默认交替最小二乘法(Alternating Least Squares(ALS))——snmf/r  
# 参数rank=，是期望的细胞亚群数量

runtime(res)
#    用户     系统     流逝 
#1063.147   78.019 1139.831 

# 查看结果：
plot(t(coef(res) ), 
     col= scObj$seurat_clusters)
head(basis(res))



## 分解结果返回suerat对象
pbmc@reductions$nmf <- pbmc@reductions$pca
pbmc@reductions$nmf@cell.embeddings <- t(coef(res))    
pbmc@reductions$nmf@feature.loadings <- basis(res)  
 
## 使用nmf的分解结果降维聚类
set.seed(219)
pbmc.nmf <- RunUMAP(pbmc, reduction = 'nmf', dims = 1:10) %>% 
  FindNeighbors(reduction = 'nmf', dims = 1:10) %>% FindClusters(resolution = 0.8)

## 结果可视化  
p <- DimPlot(pbmc.nmf, label = T)   ggsci::scale_color_igv()
ggsave("pbmc_nmf.png", p, width = 9, height = 6)
p <- FeaturePlot(pbmc.nmf, features = c('CD3D', 'CD3E', 'MS4A1', 'CD79A', 'GNLY', 'NKG7', 'CD14', 
                                        'FCGR3A', 'PPBP', 'FCER1A', 'CD4', 'CD8A'), ncol = 4)
ggsave("pbmc_nmf_markers.png", p, width = 12, height = 8)



(3) NMF因子可解释性探索
对比PCA分析的结果，NMF虽然毫不逊色，但是它的运行时间更长。（1min vs 1h）

我们为什么要用NMF呢？一个很重要的原因是NMF的因子可解释性更强，每个因子贡献度最大的基因基本代表了某种或某个状态细胞的表达模式，相比差异分析得到marker基因更有代表性。


(4) NMF因子与细胞类型的关系
## 人工定义细胞类型
pbmc.nmf$celltype <- pbmc.nmf$seurat_clusters
pbmc.nmf$celltype <- recode(pbmc.nmf$celltype,
                            '1' = "B cells", 
                            '5' = "NKs", 
                            '10' = "CD8  T", 
                            '6' = "CD8  T", 
                            '4' = "CD4  T",
                            '9' = "CD4  T", 
                            '0' = "CD4  T", 
                            '3' = "CD4  T", 
                            '7' = "CD4  T", 
                            '2' = "CD14  Mono",
                            '8' = "CD14  Mono", 
                            '11' = "CD16  Mono", 
                            '12' = "DCs", 
                            '13' = "Platelet", 
                            '14' = "Unknown")
p <- DimPlot(pbmc.nmf, group.by = 'celltype', label = T, label.size = 3) 
    +  ggsci::scale_color_npg(alpha = 0.6)
ggsave("pbmc_nmf_celltype.png", p, width = 9, height = 6)



## 查看细胞因子上的荷载
tmp <- data.frame(t(coef(res)), check.names = F)
colnames(tmp) <- paste0("factor", 1:ncol(tmp))
pbmc.nmf <- AddMetaData(pbmc.nmf, metadata = tmp) #给 str(pbmc.nmf@meta.data) 添加若干列

p4 <- FeaturePlot(pbmc.nmf, features = paste0("factor", 1:11), ncol = 4); p4
#ggsave("pbmc_nmf_factors.png", p4, width = 12, height = 8)

## 查看细胞主成分上的荷载
p5 <- FeaturePlot(pbmc.nmf, features = paste0("PC_", 1:12), ncol = 4); p5
#ggsave("pbmc_nmf_PCs.png", p, width = 12, height = 8)

# 对比上下两张图，很容易发现NMF的因子比PCA的PC轴解释性更强。




## (6) 提取celltype的signatures ----
## 提取每个因子贡献度最大的20个基因
f <- extractFeatures(res, 20L)
f <- lapply(f, function(x) rownames(res)[x])
f <- do.call("rbind", f)
View(t(f) )
#DT::datatable(t(f))

NMF的11个因子中，很容易发现我们对细胞进行分类的marker基因，是不是很神奇？










ref:
单细胞分析之NMF(非负矩阵分解) https://www.plob.org/article/27713.html

单细胞数据分析——非负矩阵分解（NMF）识别功能模块 https://blog.csdn.net/m0_47675572/article/details/131169434
    对于细胞分群效果不理想，如上皮细胞存在异质性等，可以考虑使用非负矩阵分解（NMF）的方式去定义元程序（meta program，即功能模块）和元标签（meta label，即功能基因集）。

https://www.bilibili.com/video/BV1K3411x7J8/

https://cloud.tencent.com/developer/article/1806266









========================================
双细胞检测 doublet detection: Scrublet
----------------------------------------
什么是doublets？简单的说就是两个细胞混在一起，可能发生在细胞捕获过程中，并且可能会误导认为是两种细胞类型的过渡态（transitory states），所以应该去除

Doublets检测的软件：
①DoubletFinder
(https://github.com/chris-mcginnis-ucsf/DoubletFinder)
②Scrublet
(https://github.com/AllonKleinLab/scrublet)
③DoubletDecon
(https://github.com/EDePasquale/DoubletDecon)
④DoubletCluster



1. 张泽民 Science paper方法学描述

看来是对读入Seurat对象的做初步质控的细胞做的 Scrublet 检测。

(1)For the newly generated scRNA-seq data, Cell Ranger (version 3.0, 10x Genomics Inc) was used for sequencing reads mapping against the GRCh38 human reference genome, UMI counting, and cell identification. 

(2)Then cells with fewer than 200 genes detected or >10% mitochondrial UMI counts were filtered out; 
- genes detected in > 3 cells were kept. 
- Scrublet (49) was applied to each sequencing library to remove potential doublets, setting the expected doublet rate to 0.05, and the cells with doubletScore larger than 0.3 were filtered out.

(3) We applied Seurat (version 3) with default parameters to identify T/NK clusters.





2. Scrublet 的安装
https://github.com/AllonKleinLab/scrublet

(1) 官方安装会报错
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
一直报错，有人说 I also experienced this and managed to solve this by downgrading annoy to 1.16.3.
https://github.com/swolock/scrublet/issues/28

# 再次尝试
$ pip3 install --user annoy==1.16.3 -i https://pypi.douban.com/simple/
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
Successfully installed scrublet-0.2.3

# 版本检测
$ pip3 freeze | grep scrublet
scrublet==0.2.3


(2) 开 jupyter notebook 
$ jupyter notebook --no-browser --port 8787 --ip=192.168.2.xx
## 可能需要开放端口 sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT 


(3) numpy兼容性报错修复
ImportError: cannot import name '_validate_lengths' from 'numpy.lib.arraypad' (/home/wangjl/software/anaconda3/lib/python3.7/site-packages/numpy/lib/arraypad.py)

~/software/anaconda3/lib/python3.7/site-packages/skimage/util/arraycrop.py in <module>
import numpy as np
----> 8 from numpy.lib.arraypad import _validate_lengths


版本太高了，而本工具使用的是 1.15.2: https://github.com/swolock/scrublet/issues/4
$ pip3 freeze | grep numpy
numpy==1.18.3
numpydoc==0.8.0



1)要么降低 np 版本：有风险，用完再升级回1.18.3。
$ pip3 install numpy==1.16.2 -i https://pypi.douban.com/simple/ #还是报错
$ pip3 install numpy==1.15.2 -i https://pypi.douban.com/simple/ #需要重启 jupyter 才能生效！




2) 要么修改该包源码：尝试，没找到地方，放弃
> import sys
> print(sys.path)

['/data/jinwf/wangjl/neu/scRNA/202201filter/script', 
'/home/wangjl/software/anaconda3/lib/python37.zip', 
'/home/wangjl/software/anaconda3/lib/python3.7', 
'/home/wangjl/software/anaconda3/lib/python3.7/lib-dynload', 
'/home/wangjl/.local/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages/IPython/extensions', 
'/home/wangjl/.ipython']


一个一个找这些路径，肯定能找到:
$ find /home/wangjl/.local/lib/python3.7/site-packages/. | grep -v -P "(py|pyc)$" | xargs grep -i "scrublet" --color=auto

因为设定了 --user，装到这里了：
$ cd /home/wangjl/.local/lib/python3.7/site-packages/./scrublet
$ ls -lht
total 52K
drwxr-xr-x. 2 wangjl jinwf 123 Dec 28 09:17 __pycache__
-rw-r--r--. 1 wangjl jinwf 25K Dec 28 09:17 scrublet.py
-rw-r--r--. 1 wangjl jinwf 20K Dec 28 09:17 helper_functions.py
-rw-r--r--. 1 wangjl jinwf  63 Dec 28 09:17 __init__.py

查找这个函数的位置
$ find . | xargs grep "_validate_lengths" --color=auto 2>/dev/null

没找到位置，放弃。

解决方法: 
from distutils import LooseVersion as Version
old_numpy = Version(np.__version__) < Version('1.16')
if old_numpy:
    from numpy.lib.arraypad import _validate_lengths
else:
    from numpy.lib.arraypad import _as_pairs




(4) 基本使用
给定原始（非标准化）UMI计算矩阵counts_matrix，其中细胞为行，基因为列，计算每个cell的doublet分数：

import scrublet as scr
scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()

scr.scrub_doublets（）模拟数据的doublets，并使用k-最近邻分类器是每个转录组计算连续的doublet_score（在0和1之间）。
分数是由自动设定的阈值生成 predict_doublets，一个布尔数组，预测是doublets时为True，否则为False。








3. 运行
(1) 我的版本
import pandas as pd
counts_matrix = pd.read_csv("../filterSample/data/_BL2Y.counts.df.txt", sep=" ") #, header = None, index_col=None, names=['barcode'])
counts_matrix.shape

# check
# print(counts_matrix.shape)
# counts_matrix.iloc[1:4, 1:4]

import numpy as np
import scrublet as scr

scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()


最佳实践 Best practices:
- 处理来自多个样品的数据时，分别对每个样品运行Scrublet。Scrublet用于检测由两个细胞的随机共包封形成的doublets，所以它可能在合并数据集上表现不佳;
- 在2-D嵌入（例如，UMAP或t-SNE）中可视化doublets预测;




(2) 重要的参数
https://github.com/swolock/scrublet/blob/master/examples/scrublet_basics.ipynb

1)初始化Scrublet对象
相关参数为：
•expected_doublet_rate，doublets的预期占比，通常为0.05-0.1，结果对该参数不是特别敏感。对于此示例数据，预期的doublets占比来自Chromium用户指南[9]
•sim_doublet_ratio，要模拟的doublets数量相对于转录组的观测值的比例。此值应该足够高，以使所有的doublet状态都能很好地由模拟doublets表示。设置得太高会使计算量增大，默认值是2（尽管设置低至0.5的值也对测试的数据集产生非常相似的结果。
•n_neighbors，用于构造转录组观测值和模拟doublets的KNN分类器的邻居数。默认值为round（0.5 * sqrt（n_cells）），通常表现比较好。

scrub = scr.Scrublet(counts_matrix, expected_doublet_rate=0.06)



2) 计算doublet score
运行下面的代码计算doublet score，内部处理过程包括:
	1.Doublet simulation
	2.Normalization, gene filtering, rescaling, PCA
	3.Doublet score calculation
	4.Doublet score threshold detection and doublet calling

doublet_scores, predicted_doublets = scrub.scrub_doublets(n_prin_comps=30, mean_center=True, normalize_variance=True)

doublet_scores, predicted_doublets = scrub.scrub_doublets(min_counts=2, min_cells=3, min_gene_variability_pctl=85, n_prin_comps=30)










========================================
|-- DoubletDetection依赖scanpy，在安装DoubletDetection前务必安装scanpy //todo
----------------------------------------












========================================
细胞周期的区分方法？
----------------------------------------

1. 2015 cell, Drop-seq

> dput(cycle.list)
list(G1S = c("ACD", "ACYP1", "ADAMTS1", "ANKRD10", "APEX2", "ARGLU1", "ATAD2", "BARD1", "BRD7", "C1orf63", "C7orf41", "C14orf142", "CAPN7", "CASP2", "CASP8AP2", "CCNE1", "CCNE2", "CDC6", "CDC25A", "CDCA7", "CDCA7L", "CEP57", "CHAF1A", "CHAF1B", "CLSPN", "CREBZF", "CTSD", "DIS3", "DNAJC3", "DONSON", "DSCC1", "DTL", "E2F1", "EIF2A", "ESD", "FAM105B", "FAM122A", "FLAD1", "GINS2", "GINS3", "GMNN", "HELLS", "HOXB4", "HRAS", "HSF2", "INSR", "INTS8", "IVNS1ABP", "KIAA1147", "KIAA1586", "LNPEP", "LUC7L3", "MCM2", "MCM4", "MCM5", "MCM6", "MDM1", "MED31", "MRI1", "MSH2", "NASP", "NEAT1", "NKTR", "NPAT", "NUP43", "ORC1", "OSBPL6", "PANK2", "PCDH7", "PCNA", "PLCXD1", "PMS1", "PNN", "POLD3", "RAB23", "RECQL4", "RMI2", "RNF113A", "RNPC3", "SEC62", "SKP2", "SLBP", "SLC25A36", "SNHG10", "SRSF7", "SSR3", "TAF15", "TIPIN", "TOPBP1", "TRA2A", "TTC14", "UBR7", "UHRF1", "UNG", "USP53", "VPS72", "WDR76", "ZMYND19", "ZNF367", "ZRANB2"), 

S = c("ABCC5", "ABHD10", "ANKRD18A", "ASF1B", "ATAD2", "BBS2", "BIVM", "BLM", "BMI1", "BRCA1", "BRIP1", "C5orf42", "C11orf82", "CALD1", "CALM2", "CASP2", "CCDC14", "CCDC84", "CCDC150", "CDC7", "CDC45", "CDCA5", "CDKN2AIP", "CENPM", "CENPQ", "CERS6", "CHML", "COQ9", "CPNE8", "CREBZF", "CRLS1", "DCAF16", "DEPDC7", "DHFR", "DNA2", "DNAJB4", "DONSON", "DSCC1", "DYNC1LI2", "E2F8", "EIF4EBP2", "ENOSF1", "ESCO2", "EXO1", "EZH2", "FAM178A", "FANCA", "FANCI", "FEN1", "GCLM", "GOLGA8A", "GOLGA8B", "H1F0", "HELLS", "HIST1H2AC", "HIST1H4C", "INTS7", "KAT2A", "KAT2B", "KDELC1", "KIAA1598", "LMO4", "LYRM7", "MAN1A2", "MAP3K2", "MASTL", "MBD4", "MCM8", "MLF1IP", "MYCBP2", "NAB1", "NEAT1", "NFE2L2", "NRD1", "NSUN3", "NT5DC1", "NUP160", "OGT", "ORC3", "OSGIN2", "PHIP", "PHTF1", "PHTF2", "PKMYT1", "POLA1", "PRIM1", "PTAR1", "RAD18", "RAD51", "RAD51AP1", "RBBP8", "REEP1", "RFC2", "RHOBTB3", "RMI1", "RPA2", "RRM1", "RRM2", "RSRC2", "SAP30BP", "SLC38A2", "SP1", "SRSF5", "SVIP", "TOP2A", "TTC31", "TTLL7", "TYMS", "UBE2T", "UBL3", "USP1", "ZBED5", "ZWINT"), 

G2M = c("ANLN", "AP3D1", "ARHGAP19", "ARL4A", "ARMC1", "ASXL1", "ATL2", "AURKB", "BCLAF1", "BORA", "BRD8", "BUB3", "C2orf69", "C14orf80", "CASP3", "CBX5", "CCDC107", "CCNA2", "CCNF", "CDC16", "CDC25C", "CDCA2", "CDCA3", "CDCA8", "CDK1", "CDKN1B", "CDKN2C", "CDR2", "CENPL", "CEP350", "CFD", "CFLAR", "CHEK2", "CKAP2", "CKAP2L", "CYTH2", "DCAF7", "DHX8", "DNAJB1", "ENTPD5", "ESPL1", "FADD", "FAM83D", "FAN1", "FANCD2", "G2E3", "GABPB1", "GAS1", "GAS2L3", "H2AFX", "HAUS8", "HINT3", "HIPK2", "HJURP", "HMGB2", "HN1", "HP1BP3", "HRSP12", "IFNAR1", "IQGAP3", "KATNA1", "KCTD9", "KDM4A", "KIAA1524", "KIF5B", "KIF11", "KIF20B", "KIF22", "KIF23", "KIFC1", "KLF6", "KPNA2", "LBR", "LIX1L", "LMNB1", "MAD2L1", "MALAT1", "MELK", "MGAT2", "MID1", "MIS18BP1", "MND1", "NCAPD3", "NCAPH", "NCOA5", "NDC80", "NEIL3", "NFIC", "NIPBL", "NMB", "NR3C1", "NUCKS1", "NUMA1", "NUSAP1", "PIF1", "PKNOX1", "POLQ", "PPP1R2", "PSMD11", "PSRC1", "RANGAP1", "RCCD1", "RDH11", "RNF141", "SAP30", "SKA3", "SMC4", "STAT1", "STIL", "STK17B", "SUCLG2", "TFAP2A", "TIMP1", "TMEM99", "TMPO", "TNPO2", "TOP2A", "TRAIP", "TRIM59", "TRMT2A", "TTF2", "TUBA1A", "TUBB", "TUBB2A", "TUBB4B", "TUBD1", "UACA", "UBE2C", "VPS25", "VTA1", "WSB1", "ZNF587", "ZNHIT2"), 

M = c("AHI1", "AKIRIN2", "ANKRD40", "ANLN", "ANP32B", "ANP32E", "ARHGAP19", "ARL6IP1", "ASXL1", "ATF7IP", "AURKA", "BIRC2", "BIRC5", "BUB1", "CADM1", "CCDC88A", "CCDC90B", "CCNA2", "CCNB2", "CDC20", "CDC25B", "CDC27", "CDC42EP1", "CDCA3", "CENPA", "CENPE", "CENPF", "CEP55", "CFLAR", "CIT", "CKAP2", "CKAP5", "CKS1B", "CKS2", "CNOT10", "CNTROB", "CTCF", "CTNNA1", "CTNND1", "DEPDC1", "DEPDC1B", "DIAPH3", "DLGAP5", "DNAJA1", "DNAJB1", "DR1", "DZIP3", "E2F5", "ECT2", "FAM64A", "FOXM1", "FYN", "G2E3", "GADD45A", "GAS2L3", "GOT1", "GRK6", "GTSE1", "HCFC1", "HMG20B", "HMGB3", "HMMR", "HN1", "HP1BP3", "HPS4", "HS2ST1", "HSPA8", "HSPA13", "INADL", "KIF2C", "KIF5B", "KIF14", "KIF20B", "KLF9", "LBR", "LMNA", "MCM4", "MDC1", "MIS18BP1", "MKI67", "MLLT4", "MZT1", "NCAPD2", "NCOA5", "NEK2", "NUF2", "NUP35", "NUP98", "NUSAP1", "ODF2", "ORAOV1", "PBK", "PCF11", "PLK1", "POC1A", "POM121", "PPP1R10", "PRPSAP1", "PRR11", "PSMG3", "PTP4A1", "PTPN9", "PWP1", "QRICH1", "RAD51C", "RANGAP1", "RBM8A", "RCAN1", "RERE", "RNF126", "RNF141", "RNPS1", "RRP1", "SEPHS1", "SETD8", "SFPQ", "SGOL2", "SHCBP1", "SMARCB1", "SMARCD1", "SPAG5", "SPTBN1", "SRF", "SRSF3", "SS18", "SUV420H1", "TACC3", "THRAP3", "TLE3", "TMEM138", "TNPO1", "TOMM34", "TPX2", "TRIP13", "TSG101", "TSN", "TTK", "TUBB4B", "TXNDC9", "TXNRD1", "UBE2D3", "USP13", "USP16", "VANGL1", "WIBG", "WSB1", "YWHAH", "ZC3HC1", "ZFX", "ZMYM1", "ZNF207"), 

MG1 = c("AGFG1", "AGPAT3", "AKAP13", "AMD1", "ANP32E", "ANTXR1", "BAG3", "BTBD3", "CBX3", "CDC42", "CDK7", "CDKN3", "CEP70", "CNIH4", "CTR9", "CWC15", "DCP1A", "DCTN6", "DEXI", "DKC1", "DNAJB6", "DSP", "DYNLL1", "EIF4E", "ELP3", "FAM60A", "FAM189B", "FOPNL", "FOXK2", "FXR1", "G3BP1", "GATA2", "GNB1", "GRPEL1", "GSPT1", "GTF3C4", "HIF1A", "HMG20B", "HMGCR", "HSD17B11", "HSPA8", "ILF2", "JMJD1C", "KDM5B", "KIAA0586", "KIF5B", "KPNB1", "KRAS", "LARP1", "LARP7", "LRIF1", "LYAR", "MORF4L2", "MRPL19", "MRPS2", "MRPS18B", "MSL1", "MTPN", "NCOA3", "NFIA", "NFIC", "NUCKS1", "NUFIP2", "NUP37", "ODF2", "OPN3", "PAK1IP1", "PBK", "PCF11", "PLIN3", "PPP2CA", "PPP2R2A", "PPP6R3", "PRC1", "PSEN1", "PTMS", "PTTG1", "RAD21", "RAN", "RHEB", "RPL13A", "SLC39A10", "SNUPN", "SRSF3", "STAG1", "SYNCRIP", "TAF9", "TCERG1", "TLE3", "TMEM138", "TOB2", "TOP1", "TROAP", "TSC22D1", "TULP4", "UBE2D3", "VANGL1", "VCL", "WIPF2", "WWC1", "YY1", "ZBTB7A", "ZCCHC10", "ZNF24", "ZNF281", "ZNF593"))





2. 其他的文献线索

(1) 荧光法
Genome Res. 2020 Apr;30(4):611-621. doi: 10.1101/gr.247759.118. Epub 2020 Apr 20.
Characterizing and inferring quantitative cell cycle phase in single-cell RNA-seq data analysis

https://pubmed.ncbi.nlm.nih.gov/32312741/

Although standard methods assign cells to discrete cell cycle stages, our method goes beyond this and quantifies cell cycle progression on a continuum. We found that, on average, scRNA-seq data from only five genes predicted a cell's position on the cell cycle continuum to within 14% of the entire cycle and that using more genes did not improve this accuracy. 


(2)Applying Oscope to a number of data sets, we demonstrated its utility and also identified a potential artifact in the Fluidigm C1 platform.
https://pubmed.ncbi.nlm.nih.gov/26301841/

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE64016

Total 213 H1 single cells and 247 H1-Fucci single cells were sequenced. The 213 H1 cells were used to evaluate Oscope in identifying oscillatory genes. The H1-Fucci cells were used to confirm the cell cycle gene cluster identified by Oscope in the H1 hESCs.











========================================
细胞通讯分析
----------------------------------------




========================================
|- 细胞间通讯教程： cellphonedb 及其可视化
----------------------------------------
https://www.jianshu.com/p/f196c98e0954
细胞通讯分析的方法 https://mp.weixin.qq.com/s/m1EzVPgt7257Bz67eURXGQ

1.
但是解析细胞类型异质性不应止于这些，还可以看细胞群之间的通讯。当然，这方面我们介绍过CellChat：细胞间相互作用分析利器。CellChat是以信号通路为单位来计算细胞间交流状态的，很多同学用cellphonedb来做基于配受体对的细胞间交流。


文章用到的图实例： Single-cell transcriptomics reveals regulators underlying immune cell diversity and immune subtypes associated with prognosis in nasopharyngeal carcinoma




2. 实例: 用经典的pbmc3k数据跑一下cellphonedb，并尝试可视化。










========================================
|-- CellChat：细胞间相互作用分析利器
----------------------------------------
http://www.cellchat.org/
https://github.com/sqjin/CellChat

https://www.jianshu.com/p/da145cff3d41

1. 简介
细胞间信息传递方式一个是细胞表面配受体的相互作用，另一个通过细胞产生的可溶性小分子，即细胞因子。在单细胞数据分析中下游，有时候我们想看某几种细胞类型之间的相互作用，就有人推荐我们做一个配受体分析。那什么是配受体？我们在文章Cell-Cell Interaction Database|| 单细胞配受体库你还在文章的附录里找吗？中提到配受体其实是细胞的特定蛋白，蛋白追溯到基因表达上就是基因对。

Inference and analysis of cell-cell communication using CellChat
Suoqin Jin, Christian F. Guerrero-Juarez, Lihua Zhang, Ivan Chang, Peggy Myung, Maksim V. Plikus, Qing Nie
bioRxiv 2020.07.21.214387; doi: https://doi.org/10.1101/2020.07.21.214387

源码: 
http://www.cellchat.org/
https://github.com/sqjin/CellChat

应用案例文章分析: https://zhuanlan.zhihu.com/p/525115168



2.安装
NMF 0.27
BiocManager::install("ComplexHeatmap") #2.18.0
BiocManager::install("BiocNeighbors") #1.20.2
devtools::install_github("sqjin/CellChat") #1.6.1
library(CellChat)


(1) 安装 
> devtools::install_github("sqjin/CellChat")

CentOS 正常，Docker 不正常。

Installing package into ‘/docker/jinwf/wangjl/R_inDocker/x86_64-pc-linux-gnu-library/4.1’
(as ‘lib’ is unspecified)
ERROR: dependencies ‘ComplexHeatmap’, ‘ggpubr’ are not available for package ‘CellChat’
* removing ‘/docker/jinwf/wangjl/R_inDocker/x86_64-pc-linux-gnu-library/4.1/CellChat’
Warning messages:
1: In i.p(...) : installation of package ‘nloptr’ had non-zero exit status
2: In i.p(...) : installation of package ‘lme4’ had non-zero exit status
3: In i.p(...) :
  installation of package ‘pbkrtest’ had non-zero exit status
4: In i.p(...) : installation of package ‘car’ had non-zero exit status
5: In i.p(...) :
  installation of package ‘rstatix’ had non-zero exit status
6: In i.p(...) : installation of package ‘ggpubr’ had non-zero exit status
7: In i.p(...) :
  installation of package ‘/tmp/Rtmp13CW3A/filecc56fd9658/CellChat_1.5.0.tar.gz’ had non-zero exit status


往前找: ERROR: dependency ‘car’ is not available for package ‘rstatix’

$ sudo apt install cmake
> install.packages ("car")
> devtools::install_github("jokergoo/ComplexHeatmap")

> devtools::install_github("sqjin/CellChat")




(2) 安装 (2023.6 on Ubuntu 20.04)
> devtools::install_github("sqjin/CellChat")
Error: Failed to install 'CellChat' from GitHub:
  HTTP error 403.
  API rate limit exceeded for 116.6.234.147. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)

  Rate limit remaining: 0/60
  Rate limit reset at: 2023-06-14 02:52:39 UTC

  To increase your GitHub API rate limit
  - Use `usethis::create_github_token()` to create a Personal Access Token.
  - Use `usethis::edit_r_environ()` and add the token as `GITHUB_PAT`.


(3) 尝试安装2
$ git --version
git version 2.25.1

$ cd ~/data/
$ git clone https://github.com/sqjin/CellChat.git
Cloning into 'CellChat'...
remote: Enumerating objects: 1226, done.
remote: Counting objects: 100% (430/430), done.
remote: Compressing objects: 100% (225/225), done.
remote: Total 1226 (delta 301), reused 309 (delta 205), pack-reused 796
Receiving objects: 100% (1226/1226), 46.58 MiB | 6.41 MiB/s, done.
Resolving deltas: 100% (744/744), done.


$ gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.

> devtools::install_git(url="~/data/CellChat/")


NMF 0.27
circlize 0.4.16
ComplexHeatmap 2.18.0







========================================
|-- CellChat 实例
----------------------------------------
1. 用CellChat来分析一下我们的PBMC数据，看看配受体分析的一般流程。

https://htmlpreview.github.io/?https://github.com/sqjin/CellChat/blob/master/tutorial/CellChat-vignette.html
https://zhuanlan.zhihu.com/p/525365897

library(CellChat)
library(patchwork)
options(stringsAsFactors = FALSE)

(1) CellChat需要两个输入
* 一个是细胞的基因表达数据，
* 另一个是细胞标签(即细胞标签)。

对于基因表达数据矩阵，基因应该在带有行名的行中，cell应该在带有名称的列中。CellChat分析的输入是均一化的数据(Seurat@assay$RNA@data)。如果用户提供counts数据，可以用normalizeData函数来均一化。对于细胞的信息，需要一个带有rownames的数据格式作为CellChat的输入。



1) 数据库名字:
> dplyr::glimpse(CellChatDB$interaction)
Rows: 1,939
Columns: 11
$ interaction_name   <chr> "TGFB1_TGFBR1_TGFBR2", "TGFB2_TGFBR1_TGFBR2", "TGFB3_TGFBR1_TGFBR2", "TGFB1_ACVR1B_TGFBR2", "TGFB1_ACVR…
$ pathway_name       <chr> "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "TGFb", "BMP", …
$ ligand             <chr> "TGFB1", "TGFB2", "TGFB3", "TGFB1", "TGFB1", "TGFB2", "TGFB2", "TGFB3", "TGFB3", "TGFB1", "TGFB2", "TGF…
$ receptor           <chr> "TGFbR1_R2", "TGFbR1_R2", "TGFbR1_R2", "ACVR1B_TGFbR2", "ACVR1C_TGFbR2", "ACVR1B_TGFbR2", "ACVR1C_TGFbR…
$ agonist            <chr> "TGFb agonist", "TGFb agonist", "TGFb agonist", "TGFb agonist", "TGFb agonist", "TGFb agonist", "TGFb a…
$ antagonist         <chr> "TGFb antagonist", "TGFb antagonist", "TGFb antagonist", "TGFb antagonist", "TGFb antagonist", "TGFb an…
$ co_A_receptor      <chr> "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",…
$ co_I_receptor      <chr> "TGFb inhibition receptor", "TGFb inhibition receptor", "TGFb inhibition receptor", "TGFb inhibition re…
$ evidence           <chr> "KEGG: hsa04350", "KEGG: hsa04350", "KEGG: hsa04350", "PMID: 27449815", "PMID: 27449815", "PMID: 274498…
$ annotation         <chr> "Secreted Signaling", "Secreted Signaling", "Secreted Signaling", "Secreted Signaling", "Secreted Signa…
$ interaction_name_2 <chr> "TGFB1 - (TGFBR1+TGFBR2)", "TGFB2 - (TGFBR1+TGFBR2)", "TGFB3 - (TGFBR1+TGFBR2)", "TGFB1 - (ACVR1B+TGFBR…
> 



2) 并行设置
future::plan(strategy ="multisession", workers = 4) # do parallel, Rstudio内不支持 multicore 模式







Ref: CellChat 帮助文档
https://zhuanlan.zhihu.com/p/554129661
https://zhuanlan.zhihu.com/p/629468306


========================================
SCENIC转录因子分析: 单细胞基因调控网络分析
----------------------------------------

py https://www.bilibili.com/video/BV1az4y1673b/

1. 概述
(1)软件 SCENIC(Single Cellr Egulatory Network Inference and Clustering)
利用单细胞转录组数据，进行调控子的分析，并构建基因调控网络，鉴定稳定的细胞状态。

(2) SCENIC 分析流程主要分2大步4小步
1)Gene regulatory network:
- Co-expression 
- Motif discovery 
2)Cell states
- Cell scoring
- Clustering

(3) 子软件 主要是4个
- GENIE3: 共表达模块分析
- RcisTarget: 调控元件分析
- AUCell: 细胞网络活动度分析
- cluster: 鉴定稳定的细胞状态









2. SCENIC 和 pySCENIC 的异同点

相同点 
	- 功能基本相同，都可以进行基因调控子分析和细胞状态的鉴定
	- 研发团队相同，作者排序略有差异
不同点
	- 样本量不同：
		前者用 GENIE3 适合小样本量数据
		后者使用 GRNBoost，更适合处理大样本数据
	- 网址不同
		https://github.com/aertslab/SCENIC 
		https://github.com/aertslab/pySCENIC



3. 单细胞转录组分析目的
- 细胞类型鉴定
- 拟时间分析

在单细胞转录组中，基因调控网络分析主要实现前者: 细胞类型鉴定。











========================================
|- 转录因子调控网络 SCENIC: single-cell regulatory network inference and clustering //todo
----------------------------------------
SCENIC | 从单细胞数据推断基因调控网络和细胞类型 

SCENIC是一种同时重建基因调控网络并从单细胞RNA-seq数据中鉴定stable cell states的工具。基于共表达和DNA模基序 （motif）分析推断基因调控网络 ，然后在每个细胞中分析网络活性以鉴定细胞状态。


1.
SCENIC发表于2017年的Nature method文章。具体见链接:
https://www.nature.com/articles/nmeth.4463

以t-SNE图呈现AUC评分和TF表达情况（即调控元件的活动度）




2. 文章中的实例
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac

(1)2018年CELL文章的800多个单细胞
文章标题是《Toward Minimal Residual Disease-Directed Therapy in Melanoma》，链接：https://pubmed.ncbi.nlm.nih.gov/30017245/

使用了SCENIC转录因子分析的结果制作了如下所示的3张图：

(A) t-SNE shows cells colored by state identity(SCENIC approach). The identities are inferred by the binary activities of the TF regulons. Cell identitiesinferred by SCENIC are largely overlappingwith the SCDE approach
(B) SCENIC analysis predicts TFs such as SOX10,MEF2C, TFAP2B, and RXRG as central hubs governing the NCSC state. TF regulon activitieswere quantified using AUCell.
(D) Gene regulatory network analysis using SCENIC identifies critical nodes driving the NDTC state.
图A是为了突出一个细胞亚群是某些TF的调控活性区域，图B是分别显示具体的TF是如何在该细胞亚群被富集出来的，图C是看该调控活性区域的突出TF的基因网络情况。

每个亚群都有各自富集到的转录因子，包括：pigmentation, NCSC, “invasive,” “proliferative” and SMC states ，都可以根据SCENIC转录因子分析的结果来绘制经典三张图，数据集在GSE116237，总共也就是 865个细胞：


(2)
2020年10月NC的膀胱癌免疫微环境
文章标题是；《Single-cell RNA sequencing highlights the role of inflammatory cancer-associated fibroblasts in bladder urothelial carcinoma》，链接是：https://www.nature.com/articles/s41467-020-18916-5

首先是：图 a Heatmap of the area under the curve (AUC) scores of TF motifs estimated per cell by SCENIC. Shown are top five differentially activated motifs in iCAFs and mCAFs, respectively

也就是说，研究者定位到了两个细胞亚群 iCAFs and mCAFs，然后针对性的对这两个细胞亚群进行SCENIC分析，取那些在两个细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化，如下：


然后是对两个细胞亚群有统计学差异的TF各取2个进行tSNE的可视化，看看具体是如何的差异：

TF各取2个进行tSNE的可视化

哪怕是这篇文章的作者并没有直接在GEO里面提供表达矩阵，我们也可以很容易去借鉴这里面的可视化方法，来具体展现我们的SCENIC分析结果！


(3)2020年12月NC的食管鳞状细胞癌微环境
文章标题是；《Immune suppressive landscape in the human esophageal squamous cell carcinoma microenvironment》，链接是 https://www.nature.com/articles/s41467-020-20019-0

同样的，取细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化：

文中图例是：j Heat-map of the t values of AUC scores of expression regulation by transcription factors of the indicated clusters, as estimated using SCENIC

这个时候的细胞亚群比较多，所以并不需要展现具体的每个细胞里面的该TF的AUC值啦，直接以细胞亚群的混合方式进行展现即可。

同样的分析，完全不同的展现方式

主要是靠大家对这个细胞通讯分析流程的理解，以及对结果的解读，后续我们会针对此推文前面提到的5款做细胞通讯分析软件的用法解读，并且合理的使用它们的分析结果来支撑我们的数据成为一个合理的生物学故事！





ref:
实例：https://www.jianshu.com/p/0bf18fe92c7d
http://blog.sciencenet.cn/home.php?mod=space&uid=118204&do=blog&id=1208136
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac




========================================
一张表弄懂细胞可塑性、细胞分化轨迹、细胞谱系和RNA速率
----------------------------------------
https://blog.sciencenet.cn/home.php?do=blog&id=1251830&mod=space&uid=3447504

1. 概念	介绍
(1) 可塑性（Plasiticity）	
定义：细胞以可逆的方式动态切换出不同的细胞表型（Phenotype）的能力，通常指的是干细胞（Stem Cells），例如：癌症干细胞（Cancer Stem Cells）。因为这一切换过程涉及到多种细胞内在以及外在因素的调控，因此这是一个复杂的过程。

过程：细胞表型的切换需要抑制前一个细胞表型有关的基因表达，同时需要激活新的细胞表型有关的基因的表达。

意义：研究细胞可塑性对于探索癌细胞抗药性、肿瘤复发以及癌细胞的转移具有重要意义。

(2) 分化轨迹（Trajectory）	
定义：又名伪时间序列（Pseudo-Time），指的是根据表达模式的相似度构造出的细胞分化的方向和路径。这是一个虚拟的概念。

拓扑结构：如今人们已经构造出了多种细胞分化轨迹的形状，包括：圈、直线、分叉、树、连通图和不连通图，等等。拓扑结构的不同决定了需要采用不同的算法构造分化轨迹。

意义：获取细胞的分化轨迹有助于进一步对细胞进行分类和分型，可以起到降低噪音、提高准确率的作用。


(3) 细胞谱系（Lineage）	
定义：细胞谱系指的是原始细胞（例如：胚胎干细胞）演化为一个分化细胞的历程。它的起点是起始细胞，终点是一个不能再分裂的细胞。

方法：最初人们主要依靠肉眼观察来研究细胞谱系，该方法仅仅适用于某些透明的生物细胞。后来，由于共聚焦显微镜的发明与推广，人们可以观察更加复杂的细胞谱系。另外一种主流方法就是克隆法。


(4) RNA速率（RNA Velocity）	
定义：RNA速率指的是基因表达状态相对于时间的导数，或者说是已剪接mRNA（Spliced mRNA）和未剪接mRNA（Unspliced mRNA）的含量相对于时间的变化速率。RNA速率为正值，表示该基因正在被上调，也就是目前有大量的未剪接的mRNA；相反，RNA速率为负值，表示该基因正在被下调。

意义：RNA速率可用于预测细胞未来的表达状态研究细胞动态（Dynamics），构造细胞分化轨迹，估计转录、剪接和降解的速率以及对不同的细胞动力学机制（Kinetics Regime）进行分类。





========================================
RNA kinetics / RNA 速率，RNA velocity /?
----------------------------------------
你会选择拟时许分析还是RNA velocity分析呢

1.

RNA速度将极大地帮助分析发育谱系和细胞动力学，特别是在人类。

因为我们在进行RNA速率分析的时候，需要区分表达矩阵内前提mRNA（unspliced）和成熟的mRNA（spliced），所以需要从原始数据入手，得到loom文件后，再去进行后续分析。





2. 代码 

(1) 安装py包
pip install -U scvelo

pip install -i https://pypi.tuna.tsinghua.edu.cn/simple velocyto


(2) 运行velocyto
$ velocyto run -o ./ -m /path/mouse/mus_repeat.gtf new.bam ../mouse/genes.gtf


(3) R转化loom文件为h5ad文件
library(Seurat)
library(SeuratWrappers)
library(SeuratDisk)
# loom_data bm bm[["RNA"]] bm bm bm bm bm

DefaultAssay(bm) <- "RNA"
SaveH5Seurat(bm, filename = "test.h5Seurat")
Convert("test.h5Seurat", dest = "h5ad")


(4) scvelo RNA速率分析
adata = scv.read("/path/test.h5ad")
scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=2000)
scv.pp.moments(adata, n_pcs=30, n_neighbors=30)
scv.tl.velocity(adata)
scv.tl.velocity_graph(adata)

scv.set_figure_params(dpi=300)
scv.pl.velocity_embedding_stream(adata, basis="umap", size= 10, alpha=0.6, color="seurat_clusters")







ref:
- RNA velocity of single cells, (2018), Nature
-  V. Bergen, M. Lange, S. Peidli, F. Alexander Wolf & F. J. Theis, Generalizing RNA velocity to transient cell states through dynamical modeling, (2020), Nature Biotechnology
- V. Bergen, R. Soldatov, P. V. Kharchenko, F. J. Theis, RNA velocity — current challenges and future perspectives, (2021), Molecular Systems Biology

https://www.jianshu.com/p/1e7acde1a318
http://www.biomarker.com.cn/archives/28929







========================================
inferCNV 安装: H3:8787, 及 J3 docker 可用
----------------------------------------
1. 安装 @H3:8787
https://github.com/broadinstitute/inferCNV/wiki/Installing-infercnv

(1) 安装依赖 jags
安装inferCNV之前需要安装JAGS程序，下载地址：
https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/

$ wget https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/Source/JAGS-4.3.2.tar.gz
$ tar zxvf JAGS-4.3.2.tar.gz
$ cd JAGS-4.3.2
$ ./configure --prefix=/home/wangjl/.local/  #库都放到这里
	## configure: error: "You need to install the LAPACK library"
	$ sudo yum install blas-devel lapack-devel
$ make -j32
$ make install

$ vim ~/.bashrc #添加
export LD_LIBRARY_PATH=/home/wangjl/.local/lib/:$LD_LIBRARY_PATH
export PATH=/home/wangjl/.local/bin:$PATH
export PKG_CONFIG_PATH=/home/wangjl/.local/lib/pkgconfig:$PKG_CONFIG_PATH

在 ~/.Rprofile 中添加
Sys.setenv("PKG_CONFIG_PATH"=paste0("/home/wangjl/.local/lib/pkgconfig:", Sys.getenv("PKG_CONFIG_PATH") ) )


$ source ~/.bashrc

$ which jags
~/.local/bin/jags

$ jags
Welcome to JAGS 4.3.2 on Fri May 31 20:42:48 2024

此程序安装之后，inferCNV依赖的rjags包才能正常安装，否则报错：configuration failed for package ‘rjags’



2) 放到路径中
$ pkg-config --modversion jags
4.3.2


> install.packages("rjags", configure.args="--enable-rpath")

> library(rjags)
Loading required package: coda
Linked to JAGS 4.3.2
Loaded modules: basemod,bugs




(2) 安装R包：失败
@H3$ R #4.3.2
if (!requireNamespace("BiocManager", quietly = TRUE))
     install.packages("BiocManager")
> BiocManager::install("infercnv")
	> options(BioC_mirror="https://mirrors.tuna.tsinghua.edu.cn/bioconductor")
	> options(BioC_mirror="https://mirrors.westlake.edu.cn/bioconductor/")

	报错: RROR: dependency ‘parallelDist’ is not available for package ‘infercnv’
	怎么安装 parallelDist
	
	> install.packages("parallelDist")
	搞不定。
	
library(infercnv) # v 1.0.4


报错内容：编译中夹杂一条 WARNING: ignoring environment value of R_HOME
	/home/wangjl/soft/gcc-12.3.0/bin/g++ -std=c++11 -fPIC -std=gnu++11 -shared -L/opt/R/4.3.2/lib64/R/lib -L/usr/local/lib64 -o parallelDist.so DistanceDTWFactory.o DistanceFactory.o RcppExports.o Util.o parallelDist.o WARNING: ignoring environment value of R_HOME -lopenblas -lgfortran -lm -lquadmath -L/opt/R/4.3.2/lib64/R/lib -lR
	["/picb/jinlab/wangjl/R/x86_64-pc-linux-gnu-library/4.3/00LOCK-parallelDist/00new","/picb/jinlab/wangjl/R/x86_64-pc-linux-gnu-library/4.3","/opt/R/4.3.2/lib64/R/library","/picb/jinlab/wangjl/Downloads/R-4.3.2/library"]

	/bin/ld: cannot find WARNING:: No such file or directory
	/bin/ld: cannot find ignoring: No such file or directory
	/bin/ld: cannot find environment: No such file or directory
	/bin/ld: cannot find value: No such file or directory
	/bin/ld: cannot find of: No such file or directory
	/bin/ld: cannot find R_HOME: No such file or directory
	collect2: error: ld returned 1 exit status
	make: *** [parallelDist.so] Error 1
	ERROR: compilation failed for package ‘parallelDist’


问题：能找到该变量，为什么编译时说找不到呢？
> system("echo $R_HOME")
/opt/R/4.3.2/lib64/R

提问：https://github.com/cran/parallelDist/issues/1



(2B) 安装github上的最新版 @H
> library("devtools") #2.4.5
> devtools::install_github("broadinstitute/infercnv")

降低版本呢？
trying URL 'https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/contrib/parallelDist_0.2.6.tar.gz'
> devtools::install_version("parallelDist", version="0.2.1")
还是同样报错。定义过R_HOME为什么找不到呢？


修改包：还是最新版吧
	$ cd /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv
	$ wget https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/contrib/parallelDist_0.2.6.tar.gz
	$ tar zxvg parallelDist_0.2.6.tar.gz
	$ cd parallelDist/
	$ find . | xargs grep -in HOME --color=auto 2>/dev/null
	./src/Makevars.win:5:PKG_LIBS += $(shell "${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe" \
	./src/Makevars:3:PKG_LIBS = `${R_HOME}/bin/Rscript -e "RcppParallel::RcppParallelLibs()"` $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)

	$ vim ./src/Makevars
	添加一句：
	#R_HOME=/opt/R/4.3.2/lib64/R 没用，已删除
	重新打包：
	$ cd ..
	$ tar zcvf parallelDist_0.2.6b.tar.gz parallelDist #不用打包，或者不能这样打包
	$ R CMD BUILD parallelDist #应该这样打包
	直接安装吧：
	

本地安装: install 应按大写
$ R CMD install parallelDist_0.2.6b.tar.gz
	报错：install: missing destination file operand after  ‘parallelDist_0.2.6b.tar.gz’

	$ R CMD install --help
	install [OPTION]... [-T] SOURCE DEST

	> install.packages("/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/parallelDist_0.2.6b.tar.gz")
	$ R CMD install parallelDist_0.2.6b.tar.gz /picb/jinlab/wangjl/R/x86_64-pc-linux-gnu-library/4.3 #仅仅是复制到后面的路径

build 应按大写
$ R CMD build parallelDist
	同样报错。

https://github.com/cran/parallelDist
> devtools::install_github("alexeckert/parallelDist")
	更新 RcppArmad... (0.12.6.6.1 -> 0.12.8.4.0) [CRAN]
	同样报错



十分关键！！修改包编译文件：
	$ vim src/Makevars
	CXX_STD = CXX11
	#R_HOME=/opt/R/4.3.2/lib64/R
	#PKG_LIBS = `${R_HOME}/bin/Rscript -e "RcppParallel::RcppParallelLibs()"` $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)  #去掉R_HOME外的花括号，改为
	PKG_LIBS = `$R_HOME/bin/Rscript -e "RcppParallel::RcppParallelLibs()"` $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)
	这里的$()似乎都是函数，能否找到呢？


直接安装文件夹
$ cd ..
$ R CMD INSTALL parallelDist

在R中检查：
> packageVersion("parallelDist")
[1] ‘0.2.6’
成功安装！


继续安装 目的包：
> options(BioC_mirror="https://mirrors.westlake.edu.cn/bioconductor/")
> BiocManager::install("infercnv")

> packageVersion("infercnv")
[1] ‘1.18.1’

H3:8787 安装成功





(3). 下载使用镜像@J3
下载：
$ docker pull trinityctat/infercnv:latest

$ docker images
REPOSITORY             TAG       IMAGE ID       CREATED         SIZE
trinityctat/infercnv   latest    ee7df60bf751   4 months ago    5.1GB


运行：
$ cd /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv
$ docker run --rm -it -v `pwd`:`pwd` trinityctat/infercnv:latest bash



=>用户系统一致：
宿主机：
	$ id 
	uid=5662(wangjl) gid=1210(jinlab) groups=1210(jinlab),980(docker) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

容器内：
	新建组
	# groupadd -g 1210 dockerGroup
	新建用户
	# useradd -s /bin/bash -d /home/wangjl2  -m wangjl2 -u 5662 -g 1210
	# passwd wangjl2 #16
	# su wangjl2
	$ cd /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/
#








========================================
|-- inferCNV 示例
----------------------------------------

1. 准备三个输入文件
https://github.com/broadinstitute/inferCNV/wiki/File-Definitions

inferCNV requires:
* a raw counts matrix of single-cell RNA-Seq expression
* an annotations file which indicates which cells are tumor vs. normal.
* a gene/chromosome positions file

(1) Raw Counts Matrix for Genes x Cells
genes (rows) vs. cells (columns) containing assigned read counts
tab-delimited file.

(2) Sample annotation file
two columns, tab-delimited, and there is no column header.
The first column is the cell name, and the 2nd column indicates the known cell type.

MGH54_P2_C12    Microglia/Macrophage
MGH36_P6_F03    Microglia/Macrophage
MGH54_P16_F12   Oligodendrocytes (non-malignant)
MGH54_P12_C10   Oligodendrocytes (non-malignant)
MGH36_P1_B02    malignant_MGH36
MGH36_P1_H10    malignant_MGH36


(3) Gene ordering file
The gene ordering file provides the chromosomal location for each gene. 
The format is tab-delimited and has no column header, simply providing the gene name, chromosome, and gene span:

WASH7P  chr1    14363   29806
LINC00115       chr1    761586  762902
NOC2L   chr1    879584  894689
MIR200A chr1    1103243 1103332
SDF4    chr1    1152288 1167411
UBE2J2  chr1    1189289 1209265




2. 运行：两步

(1) create the infercnv object
library(infercnv)
infercnv_obj = CreateInfercnvObject(raw_counts_matrix="singleCell.counts.matrix",
                                    annotations_file="cellAnnotations.txt",
                                    delim="\t",
                                    gene_order_file="gene_ordering_file.txt",
                                    ref_group_names=c("normal"))

(2) perform infercnv operations to reveal cnv signal
infercnv_obj = infercnv::run(infercnv_obj,
                             cutoff=1,  # use 1 for Smart-seq2, 0.1 for 10x Genomics
                             out_dir="output_dir",  # dir is auto-created for storing outputs
                             cluster_by_groups=T,   # cluster
                             denoise=T,
                             HMM=T)

https://github.com/broadinstitute/inferCNV/wiki





(3) 内置函数
infercnv包也包含了画图函数plot_cnv

library(RColorBrewer)
infercnv::plot_cnv(infercnv_obj, #上两步得到的infercnv对象
                   plot_chr_scale = T, #画染色体全长，默认只画出（分析用到的）基因
                   output_filename = "better_plot", output_format = "pdf", #保存为pdf文件
                   custom_color_pal =  color.palette(c("#8DD3C7","white","#BC80BD"), c(2, 2))) #改颜色
#
plot_cnv(infercnv_obj,
         out_dir=tempfile(),
         obs_title="Observations (Cells)",
         ref_title="References (Cells)",
         cluster_by_groups=TRUE,
         x.center=1,
         x.range="auto",
         hclust_method='ward.D',
         color_safe_pal=FALSE,
         output_filename="infercnv",
         output_format="png",
         png_res=300,
         dynamic_resize=0
         )
#
https://www.rdocumentation.org/packages/infercnv/versions/1.3.3/topics/plot_cnv







3. 实战
(1) 准备3个文件
#筛选分析需要的细胞类型
seurat_object <- subset(seurat_object, idents=c('Epithelial cells', 'Myeloid cells', 'T cells'))
#抽样，仅用于该教程
# seurat_object <- subset(seurat_object, downsample=200)
counts <- GetAssayData(seurat_object, slot = 'counts')

#1) 表达矩阵
> counts[100:102,1:2]
3 x 2 sparse Matrix of class "dgCMatrix"
                AAACCTGAGGTTACCT-1_1 AAACCTGAGTTGCAGG-1_1
ARHGEF16                           .                    .
MEGF6                              .                    .
ENSG00000238260                    .                    .

最好输出为纯文本文件：
counts <- GetAssayData(scObj_epi, slot = 'counts') |> as.matrix()


#2) 细胞注释
anno <- data.frame(Idents(seurat_object))
colnames(anno)="celltype"
anno$celltype=paste0("c", anno$celltype) #转为字符串，否则可能报错

> table(anno$celltype)
  c0   c1  c10  c12  c14   c4   c5 
1432 1305  243  121   77  991  661

> head(anno)
                     celltype
AAACCTGAGGTTACCT-1_1       c4
AAACCTGAGTTGCAGG-1_1       c4
AAACCTGCAATCCAAC-1_1       c4


# 3) 基因注释
第一列为基因名称，第二列为染色体名称，第三列为基因起始位置，第四列为基因终止位置。
件制作方式见 https://github.com/broadinstitute/inferCNV/wiki/instructions-create-genome-position-file

先把脚本下载下来，再处理gtf文件，生成 human_genes_pos.txt
https://github.com/broadinstitute/infercnv/tree/master/scripts
https://github.com/broadinstitute/infercnv/blob/master/scripts/gtf_to_position_file.py
参考: python ./scripts/gtf_to_position_file.py --attribute_name "gene_name" your_reference.gtf human_genes_pos.txt

$ cd /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv

解压gtf文件
$ gunzip -c /picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/genes.gtf.gz > /picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/refdata-gex-GRCh38-2024-A.gene.gtf

$ python3 /picb/jinlab/wangjl/others/shenwh/script/gtf_to_position_file.py --attribute_name "gene_name" /picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/refdata-gex-GRCh38-2024-A.gene.gtf /picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/human_genes_pos.txt

$ cp /picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/human_genes_pos.txt .

$ wc human_genes_pos.txt 
  38583  154336 1312381 human_genes_pos.txt
$ head human_genes_pos.txt 
DDX11L2 chr1    11869   14409
MIR1302-2HG     chr1    29554   31109
FAM138A chr1    34554   36081
ENSG00000290826 chr1    57598   64116
OR4F5   chr1    65419   71585
ENSG00000238009 chr1    89295   133723
ENSG00000239945 chr1    89551   91105


gene_order <- "/picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/human_genes_pos.txt"



(2) 传输到docker中
# save as Rds
infercnv.input=list(
  counts,
  anno,
  gene_order
)
saveRDS(infercnv.input, paste0(outputRoot, keyword, "_4_1.infercnv.input.Rds"))

$ cp /picb/jinlab/wangjl/others/shenwh/PTC/output/PTC_4_1.infercnv.input.Rds /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/

# read to Docker R, in same uid and gid
$ R
infercnv.input=readRDS("/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/PTC_4_1.infercnv.input.Rds")

counts = infercnv.input[[1]]; 
anno = infercnv.input[[2]]; 
gene_order = infercnv.input[[3]]




(3) 创建R对象
library(infercnv)
infercnv_obj = CreateInfercnvObject(raw_counts_matrix = counts,
                                     annotations_file = anno,
                                     delim="\t",
                                     gene_order_file = gene_order,
                                     min_max_counts_per_cell = c(100, +Inf),
                                     ref_group_names = c("c14", "c2"))  #字符串格式，否则可能未知错误。
  #建议 normal 至少放2个细胞亚群，太多可以对cell id抽样，取子集:  ref_group_names = c("Myeloid cells", "T cells"))


提示：
INFO [2024-06-01 09:41:18] num genes removed taking into account provided gene ordering list: 897 = 3.21978534764349% removed.
WARN [2024-06-01 09:15:35] Please use "options(scipen = 100)" before running infercnv if you are using the analysis_mode="subclusters" option or you may encounter an error while the hclust is being generated.
> options(scipen = 100)






(4) 运行R主程序，及各种参数解释
The 'cluster_by_groups' setting indicates to perform separate clustering for the tumor cells according to the patient type, as defined in the cell annotations file.

* 如果没有 cluster_by_groups=T 参数的话,图形丑且不能用。
	以后都要设置T。
	cluster_by_groups=T, ## 选择TRUE是按样本分组。
	改为FALSE会进行按另一个参数k_obs_groups给出的分组数（默认为1）进行分组
* num_threads=50, # 设置线程数, 多线程运行，加快计算速度

* hclust_method="ward.D2", plot_steps=F) 可能第一列只有一类
* leiden_resolution = 0.01, 0.1, 0.2 和 0.6 的差异是：第一列的聚类？
* HMM = TRUE, 

* analysis_mode = "samples",  # analysis_mode ='subclusters' # 区分肿瘤亚型，慢

* noise_logistic = F, sd_amplifier = 1.3, 3 #降噪参数，越大越干净 #https://zhuanlan.zhihu.com/p/625589597?utm_id=0
* write_expr_matrix = T # 产生文件 infercnv.observations.txt https://www.jianshu.com/p/65d1841cb59b


注意两个参数cluster_by_groups=F，以及analysis_mode="subclusters"，这个参数最终会将肿瘤细胞分为8个cluster(少数情况是7类，如果实在找不出进一步的差别)，每个cluster有各自的CNV模式，如果analysis_mode="samples"，则一个样本不同细胞最终预测的CNV模式是唯一的。另外需要注意的是，一般文章放的热图是去噪后的热图，那张图两种模式没什么区别，因为去噪和预测CNV在inferCNV里面是分开的两步。



steps:
1) smoothing by chromosome
2) centering by cell
3) substracting normal from Tumor cells
4) De-noising
	denoise=TRUE
Or
5) CNV prediction
	HMM=TRUE



(4A) 初步尝试
infercnv_obj2 = infercnv::run(infercnv_obj,
                             cutoff=0.1,
                             cluster_by_groups=TRUE, 
                             out_dir="/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/A1/", 
                             k_obs_groups=8,
                             num_threads=50,
                             denoise=TRUE,
                             HMM=TRUE)

参数解释：
- cutoff：默认0.1，过滤低表达基因
	 use 1 for smart-seq, 0.1 for 10x-genomics
- min_cells_per_gene：默认3，过滤表达比例较低基因
- window_length：默认101，滑窗中包含的基因数目
- cluster_by_groups：默认FALSE，对肿瘤细胞进行聚类，展示为不同的亚群
	 cluster_by_groups=T, 选择TRUE是按样本分组；默认FALSE会进行按另一个参数k_obs_groups给出的分组数（默认为1）进行分组
- k_obs_groups：默认1，肿瘤细胞聚类数目
- num_threads：线程数
- denoise：默认FALSE，对CNV矩阵进行降噪
- out_dir = ".", 

- HMM=F, # 是否基于HMM预测CNV,True的话时间很久
- analysis_mode ='subclusters' # 区分肿瘤亚型，慢


报错: Error: unexpected input in "​"
	不知道原因，可能是 cluster不能是数字，必须是字符？
	改变R run 参数顺序
	这2个调整后，好了。
# 17:57-> 20:22, 共耗时 2.5h，4830个细胞





(4B) 快速运行
如果想提速，如下2个参数使用默认值：
* HMM参数 when set to True, runs HMM to predict CNV level (default: FALSE)
* denoise  If True, turns on denoising according to options below (default: FALSE) 

infercnv_obj2B = infercnv::run(infercnv_obj,
                             cutoff=0.1,
                             out_dir="/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/B/", 
                             cluster_by_groups=F, 
                             k_obs_groups=8,
                             num_threads=50,
                             denoise=F,
                             HMM=F)
# 21:21->



(4C) 最佳实践 1
如果想提速，如下2个参数使用默认值：
* HMM参数 when set to True, runs HMM to predict CNV level (default: FALSE)
* denoise  If True, turns on denoising according to options below (default: FALSE) 

infercnv_obj2C = infercnv::run(infercnv_obj,
                             cutoff=0.1,
                             out_dir="/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/C/", 
                             cluster_by_groups=T, 
                             #analysis_mode="subclusters", #默认是"samples"
                             num_threads=50,
                             denoise=T,
                             HMM=T)

建议：去噪，HMM预测CNV这两项一般都选上。
cluster_by_groups：先区分细胞来源，再做层次聚类 
个人觉得使用analysis_mode = "subclusters"模式后的热图更好看


(4D) 最佳实践 2
start = Sys.time()
infercnv_obj2D = infercnv::run(infercnv_obj,
                             cutoff=0.1,
                             out_dir="/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/D/", 
                             cluster_by_groups=T, 
                             analysis_mode="subclusters", #默认是"samples"
                             num_threads=50,
                             denoise=T,
							 write_expr_matrix = T, # 为了获得文件 infercnv.observations.txt
                             HMM=T);
Sys.time()- start   # Time difference of 2.750998 hours

添加参数再跑一遍 write_expr_matrix = T
	确实很快，出现文件 infercnv.observations.txt， 10776行，831MMb

保存结果：
> saveRDS(infercnv_obj2D, file=paste0("/picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/PCT_4_D2.epi_infercnv_obj2.Rds"))
转移：
$ cp /picb/jinlab/wangjl/others/shenwh/PTC/output/infercnv/PCT_4_D2.epi_infercnv_obj2.Rds /picb/jinlab/wangjl/others/shenwh/PTC/output/







(5) 结果解读: 4A运行的结果
InferCNV通过与一组参考正常细胞相比，探索肿瘤基因组不同位置的基因表达强度来推断染色体变异。通过绘制热图很容易就能看出肿瘤基因组中哪些区域与正常区域相比是发生了扩增还是缺失。


常见问题：
* 哪种细胞类型可能是潜在的恶性细胞？
* 参考正常细胞怎么选择？
* 参考正常细胞必须提供吗？
* 最终能得到哪些细胞属于恶性细胞的结果吗？


主要的结果文件：
	infercnv.preliminary.png ：初步 inferCNV 视图（去噪或 HMM 预测之前）
	* infercnv.png ：由 inferCNV 生成的最终热图，应用了去噪方法
	infercnv.references.txt ：正常/对照细胞矩阵数据
	* infercnv.observations.txt ：肿瘤细胞矩阵数据
	infercnv.observation_groupings.txt ：肿瘤细胞簇。
	infercnv.observations_dendrogram.txt ：与热图匹配的肿瘤细胞的 newick 格式树状图
	infercnv.heatmap_thresholds.txt


$ head infercnv.observation_groupings.txt
"Dendrogram Group" "Dendrogram Color" "Annotation Group" "Annotation Color"
"CTCTAATAGATCCGAG-1_1" "c0_s27" "#8DD3C7" "1" "#8DD3C7"
"CCGGGATTCGGCTTGG-1_1" "c0_s25" "#9AD8C4" "1" "#8DD3C7"
"CAGGTGCCACCATGTA-1_1" "c0_s24" "#A8DDC2" "1" "#8DD3C7"


$ cat infercnv.heatmap_thresholds.txt
0.831837776354686
0.854259406174062
0.876681035993437
0.899102665812812
0.921524295632187
0.943945925451562
0.966367555270937
0.988789185090312
1.01121081490969
1.03363244472906
1.05605407454844
1.07847570436781
1.10089733418719
1.12331896400656
1.14574059382594
1.16816222364531


ii) infercnv.png
一般需要查看的结果为infercnv.png，横坐标代表不同细胞，纵坐标代表染色体位置。

如果 inferCNV 结果较为可信的话，在上半部分，热图基本为白底，在下半部分，蓝色条带表示染色体基因低表达（缺失），红色表示高表达，其余文件可根据需要进行进一步分析。

热图展示每个细胞在各个染色体区域的相对表达强度，上方热图代表参考细胞的展示结果，下方热图代表目标细胞的展示结果。图中每一行表示一个细胞，每一列表示一个基因。

* 热图左边第一个图注代表聚类数目，只有一个时表示没有聚类，
* 左边第二个图注代表细胞类型，上方图注为对应排列的染色体。
* 红色表示CNV 扩增，蓝色表示CNV 缺失，颜色越深代表CNV变异越明显。


出现各种奇怪的图，基本就两个原因：
1.参数原因（cluster_by_groups和leiden_resolution参数特别重要）
2.细胞数量原因 。详情见官方链接 https://www.youtube.com/watch?v=-qOcHAavZT8









(5B) 4B的运行结果解读：https://cloud.tencent.com/developer/article/1737241

1) infercnv.observations.txt
每一列表示一个细胞，每一行表示一个基因，数值表示基因的CNV值。大于1表示扩增，小于1表示缺失。

为啥没这个文件了？
	https://github.com/broadinstitute/infercnv/issues/481
	
	Those files are generated at the same type as the plots if the "write_expr_matrix" option is set to TRUE, but the default is now set to FALSE and properly linked with plot_cnv.
	现在默认 write_expr_matrix=F，不输出这些文件。
	
	If you simply restart the same run of infercnv you already did but changing this option, it should reload a backup from the end of the process and simply plot the figure again while this time outputting the files.
	如果再跑一次，加上这些选项，则可以载入备份，直接输出这些文件。


2) infercnv.observations_dendrogram.txt
读取自己走完inferCNV流程后的结果文件夹里面的 infercnv.observations_dendrogram.txt 文件，里面存储着inferCNV的CNV热图的细胞的层次聚类情况：








(6) 结果美化
* 设置样品颜色 the colors of sample labels https://github.com/broadinstitute/infercnv/issues/319
* 设置热图颜色	https://github.com/broadinstitute/infercnv/issues/201
	custom_color_pal=color.palette(c("darkgreen", "white", "darkred"), c(2, 2)) #1.3.2
* infercnv.observations_dendrogram.txt 热图附带的层次聚类结果 https://cloud.tencent.com/developer/inventory/7049/article/1737241



========================================
|-- inferCNV 如何找到染色体缺失的那部分基因？和细胞id？
----------------------------------------
1. 二次利用

根据图 infercnv.png 判断哪个分组有CNV变异大的细胞，根据文件：
* infercnv.observations.txt #见上文 3(5B)
* infercnv.observation_groupings.txt
* infercnv_subclusters.observation_groupings.txt

如何取出CNV变化的cell id 和基因呢？





(1) 找到缺失的基因 ====
如何找到染色体缺失的那部分基因 https://zhuanlan.zhihu.com/p/600044931

library(dplyr)
library(ggplot2)
library(reshape2)

# 定义缺失列或感兴趣的列
chr_num<-c("chr1","chr6") #目测 infercnv.png 缺失的染色体

# 读取准备文件
exp.obs.All = read.table( paste0(outputRoot, "infercnv/D/infercnv.observations.txt"), sep = " ", header = T, check.names = F )
dim(exp.obs.All) #10775  4737
exp.obs.All[1:3, 1:3]
#          CCTTACGCACCAGATT-1_1 GATGAGGAGGTCGGAT-1_1 AGTTGGTGTGCGCTTG-1_1
#LINC01128             1.001399             1.001399             1.001399
#NOC2L                 1.001399             1.001399             1.001399
#PLEKHN1               1.001399             1.001399             1.001399

gene_order <- "/picb/jinlab/wangjl/ref/10x/refdata-gex-GRCh38-2024-A/genes/human_genes_pos.txt"
genecodev1 <- read.table(gene_order, sep = "\t", header = F)
rownames(genecodev1)=genecodev1$V1
dim(genecodev1) #[1] 38584     4
genecodev1[1:2, ]
#           V1   V2    V3    V4
#1     DDX11L2 chr1 11869 14409
#2 MIR1302-2HG chr1 29554 31109


# 定位缺失基因
chr_genes<-genecodev1[which(genecodev1$V2 %in% chr_num), 1] #5534
#exp.obs <- exp.obs.All[chr_genes,] %>% na.omit()  #1734 4737 this may not right!!??
exp.obs <- exp.obs.All[intersect( chr_genes, rownames(exp.obs.All) ),] #[1] 1695 4737


# gene表达均值的分布
hist(rowMeans(exp.obs), n=100, 
     mgp=c(2,1,0),
     xlab="Average expression/genes",
     main= paste0( "genes in ", paste(chr_num, collapse = ",")) )
abline(v=0.972, col="red", lty=2)


# 样本的Expression均值筛选，可以修改为0.9或1左右，根据热图结果自己控制，数字越小越严格
selected_exp <- exp.obs[which(rowMeans(exp.obs)<0.972), ]%>%as.matrix()
dim(selected_exp) #100 4737
selected_exp[1:2, 1:2]
#        CCTTACGCACCAGATT-1_1 GATGAGGAGGTCGGAT-1_1
#CEPT1               1.001399            0.9158052
#DENND2D             1.001399            0.9161874


heat_data<-reshape2::melt(selected_exp) #长宽矩阵转化，为作图准备
colnames(heat_data)=c("symbol", "cell_id", "value")
head(heat_data)

# 查看缺失列的expression热图
ggplot(heat_data, aes(symbol, cell_id, fill= value)) + 
  geom_tile() +  labs(x="")+ theme_classic()+
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1),
    axis.text.y = element_blank(),
  )+
  scale_fill_gradient2(low ="#00008b",mid = "#ffffff",high = "#8b0000",midpoint = 1)

# 输出genes
write.table(x = row.names(selected_exp), 
            file = paste0(outputRoot, "infercnv/D/interest_genes.del.chr1_6.txt"), 
            sep = "\t",row.names = F,col.names = F,quote = F)
row.names(selected_exp) |> head()


## 阈值为1时
可以看到基本expression都是小于1的，也有接近于1的情况

## 阈值为0.9时
得到的基因基本都满足条件了

## 当然还有输出基因的结果
这个文件中的基因即可进行后续分析
> row.names(selected_exp) |> head()
[1] "CEPT1"           "DENND2D"         "ENSG00000272009" "ZNF165"          "ZSCAN26"         "ZSCAN31"  
......







(2) pheatmap ====
#get cell_id and cluster
scObj_epi$cid=rownames(scObj_epi@meta.data)
cell_info=FetchData(scObj_epi, vars = c("cid", "seurat_clusters"))
cell_info$seurat_clusters=paste0("c", cell_info$seurat_clusters)
cell_info=cell_info[order(cell_info$seurat_clusters),]
head(cell_info)

# 构建行注释信息:cell
annotation_row = data.frame(
  cluster = cell_info$seurat_clusters
)
rownames(annotation_row) = cell_info$cid
head(annotation_row)
table(annotation_row$cluster)


# 构建列注释信息: gene
rownames(genecodev1)=genecodev1$V1
annotation_col = genecodev1[rownames(selected_exp), c(1,2)]
colnames(annotation_col)=c("symbol", "chr")
annotation_col=annotation_col[order(annotation_col$chr), ,drop=F]
annotation_col=annotation_col[,2, drop=F]
head(annotation_col)
table(annotation_col$chr)


# 自定注释信息的颜色列表
ann_colors = list(
  cluster = c(c0="#8DD3C7", c1="#CAAEC5", c10="#B2B2A5", c12="#DED3B3", c4="#C191C2", c5="#FFED6F"),
  chr = c(chr1 = "#8DD3C7", chr6 = "#CFA9BB")
)

# order cid
dat=t(selected_exp)
common_cids=rev( intersect(cell_info$cid, rownames(dat)) )
dat=dat[common_cids, rownames(annotation_col)]

dim(dat) # 4737 343
dat[1:2, 1:2]
write(dat, paste0(outputRoot, "infercnv/D/interest_genes.del.chr1_6.heatmap.txt"))

library(pheatmap)
pdf(paste0(outputRoot, "infercnv/D/interest_genes.del.chr1_6.heatmap.pdf"), width=5, height=4)
pheatmap::pheatmap(dat, border_color =NA,
                   annotation_row = annotation_row, #row: cell cluster
                   annotation_col = annotation_col, #col: gene chr
                   annotation_colors = ann_colors,
                   cluster_rows=F, cluster_cols=F,
                   show_rownames=F,
                   show_colnames=F,
                   main="Del chr1,chr6")
dev.off()
#



(3) boxplot
http://www.360doc.com/content/21/0715/15/76149697_986667784.shtml

- 读取infercnv.observations.txt文件来计算CNV score
- 按照分区填充新矩阵
	[范围) 评级，填充值，意思
	[  0, 0.3) A, -2; # complete loss. 2pts
	[0.3, 0.7) B, -1; # loss of one copy. 1pts
	[0.7, 1.3) C, 0; # Neutral, 0pts
	[1.3, 1.5) D, 1; # addition of one copy. 1pts
	[1.5, 2) E, 2; # addition of two copy. 2pts
	[2, ) F, 2; # addition of more than two copy. 2pts

绘制 cnv score:
	按cell cluster
	按是否是肿瘤
	按样品










2. inferCNV结合UPhyloplot2分析肿瘤进化
https://www.dxy.cn/bbs/newweb/pc/post/45112367


这个小软件其实很简单，两百行代码，只有一个功能就是画图，里面唯一的分析就是计算一下各种CNV cluster的比例，小于5%的cluster不画。

https://github.com/harbourlab/uphyloplot2

单独看每一个样本的进化树，上方主干对应的CNV事件，是早期就发生的；下方分枝的CNV事件是后期发生的。其中蕴含的逻辑就是含有某个CNV的细胞占比越多，那么这个CNV就发生得越早；含有某个CNV的细胞占比越少，这个CNV就发生得越晚。

注意：这种方法做出的进化树只涉及细胞占比信息，和其他利用突变数量推测molecular time的算法不一样。 ﻿









ref:
https://zhuanlan.zhihu.com/p/625589597?utm_id=0









========================================
CITE-seq 同时测蛋白量
----------------------------------------
1. 背景介绍

(1) paper: https://www.nature.com/articles/nmeth.4380
	nature-2017: Simultaneous epitope and transcriptome measurement in single cells
之前是用 专家选的 marker 抗体，用荧光标记细胞，通常能指示细胞活性或功能。

最近的研究，结合 流式的 index-sorting 方法 和 单细胞转录组 是有可能的。
然而，基于 微流控、孔板、index组合等和流式不兼容，不能扩增到蛋白信息上。
靶向法只能同时平行测试很有限的几个基因和蛋白。

本文 CITE-seq 结合了多路蛋白信号检测与上千细胞的无偏转录谱分析。
本文可用于高通量单细胞应用，展示了2个模型比一个更能展示细胞表型的细节特征。

我们设计了数字化、可测序的蛋白水平读数 - 通过连接抗体和核算序列oligo，
	后者可以被 oligo-dT 引物捕获。
	包含抗体身份信息
	包含PCR扩增接头
	streptavidin–biotin 反应连接 oligo 的5'端 和抗体
	一个二硫键可以让oligo在还原环境下解离 Fig.1a

步骤:
	抗体-oligo 复合物先和单细胞悬液共培养，流式液体中。
	然后wash掉多余的抗体
	Drop-seq 微滴化
	每个微滴内的细胞裂解后，细胞mRNA和抗体来源的oligo，通过3'polyA 尾巴结合到 带polyT的珠子上；
	反转录，添加cell barcode;
	cDNA和抗体来源的tag可以通过大小分开，分别转化为测序文库。
	
Importantly, because the two library types are generated separately, their relative proportions can be adjusted in a pooled single lane to ensure that the required sequencing depth is obtained for each library.
因为是独立建库，他们的相对量可以在混库时调整，以便每个文库的测序深度都符合预期。

文章还有一个官网: https://cite-seq.com/


https://www.jianshu.com/p/442d890d12ea




2. 分析教程


教程: https://satijalab.org/seurat/articles/multimodal_vignette.html







========================================
单细胞整合方法 简介与比较
----------------------------------------
scRNA-seq 数据集整合方法
https://www.jianshu.com/p/5b88bf5434bc

	MNN,
	CCA,
	Harmony、
	LIGER（最近成为 rliger）
	和 Seurat (v3) 的表现最好。





========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

