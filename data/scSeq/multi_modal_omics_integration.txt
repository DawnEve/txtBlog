多模态、多组学 单细胞数据整合





========================================
Seurat 多组学整合 CCA: 典型相关分析（canonical correlation analysis): 快速分析多变量的相关关系
----------------------------------------
1. CCA 权威资料
https://blog.csdn.net/weixin_60734652/article/details/133022518

Comprehensive Integration of Single-Cell Data, Cell 2019
	https://www.sciencedirect.com/science/article/pii/S0092867419305598


CCA & singleR
	https://www.jianshu.com/p/0887b49122eb




2. 要解决的问题
CCA 就是联系2个不相关的多变量之间的相关性。

(1) 实例
比如几百个学生的 多学科成绩矩阵A(语数外数理化史地生)，和学生其他指标矩阵B(身高体重肺活量百米握力睡眠时间等)，是否有关系？

A: m1*n
B: m2*n
其中n是样本个数：学生个数
m1和m2是不同类别的特征的维度：成绩的学科m1个，其他指标个数m2个。

思路1：对2个矩阵中的每个特征列，两两求相关性。
缺点：我们直接对这些变量的相关进行两两分析，很难得到关于这两组变量之间关系的一个清楚的印象

我们需要把多个变量与多个变量之间的相关化为两个具有代表性的变量之间的相关

代表：能较为综合、全面的衡量所在组的内在规律
一组变量最简单的综合形式就是该组变量的线性组合

典型相关分析是研究两个多变量（向量）之间之间的线性相关关系，能够揭示出两组变量之间的内在联系。


(2) 算法的提出

在一元统计分析中，用相关系数来衡量两个随机变量的线性相关关系，用复相关系数研究一个随机变量与多个随机变量的线性相关关系。然而，这些方法均无法用于研究两组变量之间的相关关系，于是提出了CCA

一般有两个典型的目的：
- 数据简化：用少量的线性组合来解释两组变量之间的相关作用。
- 数据解释：寻找特征值，这些特征值对于解释两个变量集合之间的相互作用十分关键。


(3) 与主成分分析（PCA）之间的关系：
典型相关分析的基本思想和主成分分析的基本思想相似，它将一组变量与另一组变量之间单变量的多重线性相关性研究，转换为少数几对综合变量之间的简单线性相关性的研究，并且这少数几对变量所包含的线性相关性的信息几乎覆盖了原变量组所包含的全部相应信息。

联系：无论是典型相关分析还是主成分分析，都是线性分析的范畴，一组变量的典型变量和其主成分都是经过线性变换，通过计算矩阵的特征值与特征向量得出的。

区别：主成分分析中只涉及一组变量的相互依赖关系，而典型相关则扩展到了两组变量之间的相互依赖的关系之中，度量了这两组变量之间联系的强度。



(4) 分析步骤
1)首先在每组变量中找到变量的线性组合，使得两组的线性组合之间具有最大的相关系数。
2)然后选取和最初挑选的这对线性组合不相关的线性组合，使其配对，并选取相关系数最大的那一组。
3)如此继续配对，直到两组变量之间的相关性被提取完。


(5) 典型相关系数的假设检验
在做两组变量 X，Y 的典型相关分析之前，首先应该检验两组变量是否相关，如果不相关，则讨论两组变量的典型相关就毫无意义。

最多可以选取 r = min(p,q) 组，可经由卡方检验决定要选取多少组典型变量。先检验最大的典型根，然后再一个接一个对各个根进行检验，只保留有统计显著性（就是拒绝原假设）的根。


(6) 冗余分析
在进行样本典型相关分析时，分析每组变量提取出的典型变量所能解释的该组样本总方差的比例，称为冗余分析。冗余分析包括组内代表比例和交叉解释比例，是典型相关分析中很重要的部分。

组内代表比例是指本组所有观测变量的总标准方差中由本组形成的各个典型变量所分别代表的比例；

交叉解释比例是指一组变量形成的典型变量对另一组观测变量的总标准方差所解释的比例， 是一种组间交叉共享比例。

冗余分析可以定量地测度典型变量所包含的原始信息量的大小。


实际上，只需要掌握典型相关分析的基本原理，基本思想就可以了，具体实际操作并不难，不需要通过公式进行计算，目前基本上是使用SPSS进行分析。




(7) CCA的解释和限制
CCA的建模目标是实现多个矩阵的共同分解。这个目的使得该工具对于处理跨多个调查层面的丰富样本描述的人群观察特别有用。然而，这种分析技术是否更接近于数据的描述性重表达（即，无监督建模）还是应该更容易理解为预测性降维回归的一种形式（即，监督建模，参见Bach和Jordan，2005；Bzdok等人，2018；Breiman和Friedman，1997；Witten等人，2009）仍然是一个持续的争论。

两种观点都有合理的论据。监督算法依赖于一个指定的建模目标，该目标将从一组输入变量中预测，而无监督算法旨在在没有与模型估计期间可用的关联基准标签的情况下提取观察中的连贯模式（Hastie等人，2001）。有可能随着其中一个变量集的维数减少以接近大多数线性回归类型方法的单一输出，在这种情况下，CCA可能更类似于更多的监督建模方法。相反，随着双方变量集的不断增大，应用CCA可能更接近无监督建模方法的精神。

总的来说，CCA模型是一种相对独特的方法——“介于两者之间”——它共享了监督和无监督方法的经典属性。


限制：

在这种通用建模目标的三重视图背景下，CCA可能最自然地符合估计类别，而不是主要的预测或推断工具。由于其探索性质，CCA通常对于专注于揭示复杂高维空间中简洁原则的应用非常有用，作为手头观测的替代描述。


与许多统计方法一样，观测值的数量n与变量的数量p之间的关系是考虑CCA是否可能有用的关键方面（Giraud, 2014; Hastie et al., 2015）。普通CCA只能在数据中的观测值数量多于较大变量集的变量数量时才能产生有用的模型拟合（即，n > max(p;q)）。具体来说，如果分析中包括的个体数量接近大脑或行为或基因组变量的数量，那么CCA将很难估算出存在于人口中的任何潜在维度






3. 具体实现
实际上，只需要掌握典型相关分析的基本原理，基本思想就可以了，具体实际操作并不难，不需要通过公式进行计算，目前基本上是使用R语言进行分析。

好的示例：
R code for ecological data analysis, CCA part:
	https://userweb.eng.gla.ac.uk/umer.ijaz/bioinformatics/ecological.html


(1)两个对象分别做分析后：合并后细胞是两个对象的细胞数之和，cell id会加后缀_1, _2。

=> 是不同细胞的转录组整合。

scObj_intigrat.anchors = FindIntegrationAnchors(object.list =  list(scObj_RNA, scObj_DPAU), dims=1:30)
#Retained 3034 anchors
scObj_intigrat = IntegrateData(anchorset = scObj_intigrat.anchors, dims = 1:30)
DefaultAssay(scObj_intigrat) <- "integrated"
scObj_intigrat #6132

# pipe
scObj_intigrat <- ScaleData(scObj_intigrat, verbose = FALSE)
scObj_intigrat <- RunPCA(scObj_intigrat, npcs = 30, verbose = FALSE)
scObj_intigrat <- RunUMAP(scObj_intigrat, reduction = "pca", dims = 1:30)
scObj_intigrat <- FindNeighbors(scObj_intigrat, reduction = "pca", dims = 1:30)
scObj_intigrat <- FindClusters(scObj_intigrat, resolution = 0.5)

# save Rds
saveRDS(scObj_intigrat, file = paste0(outputRoot, keyword, "_03_1-CCA.DPAU_RNA.Seurat.Rds"))








========================================
Seurat 多组学整合 WNN (加权最近邻)：Using Seurat with multimodal data: scRNA-seq & 蛋白组 CITE-seq
----------------------------------------
1. 教程
https://satijalab.org/seurat/articles/multimodal_vignette

Weighted Nearest Neighbors (WNN) approach
	https://www.cell.com/cell/fulltext/S0092-8674(21)00583-3




2. 代码实现

两个对象分别做分析后：合并后细胞数不变
=> 是同一个细胞的不同多组学数据的整合。

## (1) to one object ====
scObj=scObj_RNA

# 1) set DPAU assay
DPAU_assay=scObj_DPAU@assays$RNA
DPAU_assay@key="dpau_"
scObj[["DPAU"]] <- DPAU_assay
DefaultAssay(scObj)

# 2) set DPAU pca
DPAU_pca=scObj_DPAU@reductions$pca
DPAU_pca@assay.used="DPAU"
scObj@reductions$pca2=DPAU_pca


## (2) [WNN] in same cell ====
scObj <- FindMultiModalNeighbors(
  scObj, reduction.list = list("pca", "pca2"), 
  dims.list = list(1:30, 1:10), modality.weight.name = "RNA.weight"
) #RNA.weight DPAU.weight
scObj #3066
#Warning messages:
#1: Cannot add objects with duplicate keys (offending key: normPC_), setting key to 'pca2.norm_' 
#2: In FindMultiModalNeighbors(scObj, reduction.list = list("pca", "pca2"),  :
#   The number of provided modality.weight.name is not equal to the number of modalities. RNA.weight DPAU.weight are used to store the modality weights

scObj <- RunUMAP(scObj, 
                 nn.name="weighted.nn", 
                 reduction.name = "wnn.umap",
                 reduction.key = "wnnUMAP_",
                 verbose = T)
scObj = FindClusters(scObj, graph.name = "wsnn", algorithm = 3, resolution = 1) #0.5


## (3) Dim plot ====
pdf(paste0(outputRoot, keyword, "_2_3.UMAP.DimPlot.pdf"), width = 3.8, height = 3.4)
DimPlot(scObj, reduction = "wnn.umap", label=T, #label.size = 2.5,
        repel = F)+  #NoLegend()+
  ggtitle("WNN: DPAU+RNA");
dev.off()







========================================
基于多组学聚类R包 SNFtool：Similarity Network Fusion //todo
----------------------------------------











Ref:
http://th.archive.ubuntu.com/cran/web/packages/SNFtool/
https://www.rdocumentation.org/packages/SNFtool/versions/2.3.1
https://github.com/maxconway/SNFtool
R语言之基于多组学的肿瘤亚群聚类分析 https://cloud.tencent.com/developer/article/2171119







========================================
多组学的例子：
----------------------------------------
1.
https://pubmed.ncbi.nlm.nih.gov/35288753/  Fig3A










========================================
----------------------------------------



========================================
----------------------------------------






========================================
----------------------------------------



========================================
----------------------------------------






========================================
----------------------------------------



========================================
----------------------------------------






========================================
----------------------------------------



========================================
----------------------------------------



