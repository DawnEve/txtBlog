java SE入门到精通


All my code: https://github.com/DawnEve/learngit/tree/master/Java
https://www.runoob.com/java/number-pow.html


一天精通: https://www.cnblogs.com/happyframework/p/3332243.html



========================================
Java 基础(30天入门)：Java 11
----------------------------------------

1. java中常用的几个包介绍
包名	说明
java.lang	该包提供了Java编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread等，不使用该包就很难编写Java代码了。

java.util	该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。

java.io	该包通过文件系统、数据流和序列化提供系统的输入与输出。
java.net	该包提供实现网络应用与开发的类。
java.sql	该包提供了使用Java语言访问并处理存储在数据源（通常是一个关系型数据库）中的数据API。

java.awt
javax.swing
这两个包提供了GUI设计与开发的类。java.awt包提供了创建界面和绘制图形图像的所有类，而javax.swing包提供了一组“轻量级”的组件，尽量让这些组件在所有平台上的工作方式相同。

java.text	提供了与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。



(1) 知识层面 https://mikechen.cc/17129.html

1)基础:
	编程基础
	面向对象OOP
	Java集合
	注解
	异常处理
	输入/输出

2) 高级特性：
	IO流
	枚举和注解
	集合
	泛型
	常用类：字符串、日期、随机数
	
	多线程
	并发编程
	反射机制
	网络编程
	
	Lambda表达式和Stream API的使用
	Java9 & Java11

3) 数据结构和算法：有经验后再继续
	数据结构
	算法
	设计模式：经典的23种
	JVM: Java虚拟机，底层

4) Java 框架
	Spring
	Spring MVC
	Spring Boot
	Spring Cloud
	Mybatis
	Redis
	RoketMQ等

5) 开发工具
	web 调试工具
	集成开发工具 Eclipse
	版本控制工具 Git
	构建工具 Maven
	Java 调试工具

6) 架构技术
	微服务
	中间件
	分布式架构
	容器部署



(2) 把个人融入到集体的发展中
学习的百分比:
	工作中学到 70%
	向他人学习 20%
	自我学习 10%


(3) 学习方法
- 保证听得懂：一天保证三个小时，并提高效率，要思考。
- 要敲三遍，运行: 必须手动，脑子和手是不同步的；知识？技能？骑自行车。
	代码量上来，就熟练了。
	三分看，七分练
- 整理笔记，模仿好的编码习惯/工具：模仿到走





2. 基础 

基础资料 https://www.w3schools.com/java/java_switch.asp
官方基础资料 https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html
官方API: https://docs.oracle.com/javase/8/docs/api/

学习方法: 
	视频讲解 https://www.bilibili.com/video/BV1Kb411W75N/
	看教程 https://www.weixueyuan.net/view/6316.html
	写代码 把 learngit 中的 重写一遍，不漏掉注释


大纲
	共有: 关键字、数据类型、运算符、流程控制、数组
	OOP(重点): 类/对象，类的结构，三大特性，接口，设计模式, 异常处理
	app开发: 集合,IO/NIO, 类库，多线程，反射，网络，JDBC->Oracle/MySql;
	新特性: 泛型，元注解，装箱-拆箱，枚举，可变参数，Lambda表达式，Stream API，Date/Time API
	三个项目: 家庭记账系统，客户信息管理系统，开发团队人员调度软件；
	附加项目：银行业务管理系统，单机考试管理系统



Java程序由package+class组成，package对应目录的相对路径，class对应文件




========================================
|-- Java历史、环境、hello world、注释、API文档
----------------------------------------
1. Dos 命令: 对应的 linux 命令
dir: ls
cd:
md: mkdir
echo: : echo age=12;name=xiaoming>a1.txt 
exit:
del: rm 删除文件
rd: rmdir 删除目录
	rd dirName1 只能删除空目录
	del dirName2 递归删除文件，然后再 rd dirName2

.. 上一级目录
. 本级目录

换盘符: 直接输入盘符 D: 回车。


2. Java 历史
常用的 1.6-1.8之间。

Java 是类C语言
	舍弃了 C的指针：
	自动 GC 垃圾回收：Java会出现内存泄漏和内存溢出问题吗？会。
	JVM：Java 虚拟机

特点
	OOP: 类/对象的概念，三大特征：封装、继承、多态
	健壮性：指针、垃圾回收 容易出问题，Java有优化
	跨平台: JVM 实现本身不是跨平台的


3. 环境
(1) Java
JDK =  JRE + 开发工具集(如 Javac 编译工具)
JRE = JVM + JavaSE 标准类库

https://www.oracle.com/cn/java/technologies/downloads/archive/
https://www.oracle.com/cn/java/technologies/javase/javase8u211-later-archive-downloads.html
https://www.oracle.com/cn/java/technologies/javase/javase8u211-later-archive-downloads.html#license-lightbox

安装时的目录：英文、不能有空格。

JDK8 有部分协议变了：
jdk/下的目录：
	bin/ 工具目录, java, javac, javadoc
	db/ 数据库 ...
	include/ *.h C库
	jre/ 运行环境
	lib/ *.jar包
	src.zip 开源代码


设置环境变量：cmd进入jdk的bin目录执行；想在任何地方执行，需要设置环境变量。
	admin 对当前用户有效；系统变量 对所有人有效（推荐）；设置哪个都行，要坚持一个。
	path: windows 执行命令时的搜索顺序，先在当前路径找，然后在path中找。
		JAVA_HOME=D:\xx\jdk8_x\
		path: %JAVA_HOME%\bin\
		这么搞是因为tomcat需要变量 JAVA_HOME
	测试: java, javac
	可以安装几个版本，使用时看配置的是什么就用的什么。


C:\Users\admin>java -version
java version "1.8.0_161"

需要显示后缀。


(2) IDE
https://www.eclipse.org/downloads/
https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2022-12/R/eclipse-inst-jre-win64.exe






4. Hello world 
(1) 编写源文件：记事本新建文件 Hello.java
public class Hello{
	public static void main(String[] args){
		System.out.print("hello, world!!!");
	}
}

(2) 编译文件 (javac xx.java)
我的电脑-找到桌面-地址栏输入 cmd 回车，自动在当前了路径（桌面）打开cmd工具。

> javac Hello.java
没有报错，就是编译成功。
查看桌面，发现多了 Hello.class 文件。


(3) 解释运行 字节码文件(java xx) 
D:\Desktop>java Hello
hello, world!!!


(4) 注意
Java是大小写敏感的！但是windows不区分大小写，所以大小写写错不报错。
	而linux 是区分大小写的。
文件找不到，可能路径错误，文件名错误。

一个文件可以有多个类。
	编译后一个类对应一个class文件，字节码文件和类名一样。
但是一个文件只有有一个public类
	这时文件名要和 public 类同名。

入口文件是 main，是固定的。







5. 注释
Java的三种注释
	单行注释 //
	多行注释 /*   */，多行注释 不能嵌套使用。
	文档注释(Java 特有) /**   */

(1) 文档注释实例
文件 Hello.java 内容，保持ansi格式，否则中文报错。
/**
文档注释实例for class
@author 张三的老板
*/
public class Hello{
	/**
	文档注释 for main 方法
	@author 张三
	@version v0.2	
	*/
	public static void main(String[] args){
		System.out.print("hello, world!!!");
	}
}

编译
D:\Desktop\hi>javadoc -d docs -author -version Hello.java
D:\Desktop\hi

打开其中的 \hi\docs\index.html 文件，可见
类的注释，在最顶部。
方法的注释，在 方法概要 表格中。




6. Java API 文档
https://docs.oracle.com/javase/8/docs/

教程
https://docs.oracle.com/javase/tutorial/
Getting Started — An introduction to Java technology and lessons on installing Java development software and using it to create a simple program.
Learning the Java Language — Lessons describing the essential concepts and features of the Java Programming Language.
Essential Java Classes — Lessons on exceptions, basic input/output, concurrency, regular expressions, and the platform environment.
Collections — Lessons on using and extending the Java Collections Framework.
Date-Time APIs — How to use the java.time pages to write date and time code.
Deployment — How to package applications and applets using JAR files, and deploy them using Java Web Start and Java Plug-in.
Preparation for Java Programming Language Certification — List of available training and tutorial resources.


下载
https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html
使用方法：点击右侧的 Java SE API，可以打开熟悉的帮助页面。
左侧找到 java.lang 包，类选择 String，右侧就可以看到帮助文档。





7. 常用的编辑器
文本编辑器
	记事本
	UltraEdit
	EditPlus

IDE:
	JBuilder 历史
	NetBeans 历史
	Eclipse: IBM 开发的，免费的
	myEclipse: 收费版，集成了插件
	IDEA: 最新的，很流行，设计更人性化，功能和 Eclipse 相同





ref: https://www.bilibili.com/video/BV1Kb411W75N/?p=18
2023.3.12 19,20, 21-26, 27 概述,28,29-30安装环境, 31-32设置环境变量。
	33-34 hello world; 35 EditPlus编辑器; 37 文档注释；39 Java API 文档
	41.编码风格，IDE。42考试; 43-44复习;




========================================
|-- Java 语言基础: 关键字/保留字/标识符、数据类型、运算符、流程控制
----------------------------------------
1. 关键字、保留字
类、流程控制、数据类型等。
异常处理

保留字：以后可能会用的: goto, const

注意：Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。

(2) 标识符规则，就是变量名、类名、方法名、接口名等，自己能起名字的地方
1) 规则：不遵守报错
26个字母大小写、数字、下划线、$符，不能有空格: class Dog_${}
开头不能是数字。
不能使用关键字，但是可以包含关键字: int static1=3;
严格区分大小写，长度无限制

2) 规范，就是习惯。不遵守影响别人阅读
包名：小写，多个单词小写 xxyy
类名: 单词首字母大写: XxYy, class Cat{}
变量名、方法名：单词首字母大写，第一个单词首字母小写: xxYy, myCat, charAt(); 
常量名：所有字母都大写、多单词时每个单词用下划线连接 XX_YY, MY_PI=3.14

要见名知意。
谨慎使用单字母变量。

变量名可以用中文，但是会被鄙视。

(3). 变量
Java是强类型语言，声明变量时必须明确类型。
1) 声明变量
int myAge=12;
类型 变量名=变量值;

2) 作用域内有效





2. 数据类型
8种原子类型
小数类型的常量默认是double类型，声明float类型的常量需要使用F作为后缀。

	整数类型：byte、short、int和long。
	小数类型：float和double。
	字符类型：char。
	布尔类型：bool。
	除此之外的是interface、class和array。


基本数据类型 primitive type
	数值: 整数(byte, short, int, long), 浮点数(float, double)
	字符(char)
	布尔(boolean)
引用数据类型 reference type
	类 class: 字符串是一个String 类，是引用类型。
	接口 interface
	数组[]


(1) 整型
类型  占用存储空间   表示范围
byte 1字节=8bit位    -128~127: -2^7~2^7-1
short 2字节         -2^15 ~ 2^15-1
int 4字节         -2^31 ~ 2^31-1
long 8字节         -2^63 ~ 2^63-1

byte b1=128; //编译报错 错误: 不兼容的类型: 从int转换到byte可能会有损失
long L2=1234567895L; //long的结尾必须有一个大写或小写的L结尾，不加会怎样？


(2) 浮点数
单精度 float  4  -3.403E38~3.403E28 
双精度 double 8   -1.798E308~1.798E308

float 占4个字节，但是比long表达的范围大。缺点是小数点后的不精确。


float b3=12.5; //错误: 不兼容的类型: 从double转换到float可能会有损失
float b3=12.5f; //末尾要加F或f


(3) 字符类型 char 
一个字符占用2个字节。
声明时使用单引号。只能有一个字符。
char c1='c';

转义字符 \n 表示换行; \t 制表符(tab键); 
char c2='\n'; 

或者使用 unicode 值表示字符 '\uXXXX'
char c3='\u0123'; //表示问号，可能是无法输出。
char c3='\u0043'; //表示大写C

字符集 
基本的 ascii，只有中文。
后来放大的 unicode，最后的实现是 UTF-8

cmd 命令行默认是 gbk 格式。
如果保存的文件不是 gbk，则可能报错。
各字符集中的 ascii 部分是一致的，其余差异很大。


(4) 布尔型
判断时，循环中使用。
boolean b2=true;


(5) 七种数据类型的互相运算(除了 布尔 外的7种)
- 自动类型提升
    1) byte,short,char ->int->long->float->double: 逐步提升，两两运算的结果是容量大（类型范围，不是所占字节）的类型。
    char呢？ 一个字符是2个byte。测试发现用short接收报错“错误: 不兼容的类型: 从int转换到short可能会有损失”
		说明 需要使用 int 接收 char 类型。
    2) 特别地: byte,char,short三种做运算时，包括同种类型的运算，结果都是int类型。


- 强制类型转换
	1)就是自动类型提升的逆运算: 
		int i2= (int)15.9; //15 浮点数变整数就是截断小数部分，不是四舍五入。
	2)可能导致精度损失: 上文损失小数点，下例符号变了，变为另一个极值。
		byte b1=(byte)128; //-128


- 两个错误，编码习惯问题: 
	1) long 类型的要有后缀L或l，否则可能出错。（默认int范围不报错，超过int则报错）
		long t1=123; //右边默认是 int，赋值给long 相当于自动提升了。不报错。
		long t2=12345678912345678L; //如果不加L则报错：错误: 过大的整数
	整型默认是int。
	浮点数默认是 double，所以声明 float 必须加后缀 F或f，否则肯定报错。因为float比double小。
		float f1=12.5; //错误: 不兼容的类型: 从double转换到float可能会有损失
	3) 编码情况2
		byte b1=12;
		byte b2=b1+0; // 错误: 不兼容的类型: 从int转换到byte可能会有损失
		加上0也是提升为int。


(6) 字符串
- char 不能为空，String可以。
	String s1="abc";
	String s2=""; //可以
	char s3=''; //错误: 空字符文字

- 字符串也可以包含unicode字符
	String a="\u0001"; System.out.print(a);


(7) 常量 final 修饰，命名通常大写 
	final double PI = 3.1415927;
	PI=3.5; //错误: 无法为最终变量PI分配值







3. 运算符
算术运算符：+、-、*、/ 和 %，两个整数相除，结果还是整数。
赋值运算符：=、+=、-=、*=、/=、%=、&=、|=、~=、^=、<<=、>>= 、 >>>=、++ 和 --。
比较运算符：==、!=、<、<=、> 和 >=。
逻辑运算符：&&、|| 和 !。
	短路运算：使用 A && B 时，如果A已经false，则跳过B的运算。
位运算符：&、|、~、^、<<、>> 和 >>>。
	~	按位取反运算符翻转操作数的每一位，即0变成1，1变成0。
	^	如果相对应位值相同，则结果为0，否则为1
三元运算符: variable x = (expression) ? value if true : value if false

instanceof 运算符：检查该对象是否是一个特定类型（类类型或接口类型）。 obj instanceof ClassName;
	String name = "James";
	boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真

运算的优先级
	查表
	不放心就多加括号




4. 控制结构
条件：if...else if...else、switch-case-default和三元运算符（?:）。
		int week=6;
		switch(week){
			case 1:
			   //语句
			   break; //可选
			case 2:
			case 3: //可以多个连写
			   //语句
			   break; //可选
			//你可以有任意数量的case语句
			default : //可选
			   //语句
		}
循环：while、do-while、for和foreach。
	int[] arr={1,5,8};
	for(int x : arr ){
		System.out.println(x);
	}
break; 退出循环
continue; 跳过本次循环。

Labeled block。







ref: https://www.bilibili.com/video/BV1Kb411W75N/?p=45
2023.3.12 45关键字, 命名规范; 48 变量; 49 先声明再使用; 50 变量类型
	51 整型变量; 52 浮点数; 53 字符类型 54 字符集; 55布尔型; 56 自动类型转换
2023.3.13 56 自动类型转换, 58 强制类型转换; 59 运算规则的特殊情况; 60 string 是引用类型。


========================================
>>> 多看书，多练习，多总结！ | 当前Java进度: https://www.bilibili.com/video/BV1Kb411W75N/?p=56
----------------------------------------
docs: https://docs.oracle.com/javase/8/docs/
file:///G:/books_on_coding/Java/java8_docs/api/index.html

https://www.weixueyuan.net/view/6316.html

快速入门 https://www.cnblogs.com/happyframework/p/3332243.html


老代码: G:\java_code\src\mio\DataTypeDemo




========================================
字符串: String 类, StringBuffer 类
----------------------------------------
1. 创建方法
(1) 两种方法
String str = "Tom";
String str2=new String("Tom");

(2) 差异
String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：
String s1 = "Tom";              // String 直接创建
String s2 = "Tom";              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String("Tom");   // String 对象创建
String s5 = new String("Tom");   // String 对象创建

s1, s2, s3 对应的是同一份；
s4和s5分别对应不同的




String是拥有“值语义”的引用类型，字符串常量实现了“享元模式”，equals会按照内容进行比较，==按照地址比较。

public class Hi2 {
    public static void main(String[] args) {
        String x = "你好";
        String y = new String("你好");
        
        System.out.println(x.equals(y)); // true
        System.out.println(x == y); // false
    }
}







2. 为了高效的修改字符串Java引入了 StringBuffer。

public class Hi2 {
    public static void main(String[] args) {
		StringBuffer sb = new StringBuffer();
		sb.append("你");
		sb.append("好").append("！"); //可以连续写
		
		System.out.println(sb.toString());
	}
}




========================================
数组
----------------------------------------
1.声明语法
DataType[] name 或 DataType name[]。

2. 初始化语法
DataType[] name = new DataType[length]。
DataType[] name = new DataType[] { element1, element2, ...elementn }。
DataType[] name = { element1, element2, ...elementn }。




3.多维数组
只有不等长多维数组DataType[][]，没有DataType[xxx, xxx]。






========================================
枚举
----------------------------------------
使用枚举可以减少bug。

1. 定义和使用
public class EnumDemo {
	enum FruitJuice{ SMALL, MEDIUM , LARGE }; //不能定义在方法中
	
    public static void main(String[] args) {
		FruitJuice fj1=FruitJuice.SMALL;
		System.out.println(fj1); //SMALL
		System.out.println(fj1.equals(0)); //false
	}
}

注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。 //??后半句什么意思



========================================
OOP 概念 
----------------------------------------
1. 变量 
局部变量: 方法中。
	局部变量没有初始值，必须初始化后再使用。
成员变量（实例变量）：方法外、类内、无static。
类变量：方法外、类内、有static修饰。


(2) 内部类
嵌套到另一个类内部的类。
- 非静态内部类 （内部类）: 
	要先实例化外部类，再实例化内部类： OC oc=new OC(); OC.IC ic = oc.new IC();
	内部类加 private 后， 外部不可见 OC.IC 类型。
	内部类可以在方法内定义：局部内部类
- 静态内部类：
	带 static 修饰的内部类，无需实例化外部类即可访问它
	注意：静态内部类无法访问外部类的成员。


(3) 访问修饰符 4个
	default 同一个包内可见
	private 同一个类内可见。不能修饰类（外部类）。
	protected 对同一个包内的类，和所有子类可见。不能修饰类（外部类）。
	public 对所有类可见
	说明：
		接口中的变量隐式 public static final，接口中的方法默认 public
		main() 方法必须public，否则Java解释器不能运行该类。
		接口及接口的成员变量和成员方法不能声明为 protected。
	访问控制的继承
		父类声明为 public 的方法在子类中必须为public。
		父类声明为 protected 的方法在子类中 protected 或 public，不能是 private。
		父类声明为 private 的方法不能被子类继承。

(4) 非访问修饰符
static 修饰符，用来修饰类方法和类变量。
	局部变量不能被声明为 static 变量。

final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

abstract 修饰符，用来创建抽象类和抽象方法。
	一个类不能同时被 abstract 和 final 修饰。
	如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
	抽象方法：
		抽象方法不能被声明成 final 和 static。
		任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

synchronized 和 volatile 修饰符，主要用于线程的编程。
	synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

transient 修饰符
	序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。
	该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。
	实例
	public transient int limit = 55;   // 不会持久化
	public int b; // 持久化






========================================
常用类: Number, Math, Character 
----------------------------------------
1. 层次结构
Object 
	Boolean: boolean
	Character: char
	Number 
		Byte 包装的是 byte 
		Short: short 
		Integer: int 
		Long: long
		Float: float 
		Double: double

这种由编译器特别支持的包装称为装箱。




2. Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

(1) Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。
	System.out.println("cos(60)="+Math.cos(Math.PI/3));
	System.out.println("1的反正切值:"+Math.atan(1)/Math.PI);
	System.out.println("pi/2的角度值："+Math.toDegrees(Math.PI/2));
	System.out.println("60的弧度值："+Math.toRadians(60)/Math.PI);

(2) Number & Math 类方法
https://www.runoob.com/java/java-number.html

System.out.println("随机数："+Math.random()); //[0,1]随机数

Math 的 floor,round 和 ceil 方法实例比较




3. Character 字符，不是字符串。

(1)Character 类在对象中包装一个基本类型 char 的值

// 原始字符 'a' 装箱到 Character 对象 ch 中
Character ch = 'a';
 
// 原始字符 'x' 用 test 方法装箱
// 返回拆箱的值到 'c'
char c = test('x');

(2) 转义字符 '\t'

(3) Character 方法
序号	方法与描述
1	isLetter()  是否是一个字母
2	isDigit()  是否是一个数字字符
3	isWhitespace()  是否是一个空白字符
4	isUpperCase()  是否是大写字母
5	isLowerCase()  是否是小写字母

6	toUpperCase()  指定字母的大写形式
7	toLowerCase()  指定字母的小写形式
8	toString()  返回字符的字符串形式，字符串的长度仅为1














========================================
多线程
----------------------------------------
1. volatile 修饰符
volatile 修饰符
	volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。
	而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。
	这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

public class MyRunnable implements Runnable
{
    private volatile boolean active;
    public void run()
    {
        active = true;
        while (active) // 第一行
        {
            // 代码
        }
    }
    public void stop()
    {
        active = false; // 第二行
    }
}

通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。

但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。








========================================
Java IO的一般使用原则 
----------------------------------------

一、按数据来源（去向）分类：  
1、是文件： FileInputStream, FileOutputStream, FileReader, FileWriter  
2、是byte[]：ByteArrayInputStream, ByteArrayOutputStream  
3、是Char[]: CharArrayReader, CharArrayWriter  
4、是String: StringBufferInputStream, StringReader, StringWriter  
5、网络数据流：InputStream, OutputStream, Reader, Writer  
  
  
二、按是否格式化输出分：  
1、要格式化输出：PrintStream, PrintWriter  


三、按是否要缓冲分：  
1、要缓冲：BufferedInputStream, BufferedOutputStream, 
	BufferedReader, BufferedWriter  

四、按数据格式分：  
1、二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream及其所有带Stream结束的子类  
2、纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer及其所有带Reader, Writer的子类  
  
  
五、按输入输出分：  
1、输入：Reader, InputStream类型的子类  
2、输出：Writer, OutputStream类型的子类  
  
  
六、特殊需要：  
1、从Stream到Reader,Writer的转换类：InputStreamReader, OutputStreamWriter  
2、对象输入输出：ObjectInputStream, ObjectOutputStream  
3、进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter  
4、合并输入：SequenceInputStream  
5、更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader  

   
  
决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：  
第一，考虑最原始的数据格式是什么：是否为文本？  
第二，是输入还是输出?  
第三，是否需要转换流：InputStreamReader, OutputStreamWriter?  
第四，数据来源（去向）是什么：文件？内存？网络？  
第五，是否要缓冲：bufferedReader （特别注明：一定要注意的是readLine()是否有定义，有什么比read, write更特殊的输入或输出方法）  
第六，是否要格式化输出：print?  
   
  
   
   
   
   
  
总结二：  
  
首先是java的IO。这破东西可真费事，I/O类库常使用”流(stream)”这种抽象。所谓”流”是一种能生成或接受数据的，代表数据的源和目标的对象。流把I/O设备内部的具体操作给隐藏起来了。 正如JDK文档所显示的，Java的I/O类库分成输入和输出两大部分。所有InputStream和Reader的派生类都有一个基本的，继承下来的，能读取单个或byte数组的read( )方法。同理，所有OutputStream和Writer的派生类都有一个基本的，能写入单个或byte数组的write( )方法。但通常情况下，你是不会去用这些方法的；它们是给其它类用的 —— 而后者会提供一些更实用的接口。因此，你很少会碰到只用一个类就能创建一个流的情形，实际上你得把多个对象叠起来，并以此来获取所需的功能。Java的流类库之所以会那么让人犯晕，最主要的原因就是”你必须为创建一个流而动用多个对象”。  
  
  
Java的IO类结构：  
      根接口是InputStream/OutputStream，充当数据源的IO类有FileInputStream/FileOutputStream，ByteArrayInputStream  / ByteArrayOutputStream  等，充当装饰功能的IO类有BufferedInputStream  /   BufferedOutputStream，DataInputStream   /   DataOutputStream等，  
     它们都是继承装饰接口FilterInputStream/FilterOutputStream。  
      使用IO时，首先创建一个数据源IO，然后根据需要的功能创建装饰类IO，其构造函数的参数为已创建的数据源IO。  
      我们以创建一个具有缓冲的文件输入流为例，假定需要从磁盘读取文件“C:\log.txt”：  
      // 创建一个FileInputStream:  
      FileInputStream fileInput = new FileInputStream(”C:\\log.txt”);  
      // 创建一个BufferedInputStream:  
      BufferedInputStream bufferedInput = new BufferedInputStream(fileInput);  
     // 现在得到的bufferedInput即是具有缓冲的文件输入流  
　　或者进一步简写如下：  
     InputStream input = new BufferedInputStream(new FileInputStream(”C:\\log.txt”));  
     // 现在得到的input即是具有缓冲的文件输入流  
  
  
   
  
java.io.Reader 和 java.io.InputStream 区别  
java.io.Reader 和 java.io.InputStream 组成了 Java 输入类。Reader 用于读入16位字符，也就是 Unicode 编码的字符；而 InputStream 用于读入 ASCII 字符和二进制数据。  
在 Java 中，有不同类型的 Reader 输入流对应于不同的数据源：  
    FileReader 用于从文件输入；  
    CharArrayReader 用于从程序中的字符数组输入；  
    StringReader 用于从程序中的字符串输入；  
    PipedReader 用于读取从另一个线程中的 PipedWriter 写入管道的数据。  
相应的也有不同类型的 InputStream 输入流对应于不同的数据源：FileInputStream，ByteArrayInputStream，StringBufferInputStream，PipedInputStream。另外，还有两种没有对应 Reader 类型的 InputStream 输入流：  
    Socket 用于套接字；  
    URLConnection 用于 URL 连接。  
这两个类使用 getInputStream() 来读取数据。  
相应的，java.io.Writer 和 java.io.OutputStream 也有类似的区别。  
  
  
1、Java技术支持两种数据类型的流  
InputStream和OutputStream：字节流。其它字节流都是InputStream或OutputStream的子类。  
Reader和 Writer：字符流。其它字符流都是Reader或Writer的子类。  
  
  
2、节点流  
Java 2 SDK中有三种基本类型的节点：文件(file)、内存(memory)、管道(pipe)。  
  
  
3、过程流  
过程流在其它流之上，完成排序、变换等操作。过程流也被称做过滤流。  
当你需要改变输入流的原始数据时，你可以将一个过滤输入流连接到一个原始的输入流上。  
用过滤流将原始数据变换成你需要的格式。    
  
  
4、基本字节流类  
4.1、FileInputStream和FileOutputStream  
这两个节点流用来操纵磁盘文件。这些类的构造函数允许你指定它们所连接的文件。  
要构造一个FileInputStream，所关联的文件必须存在而且是可读的。  
如果你要构造一个FileOutputStream而输出文件已经存在，则它将被覆盖。  
FileInputStream infile = new FileInputStream(”myfile.dat”);  
FileOutputStream outfile = new FileOutputStream(”results.dat”);  
4.1、 BufferInputStream和BufferOutputStream  
这些是过滤器流，它们可以提高I/O操作的效率。  
4.3、 PipedInputStream和PipedOutputStream  
管道流用来在线程间进行通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。  
要使管道流有用，必须有一个输入方和一个输出方。  
4.4、 DataInputStream和DataOutputStream  
这些过滤器通过流来读写Java基本类  
  
  
5、 基本字符流类  
图阐述了Reader和Writer字符流的体系结构。  
5.1、InputStreamReader 和 OutputStreamWriter  
用于字节流与字符流之间的转换接口。  
当你构造一个InputStreamReader或OutputStreamWriter时，转换规则定义了16位Unicode和其它平台的特定表示之间的转换。  
InputStreamReader从一个数据源读取字节，并自动将其转换成Unicode字符。  
如果你特别声明，InputStreamReade会将字节流转换成其它种类的字符流。  
OutputStreamWriter将字符的Unicode编码写到输出流，如果你的使用的不是Unicode字符，OutputStreamWriter会将你的字符编码转换成Unicode编码。  
5.2.、缓冲读者和作者  
因为在各种格式之间进行转换和其它I/O操作很类似，所以在处理大块数据时效率最高。  
在InputStreamReader和OutputStreamWriter的结尾链接一个BufferedReader和BufferedWriter是一个好主意。  
记住对BufferedWriter使用flush()方法。  
5.3、 使用其它字符转换  
如果你需要从一个非本地(例如，从连接到一个不同类型的机器的网络连接读取)的字符编码读取输入，  
你可以象下面这个程序那样，使用显式的字符编码构造ir=new InputStreamReader(System.in,  “8859_1″);  
注：如果你通过网络连接读取字符，就应该使用这种形式。  
否则，你的程序会总是试图将所读取的字符当作本地表示来进行转换，而这并不总是正确的。ISO 8859-1是映射到ASCII的Latin-1编码模式。  
  
  
6、 对象串行化  
java.io.Serializable接口支持将一个Java技术对象存放到一个流中。  
将一个对象存放到某种类型的永久存储器上称为”保持”。  
如果一个对象可以被存放到磁盘或磁带上，或者可以发送到另外一台机器并存放到存储器或磁盘上，那么这个对象就被称为可保持的。  
java.io.Serializable接口没有任何方法，它只作为一个”标记”，用来表明实现了这个接口的类可以串行化。  
类中没有实现Serializable接口的对象不能被保持。  
// 文件实现追加：  
// 其中的FileWriter()中的第二个参数的含义是:是否在文件中追加内容  
PrintWriter out = new PrintWriter(new FileWriter(logFileName, true), true);  
Java读写文件最常用的类是FileInputStream/FileOutputStream和FileReader/FileWriter。  
其中FileInputStream和FileOutputStream是基于字节流的，常用于读写二进制文件。  
读写字符文件建议使用基于字符的FileReader和FileWriter，省去了字节与字符之间的转换。  
但这两个类的构造函数默认使用系统的编码方式，如果文件内容与系统编码方式不一致，可能会出现乱码。  
在这种情况下，建议使用FileReader和FileWriter的父类：InputStreamReader/OutputStreamWriter，  
它们也是基于字符的，但在构造函数中可以指定编码类型：InputStreamReader(InputStream in, Charset cs) 和OutputStreamWriter(OutputStream out, Charset cs)。    
  
  
  
// 读写文件的编码：  
InputStreamReader r = new InputStreamReader(new FileInputStream(fileName), “utf-8″);  
OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(fileName),”utf-8″);  
  
/** 
三种IO性能比较: 
在读写一个10k文件的时候，三种方式的耗时如下: 
InputStreamReader And OutputStreamWriter : 63ms (可以设置文件的编码，如果不用buffer) 
BufferedReader And BufferedWriter : 31ms  
BufferedInputStream And BufferedOutputStream : 16ms 
*/  


/** 
* Description: Test the java IO’s efficiency 
* Author: AllanCao 
* Date: 2007-02-18 
*/

import java.io.*;  


/** 
* using the InputStreamReader And OutputStreamWriter 
*/  
class EncoderRW {  
 public static String read(String fileName) throws IOException {  
  StringBuffer sb = new StringBuffer();  
  /*此处读文件时用了buffer，如果不用，性能损失一倍*/  
  BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), “utf-8″));  
  String s;  
  while((s = in.readLine()) != null) {  
    sb.append(s);  
    sb.append(”\n”);  
  }  
  in.close();  
  return sb.toString();  
 }  
 public void write(String fileName, String text) throws IOException {  
  OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(fileName),”utf-8″);  
  out.write(text);  
  out.flush();  
  out.close();  
 }  
}


 
/** 
* using the BufferedReader And BufferedWriter 
*/  
class WriterReader {  
 public String read(String fileName) throws IOException {  
  StringBuffer sb = new StringBuffer();  
  BufferedReader in = new BufferedReader(new FileReader(fileName));  
  String s;  
  while((s = in.readLine()) != null) {  
    sb.append(s);  
    sb.append(”\n”);  
  }  
  in.close();  
  return sb.toString();  
 }  
 public void write(String fileName, String text) throws IOException {  
  PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));  
  out.print(text);  
  out.close();  
 }  
}  



/** 
* using the BufferedInputStream And BufferedOutputStream 
*/  
class BufferedStream{  
 public byte[] read(String fileName) throws IOException {  
  BufferedInputStream remoteBIS = new BufferedInputStream(new FileInputStream(fileName));  
  ByteArrayOutputStream baos = new ByteArrayOutputStream(10240);  
  byte[] buf = new byte[1024];  
  int bytesRead = 0;  
  while(bytesRead >= 0)  
  {  
   baos.write(buf, 0, bytesRead);  
   bytesRead = remoteBIS.read(buf);  
  }  
  byte[] content = baos.toByteArray();  
  return content;  
 }  
 public void write(String fileName, byte[] content)  throws IOException {  
  BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileName));  
  out.write(content);  
  out.flush();  
  out.close();  
 }  
}  
  
public class TestIO  
{  
 public static void main(String[] args)throws IOException {  
  long currentTime = System.currentTimeMillis() ;  
  EncoderRW rw = new EncoderRW();  
  rw.write(”index.dat”,rw.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
  
  currentTime = System.currentTimeMillis() ;  
  WriterReader wr = new WriterReader();  
  wr.write(”index.dat”,wr.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
  
  currentTime = System.currentTimeMillis() ;  
  BufferedStream bf = new BufferedStream();  
  bf.write(”index.dat”,bf.read(”FileUtil.java”));  
  System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);  
 }  
}  



//读写文件 
	static void bufferedReaderDemo() throws IOException, InterruptedException{
		//读写文件
		FileReader fr=new FileReader("dustbin//bb.txt");
		FileWriter fw=new FileWriter("dustbin//bb_backup2.txt");
		//加缓冲区
		BufferedReader br=new BufferedReader(fr);
		BufferedWriter bw=new BufferedWriter(fw);
		
		//System.out.print(fr.getEncoding());//UTF8
		char[] cbuf=new char[64];
		int length=0;
		while((length=br.read(cbuf))>0){
			bw.write(cbuf,0,length);
//			fw.flush();//有了这句话是时刻刷新，从缓冲区向文件中保存
		}
		//关闭
		br.close();
		bw.close();
		fr.close();
		fw.close();
	}












========================================
Spring: Java 最重要的框架 (两大核心 IoC, AOP)
----------------------------------------
课程大纲
https://www.bilibili.com/video/BV1rt4y1u7q5/

四个部分
IoC 基础容器: 其他组件功能的基础，Bean产生和关系等
AOP 面向切面编程: 用横向抽取思想对Bean进行增强，主要涉及切面配置、声明式事务控制等。
Spring 整合web环境: 方式、原理和整合web层各个MVC框架的思想
web层解决方案-Spring-MVC: 基于MVC思想打造的框架，摆脱 Servlet，用更简单的方式开发web层代码


https://spring.io/




========================================
|-- IoC 基础容器: 其他组件功能的基础，Bean产生和关系等
----------------------------------------
目录:
传统
IoC，DI和AOP思想的提出
Spring框架的诞生


1. 传统web开发的问题和解决方法















========================================
SpringBoot2 怎么学? //todo : 前置 Sping, Maven
----------------------------------------

花一两个小时简单看一下spring boot入门教程，然后看部门的业务代码，上手就是干

1. 教程
SpringBoot2: https://www.bilibili.com/video/BV19K4y1L7MT/
Vue2+Vue3: https://www.bilibili.com/video/BV1Zy4y1K7SH/

Java目录: https://www.weixueyuan.net/java/rumen/
SpringBoot2 笔记: https://www.yuque.com/atguigu/springboot
SpringBoot2 官方: https://spring.io/projects/spring-boot


前置知识: 
	Java8+
	Spring:aoc, ioc 是什么? 会使用 Spring
	Maven 3.3+ 的使用









========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------

