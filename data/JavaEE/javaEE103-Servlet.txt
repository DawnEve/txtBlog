Servlet使用

http://www.runoob.com/servlet/servlet-tutorial.html

基础：
 Java 编程语言有一个很好的理解。
 如果您对 web 应用程序和互联网如何工作的有基本的认识，将有助于您理解本教程。

 
========================================
Servlet大纲
----------------------------------------
1.
Servlet 包
Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。
Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。

2.
Servlet 生命周期
Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：
Servlet 通过调用 init () 方法进行初始化。
Servlet 调用 service() 方法来处理客户端的请求。
Servlet 通过调用 destroy() 方法终止（结束）。
最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。

3.
Tomcat 简介
http://tomcat.apache.org/
Apache Tomcat version 7.0 implements the Servlet 3.0 and JavaServer Pages 2.2 specifications from the Java Community Process.

>2016-11-08 Tomcat 8.5.8 Released

4.
Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。

========================================
xampp中的tomcat怎么激活
----------------------------------------
环境变量：https://zhidao.baidu.com/question/256492455.html
添加注册表项：http://www.ithao123.cn/content-3176358.html


环境变量：
JAVA_HOME=jdk主目录 
TOMCAT_HOME=tomcat的主目录 

--
catalina_start.bat
[XAMPP]: Searching JDK HOME with reg query ...
错误: 系统找不到指定的注册表项或值。
. [XAMPP]: Cannot find current JDK installation!
. [XAMPP]: Cannot set JAVA_HOME. Aborting ...
done.
请按任意键继续. . .
说找不到键值，我们打开这个bat看看！！！

解决方法：
我们regedit打开注册表：HKEY_LOCAL_MACHINE—>SOFTWARE—>Wow6432Node
新建项JavaSoft
在JavaSoft下新建项Java Development Kit和Java Runtime Environment

Java Development Kit默认值指定为你jdk的路径
我的jdk路径为：
D:\Program Files\Java\jdk1.8.0_66

Java Runtime Environment指定你jre路径
比如我的jre路径为：
D:\Program Files\Java\jdk1.8.0_66\jre

自己安装版的java应该是不会出现这样的现象的，只有当你免安装的时候才会出现这样的现象
我们再来运行一下xmapp的tomcat看完美解决了问题没有！！！

访问：http://localhost:8080/
登录密码：
（1）打开文件conf/tomcat-users.xml
（2）增加2条
<role rolename="admin-gui"/>
<user username="tomcat" password="tomcat" roles="admin-gui"/>
（3）重启tomcat。



被拒绝后提示详细的用户设置
You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp.

For example, to add the admin-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above.

<role rolename="admin-gui"/>
<user username="tomcat" password="s3cret" roles="admin-gui"/>
Note that for Tomcat 7 onwards, the roles required to use the host manager application were changed from the single admin role to the following two roles. You will need to assign the role(s) required for the functionality you wish to access.

admin-gui - allows access to the HTML GUI
admin-script - allows access to the text interface
The HTML interface is protected against CSRF but the text interface is not. To maintain the CSRF protection:

Users with the admin-gui role should not be granted the admin-script role.
If the text interface is accessed through a browser (e.g. for testing since this interface is intended for tools not humans) then the browser must be closed afterwards to terminate the session.



========================================
Servlet版HelloServlet，和eclipse中配置servlet
----------------------------------------

Servlet的四步开发流程。
1.首先在Tomcat的主目录下的webapp文件夹内新建mywebsite文件夹，里面新建WEB-INF文件夹;
在WEB-INF文件夹下建立classes子文件夹 存放你的servlet
然后在WEB-INF文件夹下建立一个web.xml文件,记录网站的配置信息

当然这个操作你可以自己完成 也可以在root目录下拷贝一份
大家可以看到 这个地方传递过来了一个信息，什么信息呢？
文件夹结构：

F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml 

webapps/WEB-INF/web.xml 
webapps/WEB-INF/classes/HelloServletDemo.class 


2.开发Servlet（引入Servlet-api.jar）

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class HelloServletDemo implements Servlet{
	// 用于得到servlet配置文件 与生命周期无关
	@Override
	public ServletConfig getServletConfig() {
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return "Servlet info here...";
	}

	// 该函数用于初始化该servlet， 类似于我们的类的构造函数
	// 该函数只是会被调用一次， 当用户第一次访问该servlet的时候被调用
	@Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init it !");
	}


	// service 函数用于处理业务逻辑
	// 程序员应当把业务逻辑代码写在这里
	// 该函数在用户每次访问servlet的时候都会被调用
	// ServletRequest 对象用于获得客户端信息，
	//ServletResponse 对象用于向客户端返回信息	（客户端可以理解为浏览器）
	// servelt jsp b/s
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		System.out.println("Service start");
		PrintWriter pw=res.getWriter();
		pw.println("Hello world, Servlet");
	}
	
	
	// 销毁servlet实例（释放内存）
	// 1 reload 该servlet(webApp)
	// 2 关闭Tomcat 或者说 关机之后 都会调用这个函数
	@Override
	public void destroy() {
		System.out.println("destory it");
	}

}



3.部署Servlet。在web.xml中加入如下内容：
<servlet>
	<!--给你的servlet起名字，任意的-->
	<servlet-name>hello_servlet</servlet-name>
	<!--指明servlet的路径，包名+类名 注意类名后不能加上java-->
	<servlet-class>com.tsinghua.Hello</servlet-class>
</servlet>
 
<servlet-mapping>
	<!--mapping  自然就是映射了  于是乎 这个同上,一致-->
	<servlet-name>hello_servlet</servlet-name>
	<!--这是浏览器中输入的访问该servlet的url 任意的-->
	<url-pattern>/sp</url-pattern>
</servlet-mapping>



web.xml的最终内容如下：
<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://java.sun.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>
 	  
  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>HelloServletDemo</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
	
</web-app>

这里面，servlet标签标注着我们的servlet名字和class名，而mapping标签则是代表着servlet的访问地址。


4.启动tomcat，访问你的Servlet
http://localhost:8080/mywebsite/hello

显示：Hello world, Servlet


注意：WEB-INF不要写错！不是WEB_INF，也不是WEB-INFO。
https://www.zhihu.com/question/21416727



我的实践：
1.在Eclipse中提示 找不到类 javax.servlet.http.HttpServletResponse
http://bbs.csdn.net/topics/370187655?page=1

在tomcat的lib目录下可以找到的。如果你把J2EE的相关包加到buildPath里面去，那应该不会出错的。

到tomcat的安装路径下\lib\servlet-api.jar 复制到WEB-INF/lib下，然后点项目名按F5，应该就OK了。


2.如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。
web.xml中也必须是包的全称 com.myorg.MyServlet。





========================================
Eclipse+Tomcat环境下部署Servlet步骤如下：
----------------------------------------
一、建立项目：建立一个动态的web项目（Dynamic Web Project），起名为BlogWeb，并在Target runtime下配置tomcat 
二、在WebContent下WEB-INF的lib里放入mysql-connector-java.5.0.5-bin.jar 
三、编写数据库操作和servlet页面信息的代码：在src里编写pojo类，数据库连接类，数据库操作类dao以及servlet中用于显示页面信息的类 
四、编写html页面，并放在WEB-INF下 
五、配置web.xml中的信息，即servlet中的页面信息 
六、创建Server并启动 
七、打开IE，输入地址进行测试 
八、发布WEB项目：将项目以WAR file形式导出，并将导出的文件置于tomcat目录下的webapps里。
这样不用启动server，也能直接用IE看见我们编写的html了




========================================
Servlet get参数
----------------------------------------
1.输出到网页，获取get方式传递过来的变量
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello3 extends HttpServlet {

	private static final long serialVersionUID = 1L;
	private String message="";
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		message = "Hello World, today";
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		// 设置响应内容类型
		res.setContentType("text/html");//设置编码格式
		
		//接收get过来的变量
		String usr=req.getParameter("username");
		String pass=req.getParameter("password");
		
		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();//输出内容到网页
		out.println("<h1>" + message + "</h1>" + usr+":"+pass);
	}

}


========================================
Servlet Session
----------------------------------------

页面间信息传递的几种方式：
	1.cookies方式；
	2.隐藏表单字段；
	3.url重写
	4.session方式；

URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。

通过调用 HttpServletRequest 的公共方法 getSession() 来获取 HttpSession 对象，如下所示：
HttpSession session = request.getSession();




1.ReadSession.java 遍历session
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class ReadSession extends HttpServlet {
	private static final long serialVersionUID = 1L;

	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//设置session时间.默认是30min。
		//hs.setMaxInactiveInterval(10);//10s 
		//输出到控制台
		System.out.println(hs.getAttribute("pass"));
		System.out.println(hs.getAttribute("usr"));
		System.out.println(hs.getAttribute("usr_id"));
		System.out.println();
		
		
		//获取输出流,输出到网页
		PrintWriter out = res.getWriter();
		java.util.Enumeration   e   =   req.getSession().getAttributeNames(); 
		//遍历输出session内容
		//http://ssh-2009-126-com.iteye.com/blog/1111994
		while( e.hasMoreElements()){   
		    String sessionName=(String)e.nextElement();   
		    out.println("\nsession item name="+sessionName);  
		    out.println("\nsession item value="+req.getSession().getAttribute(sessionName)); 
		    out.println("<br>");
		}
	}
}



2.session操作 Hello4.java 
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello4 extends HttpServlet {

	/** 
	 * session操作
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//设置session时间.默认是30min。
		hs.setMaxInactiveInterval(10);//10s 
		
		//设置session内容
		hs.setAttribute("pass","ok");
		hs.setAttribute("name","天天");
		
		//读取session内容
		String str=(String)hs.getAttribute("name");
		System.out.println(str);
		
		//获取sessionid
		String id=hs.getId();
		System.out.println(id);//A10F4CC8AD14A3BB7D09B0143E10FAA7
		
		
		// 设置响应内容类型
		//res.setContentType("text/html");
		
		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();
		out.println("<h1>" + str + "</h1> sessionid="+id);
	}

}

3.判断是否有session值
Hello5.java 
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello5 extends HttpServlet {

	/** 
	 * session操作 判断与跳转
	 */
	private static final long serialVersionUID = 1L;
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//判断是否合格
		String val=(String) hs.getAttribute("pass");
		if(val==null){
			//非法登录
			res.sendRedirect("hello4?info=error");//重定向到某个url
			return;
		}

		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();
		out.println("<h1>" + "保密内容" + "</h1>");
	}
}


4.删除 Session 会话数据
当您完成了一个用户的 session 会话数据，您有以下几种选择：
 - 移除一个特定的属性：您可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。
 - 删除整个 session 会话：您可以调用 public void invalidate() 方法来丢弃整个 session 会话。
 - 设置 session 会话过期时间：您可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。
 - 注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。
 - web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：
  <session-config>
    <session-timeout>15</session-timeout>
  </session-config>
上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。

在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。






========================================
Servlet Cookie
----------------------------------------
问题：
Cookie1 cookie的读写: cookie时间总是不准确，超前24小时左右。但是时间5和10s还是有区别的。
	ame	tomcat	localhost	/mywebsite	2017-01-01T17:03:09.672Z	10				
	pass	123	localhost	/	2017-01-01T17:03:14.672Z	7	

1.Servlet Cookie 处理需要对中文进行编码与解码，方法如下：
String   str   =   java.net.URLEncoder.encode("中文");            //编码
String   str   =   java.net.URLDecoder.decode("编码后的字符串");   // 解码



2.文件Cookie1.java 
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;
import java.util.TimeZone;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Cookie1 extends HttpServlet{

	/**
	 * cookie封装： http://www.cnblogs.com/muzongyan/archive/2010/08/30/1812552.html
	 * 
	 * http://localhost:8080/mywebsite/cookie1?option=get 获取cookie
	 * http://localhost:8080/mywebsite/cookie1 删除cookie name
	 * http://localhost:8080/mywebsite/cookie1?option=set 设置cookie name pass
	 */
	private static final long serialVersionUID = 1L;
	static{
		TimeZone.getTimeZone("Asia/Shanghai");//
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		String option=req.getParameter("option");
		if(option==null){
			System.out.println("没有参数");
			
			//清空cookie name
			Cookie cookie = new Cookie("name", null);
			cookie.setMaxAge(0);
			//删除指定路径上的Cookie，不设置该路径，默认为删除当前路径Cookie；
			//cookie.setPath("/");
			res.addCookie(cookie);
			
			return;
		}
		if(option.equals("set")){
			mySet(req,res);
		}
		if(option.equals("get")){
			myGet(req,res);
		}
		
	}
	
	//设置cookie
	static void mySet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		//分别设定cookie，和生命周期
		Cookie name=new Cookie("name","tomcat");
		//如果设置为负值的话，则为浏览器进程Cookie(内存中保存)，关闭浏览器就失效
		name.setMaxAge(5);//5s
		res.addCookie(name);

		Cookie pass=new Cookie("pass","123");
		pass.setMaxAge(10);//10s
		//设置路径，这个路径即该工程下都可以访问该cookie 
		//如果不设置路径，那么只有设置该cookie路径及其子路径可以访问
		pass.setPath("/");
		res.addCookie(pass);
		
//		Cookie c = new Cookie("lastAccessTime",System.currentTimeMillis()+"");
		Cookie c = new Cookie("lastAccessTime", new Date().toString());
		//c.setMaxAge(0);//0s不保存
		c.setMaxAge(-1);//浏览器关闭前有效
		res.addCookie(c);
		
		System.out.println("cookie设定完成！");
	}
	
	//读取cookie
	static void myGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		Cookie[] cookies = req.getCookies();//这样便可以获取一个cookie数组
		if (null==cookies) {
            System.out.println("没有cookie=========");
        } else {
        	PrintWriter out=res.getWriter();
			for(Cookie cookie : cookies){
			    String str=cookie.getName()+"="+cookie.getValue();
			    System.out.println(str);
			    out.println(str);
			}
        }
		
		System.out.println("cookie读取完成");
	}

	
}

3.删除某个cookie
删除 Cookie 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：
	读取一个现有的 cookie，并把它存储在 Cookie 对象中。
	使用 setMaxAge() 方法设置 cookie 的年龄为零，来删除现有的 cookie。
	把这个 cookie 添加到响应头。



========================================
Servlet, JDBC, 分页
----------------------------------------
1.文件 
Hello7.java 
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello7 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello7~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			//1.连接数据库
			Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_user;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_user limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>name</td><td>pass</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页代码
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}
					
			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}

2.配置文件：
F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml
	  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello7</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>Hello7</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello7</servlet-name>
		<url-pattern>/hello7</url-pattern>
	</servlet-mapping>

3.url 
http://localhost:8080/mywebsite/hello7?page=3

id	name	pass
6	Smith	e10adc3949ba59abbe56e057f20f883e
7	timoc	e10adc3949ba59abbe56e057f20f883e
11	石劲	e10adc3949ba59abbe56e057f20f883e
25	Tomcat	e10adc3949ba59abbe56e057f20f883e
27	Tomcat@qq.com	e10adc3949ba59abbe56e057f20f883e
上一页 1 2 3 下一页





========================================
servlet设置-列举文件、改端口、设置虚拟目录、添加用户
----------------------------------------
http://www.cnblogs.com/webqiand/p/4315618.html

1.控制列举文件夹
打开Tomcat目录下的/conf/web.xml，将下面listings的属性设置为True。
    <servlet>
        <servlet-name>default</servlet-name>
        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
        <init-param>
            <param-name>debug</param-name>
            <param-value>0</param-value>
        </init-param>
        <init-param>
            <param-name>listings</param-name>
            <param-value>true</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
如果把false设成true，那么将允许在网页中列出目录，让Tomcat 支持文件列表显示
因此注意，这里为了安全，应该设置成false

2.改端口
在conf目录下的server.xml文件里面，修改
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"
redirectPort="8443" />
8080是默认的端口！可以改成80，这样在地址栏就不需要写端口号了。

3.设置tomcat虚拟目录
tomcat7的安装路径下，D:\Program Files\java\Tomcat 7.0\conf，修改server.xml文件
在</Host>标签前，添加上图选中部分即可，
  path ： 地址栏访问路径。
  docBase : 文件的真实路径。注意这里如果有文件上传，则将上传的文件路径设置为docBase，而不是path。  
例如： 
<Context path="/carapp" docBase="D:\nginx-1.8.1\html\carapp" debug="0" reloadable="true" />

可添加多个 目录
修改好之后，重启tomcat7

通过路径http://localhost:8080  即可访问了
本人在测试时，把上面选中部分删掉后，访问路径http://localhost:8080,还是访问的演示工程，而不是tomcat7欢迎页面，
这是tomcat缓存目录在作怪，删除路径Tomcat 7.0\work\Catalina\localhost下的文件夹名是 -  (横杠)的文件夹即可。


以上虚拟目录一直无效，因为eclipse默认的build路径和tomcat不一致。
eclipse的java EE配置一直无效。//todo 


/////////////////////////////////////////
起作用的设置如下，我新建了个ServletDemo项目：
（1）修改Eclipse的build路径：
右击项目，选择 properties，右侧选择Java Build Path，Source选项卡， 
底部默认输出文件夹：ServletDemo/build/classes，改为 ServletDemo/WEB-INF/classes

(2)查看文件夹结构
Servlet/ 这个文件夹的绝度路径放到comcat\conf\server.xml的Context标签的docBase中。
 |-放图片、文本等资源文件。
 |-WEB-INF
    |-web.xml 部署class文件
    |-classes 其中就是eclipse生成的class文件。
看时间戳，确保eclipse修改后classes文件也会重新生成。

（3）配置tomcat虚拟目录，
F:\xampp\tomcat\conf\server.xml文件，在底部</Host>标签前增加一行
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet"></Context>
  path ： 地址栏url访问路径。
  docBase : 文件的真实路径。注意其中的文件结构符合（2）；
（4）重启tomcat，输入路径 http://localhost:8080/mywebsite/readnum
即可访问其中的Servlet文件了。


备注：
F:\xampp\tomcat\conf\context.xml中设置web.xml文件的位置：
    <WatchedResource>WEB-INF/web.xml</WatchedResource>
	
	
4.tomcat添加用户
空密码是不安全的。
设置方式：F:\xampp\tomcat\conf\tomcat-users.xml中添加：

<tomcat-users>
	<role rolename="admin-gui"/>
	<user username="tomcat" password="tomcat" roles="admin-gui"/>

	<role rolename="manager-gui"/>
	<user username="tomcat" password="tomcat" roles="manager-gui"/>
</tomcat-users>

重启tomcat即可。



========================================
tomcat如何设置数据源和连接池（公司常用）？
----------------------------------------
什么是数据库连接池
数据库连接池技术的思想非常简单，将数据库连接作为对象存储在一个Vector对象中，一旦数据库连接建立后，不同的数据库访问请求就可以共享这些连接，这样，通过复用这些已经建立的数据库连接，可以克服上述缺点，极大地节省系统资源和时间。

在实际应用开发中，特别是在WEB应用系统中，如果JSP、Servlet或EJB使用JDBC直接访问数据库中的数据，每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。数据库连接池技术是解决这个问题最常用的方法，在许多应用程序服务器（例如：Weblogic,WebSphere,JBoss）中，基本都提供了这项技术，无需自己编程，但是，深入了解这项技术是非常必要的。


数据库连接池的主要操作如下：
（1）建立数据库连接池对象（服务器启动）。
（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）。
（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。
（4）存取数据库。
（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。
（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。

配置步骤：
1.在Tomcat/conf/content.xml中<Context>节点内添加如下内容
<Resource name="jdbc/user" auth="Container" type="javax.sql.DataSource" maxActive="100" maxIdle="30" maxWait="10000" username="sa" password="120010" driverClassName="com.microsoft.sqlserver.jdbc.SQLServerDriver" url="jdbc:sqlserver://localhost:1433;DatabaseName=user"/>

	name:之后我们要调用resource时候用到 
	type:是链接数据库时候用到的java扩展包下的类 
	maxActive:最大连接数 
	maxIdle:是空闲时候最大连接数 
	maxwait:空闲判断标准 

注意： 
1.该配置文件里不允许有中文；各个属性间的用一个空格隔开 
2.要将对应链接数据库的jar包放到tomcat/lib文件夹中工程中就不需要存放了 
下面还中是链接oracle的
<Resource type="javax.sql.DataSource" name="jdbc/user" url="jdbc:oracle:thin:@192.168.2.102:1521:orcl" driverClassName="oracle.jdbc.driver.OracleDriver" password="bg" username="test" maxWait="10000" maxIdle="30" maxActive="100" auth="Container"/>
2.在工程的web.xml中添加如下代码
<resource-ref>
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
</resource-ref>
这里<res-ref-name>标签里面的名字就是在content.xml文件中的name的名字

3.得到数据库连接池中的Connection对象

Context context=new InitialContext();
DataSourceds=(DataSource)context.lookup("java:comp/env/jdbc/user");
Connectionconn = ds.getConnection();

context是javax.namingx下的类 
dataSource是javax.sql下的类 
"java:comp/env/jdbc/user"中：java:comp/env是固定写法 jdbc/user是jndi名称（Tomcat中配置的那个name）




如果我们不是在web.xml中配置数据源，我们用spring来控制数据库链接方法步骤：
1.在配置文件中添加如下节点
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
    <property name="jndiName" value="java:comp/env/jdbc/user"/> 
</bean>
配置好了获取sql语句查询数据有多少条：

    调用的时候直接Dao类继承JdbcDaoSupport类（spring.jar中的类） 
    int count = this.getJdbcTemplate().queryForInt("select * from users");

http://www.jb51.net/article/36705.htm






/////////////////////////////////////////
我的配置：
参考：【推荐】http://kingxss.iteye.com/blog/1479451
1.
修改tomcat/conf/server.xml 
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet">
	<Resource name="jdbc/user" auth="Container"   
    type="javax.sql.DataSource"  
    driverClassName="com.mysql.jdbc.Driver"  
    url="jdbc:mysql://localhost:3306/think"  
    username="root"  
    password=""  
    maxActive="50"  
    maxIdle="10"  
    maxWait="10000" />
</Context>

使用的是think数据库。


2.
在项目文件件下web.xml的根节点配置：
  <resource-ref>
      <description>mysqlDB Connection</description>  
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
 </resource-ref>

完成上述步骤数据源的连接池配置已经完成，但是为了提高项目的可移植性，
最好将上述第一步的内容放入到工程的META-INF目录的context.xml中（这个文件需要自行建立）：
<?xml version="1.0" encoding="UTF-8"?>  
<Context>  
      <Resource name="jdbc/demoDB" auth="Container"   
      type="javax.sql.DataSource"  
      driverClassName="com.mysql.jdbc.Driver"  
      url="jdbc:mysql://localhost:3306/demo"  
      username="root"  
      password="123"  
      maxActive="50"  
      maxIdle="30"  
      maxWait="10000" />  
</Context>  


3.使用配置数据源的数据库连接池时的数据库操作工具类
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.sql.DataSource;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello8 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello8~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		System.out.println("use 连接池");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			
			//1.2.使用数据库连接池获得连接
			Context context=new InitialContext();
			DataSource ds=(DataSource)context.lookup("java:comp/env/jdbc/user");
			if( ds == null ){  
		           throw new Exception("Data source not found!");  
		    }
			conn = ds.getConnection();
			
			//1.连接数据库
			//Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			//conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_weibo;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_weibo limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>uid</td><td>content</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页按钮
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			//如果太多，怎么显示分页按钮呢？模仿网易博客
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}

			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}
数据库连接写到init方法中。
数据库销毁放到destroy方法中。




========================================
eclipseEE不能编译Servlet
----------------------------------------
能编译java。
能编译jsp。
不能编译Servlet，修改后不编译，更新后不编译。
重启eclipse和tomcat都没用。

Deleted .classpath and project settings files from project folder. Then imported the maven project again.
It works fine after that.
我就删除了这2个文件，然后重新import到eclipse中。
一切正常。


http://stackoverflow.com/questions/24416569/eclipse-project-cannot-reference-itself


在左侧的package explorer中右击这个class所在包的上一级目录--build path--设置。
填写符合servlet的build路径： Servlet/WEB-INF/classes
这样就解决问题了。

========================================
Servlet不自动添加到web.xml中
----------------------------------------

你创建的工程的servlet的版本是不是2.5以上（不含2.5）啊！如果是的话，那么不自动配置web.xml是因为，servlet的配置直接在Java代码中进行注解配置了。


========================================
Servlet获取参数，获取汉字参数
----------------------------------------

注意：如果表单提交的数据中有中文数据则需要转码：
String name =new String(request.getParameter("name").getBytes("ISO8859-1"),"UTF-8");


1.GetDemo.java 
package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class GetDemo
 * url: http://localhost:8080/mywebsite/getDemo
 * 
 */
//@WebServlet("/GetDemo")
public class GetDemo extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * 获取参数，获取汉字参数。
     * @see HttpServlet#HttpServlet()
     */
    public GetDemo() {
        super();
        System.out.println("1.this is construct method.数据库打开");
        // TODO Auto-generated constructor stub
    }
    
    // 该函数用于初始化该servlet， 类似于我们的类的构造函数
 	// 该函数只是会被调用一次， 当用户第一次访问该servlet的时候被调用
 	@Override
 	public void init(ServletConfig arg0) throws ServletException {
 		System.out.println("2.init it !");
 	}


	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//response.setContentType("text/html");//有这句话，后面的html标签才起作用
		response.setContentType("text/html;charset=UTF-8");//输出中文
		
		System.out.println("3.this is a doGet method.");
		response.getWriter().append("Served at: ").append(request.getContextPath());
		PrintWriter out = response.getWriter();
		out.println("<h1>hello, test Get Method.好的</h1>");
		
		//获取参数
		//http://localhost:8080/mywebsite/getDemo?token=sfd
		String token=request.getParameter("token");
		if(token!=null){
			//token="null";
			out.println("token="+token+"<br>");
		}
		
		//获取汉字参数
		//http://localhost:8080/mywebsite/getDemo?keyword=sfd事务
		String _keyword=request.getParameter("keyword");
		if(_keyword!=null){
			String keyword=new String(_keyword.getBytes("ISO8859-1"),"UTF-8");//转码
			out.println("_keyword="+_keyword+"<br>");//乱码
			out.println("keyword="+keyword+"<br>");//正常显示
		}
		
	}
	
	public void destroy() {
		System.out.println("4.destory it数据库关闭");
	}
}


2.web.xml添加配置：
	<servlet>
		<servlet-name>getDemo</servlet-name>
		<servlet-class>com.dawn.servlet.GetDemo</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>getDemo</servlet-name>
		<url-pattern>/getDemo</url-pattern>
	</servlet-mapping>

========================================
HTTP 状态码
----------------------------------------
HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：
	初始状态行 + 回车换行符（回车+换行）
	零个或多个标题行+回车换行符
	一个空白行，即回车换行符
	一个可选的消息主体，比如文件、查询数据或查询输出



========================================
Servlet header获取与设置
----------------------------------------

1.GetHeader.java 
package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 获取header信息。
 * 
 * */
public class GetHeader extends HttpServlet {
	
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 设置响应内容类型
		response.setContentType("text/html;charset=UTF-8");
		
		PrintWriter out = response.getWriter();
		String title = "HTTP Header 请求实例";
		out.println("<h1>"+title+"</h1>");
		
		//
		//获取请求req.header
		Enumeration headerNames=request.getHeaderNames();
		out.print("<b><p> 键 : 值 </p></b>");
		while(headerNames.hasMoreElements()){
			String paraName=(String)headerNames.nextElement();
			String paraValues=request.getHeader(paraName);
			out.print("<p><b style='color:red'>"+paraName+"</b>: "+paraValues+"</p>");
		}
		
		//
		//设置响应res.header
		//见SetHeader.java
	}
}




2.SetHeader.java
package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 设置header信息。
 * 
 * */
public class SetHeader extends HttpServlet {
	private static final long serialVersionUID = 1L;
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 设置刷新自动加载时间为 10 秒
	    response.setIntHeader("Refresh", 10);
	      
		// 设置响应内容类型
		response.setContentType("text/html;charset=UTF-8");
		
		//使用默认时区和语言环境获得一个日历
		Calendar cale=Calendar.getInstance();
		//将Calendar类型转换成Date类型  
		Date tasktime=cale.getTime();
		//设置日期输出的格式 
		SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		//格式化输出
		String nowTime=df.format(tasktime);
		
		PrintWriter out = response.getWriter();
		String title = "HTTP Header 设置实例-自动刷新";
		out.println("<h1>"+title+"</h1>");
		out.print("当前时间是："+nowTime);
		
		out.println("<a href='http://localhost:8080/mywebsite/getHeader'>getHeader</a>");
		
		//设置404状态。 好像被废除了。
		//response.setStatus(504, "not found now....");
	}

}







========================================
Servlet 过滤器
----------------------------------------
Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：
	在客户端的请求访问后端资源之前，拦截这些请求。
	在服务器的响应发送回客户端之前，处理这些响应。

根据规范建议的各种类型的过滤器：
	身份验证过滤器（Authentication Filters）。
	数据压缩过滤器（Data compression Filters）。
	加密过滤器（Encryption Filters）。
	触发资源访问事件过滤器。
	图像转换过滤器（Image Conversion Filters）。
	日志记录和审核过滤器（Logging and Auditing Filters）。
	MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。
	标记化过滤器（Tokenizing Filters）。
	XSL/T 过滤器（XSL/T Filters），转换 XML 内容。

1.先写过滤器类，需要实现Filter接口。LogFilter.java 
package com.dawn.test;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class LogFilter implements Filter{
	@Override
	public void init(FilterConfig config) throws ServletException {
		// 获取初始化参数，从web.xml文件获取配置信息
		String site = config.getInitParameter("Site"); 
		// 输出初始化参数
		String site2=site;
		try {
			site2 = new String(site.getBytes("ISO8859-1"),"UTF-8");//防止中文乱码
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		System.out.println("init: 网站名称=" + site2); 
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		// 输出站点名称
		System.out.println("站点网址：http://www.biomooc.com");
		
		// 把请求传回过滤链
		chain.doFilter(request,response);
	}


	@Override
	public void destroy() {
		/* 在 Filter 实例被 Web 容器从服务移除之前调用 */
		System.out.println("destroy logfilter.");
		
	}
}


2.在web.xml中配置：
<!--s filter1 -->
<filter>
	<filter-name>LogFilter</filter-name>
	<filter-class>com.dawn.test.LogFilter</filter-class>
	<init-param>
		<param-name>Site</param-name>
		<param-value>Servlet EXAMPLES.教程-中文乱码吗？</param-value>
	</init-param>
</filter>
<filter-mapping>
  <filter-name>LogFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
<!--e filter1 -->

定义一个filter类，与类关联。其中可以定义参数，在类中调用。
定义一个filter mapping，和url关联。*表示给所有类使用该过滤器。


3.也可以定义多个过滤器，其中<filter-mapping>的顺序，决定着使用过滤器的顺序。

4.测试：访问http://localhost:8080/mywebsite/getHeader
即可看到控制器台上的输出：
站点网址：http://www.biomooc.com


========================================
文件上传与jar包位置
----------------------------------------
http://www.runoob.com/servlet/servlet-file-uploading.html
该页面有一个错误，共出现2处都需要改：
错误：getServletContext()
正确：request.getServletContext()

一共三个文件。涉及到2个包。
	upload.jsp : 文件上传表单。
	message.jsp : 上传成功后跳转页面。
	UploadServlet.java : 上传处理 Servlet。
	需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。

下面的实例依赖于 FileUpload，所以一定要确保在您的 classpath 中有最新版本的 commons-fileupload.x.x.jar 文件。可以从 http://commons.apache.org/proper/commons-fileupload/ 下载。
FileUpload 依赖于 Commons IO，所以一定要确保在您的 classpath 中有最新版本的 commons-io-x.x.jar 文件。可以从 http://commons.apache.org/proper/commons-io/ 下载。

	http://static.runoob.com/download/commons-fileupload-1.3.2.jar
	http://static.runoob.com/download/commons-io-2.5.jar

	
问题：
1.为什么这两个包需要存在2份？
一份是Servlet/WebContent/WEB-INF/lib下，一份是Servlet/WEB-INF/lib/下。
前者是eclipse生成用，后者是tomcat运行用。
能否少一份，以便减少git文件体积。只能减少前者了。
删除Servlet/WebContent/WEB-INF/lib/下的2个jar包，UploadServlet.java报错，右击该java文件，选择build path,
configure build path, libraries, add JARs,选择Servlet/WEB-INF/lib/下的2个jar包确定即可。

2.jar包存放的位置？
jar包如果是项目运行必须的，则2个地方至少放一个。
一个tomcat级别的lib文件夹：\tomcat\lib\
一个是具体项目级别的lib文件夹：\项目名\WEB-INF\lib\
tomcat级别的所有项目都可用，而项目级别的只有该项目可用该jar包。

其他位置则可能是编辑器IDE的要求。可以简化。

	
	
	
	
	
	以下是 UploadServlet 的源代码，同于处理文件上传，在这之前我们先确保依赖包已经引入到项目的 WEB-INF/lib 目录下：
	
	
1.upload.jsp : 文件上传表单。
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传实例</title>
</head>
<body>
<h1>文件上传实例</h1>
<form method="post" action="/mywebsite/UploadServlet" enctype="multipart/form-data">
	选择一个文件:
	<input type="file" name="uploadFile" />
	<br/><br/>
	<input type="submit" value="上传" />
</form>
</body>
</html>


2.message.jsp : 上传成功后跳转页面。
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>文件上传结果</title>
</head>
<body>
    <center>
        <h2>${message}</h2>
    </center>
</body>
</html>

3.UploadServlet.java : 
package com.dawn.test;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
 

/**
 * Servlet implementation class UploadServlet
 */
@WebServlet("/UploadServlet")
public class UploadServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
     
    // 上传文件存储目录
    private static final String UPLOAD_DIRECTORY = "upload";
 
    // 上传配置
    private static final int MEMORY_THRESHOLD   = 1024 * 1024 * 3;  // 3MB
    private static final int MAX_FILE_SIZE      = 1024 * 1024 * 40; // 40MB
    private static final int MAX_REQUEST_SIZE   = 1024 * 1024 * 50; // 50MB
 
    @Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init it ! uploading");
	}
    /**
     * 上传数据及保存文件
     */
    protected void doPost(HttpServletRequest request,
		HttpServletResponse response) throws ServletException, IOException {
		// 检测是否为多媒体上传
		if (!ServletFileUpload.isMultipartContent(request)) {
		    // 如果不是则停止
		    PrintWriter writer = response.getWriter();
		    writer.println("Error: 表单必须包含 enctype=multipart/form-data");
		    writer.flush();
		    return;
		}
 
        // 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        // 设置临时存储目录
        factory.setRepository(new File(System.getProperty("java.io.tmpdir")));
 
        ServletFileUpload upload = new ServletFileUpload(factory);
         
        // 设置最大文件上传值
        upload.setFileSizeMax(MAX_FILE_SIZE);
         
        // 设置最大请求值 (包含文件和表单数据)
        upload.setSizeMax(MAX_REQUEST_SIZE);
 
        // 构造临时路径来存储上传的文件
        // 这个路径相对当前应用的目录
        
        System.out.println(request.getServletContext().getRealPath("./"));
        
        String uploadPath = request.getServletContext().getRealPath("./") + File.separator + UPLOAD_DIRECTORY;
       
         
        // 如果目录不存在则创建
        File uploadDir = new File(uploadPath);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }
 
        try {
            // 解析请求的内容提取文件数据
            @SuppressWarnings("unchecked")
            List<FileItem> formItems = upload.parseRequest(request);
 
            if (formItems != null && formItems.size() > 0) {
                // 迭代表单数据
                for (FileItem item : formItems) {
                    // 处理不在表单中的字段
                    if (!item.isFormField()) {
                        String fileName = new File(item.getName()).getName();
                        String filePath = uploadPath + File.separator + fileName;
                        File storeFile = new File(filePath);
                        // 在控制台输出文件的上传路径
                        System.out.println(filePath);
                        // 保存文件到硬盘
                        item.write(storeFile);
                        request.setAttribute("message", "文件上传成功!");
                    }
                }
            }
        } catch (Exception ex) {
            request.setAttribute("message",
                    "错误信息: " + ex.getMessage());
        }
        // 跳转到 message.jsp
        request.getServletContext().getRequestDispatcher("/message.jsp").forward(request, response);
    }
}


4.在web.xml中注册类
 <servlet>
    <display-name>UploadServlet</display-name>
    <servlet-name>UploadServlet</servlet-name>
    <servlet-class>com.dawn.test.UploadServlet</servlet-class>
  </servlet>
   
  <servlet-mapping>
    <servlet-name>UploadServlet</servlet-name>
    <url-pattern>/UploadServlet</url-pattern>
  </servlet-mapping>

5.访问 http://localhost:8080/mywebsite/upload.jsp
即可上传图片到根目录下的upload文件夹。





========================================
Servlet 处理日期
----------------------------------------

 Java 提供的 java.util 包中的 Date 类，这个类封装了当前的日期和时间。Date 类支持两个构造函数。
1.第一个构造函数初始化当前日期和时间的对象。
Date( )

2.下面的构造函数接受一个参数，该参数等于 1970 年 1 月 1 日午夜以来经过的毫秒数。
Date(long millisec)

一旦您有一个可用的 Date 对象，您可以调用下列任意支持的方法来使用日期：

3.CurrentDate.java

import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.*;

public class CurrentDate extends HttpServlet {

	private static final long serialVersionUID = 1L;
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=UTF-8");
		
		PrintWriter out=response.getWriter();
		
		//当前时间
		Date date=new Date();
		out.println("1.当前日期和时间："+date.toString());
		
		//java的时间戳
		out.println("<br>2.java时间戳 （单位：ms）："+date.getTime()+", 需要缩小1000倍后和php一样:"+ date.getTime()/1000);
		out.println("<br>(php[10位]:1482674513)<br>");
		
		//格式化显示
		SimpleDateFormat ft = 
				new SimpleDateFormat ("yyyy.MM.dd hh:mm:ss E a");
		out.println("3.格式化后："+ft.format(date));
	}
}

4.在web.xml中定义类和url
 <servlet>
    <display-name>currentDate</display-name>
    <servlet-name>currentDate</servlet-name>
    <servlet-class>CurrentDate</servlet-class>
  </servlet>
   
  <servlet-mapping>
    <servlet-name>currentDate</servlet-name>
    <url-pattern>/currentDate</url-pattern>
  </servlet-mapping>

5.访问： http://localhost:8080/mywebsite/currentDate 显示：

1.当前日期和时间：Tue Jan 03 17:20:36 CST 2017 
2.java时间戳 （单位：ms）：1483435236806, 需要缩小1000倍后和php一样:1483435236 
(php[10位]:1482674513)
3.格式化后：2017.01.03 05:20:36 星期二 下午


========================================
Servlet 网页重定向
----------------------------------------

1.
最简单的方式是使用 response 对象的 sendRedirect() 方法。
该方法把响应连同状态码和新的网页位置发送回浏览器。
public void HttpServletResponse.sendRedirect(String location)
throws IOException

2.也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果：
....
String site = "https://www.baidu.com" ;
response.setStatus(response.SC_MOVED_TEMPORARILY);
response.setHeader("Location", site); 
....


3.实例：
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class SRedirect extends HttpServlet{

	private static final long serialVersionUID = 1L; 
	
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=UTF-8");
		
		PrintWriter out=response.getWriter();
		out.println("跳转中...");
		
		//1.
		response.sendRedirect("http://www.163.com");
		
		//2.
		String site="https://www.baidu.com";
		response.setStatus(response.SC_MOVED_TEMPORARILY);
		response.setHeader("Location", site);
	}
}




========================================
计数器
----------------------------------------
1.网页计数器

package com.dawn.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class PageHitCounter extends HttpServlet{ 
	private static final long serialVersionUID = 1L;
	
	private int hitCount; 
    
	public void init() {
		// 重置点击计数器
		hitCount = 0;
	}
	
	public void doGet(HttpServletRequest req, HttpServletResponse res)
			throws ServletException, IOException {
		res.setContentType("text/html;charset=utf-8");
		hitCount++;
		PrintWriter out=res.getWriter();
		String str="本页面的点击次数()："+hitCount;
		out.println(str);
		System.out.println(str);
	}
	
	public void destroy() { 
		// 这一步是可选的，但是如果需要，您可以把 hitCount 的值写入到数据库
	} 
}




2.网站点击计数器
很多时候，您可能有兴趣知道整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器做到这一点。

详见上述过滤器部分。



========================================
Servlet 自动刷新页面
----------------------------------------
假设有一个网页，它是显示现场比赛成绩或股票市场状况或货币兑换率。对于所有这些类型的页面，您需要定期刷新网页。
Java Servlet 提供了一个机制，使得网页会在给定的时间间隔自动刷新。
刷新网页的最简单的方式是使用响应对象的方法 setIntHeader()。以下是这种方法的定义：
	public void setIntHeader(String header, int headerValue)

此方法把头信息 "Refresh" 连同一个表示时间间隔的整数值（以秒为单位）发送回浏览器。

1.Fefresh.java 

package com.dawn.test;

import java.io.*;
import java.util.Calendar;
import java.util.GregorianCalendar;

import javax.servlet.*;
import javax.servlet.http.*;


public class Refresh extends HttpServlet {
	private static final long serialVersionUID = 1L;
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		
		// 设置刷新自动加载的事件间隔为 5 秒
		response.setIntHeader("Refresh", 5);
		
		// 设置响应内容类型
		response.setContentType("text/html;charset=UTF-8");
		
		// 获取当前的时间
		Calendar calendar = new GregorianCalendar();
		String am_pm;
		int hour = calendar.get(Calendar.HOUR);
		int minute = calendar.get(Calendar.MINUTE);
		int second = calendar.get(Calendar.SECOND);
		if(calendar.get(Calendar.AM_PM) == 0)
			am_pm = "AM";
		else
			am_pm = "PM";
		
		String CT = hour+":"+ minute +":"+ second +" "+ am_pm;
		
		PrintWriter out = response.getWriter();
		String title = "使用 Servlet 自动刷新页面";
		String docType = "<!DOCTYPE html> \n";
		out.println(docType +
				"<html>\n" +
				"<head><title>" + title + "</title></head>\n"+
				"<body bgcolor=\"#f0f0f0\">\n" +
				"<h1 align=\"center\">" + title + "</h1>\n" +
				"<p>当前时间是：" + CT + "</p>\n");
		
		System.out.println(CT);
	}
}


2.在web.xml中配置该Servlet。
 <servlet>
    <servlet-name>Refresh</servlet-name>
    <servlet-class>com.dawn.test.Refresh</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>Refresh</servlet-name>
    <url-pattern>/Refresh</url-pattern>
  </servlet-mapping>

3.访问：http://localhost:8080/mywebsite/Refresh
即可看到时间，同时控制台也有时间。每五秒刷新一次。


========================================
Servlet 发送电子邮件
----------------------------------------
使用 Servlet 发送一封电子邮件是很简单的，但首先您必须在您的计算机上安装 JavaMail API 和 Java Activation Framework）JAF）。
您可以从 Java 网站下载最新版本的 JavaMail（http://www.oracle.com/technetwork/java/javamail/index.html），打开网页右侧有个 Downloads 链接，点击它下载。
您可以从 Java 网站下载最新版本的 JAF（版本 1.1.1）（http://www.oracle.com/technetwork/articles/java/index-135046.html）。




========================================
Servlet 包
----------------------------------------

1.涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定。给定一个顶级目录名 myapp，目录结构如下所示：
/myapp
    /images
    /WEB-INF
        /classes
        /lib
WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。所有的 HTML 文件都位于顶级目录 myapp 下。对于 admin 用户，您会发现 ROOT 目录是 myApp 的父目录。




2.创建包中的 Servlet
WEB-INF/classes 目录包含了所有的 Servlet 类和其他类文件，类文件所在的目录结构与他们的包名称匹配。例如，如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于以下目录中：
/myapp/WEB-INF/classes/com/myorg/MyServlet.class


========================================
servlet国际化
----------------------------------------

GetLocale.java 文件，获取语言，国家，日期。


import java.io.IOException;
import java.io.PrintWriter;
import java.text.DateFormat;
import java.util.*;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class GetLocale extends HttpServlet {
	
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=utf-8");
		Locale locale =request.getLocale();
		String language=locale.getLanguage();//语言
		String country=locale.getCountry();//国家

		String date = DateFormat.getDateTimeInstance(
                DateFormat.FULL, 
                DateFormat.SHORT, 
                locale).format(new Date( ));//本地化日期

		//输出
		PrintWriter out=response.getWriter();
		out.println("language:"+language+"<br>");
		out.println("country:"+country+"<br>");
		
		out.println("date:"+date+"<br>");
		//language:zh
		//country:CN
	}
}



========================================
servlet更多资料
----------------------------------------
 - servlet:http://www.oracle.com/technetwork/java/javaee/servlet/index.html 官方网站上关于 Servlet 的相关资料。
 - tomcat:http://tomcat.apache.org/ Apache Tomcat 是一个开源软件，实现了对 Java Servlet 和 JSP（JavaServer Pages）技术的支持。
 - mysql Connector/J: http://dev.mysql.com/downloads/connector/j/5.1.html   MySQL Connector/J 是 MySQL 官方 JDBC 驱动程序。MySQL Connector/J is the official JDBC driver for MySQL.

 - The Java™ Tutorials: http://docs.oracle.com/javase/tutorial/index.html   Java 编程语言入门教程。
 - java8: http://docs.oracle.com/javase/8/   Java Platform, Standard Edition (Java SE) 8

 - JDK: https://www.java.com/en/download/
 - JAVA 官网： http://www.oracle.com/technetwork/java/index.html



