Java 学习准备：环境搭建、时间估计、路线图


========================================
*** Java学习路线图 ***
----------------------------------------
1. 
入门：Java SE基础-->Java Web(含数据库+H5+js+vue)

中级：Maven-->Git-->SSM框架 -->MybatisPlus-->Spring Boot-->传智健康【项目实战】

进阶：Spring Cloud(微服务开发,学这一套就够了) 
也可分技术点学： (Dubbo-->Zookeeper-->RabbitMQ-->RocketMQ-->Docker-->Redis -->MongoDB-->搜索技术Elasticsearch-->MySQL进阶）

项目：SaaSiHRM【企业服务】-->好客租房【生活服务】-->万信金融【金融行业】-->闪聚支付【聚合支付】-->权限管理一体化解决方案-->短信网关平台以上技术，足以支撑找一份好的java开发工作。

链接：https://www.zhihu.com/question/470828417/answer/2502386643
https://zhuanlan.zhihu.com/p/451278356



Spring + SpringMVC + Mybatis: https://www.zhihu.com/question/457890725/answer/2048095339




2. 

最终上了年纪会很吃亏，尤其像我这种只会写代码，搞销售不能喝酒和吹牛，搞管理又缺乏情商低下。
我感受到这种悲哀后，每天晚上看看基础知识和体系，感觉收获很多，自己以前太过浮躁。



比如ioc的实现机制，或者aop的实现机制，或者数据库的链接字符串该如何写这样的初等理论问题
各种绕口的多线程或者线程死锁这样的问题

问了下数据库的事务，大家能说出来加个注解，也知道是用aop实现的。但是注解里面有什么样的参数，如何避免脏读，幻读，不可重复读？基本上都回答不上来了。


再比如数据库悲观锁和乐观锁的问题，更不用说分布式事务了！甚至连权限鉴别的实现也不能说出更深的道道。到使用shiro可以实现权限鉴别，但是如何实现分布式的shiro或者自己定义一些filter或者sessionManage更是闻所未闻。

然后动手搭建一个ssm框架都非常的艰难。一般回答都是这些年公司的框架都是搭建好的，自己只是写写读写删改的业务逻辑，至于这些都是框架考虑的。


至于高并发，大数据，微服务这些框架也只是点到为止。甚至都没机会去深入研究使用。





========================================
第一讲 java语言概论
----------------------------------------

1人机交互:
图形化界面
命令行界面

1.1计算机语言: 人与计算机交流的方式。

1.2java语言概述
面向互联网、面向对象。
1.2.1java语言的三种技术架构
j2ee企业版：
j2se标准版
j2me小型版 基本不用了。

Java5.0版后，更名为javaee、javase、javame


安卓系统：自己的工具包。

oracle收购了sun，与ms类似，
有自己的数据库、自己的语言等。

1.2.3java语言的特点：跨平台性
java程序可以在win、linux、mac系统下运行。
也就是具有好的可移植性。
实现方式是虚拟机JVM。虚拟机本身是不跨平台的。
（写虚拟机的都是牛人！！）

1.3java语言的环境搭建
1.3.1什么事JRE, JKD
Java6.0platform

JRE
包括(JVM Java Virtual Machine)和java程序所需的核心类库等。

JDK开发工具包
包括JRE在内，以及开发工具。
安装后放U盘在其他机器也可以用。

下载和安装JDK
配制环境变量。
JDK的bin目录：D:\Program Files\Java\jdk1.6.0_35\bin
都是可执行程序。

命令行简介：
开始运行，输入cmd，进入CMD命令行，java -version
Java version "1.7.0_45"

进入目录 cd命令；进入其他盘，直接输入F:

常见命令：
Md aaa //新建目录
Rm aaa//删除目录
如果目录不是空的，先删除里面的东西，才能删除文件夹。从里往外山。

Del 1.txt //删除文件
Del *.txt//删除txt文件
Del *.*//删除所有文件
*为通配符

Exit 退出dos；

怎么查找命令帮助？
Help //查找所有命令

Help cd //查找cd命令的帮助

配制环境变量
dos命令执行过程：1.在当前目录找；2.如果找不到，在环境变量path中找；3.如果还找不到，则报错。
任何目录都能实现的命令，需要配制【环境变量】。
我的电脑》右键》高级》环境变量》系统变量中 找path，修改值，加入一个; 后面跟着java的bin目录。


安装java环境的步骤：
1.下载安装JDK；
2.改变环境变量；
3.重新打开dos，输入 javac命令，不报错，就成功了。

环境变量配制技巧：
环境变量关系到系统的稳定，更改出错误删会导致不会启动等风险，所以，尽量避免直接修改path。

新建环境变量：JAVA_HOME=f:\jdk\jdk1.6.0
path则设置为：Path=%JAVA_HOME%\bin;


1.3.4 配制环境变量path——临时配制方式
加入已经放到U盘了。
dos命令set，查看所有环境命令
Help set命令查看此命令的帮助；
发现，set path就是直接查看path这个环境变量；
使用命令path=H:\jkd\bin
临时设置java目录到u盘。仅在此dos窗口内有效。

更好的设置方式：
Set path=H:\jkd\bin; %path%

相当于在原来的path中增加了东西。









========================================
|-- 配置 JDK (win10) 和 Eclipse: Java8 & API
----------------------------------------
Java8 API: https://docs.oracle.com/javase/8/docs/api/

1. 配置 JDK 路径
win10 控制面板，系统。

左侧 高级系统设置。
底部 环境变量。

(1) 点击“系统变量”下面的”新建“选项
在”变量名“处填上”Java_Home“
”变量值“为JDK安装路径，笔者的路径是”D:\Program Files\Java\jdk1.8.0_91“
点击”确定“选项

Java_Home
C:\Program Files\Java\jdk1.8.0_161


(2) 在”系统变量“中找到”Path“
选中”Path“点击”编辑“选项
选择右边的“编辑文本”，将引号里面的全部复制“%Java_Home%\bin;%Java_Home%\jre\bin;”，到“变量值”栏的最前面，“确定”

%Java_Home%\bin;%Java_Home%\jre\bin;

(3) 在“系统变量”栏，“新建”，“变量名”为“CLASSPATH”，“变量值”为“.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar”，“确定”
CLASSPATH
.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar;
注意: 添加环境变量，并在CLASSPATH后面加;


(4) 点击“环境变量”最下面的“确定”选项
回到电脑桌面，按快捷键“Win+R”，输入“cmd”
java 
javac
java -version
都要能找到才行。

C:\Users\admin>java -version
java version "1.8.0_291"
Java(TM) SE Runtime Environment (build 1.8.0_291-b10)
Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)


https://www.cnblogs.com/joker-game/p/13150587.html






2. 配置 Eclipse 

菜单 windows - 首选项 
Java, build path, classpath variable:

以上都不是重点，重点是项目的 .classpath 中的路径在新电脑上是不一样的。

修改方式，右击项目，选择 build path - Configuration path,
选择library选项卡，选择有红叉的条目，点edit，然后替换掉新的路径。
新的路径也在XAMPP中，可以使用 everything 搜索文件名。

eclipse 对项目是整体编译的，如果有报错，则部分也运行不了。必须把所有错误全部处理好。



(1) 老文件
$ cat Java/.classpath
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
	<classpathentry kind="lib" path="src/lib/mysql-connector-java-5.1.40-bin.jar"/>
	<classpathentry kind="lib" path="src/lib/servlet-api.jar"/>
	<classpathentry kind="lib" path="F:/xampp/tomcat/lib/jstl-1.2.jar"/>
	<classpathentry kind="lib" path="F:/xampp/tomcat/lib/standard-1.1.2.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>


(2) 新文件: 只有这几个jar文件变了
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="lib" path="src/lib/mysql-connector-java-5.1.40-bin.jar"/>
	<classpathentry kind="lib" path="src/lib/servlet-api.jar"/>
	<classpathentry kind="lib" path="G:/xampp/tomcat/webapps/examples/WEB-INF/lib/jstl.jar"/>
	<classpathentry kind="lib" path="G:/xampp/tomcat/webapps/examples/WEB-INF/lib/standard.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>









========================================
|-- 打包 jar 
----------------------------------------
1. 配置 jdk (jre 不行)
添加路径的例子:  
JAVA_HOME d:\Program Files\Java\jdk1.5.0_02
CLASS_PATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
Path %JAVA_HOME\bin;

我的实战：失败
JAVA_HOME=C:\Program Files\Java\jdk1.8.0_161
CLASS_PATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
Path %JAVA_HOME%\bin;


这样成功了，虽然只在当前 cmd 有效，不过够用了: 
G:\java_code\Louvain>
> Path=C:\Program Files\Java\jdk1.8.0_161\bin;
> javac -version
javac 1.8.0_161
>jar -version
用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...


2. 打包 
https://blog.csdn.net/u012060033/article/details/120693742

(1) 直接打包(失败)
> jar -cvf Louvain.v1.jar *


(2) 修改MANIFEST.MF文件 (失败)
用winRAR软件打开生成的 .jar文件，修改MANIFEST.MF文件，在文件中添加如下一句，并保存到 .jar文件中。这句的意思是说默认执行的主程序的入口。
Main-Class: com.jar.test.MyJarHello

注意：冒号后面有个空格，com.jar.test.MyJarHello最后有个回车。

如果当前类还依赖别的jar包，则在Main-Class下面一行添加如下代码：Class-Path: jar/axis.jar jar/commons-discovery-0.2.jar
上面的jar目录与hello.jar文件放在同一个目录下即可，即：axis.jar和commons-discovery-0.2.jar是相对路径。


==> 上文使用了 package com.jar.test; 
如果没有呢？
Main-Class: ModularityOptimizer
==> 位置也变了
先压缩一个txt文件为rar，双击打开rar界面，填入jar的绝对路径，在 META-INF/MANIFEST.MF
解压出来，添加一行 Main-Class: ModularityOptimizer
然后在移动回压缩包。



(3) 重新构建jar包(成功)

1) 要先编译
>javac *.java

2) 然后把编译文件打包
> jar -cvf Louvain.v1.jar *.class

3) 使用rar压缩软件打开jar包，在 jar包的  META-INF/MANIFEST.MF 文件最后添加一行
Main-Class: ModularityOptimizer





3.运行
> java -jar hello.jar param1 param2

教程: http://www.ludowaltman.nl/slm/
java -jar ModularityOptimizer.jar input_file output_file modularity_function resolution_parameter optimization_algorithm n_random_starts n_iterations random_seed print_output

> java -jar ModularityOptimizer.jar network.txt communities.txt 1 1.0 3 10 10 0 0


(1) try1
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 0.5 1 10 10 0 0

报错: Louvain.v1.jar中没有主清单属性
回到打包(2)。


(2) try2
再运行还报错: 错误: 找不到或无法加载主类 ModularityOptimizer
原来要打包的是 class文件。
回到打包(3)


(3) try3: OK
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df2.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 0.5 1 10 10 0 0

正常了。
$ head G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt
9
2

统计结果:
$ cat G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt | sort | uniq -c | sort -k1nr
    730 0
    480 1
    454 2
    344 3
    278 4
    162 5
    144 6
     32 7
     14 8
      1 9
#

试试分辨率高的
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df2.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 1.5 1 10 10 0 0

统计结果:
$ cat G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt | sort | uniq -c | sort -k1nr
    379 0
    349 1
    344 2
    271 3
    269 4
    255 5
    225 6
    162 7
    160 8
    145 9
     33 10
     32 11
     14 12
      1 13
确实类更多了。
Q: 有一个只有一个元素的类，不好，怎么处理掉？
A: Seurat 4 是在最后一步增加一个处理函数，把孤立点划归到最近的cluster中，最近的定义是什么？貌似 KNN 点落到哪个cluster最多。
注意：画图发现，输出文件的第一行的数字是表示总类数，画图时应该忽略。也就是跳过第一行那个只有一个元素的cluster编号。



(4) R语言可视化检查
# dataset: https://github.com/DawnEve/bioToolKit/tree/master/Python/Louvain

dat2=read.table("backup/UMAP_coord.df.txt", header = T)
head(dat2)
dim(dat2)
#
tmp1=readLines("backup/Lv.cluster.txt")
length(tmp1)
table(tmp1)
dat2$r1=tmp1[2:length(tmp1)]
#
tmp2=readLines("backup/Lv.cluster.txt")
length(tmp2)
table(tmp2)
dat2$r2=tmp2[2:length(tmp2)]
dat2$r2=factor(dat2$r2, 0:(length(unique(dat2$r2))-1) )
#
head(dat2)
library(ggplot2)
p1=ggplot(dat2, aes(x,y, color=r1))+geom_point(size=0.5)+theme_classic()+ggtitle("R=0.5")
p2=ggplot(dat2, aes(x,y, color=r2))+geom_point(size=0.5)+theme_classic()+ggtitle("R=1.5")
p1+p2








========================================
编写hello world
----------------------------------------
三大步骤：
1.写代码：将java代码编写成扩展名为.java的文件；
2.编译：进入文件目录，javac命令翻译成java的运行程序；
3.执行：java xxClass
	
	
具体实例：
1.下载并安装jdk；
2.配制环境变量； -- 请百度
	直到命令行输入java -version能查到版本号：

java version "1.7.0_45"
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing)

[My PC in 4012]D:\>java -version
java version "1.8.0_66"
Java(TM) SE Runtime Environment (build 1.8.0_66-b18)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b18, mixed mode)



3.在某个文件夹中新建文本文档HelloWorld.java，内容如下：

//定义一个类名称为HelloWorld
public class HelloWorld {
	//类的主入口函数 
	public static void main(String args[])  {  
		//System.out.println为打印语句，用来显示结果  
		System.out.println("欢迎使用Java来编写程序!");  
	}
}

4.命令行找到该目录，编译文件：javac HelloWorld.java； 
	如果有错误，请按照提示修改文件；
	如果没有错误，则会生成一个HelloWorld.class文件；
5.命令行输入：java HelloWorld，即可看到输出：

F:\java_code\new_hello>java HelloWorld
欢迎使用Java来编写程序!
	
好的，我们第一个java程序运行了！


常见错误：
	1.不要漏泄结尾的分号;
	2.大小写要正确;
	3.文件名、路径要正确，不要隐藏文件扩展名！
	4.public修饰的类，文件名必须和类名一致，否则编译错误。


classpath环境变量
	java语言classpath环境变量，告诉虚拟机怎么执行程序：
	如果没有分号结尾，在classpath中找，找不到就报错。
	如果有分号结尾，在classpath中找，找不到就在当前目录中找，如果还找不到，就报错。
	防止出错，不要加入分号结尾；
	点号代表当前路径，就是>号左边的部分。

找不到文件的原因：
	1.文件名错误（大小写）；
	2.classpath被设置了


小结：
	1.一个java程序包括编写、编译、运行几个步骤；
	2.javac编译时文件要带扩展名；
	3.java运行程序时不要扩展名！
	4.源程序里要有main方法；
	5.源程序的类名和文件名相同，包括大小写；


========================================
eclipse集成开发工具
----------------------------------------
工欲善其事，必先利其器！
使用记事本也行，但是记事本功能薄弱，没有错误提示、引用提示、帮助提示灯。
使用eclipse则能大大加快软件开发的效率，其在性能、效率、便捷性上都有优势。

Eclipse是目前最流行的Java开发工具，在Eclipse中集成了许多工具和插件，从而使Java的开发更容易。Eclipse是一个可以免费使用的软件，可以从Eclipse的官方网站<http://www.eclipse.org/>上下载。解压缩就可以使用，直接下载的Eclipse是英文版，可以下载中文语言包NLpack1-eclipse-SDK-3.2.1-win32.zip从而完成中文版Eclipse的安装。

•下载和安装Eclipse后，就可以使用该集成工具了，双击eclipse.exe文件就可以运行Eclipse。由于篇幅原因，这里读者可以自己熟练一下Ecliopse界面内容。这里主要来讲解如何在Eclipse中进行第一个HelloWorld程序开发。开发步骤如下所示。 
 
•（1）打开Eclipse，选择菜单栏“文件”，再选择级联菜单“新建”，最后选择子菜单“项目”，在弹出的对话框中选择Java项目，并单击按钮“下一步”。 
 
•（2）输入项目名称，例如：FirstProject；在“内容”选项卡中选择“从现有资源创建项目（X）”，然后在目录中找到前面HelloWorld.java的路径。单击“完成”按钮完成项目的创建。 
 
•（3）在“包资源管理器”中单击右键，弹出邮件菜单，选择“新建”->“包”菜单，在弹出对话框的“名称（N）”文本框中输入包名，这里输入FirstBao。 
 
•（4）打开Java编写界面，输入HelloWorld程序。单击运行按钮，就会在下面的控制台窗口中输出“HelloWorld”内容。这样一个Java程序就在Eclipse工具中编写、编译和运行完成。





========================================
java语言基础
----------------------------------------
2.java语言基础组成：
	2.1关键字
	2.2标示符
	2.3注释
	2.4常量和变量
	2.5运算符
	2.6语句
	2.7函数
	2.8数组

2.1.规则：关键字都是小写，
规范：类名首字母大写。

2.2标示符
大小写字母，数字，_$符号；
字母或_或$开头；
不可数字开头，不可使用关键字；

2.3注释
单行//

多行/*好多行
的注释*/

文档注释：
/**
	文档注释：
	有程序能提出出来这些说明注释。
*/


2.4常量与变量

常量分类
1 整数
2 小数
3 布尔型
4 字符常量：单引号
5.字符串常量：双引号
6.空null：


进制的由来
对于整数，由四种表现形式：
	二进制：0  1,满2进1；
	八进制0-7，满8进1；
	十进制 0-9，满10进1；
	十六进制：1-9A-F,以0x开始

计算机内部都是二进制；
来源于早期的电子开关；

1bit字节=8个二进制位；
1k = 1024;

如果三个bit位为一组，则得到八进制；
如果四个bit位为一组，则得到十六进制；


进制转换


结论：
八进制数，其实就是二进制3位分组；
十六进制数，其实就是二进制4位分组；

负数的二进制表现形式：
	负数就是整数取反再加1；
	负数的二进制的最高位是1；

变量的概念：
	内存中的一个存储区域；
	该区域有自己的名称（变量名）和类型（数据类型）；
	该区域的数据可以在同一类型范围内不断变化；
	

注意事项：
1 数据类型 变量名 = 初始化值；
2 


自动类型提升和强制装换

ascii码表：1-256；
A65，a97；
大概是字母大小写，数字
System.out.print((char)('a' +1) ); //98出来了





类型运算细节（很困难的地方！！）
Byte b=4;
b=3+7;

Byte b1=3;
Byte b2=7;
b=b1+b2;

System.out.print(b);

只有int double可以相加而类型不变。





2.5 运算符
 算术、赋值、比较、逻辑、位、三元运算符；

字符串连接用+号；
自增自减符号；++   --

比较运算符 >  < == !=  instanseof

逻辑运算符: 连接2个布尔表达式。
 and  & 双&&则左假右边不运算；
 or  |  双||则左真右边不运算；
 not  !
异或运算 ^ 两边同时为真或假，则为true；分别为真和假则为false；

2.5.5位运算符 左移右移运算；
左移n位就是乘以2的n次幂；
右移n位就是除以2的n次幂；

2.5.6三元运算符
格式：(条件)? 表达式1:表达式2;
Int x=3,y=4,z;
z=(x>y)?x:y;







2.6.程序流程控制
判断结构
选择结构
循环结构

2.6.1 三种if语句
第一种if语句
If(exp){
	Statement;
}

第二种if语句
If(exp){
	State1;
}else{
	State2;
}

第三种if语句；
If(exp1){
	State1;
}else if(exp2){
	State2;
}else if(exp3){
	State3;
}else{
	stateN;
}


局部代码块：
{}范围的东西外面找不到！！

判断结构例题： 一周七天、判断四季；


2.6.2选择结构
Switch(exp){
	Case value1:
		States1;
		Break;
		
	Case value2:
	Case value3:
		States3;
		Break;
	…
	Default:
		stateN;
}

If和switch的区别：
If 对具体的值进行判断；对区间判断；对运算结果是boolean类型的表达式进行判断；

switch：对具体的值进行判断；值的个数通常是固定的；
对于几个具体值，建议使用switch语句，因为其都加载选项，效率相对较高；
但是switch不经常使用



2.6.3循环结构：while ，do  while, for
While(exp){
	State;
}

Do{
	states
} while(exp)

do...while至少执行一次；

例子（计数器思想）：1-100之间6的倍数出现的次数；
class OperateDemo
{
	public static void main(String[] args){

		int i=0, n=0;
		while(i<=100){
			if(i%6==0){
				n++;
				System.out.println(n+": "+i);
			}
			i++;
		}
		System.out.println("totally: " + n ); //true
	}
}


2.6.3 for循环
格式
for(init; expEnd; increase){
	State;
}


例子：打印1-100中7的倍数；
class OperateDemo
{
	public static void main(String[] args){
		for(int i=0; i<100; i++){
			if( i%7==0 ){
				System.out.println(i);
			}
		}
	}
}


for与while的特点
1.可以互换；
2.格式上不同，在使用上有点小区别：如果for中定义的循环增量，结束后此增量就没有了；

无限循环：

循环结构的使用场景：
当对某些代码执行很多次操作时，使用循环语句；

2.6.3语句的嵌套格式
打印九九乘法表：
class For1
{
	public static void main(String[] args){
		for(int i=1; i<9; i++){
			for(int j=1; j<=i; j++){
				System.out.print(i+"*"+j+"="+i*j+"   ");
			}
			System.out.println();
		}
	}
}


打印菱形：
class For1
{
	public static void main(String[] args){
		for(int i=-10; i<10; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print(" ");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )-1; j++){
					System.out.print("*");
			}


			System.out.println();
		}
	}
}


class For1{
	public static void main(String[] args){
		for(int i=-10; i<11; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )+1; j++){
					System.out.print("-");
			}
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}

			System.out.println();
		}
	}
}


for循环的中断：
Break跳出循环；
continue此循环不算，继续下一个循环；
使用行号结束外循环：
	//按照行号终止循环
	static void test9(){
		xiaoqiang: for(int x=0;x<9;x++){
			wangcai: for(int y=0;y<9;y++){
				System.out.println("x="+x+", y="+y);
				if(y==5 && x==2)
					break xiaoqiang;
			}
		}
	}





========================================
|-- 2.7 函数
----------------------------------------
2.7.1函数的定义：
函数定义类型
修饰符 返回类型 函数名（参数类型 形式参数1，参数类型2, 形参2，...）
{
	执行语句；
	Return 返回值；
}

例子：
class Func{
	public static void main(String[] args){
		int a=3;
		int b=4;
		int c;
		System.out.println( add(a,b) );

	}

	public static int add(int a, int b){
		return a+b;
	}
}

没有返回值的函数：
返回值类型怎么体现？Void


栈的特点：先进后出；



2.7.4函数的重载overload
概念：同一各类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。
重载的特点：

class Fn1{
	/**
	overload of functions
	*/


	//int
	public static int add(int a, int b){
		return a+b;
	}

	//double
	public static double add(double a, double b){
		return a+b;
	}
	//more than 2
	public static int add(int a, int b, int c){
		return a+b+c;//or return add( add(a,b),c))
	}

	public static void main(String[] args){
		int a=3;
		int b=4;
		int c=100;
		System.out.println( add(a, b) );
		System.out.println( add(2.3,3.3) );
		System.out.println( add(a,b,34) );
		System.out.println( add(a,2.1111) );
	}
}






========================================
|-- 2.8 数组
----------------------------------------
2.8数组

2.8.1数组的定义
格式一：Int[] arr=new int[5];
格式二：int[] arr=new int[]{3,5,1,7};
Int[] arr={3,5,1,7};

内存的划分：
1.寄存器；
2.本地方法区；
3.方法区；
4.栈内存；
5.堆内存；


栈内存：
1存储的都是局部变量；
2变量所属作用域一旦结束，该变量被释放；

堆内存：
1存储的是数组和对象（其实就是数组），new建立的都在堆中；
2特点：每个实体都有首地址；有初始化值；有垃圾回收机制；

class Arr1{
	
	public static void main(String[] args){

		int[] arr1={1,2,3,4};//define
		System.out.println( arr1[1] );//use

		arr1[0]=200;//redim
		System.out.println( arr1[0] );

		//every
		for(int x: arr1){
			System.out.print(x+", ");
		}
		System.out.println();

		//---------method2:------
		int[] arr2=new int[3];
		arr2[2]=222;
		System.out.println(arr2[2]);
		
		//---------method3:------
		int[] arr3=new int[]{21,22,23,24};
		arr3[3]=333;
		System.out.println(arr3[2]);
	}
}

2.8.4数组常见操作
1.求最值：最大最小；
2.排序；
3.查找（二分法）

class Arr3{
	
	public static void main(String[] args){

		int[] arr1={16,-25,32,4};//define
		System.out.println( arr1[1] );//use

		arr1[0]=-200;//redim
		System.out.println( arr1[0] );

		//every
		for(int x: arr1){
			System.out.print(x+", ");
		}
		System.out.println();

		for(int i=0; i<arr1.length; i++){
			System.out.println("arr["+i+"]="+arr1[i]);
		}

		System.out.println();
		System.out.println( "max is:"+ getMax(arr1));
		System.out.println( "min is:"+ getMin(arr1));

	}

	//get the max of the array;
	static int getMax(int[] arr){
		int max=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]>max)
				max=arr[i];
		}
		return max;
	}

	//get the min of the array;
	static int getMin(int[] arr){
		int min=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]<min)
				min=arr[i];
		}
		return min;
	}

}

数组常见操作-遍历


数组的排序，冒泡法，选择排序法；




/**
列举数组
*/
	//list arry
	static void listArray(int[] arr){
		for(int i=0; i<arr.length; i++){
			System.out.println("arr["+i+"]="+arr[i]);
		}
	}

	//a better style[a, b, c, d]
	static void listArray2(int[] arr){
		System.out.print("[");
		for(int i=0; i<arr.length; i++){
			System.out.print(arr[i]+", ");
		}
		System.out.println("]");
	}


/**
最大最小值
*/
	//get the max of the array;
	static int getMax(int[] arr){
		int max=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]>max)
				max=arr[i];
		}
		return max;
	}

	//get the min of the array;
	static int getMin(int[] arr){
		int min=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]<min)
				min=arr[i];
		}
		return min;
	}



/**
选择排序

int temp=arr[i];
arr[i]=arr[j];
arr[j]=temp;

不用返回值；
*/
	//sort from MAX to min
	static int[] sortSelection(int[] arr){
		for(int i=0; i<arr.length; i++){
			for(int j=i+1; j<arr.length; j++){
				if(arr[i]<arr[j]){
					int temp=arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			}
		}
		return arr;
	}

	//sort from min to MAX
	static int[] sortSelectionReverse(int[] arr){
		for(int i=0; i<arr.length; i++){
			for(int j=i+1; j<arr.length; j++){
				if(arr[i]>arr[j]){
					int temp=arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			}
		}
		return arr;
	}

/**
冒泡排序
两两比较，符合条件就交换，最后最值冒泡到端点；
*/
	
	//sort from min to MAX
	static void sortBuble(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]>arr[j+1]){
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
				}
			}
		}
		//return arr;
	}

	//sort from MAX to min
	static void sortBubleReverse(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]<arr[j+1]){
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
				}
			}
		}
	}


	static void swap(int[] arr, int i, int j){
		int t=arr[i];
		arr[i]=arr[j];
		arr[j]=t;
	}

	//sort from MAX to min
	static void sortBubleReverse(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]<arr[j+1]){
					swap(arr,j,j+1);
					/*
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
					*/
				}
			}
		}
	}
//end



08java基础（数组：排序的性能问题）


数组的查找：
	//query the index
	public static int getIndex(int[] arr, int key){
		for(int i=0; i<arr.length; i++){
			if(arr[i]==key){
				return i;
			}
		}
		return -1;
	}

折半查询：（也叫 二分查找）
前提是数组必须是排序过的。

/**
数组的查询
*/
	//query the index
	public static int getIndex(int[] arr, int key){
		for(int i=0; i<arr.length; i++){
			if(arr[i]==key){
				return i;
			}
		}
		return -1;
	}


	//getIndex by half search
	static int getIndexHalfSearch(int[] arr, int key){
		int min, mid, max;
		min=0;
		max=arr.length;
		mid=(min+max)/2;

		while(arr[mid]!=key){
			if(key>arr[mid])
				min=mid+1;
			else if(key<arr[mid])
				max=mid-1;

			if(max<min)
				return -1;

			mid=(min+max)/2;
		}
		return mid;
	}

	//getIndex by half search 二分法查找【经典】
	static int getIndexHalfSearch_2(int[] arr, int key){
		int min, mid, max;
		min=0;
		max=arr.length;

		while(max>=min){
			mid=(min+max)/2; //or mid=(min+max)>>1;

			if(key>arr[mid])
				min=mid+1;
			else if(key<arr[mid])
				max=mid-1;
			else
				return mid;			
		}
		return -1;
	}

思考题：
给定一个有序数组，放入一个元素，并保证这个数组有序，请问怎么确定此元素位置；

二分法返回min即可；
而内置方法，返回的是-min-1；
Array.binarySearch(arr, 50);//查看50在arr中是否存在？不存在则返回其插入点；












数组的常见应用

（进制转换）；略


星期转换：
//getWeek
	static String getWeek(int i){
		if(i>7 || i<1){
			return "wrong weeks";
		}

		String[] weeks={"", "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday", "Sunday"};
		return weeks[i];
	}

	
	
	
	

2.8.7二维数组
初始化后，二维数组中第一维表示此数组含有3个一维数组；
但是数组是引用型类型，在堆中初始化为null，所以如下的存储：



例子：
		int[][] arr=new int[3][2];//define
		//set 3 one-d array, each has 2 element;

		arr[0][1]=12;//

		System.out.println(arr); // print the whole 2d-array
		System.out.println(arr[0]);//print the 1st array in the 2d-array;


		System.out.println(arr[0][1]);//element at 1row 2column 


输出如下：
[[I@811c88
[I@785d65
12


或者分别初始化次低级数组：
	static void test2(){
		int[][] arr=new int[3][2];//define
	    //set 3 one-d array, each has 2 element;
		arr[0]=new int[2];
		arr[1]=new int[]{11,12,13};
		arr[2]=new int[4];
		
		int sum=sum2d(arr);
		System.out.print(sum);
	}

	
二维数组求和：
	//sum the 2d-array
	static int sum2dArray(int[][] arr){
		int sum=0;
		for(int x=0; x<arr.length; x++){
			for(int y=0; y<arr[x].length; y++){
				sum +=arr[x][y];
			}
		}
		return sum;
	}










========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------












