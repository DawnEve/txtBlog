Java 学习准备：环境搭建、时间估计、路线图





========================================
*** Java学习路线图 ***
----------------------------------------
1. 学习路线
入门：Java SE基础-->Java Web(含数据库+H5+js+vue)

中级：Maven-->Git-->SSM框架 -->MybatisPlus-->Spring Boot-->传智健康【项目实战】

进阶：Spring Cloud(微服务开发,学这一套就够了) 
也可分技术点学： (Dubbo-->Zookeeper-->RabbitMQ-->RocketMQ-->Docker-->Redis -->MongoDB-->搜索技术Elasticsearch-->MySQL进阶）

项目：SaaSiHRM【企业服务】-->好客租房【生活服务】-->万信金融【金融行业】-->闪聚支付【聚合支付】-->权限管理一体化解决方案-->短信网关平台以上技术，足以支撑找一份好的java开发工作。

链接：https://www.zhihu.com/question/470828417/answer/2502386643
黑马程序员2022年Java学习路线图 https://zhuanlan.zhihu.com/p/451278356



Spring + SpringMVC + Mybatis: https://www.zhihu.com/question/457890725/answer/2048095339

Java的三个方向：JavaEE，大数据，安卓
	企业级应用: Spring-Rest(Spring MVC): 
	安卓: library 都是C写的。
	大数据: Spark-Spark Streaming(Scalar开发的): 其他语言也有接口



大数据:
	hadoop
	flink/spark

JavaSE 

JavaWeb
	html,css,
	JS Dom, jQ
	XML与Tomcat
	http协议
	服务器端组件 Servlet
	JSP
	EL表达式
	JSTL
	会话控制Cookie和Session
	服务器端组件Filter
	服务器端组件 Listener
	国际化
	异步数据传输框架Ajax
	文件的上传下载
	web项目：书城

JavaEE框架
	系统整体分层解耦框架 Spring
	轻量级Web框架springMVC
	轻量级持久层框架mybatis
	服务器操作系统 Linux
	内存数据库 Redis
	项目架构、jar包管理工具Maven
	项目：众筹(Maven/SVN/SpringBoot/Activity/SpringCloud)





2. 学习方法
(1) 尚硅谷 https://www.bilibili.com/video/BV1Kb411W75N/?p=21
背单词 20个。
公开演讲 2 分钟，一个主题。
考试：昨天的5个题目
每天登记excel，干了什么，打分等。
关于笔记：怎么合理？电子版最好。要有整理的过程。
关于兴趣：天生存在的兴趣，可能后天变得没有了兴趣。后天没有的兴趣，也可以慢慢培养起来。

(2) 开始慢，后面快
前两周会比较慢。
从OOP讲完，开始提速。

(3) 后台语言
Java, PHP, Python, Go, Node.js 











10. 要深入学点东西

最终上了年纪会很吃亏，尤其像我这种只会写代码，搞销售不能喝酒和吹牛，搞管理又缺乏情商低下。
我感受到这种悲哀后，每天晚上看看基础知识和体系，感觉收获很多，自己以前太过浮躁。



比如ioc的实现机制，或者aop的实现机制，或者数据库的链接字符串该如何写这样的初等理论问题
各种绕口的多线程或者线程死锁这样的问题

问了下数据库的事务，大家能说出来加个注解，也知道是用aop实现的。但是注解里面有什么样的参数，如何避免脏读，幻读，不可重复读？基本上都回答不上来了。


再比如数据库悲观锁和乐观锁的问题，更不用说分布式事务了！甚至连权限鉴别的实现也不能说出更深的道道。到使用shiro可以实现权限鉴别，但是如何实现分布式的shiro或者自己定义一些filter或者sessionManage更是闻所未闻。

然后动手搭建一个ssm框架都非常的艰难。一般回答都是这些年公司的框架都是搭建好的，自己只是写写读写删改的业务逻辑，至于这些都是框架考虑的。


至于高并发，大数据，微服务这些框架也只是点到为止。甚至都没机会去深入研究使用。





========================================
|-- 部署到 Linux 上
----------------------------------------
https://how2j.cn/frontroute

1 .JAVA 基础 --- HelloWorld
2 .JAVA 基础 --- 面向对象
3 .JAVA 基础 --- 变量
4 .JAVA 基础 --- 操作符
5 .JAVA 基础 --- 控制流程
6 .JAVA 基础 --- 数组
7 .JAVA 基础 --- 类和对象
8 .JAVA 基础 --- 接口与继承
9 .JAVA 基础 --- 数字与字符串
10 .JAVA 基础 --- 日期
11 .JAVA 中级 --- 异常处理
12 .JAVA 中级 --- I/O
13 .JAVA 中级 --- 集合框架
14 .JAVA 中级 --- 泛型
15 .JAVA 中级 --- JDBC
16 .前端部分 --- HTML
17 .前端部分 --- CSS
18 .前端部分 --- JavaScript

19 .J2EE --- Tomcat
20 .J2EE --- Servlet
21 .J2EE --- HTTP协议
22 .J2EE --- JSP
23 .工具和中间件 --- 部署到Linux







========================================
|-- 使用 SpringBoot
----------------------------------------
https://how2j.cn/frontroute

1 .JAVA 基础 --- HelloWorld
2 .JAVA 基础 --- 面向对象
3 .JAVA 基础 --- 变量
4 .JAVA 基础 --- 操作符
5 .JAVA 基础 --- 控制流程
6 .JAVA 基础 --- 数组
7 .JAVA 基础 --- 类和对象
8 .JAVA 基础 --- 接口与继承
9 .JAVA 基础 --- 数字与字符串
10 .JAVA 基础 --- 日期
11 .JAVA 中级 --- 异常处理
12 .JAVA 中级 --- I/O
13 .JAVA 中级 --- 集合框架
14 .JAVA 中级 --- 泛型
15 .JAVA 中级 --- JDBC
16 .前端部分 --- HTML
17 .前端部分 --- CSS
18 .前端部分 --- JavaScript

19 .前端部分 --- JSON
20 .前端部分 --- Ajax
21 .前端部分 --- JQuery
22 .J2EE --- Tomcat
23 .J2EE --- Servlet
24 .J2EE --- HTTP协议
25 .J2EE --- JSP
26 .J2EE --- 前后端分离
27 .JAVA 框架 --- Spring
28 .JAVA 框架 --- SpringBoot






========================================
Java 重要思想和书籍
----------------------------------------
1. 思想

(1) 学习真没有捷径，唯一让人省力的方式就是悟性。

哪些是真正的核心思想？
http://swiftlet.net/archives/3124

2023年的目标: 每天2小时，学习Java基础到SpringBoot。






2. 书籍
《Java核心技术》、《Thinking in Java》和《Effective Java》等。
https://zhuanlan.zhihu.com/p/402329452



(1) 关于辅助书籍，只推荐两本
> Core Java 字典
比如学习完了IO的知识，觉得意犹未尽，那么就通过这本字典一样的Java书籍，把IO的知识更丰满的刷一遍，因为已经通过本站做了很多实践操作了，所以这个时候，看这些知识就会触类旁通，比较好消化了。

站长说的Core Java  就是核心技术卷二，不过你说的这2本书，里面的图形化界面(swing，gui) ，其实没必要学了。
而且我建议你看最新的11版。里面有一些很方便的版本新特性
https://manongbook.com/download/1695.html



> Effective Java 零食，提升代码质量
作为初学者，首要任务不是提升质量，而是掌握完成功能的基本手法。这本书就像零食一样，只要主食吃了，你不吃零食也没关系，但是吃点零食会觉得生活质量得到了提升。 本书可以帮你写出更优质的代码，空隙时间可以拿出来看看，不用通看，碰到什么，看什么，一次也不应该看太多，当做有益的课外补充。


(2) 
> Thinking in Java 提升功力
太早看不合适，里面有些概念需要相当的基础才能理解，否则消化不好。 1年左右看，可以提高不少功力，相当于一个十人副本，在你有了一些基本装备之后，去一趟。为以后去25人团队副本添砖加瓦。

> Head First Java 这是给幼儿园小朋友看的
适合完全外行的人看看，页面很多，包含的知识量较少，学习效率较低。

> 官方出的 Java Tutorial BEST OF THE BEST
曾经心中的最好的Java入门教程，没有之一，当然，现在被本站代替了，哇哈哈哈。 本站的建设从这个教程里得到很多启发，比如基于代码的学习方式，有兴趣的可以过一过，前提是你的英语还不错。 缺点是，有些概念翻来覆去地讲，我曾经翻译过Java Tutorial，但是一部分翻来覆去倒腾的理论讲解，让我的胃翻腾了很久。






3.看看AI的回答
怎么学Java
Java是一种跨平台的编程语言，广泛应用于企业级应用、移动应用、游戏开发、云计算等领域。

(1)学习Java需要掌握以下几个方面：

Java基础知识：掌握Java基础知识，如语法、数据类型、运算符、控制语句、方法、类、对象等。
面向对象编程：Java是一种面向对象的编程语言，需要掌握面向对象编程的思想和技能，如封装、继承、多态等。
Java标准库：Java标准库提供了丰富的API，包括输入输出、网络、多线程、集合等方面，需要掌握Java标准库的使用方法。
数据库编程：Java可以通过JDBC或ORM框架来操作数据库，需要掌握数据库编程的基础知识和技能。
Web开发：Java可以通过Servlet、JSP、Spring MVC等技术来开发Web应用程序，需要掌握Web开发的基础知识和技能。
框架和工具：Java有很多框架和工具，如Spring、Hibernate、MyBatis、Maven等，需要掌握这些框架和工具的使用方法。

(2)自学Java可以通过以下几个步骤：

学习Java基础知识：学习Java基础知识，如语法、数据类型、运算符、控制语句、方法、类、对象等。可以通过在线教程、视频课程、Java编程书籍等途径学习。
练习编程：练习编写Java代码，可以通过编写小程序、练习算法、解决编程问题来提高编程能力。
学习面向对象编程：Java是一种面向对象的编程语言，需要掌握面向对象编程的思想和技能，如封装、继承、多态等。
学习Java标准库：Java标准库提供了丰富的API，包括输入输出、网络、多线程、集合等方面，需要掌握Java标准库的使用方法。
学习Web开发：Java可以通过Servlet、JSP、Spring MVC等技术来开发Web应用程序，需要掌握Web开发的基础知识和技能。
练习项目：通过练习项目来巩固Java编程知识，可以从一些开源项目中找到一些练手的项目，并尝试使用Java进行开发。
参加社区和论坛：参加Java编程社区和论坛，与其他Java开发者交流和学习，可以获取更多的Java知识和经验。
总的来说，自学Java需要不断地实践和探索，需要有一定的耐心和毅力。可以通过多种途径来学习和练习Java编程，不断提高自己的技能水平。

(3) 以下是一些比较好的Java编程书籍推荐：

《Java编程思想》（Thinking in Java）：作者Bruce Eckel，这是一本经典的Java编程入门书籍，深入浅出地介绍了Java编程语言的基本概念和技术。
《Head First Java》：作者Kathy Sierra和Bert Bates，这是一本非常适合初学者的Java编程书籍，通过生动有趣的图例和案例，帮助读者快速掌握Java编程的基础知识。
《Effective Java》：作者Joshua Bloch，这是一本讲述Java编程最佳实践的书籍，全面介绍了Java编程中的一些常见问题和最佳解决方案。
《Java核心技术》（Core Java）：作者Cay S. Horstmann和Gary Cornell，这是一本介绍Java编程语言和Java标准库的权威书籍，内容涵盖了Java编程的方方面面。
《Java并发编程实战》（Java Concurrency in Practice）：作者Brian Goetz等，这是一本介绍Java并发编程的经典书籍，详细讲解了Java并发编程的基本概念和技术。
《深入理解Java虚拟机》：作者周志明，这是一本介绍Java虚拟机的书籍，全面深入地讲解了Java虚拟机的工作原理和调优技术。
以上是一些比较好的Java编程书籍推荐，可以帮助读者深入学习和理解Java编程语言。

(4) 以下是一些比较好的Java编程社区和论坛推荐：

Stack Overflow：这是一个全球性的程序员问答社区，可以在其中提问和回答关于Java编程的问题。
GitHub：这是一个代码托管平台，也是一个开源社区，可以在其中找到很多Java项目和开源库，并参与开源项目的贡献和讨论。
Oracle Community：这是Oracle官方的Java社区，提供了Java技术的最新资讯、文档、工具和讨论。
CSDN：这是一个专注于程序员的社区和博客平台，其中有很多Java编程的技术文章、教程和经验分享。
JavaRanch：这是一个Java编程社区和论坛，提供了关于Java编程的讨论、问答和资源分享。
JavaWorld：这是一个Java编程的在线杂志和社区，提供了最新的Java技术资讯、文章和经验分享。

以上是一些比较好的Java编程社区和论坛推荐，可以帮助Java开发者在学习和工作中获取更多的资源和支持。






========================================
|-- 进制: 2/8/16
----------------------------------------
一个bit是最基本单元。是01。
1 byte = 8 bit

3个一组，就是8进制。
010-101-110
 2   5   6 = 0256

4个一组，就是16进制。
1010-1110
10    14  =0xAE  
 1111(16)=127
所以2进制和16进制常用。8进制不常用。





========================================
第一讲 java语言概论
----------------------------------------

1人机交互:
图形化界面
命令行界面

(1) 计算机语言: 人与计算机交流的方式。

(2) java语言概述
面向互联网、面向对象。


1) java语言的三种技术架构
j2ee企业版：
j2se标准版
j2me小型版 基本不用了。

JDK1.5，也就是
Java5.0版后，更名为 JavaEE、JavaSE、JavaME

安卓系统：自己的工具包。

2009年，
oracle收购了sun，与ms类似，
有自己的数据库、自己的语言等。

2014 JDK 8.0;

常用的 1.6-1.8之间。



2) java语言的特点：跨平台性
java程序可以在win、linux、mac系统下运行。
也就是具有好的可移植性。
实现方式是虚拟机JVM。虚拟机本身是不跨平台的。
（写虚拟机的都是牛人！！）





(3) java语言的环境搭建
1.3.1什么事JRE, JKD
Java6.0platform

JRE
包括(JVM Java Virtual Machine)和java程序所需的核心类库等。

JDK开发工具包
包括JRE在内，以及开发工具。
安装后放U盘在其他机器也可以用。

下载和安装JDK
配制环境变量。
JDK的bin目录：D:\Program Files\Java\jdk1.6.0_35\bin
都是可执行程序。

命令行简介：
开始运行，输入cmd，进入CMD命令行，java -version
Java version "1.7.0_45"

进入目录 cd命令；进入其他盘，直接输入F:

常见命令：
Md aaa //新建目录
Rm aaa//删除目录
如果目录不是空的，先删除里面的东西，才能删除文件夹。从里往外山。

Del 1.txt //删除文件
Del *.txt//删除txt文件
Del *.*//删除所有文件
*为通配符

Exit 退出dos；

怎么查找命令帮助？
Help //查找所有命令

Help cd //查找cd命令的帮助

配制环境变量
dos命令执行过程：1.在当前目录找；2.如果找不到，在环境变量path中找；3.如果还找不到，则报错。
任何目录都能实现的命令，需要配制【环境变量】。
我的电脑》右键》高级》环境变量》系统变量中 找path，修改值，加入一个; 后面跟着java的bin目录。


安装java环境的步骤：
1.下载安装JDK；
2.改变环境变量；
3.重新打开dos，输入 javac命令，不报错，就成功了。

环境变量配制技巧：
环境变量关系到系统的稳定，更改出错误删会导致不会启动等风险，所以，尽量避免直接修改path。

新建环境变量：JAVA_HOME=f:\jdk\jdk1.6.0
path则设置为：Path=%JAVA_HOME%\bin;


1.3.4 配制环境变量path——临时配制方式
加入已经放到U盘了。
dos命令set，查看所有环境命令
Help set命令查看此命令的帮助；
发现，set path就是直接查看path这个环境变量；
使用命令path=H:\jkd\bin
临时设置java目录到u盘。仅在此dos窗口内有效。

更好的设置方式：
Set path=H:\jkd\bin; %path%

相当于在原来的path中增加了东西。









========================================
|-- 配置 JDK (win10) 和 Eclipse: Java8 & API
----------------------------------------
Java8 API: https://docs.oracle.com/javase/8/docs/api/

1. 配置 JDK 路径
https://www.cnblogs.com/WangYiqiang/p/9735304.html

win10 控制面板，系统。

左侧 高级系统设置。
底部 环境变量。

(1) 点击“系统变量”下面的”新建“选项
在”变量名“处填上”Java_Home“
”变量值“为JDK安装路径，笔者的路径是”D:\Program Files\Java\jdk1.8.0_91“
点击”确定“选项

Java_Home
C:\Program Files\Java\jdk1.8.0_161



(2) 在”系统变量“中找到“Path”
选中”Path“点击”编辑“选项
选择右边的“编辑文本”，将引号里面的全部复制“%Java_Home%\bin;%Java_Home%\jre\bin;”，到“变量值”栏的最前面，“确定”

%Java_Home%\bin;%Java_Home%\jre\bin;

(3) 在“系统变量”栏，“新建”，“变量名”为“CLASSPATH”，“变量值”为“.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar”，“确定”
CLASSPATH
.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar;
注意: 添加环境变量，并在CLASSPATH后面加;


(4) 点击“环境变量”最下面的“确定”选项
回到电脑桌面，按快捷键“Win+R”，输入“cmd”
java 
javac
java -version
都要能找到才行。

C:\Users\admin>java -version
java version "1.8.0_291"
Java(TM) SE Runtime Environment (build 1.8.0_291-b10)
Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)


https://www.cnblogs.com/joker-game/p/13150587.html






2. 配置 Eclipse 

菜单 windows - 首选项 
Java, build path, classpath variable:

以上都不是重点，重点是项目的 .classpath 中的路径在新电脑上是不一样的。

修改方式，右击项目，选择 build path - Configuration path,
选择library选项卡，选择有红叉的条目，点edit，然后替换掉新的路径。
新的路径也在XAMPP中，可以使用 everything 搜索文件名。

eclipse 对项目是整体编译的，如果有报错，则部分也运行不了。必须把所有错误全部处理好。



(1) 老文件
$ cat Java/.classpath
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
	<classpathentry kind="lib" path="src/lib/mysql-connector-java-5.1.40-bin.jar"/>
	<classpathentry kind="lib" path="src/lib/servlet-api.jar"/>
	<classpathentry kind="lib" path="F:/xampp/tomcat/lib/jstl-1.2.jar"/>
	<classpathentry kind="lib" path="F:/xampp/tomcat/lib/standard-1.1.2.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>


(2) 新文件: 只有这几个jar文件变了
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="lib" path="src/lib/mysql-connector-java-5.1.40-bin.jar"/>
	<classpathentry kind="lib" path="src/lib/servlet-api.jar"/>
	<classpathentry kind="lib" path="G:/xampp/tomcat/webapps/examples/WEB-INF/lib/jstl.jar"/>
	<classpathentry kind="lib" path="G:/xampp/tomcat/webapps/examples/WEB-INF/lib/standard.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>









========================================
|-- 打包 jar 
----------------------------------------
1. 配置 jdk (jre 不行)
添加路径的例子:  
JAVA_HOME d:\Program Files\Java\jdk1.5.0_02
CLASS_PATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
Path %JAVA_HOME\bin;

我的实战：失败
JAVA_HOME=C:\Program Files\Java\jdk1.8.0_161
CLASS_PATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
Path %JAVA_HOME%\bin;


这样成功了，虽然只在当前 cmd 有效，不过够用了: 
G:\java_code\Louvain>
> Path=C:\Program Files\Java\jdk1.8.0_161\bin;
> javac -version
javac 1.8.0_161
>jar -version
用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...


2. 打包 
https://blog.csdn.net/u012060033/article/details/120693742

(1) 直接打包(失败)
> jar -cvf Louvain.v1.jar *


(2) 修改MANIFEST.MF文件 (失败)
用winRAR软件打开生成的 .jar文件，修改MANIFEST.MF文件，在文件中添加如下一句，并保存到 .jar文件中。这句的意思是说默认执行的主程序的入口。
Main-Class: com.jar.test.MyJarHello

注意：冒号后面有个空格，com.jar.test.MyJarHello最后有个回车。

如果当前类还依赖别的jar包，则在Main-Class下面一行添加如下代码：Class-Path: jar/axis.jar jar/commons-discovery-0.2.jar
上面的jar目录与hello.jar文件放在同一个目录下即可，即：axis.jar和commons-discovery-0.2.jar是相对路径。


==> 上文使用了 package com.jar.test; 
如果没有呢？
Main-Class: ModularityOptimizer
==> 位置也变了
先压缩一个txt文件为rar，双击打开rar界面，填入jar的绝对路径，在 META-INF/MANIFEST.MF
解压出来，添加一行 Main-Class: ModularityOptimizer
然后在移动回压缩包。



(3) 重新构建jar包(成功)

1) 要先编译
>javac *.java

2) 然后把编译文件打包
> jar -cvf Louvain.v1.jar *.class

3) 使用rar压缩软件打开jar包，在 jar包的  META-INF/MANIFEST.MF 文件最后添加一行
Main-Class: ModularityOptimizer





3.运行
> java -jar hello.jar param1 param2

教程: http://www.ludowaltman.nl/slm/
java -jar ModularityOptimizer.jar input_file output_file modularity_function resolution_parameter optimization_algorithm n_random_starts n_iterations random_seed print_output

> java -jar ModularityOptimizer.jar network.txt communities.txt 1 1.0 3 10 10 0 0


(1) try1
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 0.5 1 10 10 0 0

报错: Louvain.v1.jar中没有主清单属性
回到打包(2)。


(2) try2
再运行还报错: 错误: 找不到或无法加载主类 ModularityOptimizer
原来要打包的是 class文件。
回到打包(3)


(3) try3: OK
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df2.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 0.5 1 10 10 0 0

正常了。
$ head G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt
9
2

统计结果:
$ cat G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt | sort | uniq -c | sort -k1nr
    730 0
    480 1
    454 2
    344 3
    278 4
    162 5
    144 6
     32 7
     14 8
      1 9
#

试试分辨率高的
> java -jar Louvain.v1.jar G:/xampp/htdocs/bioToolKit/Python/Louvain/data/snn_df2.txt G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt 1 1.5 1 10 10 0 0

统计结果:
$ cat G:/xampp/htdocs/bioToolKit/Python/Louvain/backup/result.txt | sort | uniq -c | sort -k1nr
    379 0
    349 1
    344 2
    271 3
    269 4
    255 5
    225 6
    162 7
    160 8
    145 9
     33 10
     32 11
     14 12
      1 13
确实类更多了。
Q: 有一个只有一个元素的类，不好，怎么处理掉？
A: Seurat 4 是在最后一步增加一个处理函数，把孤立点划归到最近的cluster中，最近的定义是什么？貌似 KNN 点落到哪个cluster最多。
注意：画图发现，输出文件的第一行的数字是表示总类数，画图时应该忽略。也就是跳过第一行那个只有一个元素的cluster编号。



(4) R语言可视化检查
# dataset: https://github.com/DawnEve/bioToolKit/tree/master/Python/Louvain

dat2=read.table("backup/UMAP_coord.df.txt", header = T)
head(dat2)
dim(dat2)
#
tmp1=readLines("backup/Lv.cluster.txt")
length(tmp1)
table(tmp1)
dat2$r1=tmp1[2:length(tmp1)]
#
tmp2=readLines("backup/Lv.cluster.txt")
length(tmp2)
table(tmp2)
dat2$r2=tmp2[2:length(tmp2)]
dat2$r2=factor(dat2$r2, 0:(length(unique(dat2$r2))-1) )
#
head(dat2)
library(ggplot2)
p1=ggplot(dat2, aes(x,y, color=r1))+geom_point(size=0.5)+theme_classic()+ggtitle("R=0.5")
p2=ggplot(dat2, aes(x,y, color=r2))+geom_point(size=0.5)+theme_classic()+ggtitle("R=1.5")
p1+p2








========================================
编写hello world
----------------------------------------
三大步骤：
1.写代码：将java代码编写成扩展名为.java的文件；
2.编译：进入文件目录，javac命令翻译成java的运行程序；
3.执行：java xxClass
	
	
具体实例：
1.下载并安装jdk；
2.配制环境变量； -- 请百度
	直到命令行输入java -version能查到版本号：

java version "1.7.0_45"
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing)

[My PC in 4012]D:\>java -version
java version "1.8.0_66"
Java(TM) SE Runtime Environment (build 1.8.0_66-b18)
Java HotSpot(TM) 64-Bit Server VM (build 25.66-b18, mixed mode)



3.在某个文件夹中新建文本文档HelloWorld.java，内容如下：

//定义一个类名称为HelloWorld
public class HelloWorld {
	//类的主入口函数 
	public static void main(String args[])  {  
		//System.out.println为打印语句，用来显示结果  
		System.out.println("欢迎使用Java来编写程序!");  
	}
}

4.命令行找到该目录，编译文件：javac HelloWorld.java； 
	如果有错误，请按照提示修改文件；
	如果没有错误，则会生成一个HelloWorld.class文件；
5.命令行输入：java HelloWorld，即可看到输出：

F:\java_code\new_hello>java HelloWorld
欢迎使用Java来编写程序!
	
好的，我们第一个java程序运行了！


常见错误：
	1.不要漏泄结尾的分号;
	2.大小写要正确;
	3.文件名、路径要正确，不要隐藏文件扩展名！
	4.public修饰的类，文件名必须和类名一致，否则编译错误。


classpath环境变量
	java语言classpath环境变量，告诉虚拟机怎么执行程序：
	如果没有分号结尾，在classpath中找，找不到就报错。
	如果有分号结尾，在classpath中找，找不到就在当前目录中找，如果还找不到，就报错。
	防止出错，不要加入分号结尾；
	点号代表当前路径，就是>号左边的部分。

找不到文件的原因：
	1.文件名错误（大小写）；
	2.classpath被设置了


小结：
	1.一个java程序包括编写、编译、运行几个步骤；
	2.javac编译时文件要带扩展名；
	3.java运行程序时不要扩展名！
	4.源程序里要有main方法；
	5.源程序的类名和文件名相同，包括大小写；




========================================
eclipse集成开发工具
----------------------------------------
工欲善其事，必先利其器！
使用记事本也行，但是记事本功能薄弱，没有错误提示、引用提示、帮助提示灯。
使用eclipse则能大大加快软件开发的效率，其在性能、效率、便捷性上都有优势。

Eclipse是目前最流行的Java开发工具，在Eclipse中集成了许多工具和插件，从而使Java的开发更容易。Eclipse是一个可以免费使用的软件，可以从Eclipse的官方网站<http://www.eclipse.org/>上下载。解压缩就可以使用，直接下载的Eclipse是英文版，可以下载中文语言包NLpack1-eclipse-SDK-3.2.1-win32.zip从而完成中文版Eclipse的安装。

•下载和安装Eclipse后，就可以使用该集成工具了，双击eclipse.exe文件就可以运行Eclipse。由于篇幅原因，这里读者可以自己熟练一下Ecliopse界面内容。这里主要来讲解如何在Eclipse中进行第一个HelloWorld程序开发。开发步骤如下所示。 
 
•（1）打开Eclipse，选择菜单栏“文件”，再选择级联菜单“新建”，最后选择子菜单“项目”，在弹出的对话框中选择Java项目，并单击按钮“下一步”。 
 
•（2）输入项目名称，例如：FirstProject；在“内容”选项卡中选择“从现有资源创建项目（X）”，然后在目录中找到前面HelloWorld.java的路径。单击“完成”按钮完成项目的创建。 
 
•（3）在“包资源管理器”中单击右键，弹出邮件菜单，选择“新建”->“包”菜单，在弹出对话框的“名称（N）”文本框中输入包名，这里输入FirstBao。 
 
•（4）打开Java编写界面，输入HelloWorld程序。单击运行按钮，就会在下面的控制台窗口中输出“HelloWorld”内容。这样一个Java程序就在Eclipse工具中编写、编译和运行完成。





========================================
|-- Eclipse 快捷键
----------------------------------------
https://www.runoob.com/w3cnote/eclipse-shortcut-keys.html?from=timeline
https://blog.csdn.net/weixin_40918067/article/details/116846952
https://www.runoob.com/eclipse/eclipse-shortcuts.html

ctrl+shift+L 显示快捷键列表。


1. 怎么快速书写输出
System.out.print();

输入 syso 按 tab 键，
	或者 alt+/，[推荐后者]。

自动导入包: 
Arrays+ alt+/


2. 运行 ctrl+F11

3. 大小写
ctrl+shift+x -- >变大写
ctrl+shift+y -- >变小写








========================================
|-- 多次学习、循序渐进
----------------------------------------
个人心得：

第一.切记不要一上来就找一大本厚书看。这样你绝对会放弃。《Java核心技术》《Java编程思想》等都不适合入门阅读。

第二.先找一个入门级别的java教程看。网上有很多极简入门教程。例如runoob网站、w3cschool网站(它还有手机app)。我记得我一开始入门找的教程，知识面全而精炼简洁，含有基础、spring、Hibernate Servlet Structs Mybatis等,地址如下供参考。http://how2j.cn?p=51259

第三.此时对java有一个整体的认识，找一个小项目，上手练习，边做边查资料。进步会飞快。

第四.这个阶段再回头精读一些java经典书籍，获得内功上的提升。







========================================
java语言基础
----------------------------------------
2.java语言基础组成：
	2.1关键字
	2.2标示符
	2.3注释
	2.4常量和变量
	2.5运算符
	2.6语句
	2.7函数
	2.8数组

2.1.规则：关键字都是小写，
规范：类名首字母大写。

2.2标示符
大小写字母，数字，_$符号；
字母或_或$开头；
不可数字开头，不可使用关键字；

2.3注释
单行//

多行/*好多行
的注释*/

文档注释：
/**
	文档注释：
	有程序能提出出来这些说明注释。
*/


2.4常量与变量

常量分类
1 整数
2 小数
3 布尔型
4 字符常量：单引号
5.字符串常量：双引号
6.空null：


进制的由来
对于整数，由四种表现形式：
	二进制：0  1,满2进1；
	八进制0-7，满8进1；
	十进制 0-9，满10进1；
	十六进制：1-9A-F,以0x开始

计算机内部都是二进制；
来源于早期的电子开关；

1bit字节=8个二进制位；
1k = 1024;

如果三个bit位为一组，则得到八进制；
如果四个bit位为一组，则得到十六进制；


进制转换


结论：
八进制数，其实就是二进制3位分组；
十六进制数，其实就是二进制4位分组；

负数的二进制表现形式：
	负数就是整数取反再加1；
	负数的二进制的最高位是1；

变量的概念：
	内存中的一个存储区域；
	该区域有自己的名称（变量名）和类型（数据类型）；
	该区域的数据可以在同一类型范围内不断变化；
	

注意事项：
1 数据类型 变量名 = 初始化值；
2 


自动类型提升和强制装换

ascii码表：1-256；
A65，a97；
大概是字母大小写，数字
System.out.print((char)('a' +1) ); //98出来了





类型运算细节（很困难的地方！！）
Byte b=4;
b=3+7;

Byte b1=3;
Byte b2=7;
b=b1+b2;

System.out.print(b);

只有int double可以相加而类型不变。





2.5 运算符
 算术、赋值、比较、逻辑、位、三元运算符；

字符串连接用+号；
自增自减符号；++   --

比较运算符 >  < == !=  instanseof

逻辑运算符: 连接2个布尔表达式。
 and  & 双&&则左假右边不运算；
 or  |  双||则左真右边不运算；
 not  !
异或运算 ^ 两边同时为真或假，则为true；分别为真和假则为false；

2.5.5位运算符 左移右移运算；
左移n位就是乘以2的n次幂；
右移n位就是除以2的n次幂；

2.5.6三元运算符
格式：(条件)? 表达式1:表达式2;
Int x=3,y=4,z;
z=(x>y)?x:y;







2.6.程序流程控制
判断结构
选择结构
循环结构

2.6.1 三种if语句
第一种if语句
If(exp){
	Statement;
}

第二种if语句
If(exp){
	State1;
}else{
	State2;
}

第三种if语句；
If(exp1){
	State1;
}else if(exp2){
	State2;
}else if(exp3){
	State3;
}else{
	stateN;
}


局部代码块：
{}范围的东西外面找不到！！

判断结构例题： 一周七天、判断四季；


2.6.2选择结构
Switch(exp){
	Case value1:
		States1;
		Break;
		
	Case value2:
	Case value3:
		States3;
		Break;
	…
	Default:
		stateN;
}

If和switch的区别：
If 对具体的值进行判断；对区间判断；对运算结果是boolean类型的表达式进行判断；

switch：对具体的值进行判断；值的个数通常是固定的；
对于几个具体值，建议使用switch语句，因为其都加载选项，效率相对较高；
但是switch不经常使用



2.6.3循环结构：while ，do  while, for
While(exp){
	State;
}

Do{
	states
} while(exp)

do...while至少执行一次；

例子（计数器思想）：1-100之间6的倍数出现的次数；
class OperateDemo
{
	public static void main(String[] args){

		int i=0, n=0;
		while(i<=100){
			if(i%6==0){
				n++;
				System.out.println(n+": "+i);
			}
			i++;
		}
		System.out.println("totally: " + n ); //true
	}
}


2.6.3 for循环
格式
for(init; expEnd; increase){
	State;
}


例子：打印1-100中7的倍数；
class OperateDemo
{
	public static void main(String[] args){
		for(int i=0; i<100; i++){
			if( i%7==0 ){
				System.out.println(i);
			}
		}
	}
}


for与while的特点
1.可以互换；
2.格式上不同，在使用上有点小区别：如果for中定义的循环增量，结束后此增量就没有了；

无限循环：

循环结构的使用场景：
当对某些代码执行很多次操作时，使用循环语句；

2.6.3语句的嵌套格式
打印九九乘法表：
class For1
{
	public static void main(String[] args){
		for(int i=1; i<9; i++){
			for(int j=1; j<=i; j++){
				System.out.print(i+"*"+j+"="+i*j+"   ");
			}
			System.out.println();
		}
	}
}


打印菱形：
class For1
{
	public static void main(String[] args){
		for(int i=-10; i<10; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print(" ");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )-1; j++){
					System.out.print("*");
			}


			System.out.println();
		}
	}
}


class For1{
	public static void main(String[] args){
		for(int i=-10; i<11; i++){
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}
			for(int j=1; j<=2*( 10-Math.abs(i)  )+1; j++){
					System.out.print("-");
			}
			for(int j=1; j<=Math.abs(i); j++){
					System.out.print("*");
			}

			System.out.println();
		}
	}
}


for循环的中断：
Break跳出循环；
continue此循环不算，继续下一个循环；
使用行号结束外循环：
	//按照行号终止循环
	static void test9(){
		xiaoqiang: for(int x=0;x<9;x++){
			wangcai: for(int y=0;y<9;y++){
				System.out.println("x="+x+", y="+y);
				if(y==5 && x==2)
					break xiaoqiang;
			}
		}
	}





========================================
|-- 2.7 函数
----------------------------------------
2.7.1函数的定义：
函数定义类型
修饰符 返回类型 函数名（参数类型 形式参数1，参数类型2, 形参2，...）
{
	执行语句；
	Return 返回值；
}

例子：
class Func{
	public static void main(String[] args){
		int a=3;
		int b=4;
		int c;
		System.out.println( add(a,b) );

	}

	public static int add(int a, int b){
		return a+b;
	}
}

没有返回值的函数：
返回值类型怎么体现？Void


栈的特点：先进后出；



2.7.4函数的重载overload
概念：同一各类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。
重载的特点：

class Fn1{
	/**
	overload of functions
	*/


	//int
	public static int add(int a, int b){
		return a+b;
	}

	//double
	public static double add(double a, double b){
		return a+b;
	}
	//more than 2
	public static int add(int a, int b, int c){
		return a+b+c;//or return add( add(a,b),c))
	}

	public static void main(String[] args){
		int a=3;
		int b=4;
		int c=100;
		System.out.println( add(a, b) );
		System.out.println( add(2.3,3.3) );
		System.out.println( add(a,b,34) );
		System.out.println( add(a,2.1111) );
	}
}






========================================
|-- 2.8 数组
----------------------------------------
2.8数组

2.8.1数组的定义
格式一：Int[] arr=new int[5];
格式二：int[] arr=new int[]{3,5,1,7};
Int[] arr={3,5,1,7};

内存的划分：
1.寄存器；
2.本地方法区；
3.方法区；
4.栈内存；
5.堆内存；


栈内存：
1存储的都是局部变量；
2变量所属作用域一旦结束，该变量被释放；

堆内存：
1存储的是数组和对象（其实就是数组），new建立的都在堆中；
2特点：每个实体都有首地址；有初始化值；有垃圾回收机制；

class Arr1{
	
	public static void main(String[] args){

		int[] arr1={1,2,3,4};//define
		System.out.println( arr1[1] );//use

		arr1[0]=200;//redim
		System.out.println( arr1[0] );

		//every
		for(int x: arr1){
			System.out.print(x+", ");
		}
		System.out.println();

		//---------method2:------
		int[] arr2=new int[3];
		arr2[2]=222;
		System.out.println(arr2[2]);
		
		//---------method3:------
		int[] arr3=new int[]{21,22,23,24};
		arr3[3]=333;
		System.out.println(arr3[2]);
	}
}

2.8.4数组常见操作
1.求最值：最大最小；
2.排序；
3.查找（二分法）

class Arr3{
	
	public static void main(String[] args){

		int[] arr1={16,-25,32,4};//define
		System.out.println( arr1[1] );//use

		arr1[0]=-200;//redim
		System.out.println( arr1[0] );

		//every
		for(int x: arr1){
			System.out.print(x+", ");
		}
		System.out.println();

		for(int i=0; i<arr1.length; i++){
			System.out.println("arr["+i+"]="+arr1[i]);
		}

		System.out.println();
		System.out.println( "max is:"+ getMax(arr1));
		System.out.println( "min is:"+ getMin(arr1));

	}

	//get the max of the array;
	static int getMax(int[] arr){
		int max=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]>max)
				max=arr[i];
		}
		return max;
	}

	//get the min of the array;
	static int getMin(int[] arr){
		int min=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]<min)
				min=arr[i];
		}
		return min;
	}

}

数组常见操作-遍历


数组的排序，冒泡法，选择排序法；




/**
列举数组
*/
	//list arry
	static void listArray(int[] arr){
		for(int i=0; i<arr.length; i++){
			System.out.println("arr["+i+"]="+arr[i]);
		}
	}

	//a better style[a, b, c, d]
	static void listArray2(int[] arr){
		System.out.print("[");
		for(int i=0; i<arr.length; i++){
			System.out.print(arr[i]+", ");
		}
		System.out.println("]");
	}


/**
最大最小值
*/
	//get the max of the array;
	static int getMax(int[] arr){
		int max=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]>max)
				max=arr[i];
		}
		return max;
	}

	//get the min of the array;
	static int getMin(int[] arr){
		int min=arr[0];
		for(int i=1; i<arr.length; i++){
			if(arr[i]<min)
				min=arr[i];
		}
		return min;
	}



/**
选择排序

int temp=arr[i];
arr[i]=arr[j];
arr[j]=temp;

不用返回值；
*/
	//sort from MAX to min
	static int[] sortSelection(int[] arr){
		for(int i=0; i<arr.length; i++){
			for(int j=i+1; j<arr.length; j++){
				if(arr[i]<arr[j]){
					int temp=arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			}
		}
		return arr;
	}

	//sort from min to MAX
	static int[] sortSelectionReverse(int[] arr){
		for(int i=0; i<arr.length; i++){
			for(int j=i+1; j<arr.length; j++){
				if(arr[i]>arr[j]){
					int temp=arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			}
		}
		return arr;
	}

/**
冒泡排序
两两比较，符合条件就交换，最后最值冒泡到端点；
*/
	
	//sort from min to MAX
	static void sortBuble(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]>arr[j+1]){
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
				}
			}
		}
		//return arr;
	}

	//sort from MAX to min
	static void sortBubleReverse(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]<arr[j+1]){
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
				}
			}
		}
	}


	static void swap(int[] arr, int i, int j){
		int t=arr[i];
		arr[i]=arr[j];
		arr[j]=t;
	}

	//sort from MAX to min
	static void sortBubleReverse(int[] arr){
		for(int i=0; i<arr.length-1; i++){
			for(int j=0; j<arr.length-i-1; j++){
				if(arr[j]<arr[j+1]){
					swap(arr,j,j+1);
					/*
					int temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=temp;
					*/
				}
			}
		}
	}
//end



08java基础（数组：排序的性能问题）


数组的查找：
	//query the index
	public static int getIndex(int[] arr, int key){
		for(int i=0; i<arr.length; i++){
			if(arr[i]==key){
				return i;
			}
		}
		return -1;
	}

折半查询：（也叫 二分查找）
前提是数组必须是排序过的。

/**
数组的查询
*/
	//query the index
	public static int getIndex(int[] arr, int key){
		for(int i=0; i<arr.length; i++){
			if(arr[i]==key){
				return i;
			}
		}
		return -1;
	}


	//getIndex by half search
	static int getIndexHalfSearch(int[] arr, int key){
		int min, mid, max;
		min=0;
		max=arr.length;
		mid=(min+max)/2;

		while(arr[mid]!=key){
			if(key>arr[mid])
				min=mid+1;
			else if(key<arr[mid])
				max=mid-1;

			if(max<min)
				return -1;

			mid=(min+max)/2;
		}
		return mid;
	}

	//getIndex by half search 二分法查找【经典】
	static int getIndexHalfSearch_2(int[] arr, int key){
		int min, mid, max;
		min=0;
		max=arr.length;

		while(max>=min){
			mid=(min+max)/2; //or mid=(min+max)>>1;

			if(key>arr[mid])
				min=mid+1;
			else if(key<arr[mid])
				max=mid-1;
			else
				return mid;			
		}
		return -1;
	}

思考题：
给定一个有序数组，放入一个元素，并保证这个数组有序，请问怎么确定此元素位置；

二分法返回min即可；
而内置方法，返回的是-min-1；
Array.binarySearch(arr, 50);//查看50在arr中是否存在？不存在则返回其插入点；












数组的常见应用

（进制转换）；略


星期转换：
//getWeek
	static String getWeek(int i){
		if(i>7 || i<1){
			return "wrong weeks";
		}

		String[] weeks={"", "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday", "Sunday"};
		return weeks[i];
	}

	
	
	
	

2.8.7二维数组
初始化后，二维数组中第一维表示此数组含有3个一维数组；
但是数组是引用型类型，在堆中初始化为null，所以如下的存储：



例子：
		int[][] arr=new int[3][2];//define
		//set 3 one-d array, each has 2 element;

		arr[0][1]=12;//

		System.out.println(arr); // print the whole 2d-array
		System.out.println(arr[0]);//print the 1st array in the 2d-array;


		System.out.println(arr[0][1]);//element at 1row 2column 


输出如下：
[[I@811c88
[I@785d65
12


或者分别初始化次低级数组：
	static void test2(){
		int[][] arr=new int[3][2];//define
	    //set 3 one-d array, each has 2 element;
		arr[0]=new int[2];
		arr[1]=new int[]{11,12,13};
		arr[2]=new int[4];
		
		int sum=sum2d(arr);
		System.out.print(sum);
	}

	
二维数组求和：
	//sum the 2d-array
	static int sum2dArray(int[][] arr){
		int sum=0;
		for(int x=0; x<arr.length; x++){
			for(int y=0; y<arr[x].length; y++){
				sum +=arr[x][y];
			}
		}
		return sum;
	}










========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------












