c语言编译与调试


多文件编译
	命令行参数
	变量作用范围: 块作用域{}、文件作用域(static)、全局作用域
	变量生存期: 静态、非静态
	gcc 
	cmake


调试：编译时错误和运行时错误。后者主要是内存管理问题。
内存:
	内存分配-> 详见: 指针
	gdb 调试
	内存泄漏 valgrind


模块化
	一个模块就是一个文件
	模块私有变量：加上 static的全局变量

高层应用
	linux 嵌入式开发
	linux 小工具开发
	linux 网络程序开发




========================================
gcc 的快速安装： 集成模块 devtoolset-9, 
----------------------------------------
1. 手动编译安装见 c++/非root权限安装新版 gcc


2. CentOS 可以使用sudo权限安装最新的gcc:
$ sudo yum install centos-release-scl
$ sudo yum install devtoolset-9


3. 印象中还有一个gcc的集成安装方式







========================================
详解三大编译器:gcc、llvm-clang 和 msvc: 编译gcc、调试小技巧gdb、参考资料
----------------------------------------
https://zhuanlan.zhihu.com/p/357803433


(1)clang 是一个由Apple主导编写，基于LLVM的C/C++/Objective-C编译器
https://clang.llvm.org/

The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project. Both a GCC-compatible compiler driver (clang) and an MSVC-compatible compiler driver (clang-cl.exe) are provided. You can get and build the source today.


(2) LLVM 命名最早源自于底层虚拟机（Low Level Virtual Machine）的缩写,由于命名带来的混乱，LLVM就是该项目的全称。
https://www.llvm.org/
LLVM已经被Apple、Microsoft、Google、Facebook等各大公司采用。

对于普通的开发人员来说，LLVM计划提供了越来越多的可以使用、编译器以外的其他工具。例如代码静态检查工具LLVM/Clang Static Analyzer，是一个 Clang 的子项目，能够使用同样的 Makefile 生成 HTML 格式的分析报告。

静态分析工具: https://clang-analyzer.llvm.org/


2000 年，本科毕业的 Chris Lattner 像中国多数大学生一样，按部就班地考了 GRE，最终前往 UIUC（伊利诺伊大学厄巴纳香槟分校），开始了艰苦读计算机硕士和博士的生涯。在这阶段，他不仅周游美国各大景点，更是翻烂了《Compilers: Principles, Techniques, and Tools》，成了 GPA 满分（4.0） 牛人，并不断地研究探索关于编译器的未知领域，发表了一篇又一篇的论文。他在硕士毕业论文里提出了一套完整的在编译时、链接时、运行时甚至是在闲置时优化程序的编译思想，直接奠定了 LLVM 的基础。LLVM 在他念博士时更加成熟，使用 GCC 作为前端来对用户程序进行语义分析产生 IF（Intermidiate Format），然后 LLVM 使用分析结果完成代码优化和生成。这项研究让他在 2005 年毕业时就成为了业界小有名气的编译器专家，他也因此早早地被 Apple 盯上，最终成为其编译器项目的骨干。


Clang 特性
速度快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 比 GCC 快2倍多。

内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10 倍。


(3) 
VC运行库，是Visual C++的运行库。很多程序在编制的时候，使用了微软的运行库，大大减少了软件的编码量，却提高了兼容性。但运行的时候，需要这些运行库。这些运行库简称就是MSVC。








1. 编译技巧

(1) 在gcc下用到数学函数 Math.h ，如sqrt。在gcc时要加上 -lm 参数，这样告诉编译器我要用到数学函数了 。
如：
gcc a.c -o a -lm

对于非标准库，是否都需要-l参数说明呢？
$ gcc  multi_thread.c -lpthread #引入多线程库 -l pthread




(2) gcc加上 -Wall参数，则显示全部警告，并可能有编译产出。
比如有未使用的变量。

$ cat p75.c 
// 使用 -Wall 参数编译
#include <stdio.h>
int main(){
	int i=10;
	int j;
	printf("hello\n");
	return 0;
}

$ gcc -Wall p75.c 
p75.c: In function ‘main’:
p75.c:5:6: warning: unused variable ‘j’ [-Wunused-variable]
  int j;
      ^
p75.c:4:6: warning: unused variable ‘i’ [-Wunused-variable]
  int i=10;
      ^

(3) 如果使用 -Werror 参数，则把warning都认为是error
有error就不会有编译产出。

$ gcc -Wall -Werror p75.c 
p75.c: In function ‘main’:
p75.c:5:6: error: unused variable ‘j’ [-Werror=unused-variable]
  int j;
      ^
p75.c:4:6: error: unused variable ‘i’ [-Werror=unused-variable]
  int i=10;
      ^
cc1: all warnings being treated as errors










2. gdb 调试技巧

(1) 带有命令行参数
进入gdb调试：
gcc -g -Wall httpTest.c -o test    生成了可调试文件
gdb test                                        进入调试

下面可以使用两种方法输入命令行参数
1) run  命令行参数
2) set args  命令行参数

如：我的程序中需要输入的时服务器端ip地址，可以通过以下两种方法输入
1) 如果直接运行程序，run  www.baidu.com
2) set  args www.baidu.com,后面再继续进行调试




(2) 设置断点

如果想跳过某一个for循环，则可以把断点设置在for循环之后的那一行。

比如在12行断点
> b 12
> start //然后从头运行，停在第12行







3. 更多高级的C项目
https://github.com/Ewenwan/ShiYanLou/blob/master/README.md

(1) Tinyhttpd
tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，
附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。
项目主页: http://sourceforge.net/projects/tinyhttpd/


(2) cJSON
cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。
cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。
其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。
项目主页: http://sourceforge.net/projects/cjson/

(3) Libev
libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。
其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。
基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。
项目主页: http://software.schmorp.de/pkg/libev.html


(4) Memcached
Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。
它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。
Memcached 基于一个存储键/值对的 hashmap。
Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。
项目主页: http://memcached.org/

(5) Lua
Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。
让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。
在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。
Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。
项目主页: http://www.lua.org/


(6) SQLite
SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 
其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。
项目主页: http://www.sqlite.org/ 。


(7) UNIX v6
UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。
有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。
看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？

另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。
就算不是初学者，想完全理解全部代码基本上也是不可能的。
项目主页: http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6





4. 其他资料

https://github.com/Ewenwan/ShiYanLou












========================================
多文件联合编译：同时编译、预编译
----------------------------------------
1. 场景: 对于大文件，可以分开编译，以便节省编译时间。

(1) 一个简单的例子: 求2个数的最大值。
$ cat 03_max.c
int max(int a, int b){
  if(a>b) return a;
  else return b;
}

仅编译, 加-c 选项
$ gcc -c 03_max.c -o max.o


(2) 编译主文件
$ cat 03_multiple_files.c 
#include<stdio.h>
// 多文件分别编译
//#include "02_max.c"

//声明函数，否则会报 警告
int max(int a, int b);

int main(){
  printf("the max is:%d\n", max(10, 20));
}

$ gcc max.o 03_multiple_files.c -o main.out
$ ./main.out 
the max is:20


(3) 可能还有更多的函数，比如 
$ cat 03_min.c
int min(int a, int b){
  if(a<b) return a;
  else return b;
}

仅编译, 加-c 选项
$ gcc -c 03_min.c -o min.o


ii)修改主函数，加入新功能
$ cat 03_multiple_files-v2.c 
#include<stdio.h>
//声明函数
int max(int a, int b);
int min(int a, int b);

int main(){
  int a=10, b=200;
  printf("the max is:%d\n", max(a, b));
  printf("the min is:%d\n", min(a, b));
}

组合编译
$ gcc max.o min.o 03_multiple_files-v2.c -o main_v2.out

$ ./main_v2.out 
the max is:200
the min is:10




(4) 最佳实践，就是把常用的函数编译成静态资源库 xx.o，作为工具库。
把经常变化的部分单独写，编译时联合编译，以便节省时间。

上面的例子看不出时间差异，因为函数太简单。
实际项目的重头编译通常需要好几个小时，甚至好几天，预编译会大大缩短编译时间。



(5) 头文件和函数定义分离：头文件公开，函数定义则编译后保密。

可以模仿系统文件 stdio.h 做法，把前面的函数声明放到一个单独的 .h 文件中。
新建2个新文件，和 .o 同名。
$ cat max.h 
int max(int a, int b);

$ cat min.h 
int min(int a, int b);


$ cat 03_multiple_files-v3.c 
#include<stdio.h>
#include "max.h"
#include "min.h"

int main(){
  int a=10, b=200;
  printf("the max is:%d\n", max(a, b));
  printf("the min is:%d\n", min(a, b));
}

$ gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out

$ ./main_v3.out 
the max is:200
the min is:10







========================================
|-- Makefile 的编写和使用：多文件自动化编译
----------------------------------------
1. 像上面只有2个函数文件，gcc 命令已经很长了。
每次变动都需要重新编译，光输编译命令就很费劲了。有没有自动化的工具？
这就是make 命令，虽然它内部也是使用 gcc 的。

$ make -v
GNU Make 4.1
Built for x86_64-pc-linux-gnu
Copyright (C) 1988-2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.




2. 定义配置文件 Makefile。
要告诉 make 要生成什么文件，依赖哪些源码文件，这些都定义在配置文件中。

先删掉 .o 和 .out 文件： 
$ rm *.o
$ rm *.out

要求：
 - 文件名只能是 Makefile 或者 makefile。如果是其他名字，需要使用参数 -f fileName
	$ make -f makefile2 
 - 第二行的命令前是一个tab键，linux下是6个空格的位置。如果不是有可能报错。



$ cat Makefile
# this is make file
# 冒号前是最终的目标文件，冒号后是依赖文件
# tab键，后面是要执行的命令
main_v3.out: max.o min.o 03_multiple_files-v3.c
	gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out

# 然后是依赖文件怎么生成的
max.o: 03_max.c
	gcc -c 03_max.c -o max.o
min.o: 03_min.c
	gcc -c 03_min.c -o min.o

执行编译 
$ make 
gcc -c 03_max.c -o max.o
gcc -c 03_min.c -o min.o
gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out


测试效果 
$ ./main_v3.out 
the max is:200
the min is:10


(2) 如果依赖文件已经有了，则自动跳过其生成步骤
$ cat Makefile
# 修改第一行，生成 a.out 文件
a.out: max.o min.o 03_multiple_files-v3.c
	gcc max.o min.o 03_multiple_files-v3.c -o a.out

max.o: 03_max.c
	gcc -c 03_max.c -o max.o
min.o: 03_min.c
	gcc -c 03_min.c -o min.o


再编译时，已经有的中间文件就直接用了。
$ make 
gcc max.o min.o 03_multiple_files-v3.c -o a.out


再次编译，则提示已经是最新版了。
$ make
make: 'a.out' is up to date.


如果修改源文件，把其中一个数字添加负号，则改动后的文件重新编译。
$ vim 03_multiple_files-v3.c
$ make 
gcc max.o min.o 03_multiple_files-v3.c -o a.out

$ ./a.out 
the max is:10
the min is:-200


也就是使用 Makefile 的好处是，
	- 以后不需要写那些麻烦的命令了。
	- 编译时，会检查时间戳(我猜测的)，如果没有修改过，则不再编译。







3. 设置其他目标

(1) 在文件末尾加上: 

clean:
    rm -f *.out && rm -f *.o


执行的时候写上，则自动执行第二行语句，清除中间文件。
$ make clean


(2) 按照这个规律，你还可以添加更多自定义子命令。

可以使用“make all”来编译所有的程序。当然也可以使用“make 程序名”来单独编译某一个文件。

既然make可以指定所有Makefile中的目标，那么也包括“伪目标”。我们可以根据这种性质来让我们的Makefile根据指定的不同目标来完成不同的任务。

通常情况下参考linux源码的Makefile规则来书写我们的Makefile中的目标。

“all”—— 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。

“clean” —— 这个伪目标功能是删除所有被make创建的文件。

“install” —— 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。

“print” —— 这个伪目标的功能是列出改变过的源文件。

“tar” —— 这个伪目标功能是把源程序打包备份。也就是一个tar文件。

“dist” —— 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件，或是gz文件。

“TAGS” —— 这个伪目标功能是更新所有的目标，以备完整地重编译使用。

“check”和“test” —— 这两个伪目标一般用来测试makefile的流程。

上述的这些伪目标都是GNU开源软件定义和采用的，为了规范和统一，我们如果编写Makefile时也尽量使用上述的关键字命名目标。




ref:
https://wiki.ubuntu.org.cn/跟我一起写Makefile:make运行






========================================
|-- makefile 中常见变量及函数
----------------------------------------
1.常用变量

$(filter-out $(PHONY) $(wildcard $^),$^)

常用用法为$(wildcard *.c)

表示列举当前目录下的所有.c文件

这里$^因为会包含依赖的文件名,如果包含的该文件存在,那么将返回其含路径的文件名

所以$(wildcard $^)就是用来过滤$^包含的所有文件并且该文件确实在本地存在.


自动化变量 $? 代表依赖文件列表中被改变过的所有文件。
自动化变量 $^ 代表所有通过目录搜索得到的依赖文件的完整路径名(目录 + 一般文件名)列表。
自动化变量 $@ 代表规则的目标。
自动化变量 $< 代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件。

自动化变量 $(@D)  

The directory part of the file name of the target, with the trailing slash removed. 
If the value of ‘$@’ is dir/foo.o then ‘$(@D)’ is dir. 
This value is . if ‘$@’ does not contain a slash.
http://www.gnu.org/software/make/manual/make.html

自动化变量 $(@F)

The file-within-directory part of the file name of the target. 
If the value of ‘$@’ is dir/foo.o then ‘$(@F)’ is foo.o. 
‘$(@F)’ is equivalent to ‘$(notdir $@)’.







2. 常见函数
函数的调用语法

函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：

$(f p)或是${ }

这里，f就是函数名，make支持的函数不多。p是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。
函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。
感觉很像一个变量，是不是？
函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。
	* no，我认为不统一才更容易分辨，不容易出错。

还是来看一个示例：

comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))

在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”



(1) $(subst ,,)

名称：字符串替换函数——subst。
功能：把字串中的字符串替换成。
返回：函数返回被替换过后的字符串。

示例：
$(subst ee,EE,feet on the street)，
把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。







(2) $(patsubst ,,)

名称：模式字符串替换函数——patsubst。
功能：查找中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式，如果匹配的话，则以替换。这里，可以包括通配符“%”，表示任意长度的字串。如果中也包含“%”，那么，中的这个“%”将是中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）
返回：函数返回被替换过后的字符串。

示例：

$(patsubst %.c,%.o,x.c.c bar.c)

把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”

备注：

这和我们前面“变量章节”说过的相关知识有点相似。如：
“$(var:=)”   相当于  “$(patsubst ,,$(var))”，
而“$(var: =)”则相当于“$(patsubst %,%,$(var))”。
例如有：objects = foo.o bar.o baz.o，
那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。





(3) $(strip )
名称：去空格函数——strip。
功能：去掉字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。
示例：
$(strip a b c )

把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。






(4) $(findstring ,)

名称：查找字符串函数——findstring。
功能：在字串中查找字串。
返回：如果找到，那么返回，否则返回空字符串。
示例：

$(findstring a,a b c)
$(findstring a,b c)

第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）






(5) $(filter ,)
名称：过滤函数——filter。
功能：以模式过滤字符串中的单词，保留符合模式的单词。可以有多个模式。
返回：返回符合模式的字串。
示例：

sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
cc $(filter %.c %.s,$(sources)) -o foo

$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。







https://blog.csdn.net/evilswords/article/details/12349187







========================================
|-- 静态链接库、动态链接库
----------------------------------------

库是一种可执行的二进制文件，是编译好的代码。使用库可以提高开发效率。在 Linux 下有静态库和动态库。

在linux中，静态库为lib*.a，动态库为lib*.so。

静态库在程序编译的时候会被链接到目标代码里面。所以程序在运行的时候不再需要静态库了。因此编译出来的体积就比较大。以 lib 开头，以.a 结尾。

动态库（动态库也叫共享库）在程序编译的时候不会被链接到目标代码里面，而是在程序运行的时候被载入的。所以程序在运行的时候需要动态库了。因此编译出来的体积就比较小。以 lib 开头，以.so 结尾。



gcc 的命令

编译 -c
$ gcc -c helloWorld.c  
生成一个helloWorld.o文件，该文件是将源文件编译成的汇编文件，在链接之前，该文件不是可执行文件。


编译并链接
$ gcc -o helloWorld helloWorld.c  
$ gcc -o helloWorld helloWorld.o #这样也行  
生成的是一个helloWorld的执行文件，格式为ELF（与windows不一样）。该文件为链接后的可执行文件。






1. 直接编译
gcc file1.c file2.c file3.c main.c -o out

前提是main.c要include其他文件的头文件，来避免main文件中没有声明就使用没定义的函数导致的报错。
如果要写的挫点，也可以不include头文件，而在main文件里手写那几个声明。

$ cat my_max.c
#include "my_lib.h"
int mmax(int x, int y){
	return x>y? x : y;
}

$ cat my_min.c
#include "my_lib.h"
int mmin(int x, int y){
	return x<y? x : y;
}

$ cat my_abs.c
#include "my_lib.h"
int mabs(int x){
	return x<0? -x : x;
}

$ cat my_lib.h
int mmax(int x, int y);
int mmin(int x, int y);
int mabs(int x);


$ cat main.c
#include<stdio.h>
#include "my_lib.h"

int main(){
	int a=-3, b=5;
	printf("max: %d\n", mmax(a,b));
	printf("min: %d\n", mmin(a,b));
	printf("abs: %d\n", mabs(a));
	
	return 0;
}

$ gcc main.c my_max.c my_min.c my_abs.c  -o out
$ ./out 
max: 5
min: -3
abs: 3



(2) 也可以分别编译，再最后链接
$ gcc -c main.c
$ gcc -c my_max.c
$ gcc -c my_min.c
$ gcc -c my_abs.c
这样，这些单个文件就可分别编译。节约时间。

$ gcc main.o my_max.o my_min.o my_abs.o  -o out
$ ./out
max: 5
min: -3
abs: 3






2. 动态共享库，又称 共享库 /shared library
把3个文件编译成动态共享库，再编译main

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。
有两点要注意，
	shared library是在程序起始时就要被加载，而不是执行中用到才加载，
	而且在连结阶段需要有该链接库才能进行连结。

不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例；可增量更新。

动态库特点：
 动态库把函数库的链接载入到程序运行时期；
 可实现进程之间资源共享（共享库）；
 增量更新；
 可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。

动态库命名形式：libxxx.so，前缀是lib，后缀名为".so"。


分2步创建动态库
	gcc –fPIC –c DynamicMath.c #生成目标文件，此时要加编译器选项-fpic
	gcc –shared –o libdynamicmath.so DynamicMath.o # 然后，生成动态库，此时要加链接器选项-shared
	通常，合成一步
	gcc –fPIC  –shared –o libdynamicmath.so DynamicMath.c

动态库制作步骤：
	编写或准备库的源代码
	将源码.c 文件编译生成.so 文件
	使用 gcc 命令创建动态库
	测试库文件

gcc -shared -fPIC file1.c -o libfile1.so
gcc -shared -fPIC file2.c -o libfile2.so
gcc -shared -fPIC file3.c -o libfile3.so
gcc main.c -L. -lfile1 -lfile2 -lfile3 -o out

-l:指定动态库的库名。lib开头，so结尾，中间是库的名字。
-L:指定动态库的查找位置。
-L . 表示在当前目录下去查找
-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。
-shared指定生成动态链接库。

通过so产生的out，依赖so文件，好处是如果 file2.c 更新了那么只需要替换新的libfile2.so，就可以直接运行原来的out获得新功能，而不需要再次编译出out替换。


实例: 
$ gcc -shared -fPIC my_max.c -o libmy_max.so
$ gcc -shared -fPIC my_min.c -o libmy_min.so
$ gcc -shared -fPIC my_abs.c -o libmy_abs.so
$ gcc main.c -L. -lmy_max -lmy_min -lmy_abs -o out2

$ ./out2
./out2: error while loading shared libraries: libmy_max.so: cannot open shared object file: No such file or directory
因为找不到 libmylib.so.1 所以无法执行程序。

编译时，使用-L参数指定动态库地址即可。
运行时，需要把动态库放到系统指定目录，否则无法运行。


(1) 动态库找不到怎么办？

有几个方式可以处理。
a. 把 libmylib.so.1 安装到系统的library目录，如/usr/lib下
b. 设定 /etc/ld.so.conf ，加入一个新的library搜寻目录，并执行ldconfig更新快取
c. 设定 LD_LIBRARY_PATH 环境变量来搜寻library
这个例子是加入当前目录来搜寻要载作的library


在动态库使用是，系统会默认去/lib，/usr/lib 目录下去查找动态函数库，如果我们使用的库不在里面，就会提示错误。

解决办法：https://zhuanlan.zhihu.com/p/509748321
将libraries 所在的目录加到 /etc/ld.so.conf 中
执行 /sbin/ldconfig –v

简单策略:
$ export LD_LIBRARY_PATH=$PWD:$LD_LIBRARY_PATH
$ echo $LD_LIBRARY_PATH
/home/wangjl/data/test/testC/1:
$ ./out2
max: 5
min: -3
abs: 3




(2)修改一个函数:

$ cat my_abs2.c
#include "my_lib.h"
int mabs(int x){
	int a = x<0? -x : x;
	return a+10;
}

只编译更新这一个文件
$ gcc -shared -fPIC my_abs2.c -o libmy_abs.so

$ gcc main.c -L. -lmy_max -lmy_min -lmy_abs -o out2

$ ./out2
max: 5
min: -3
abs: 13  #这个结果变了。

如果不行，尝试以root身份运行 /sbin/ldconfig -v 更新库缓存。





(3) 几个名词解释: soname、real name与linker name

soname 用来表示是一个特定 library 的名称，像是 libmylib.so.1 。前面以 ‘lib’ 开头，接着是该 library 的名称，然后是 ‘.so’ ，接着是版号，用来表名他的界面；如果接口改变时，就会增加版号来维护兼容度。

real name 是实际放有library程序的文件名，后面会再加上 minor 版号与release 版号，像是 libmylib.so.1.0.0 。

一般来说，版号的改变规则是(在 APress-Difinitive Guide to GCC)，最后缀的release版号用于程序内容的修正，接口完全没有改变。中间的minor用于有新增加接口，但相旧接口没改变，所以与旧版本兼容。最前面的version版号用于原接口有移除或改变，与旧版不兼容时。

linker name是用于连结时的名称，是不含版号的 soname ，如: libmylib.so。

通常 linker name 是用 ln 指到对应的 real name ，用来提供弹性与维护性。



$ rm libmy_abs.so
$ gcc -shared -fPIC my_abs.c -o libmy_abs.so.1
$ gcc -shared -fPIC my_abs2.c -o libmy_abs.so.2
$ ln -s libmy_abs.so.1 libmy_abs.so
$ ls -lht
total 148K
lrwxrwxrwx 1 wangjl wangjl   14 Sep 14 14:32 libmy_abs.so -> libmy_abs.so.1
-rwxrwxr-x 1 wangjl wangjl  16K Sep 14 14:31 libmy_abs.so.1

$ ./out2
max: 5
min: -3
abs: 3


$ ln -s -f libmy_abs.so.2 libmy_abs.so
$ ls -lth
total 164K
lrwxrwxrwx 1 wangjl wangjl   14 Sep 14 14:33 libmy_abs.so -> libmy_abs.so.2
-rwxrwxr-x 1 wangjl wangjl  16K Sep 14 14:32 libmy_abs.so.2
-rwxrwxr-x 1 wangjl wangjl  16K Sep 14 14:31 libmy_abs.so.1

$ ./out2
max: 5
min: -3
abs: 13





(4) 多个文件合成一个共享库
# https://zhuanlan.zhihu.com/p/368363594
gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 hello.o world.o

-shared 表示要编译成 shared library
-Wl 用于参递参数给linker，因此-soname与libmylib.so.1会被传给linker处理。
-soname用来指名 soname 为 limylib.so.1
library会被输出成libmylib.so.1.0.0 (也就是real name)
若不指定 soname 的话，在编译结连后的执行档会以连时的library档名为soname，并载入他。
否则是载入soname指定的library档案。

$ gcc -c my_max.c
$ gcc -c my_min.c
$ gcc -c my_abs.c
$ gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 my_max.o my_min.o my_abs.o
$ ls -lth
-rwxrwxr-x 1 wangjl wangjl  16K Sep 14 15:04 libmylib.so.1.0.0


$ objdump -p libmylib.so.1.0.0 | grep SONAME
SONAME               libmylib.so.1
若不指名-soname参数的话，则library不会有这个字段数据。

在编译后再用 ln 来建立 soname 与 linker name 两个链接。

$ ln -s libmylib.so.1.0.0 libmylib.so
$ ln -s libmylib.so.1.0.0 libmylib.so.1

使用1: 直接指定与 libmylib.so 连结。
$ gcc main.c libmylib.so -o out2a
$ ./out2a
max: 5
min: -3
abs: 3



使用2: 
$ gcc main.c -L. -lmylib -o out2b
$ ./out2b
max: 5
min: -3
abs: 3

linker会搜寻 libmylib.so 来进行连结。
如果目录下同时有static与shared library的话，会以shared为主。

使用 -static 参数可以避免使用shared连结。
$ ln -s libmy_lib.a libmylib.a  #静态库，见3
$ gcc main.c -static -L. -lmylib -o out2c
$ ./out2c
max: 5
min: -3
abs: 3

查看大小:
$ ls -lth out2*
-rwxrwxr-x 1 wangjl wangjl 852K Sep 14 15:21 out2c #如此之大！使用了同名的静态库
-rwxrwxr-x 1 wangjl wangjl  17K Sep 14 15:18 out2b
-rwxrwxr-x 1 wangjl wangjl  17K Sep 14 15:17 out2a


此时可以用 ldd 看编译出的执行档与shared链接库的相依性
$ ldd out2a
	linux-vdso.so.1 (0x00007ffec43db000)
	libmylib.so.1 => /home/wangjl/data/test/testC/1/libmylib.so.1 (0x00007f1f0672a000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1f06514000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f1f06736000)
$ ldd out2b
	linux-vdso.so.1 (0x00007fff933e8000)
	libmylib.so.1 => /home/wangjl/data/test/testC/1/libmylib.so.1 (0x00007fc26d79d000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc26d587000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fc26d7a9000)
$ ldd out2c
	not a dynamic executable











3.静态链接库 /static libraries

什么是静态链接呢？即在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。该可执行文件可能会比较大。
优点: 方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。
缺点: 文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.4K。

静态库的制作步骤：
	编写或准备库的源代码
	将源码.c 文件编译生成.o 文件
	使用 ar 命令创建静态库
	测试库文件

gcc -c file1.c 
gcc -c file2.c 
gcc -c file3.c
ar -rc liballfiles.a file1.o file2.o file3.o
gcc main.c -L. -lallfiles -o out 

大点项目手写makefile，偷懒点靠ide直接搞定。


实例:
$ gcc -c my_max.c
$ gcc -c my_min.c
$ gcc -c my_abs.c
$ ar -rc libmy_lib.a my_max.o my_min.o my_abs.o
$ ls -lth
total 172K
-rw-rw-r-- 1 wangjl wangjl 4.4K Sep 14 14:45 libmy_lib.a
-rw-rw-r-- 1 wangjl wangjl 1.4K Sep 14 14:44 my_abs.o
-rw-rw-r-- 1 wangjl wangjl 1.4K Sep 14 14:44 my_min.o
-rw-rw-r-- 1 wangjl wangjl 1.4K Sep 14 14:44 my_max.o

$ gcc main.c libmy_lib.a -o out3
$ ./out3
max: 5
min: -3
abs: 3


如果想要配合 gcc 的 ‘-l’ 参数来连结，一定要以 ‘lib’ 开头，中间是你要的library名称，然后紧接着 ‘.a’ 结尾。
$ gcc main.c -L. -lmy_lib -o out3_1
$ ./out3_1
max: 5
min: -3
abs: 3


-Ldir 参数用来指定要搜寻链接库的目录，'.' 表示搜寻现在所在的目录。通常默认会搜 /usr/lib 或 /lib 等目录。
'-llibrary' 参数用来指定要连结的链接库，-lmy_lib 表示要与my_lib进行连结，他会搜寻library名称前加'lib'后接'.a'的档案来连结。











4. 同时使用静态库和动态库
https://zhuanlan.zhihu.com/p/368363594

gcc –static a.c -Wl,-Bstatic -lm -Wl,-Bdynamic -lc

其中用到的两个选项：-Wl,-Bstatic和-Wl,-Bdynamic。
这两个选项是gcc的特殊选项，它会将选项的参数传递给链接器，作为 链接器的选项。

比如-Wl,-Bstatic告诉链接器使用-Bstatic选项，该选项是告诉链接器，对接下来的-l选项使用静态链 接；
-Wl,-Bdynamic就是告诉链接器对接下来的-l选项使用动态链接。

下面是man gcc对-Wl,option的描述

-Wl,option  
   Pass option as an option to the linker.  If option contains commas, it is split into multiple options at the commas.  You can use this syntax to pass an argument to the option.  For example, -Wl,-Map,output.map passes -Map output.map to the linker.  When using the GNU linker, you can also get the same effect with -Wl,-Map=output.map.


下面是man ld分别对-Bstatic和-Bdynamic的描述，
-Bdynamic  
-dy  
-call_shared  
   Link against dynamic libraries. You may use this option multiple times on the  
   command line: it affects library searching for -l options which follow it.  

-Bstatic  
-dn  
-non_shared  
-static  
   Do not link against shared libraries. You may use this option multiple times on   
   the command line: it affects library searching for -l options which follow it.   
   This option also implies --unresolved-symbols=report-all.  This option can be   
   used with -shared.  Doing so means that a shared library is being created but   
   that all of the library's external references must be resolved by pulling in   
   entries from static libraries.  

值得注意的是对-static的描述：-static和-shared可以同时存在，这样会创建共享库，但该共享库引用的其他库会静态地链接到该共享库中。











5. Dynamically loaded libraries

Dynamicaaly loaded libraries 才是像 windows 所用的 DLL ，在使用到时才加载，编译连结时不需要相关的library。动态载入库常被用于像plug-ins的应用。

(1) 使用方式

动态加载是透过一套 dl function来处理。



ref:
https://zhuanlan.zhihu.com/p/103167579











========================================
|-- 动态链接库的位置 (运行时 so 文件)
----------------------------------------

动态库的查找，只记录库名，不记录地址和版本号。

运行由动态链接库生成的可执行文件时，必须确保程序在运行时可以找到这个动态链接库。常用的解决方案有以下几种:


方法1：将动态链接库文件移动到Linux标准库目录下，如 /usr/lib、/usr/lib64、/lib、/lib64；

方法2：在终端输入export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx，其中 xxx 为动态链接库文件的绝对路径（此方式仅在当前终端有效，关闭终端后无效）；

方法3：修改~/.bashrc 或~/.bash_profile 文件，即在文件最后一行添加export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx（xxx 为动态库文件的绝对路径）。保存之后，执行source ~/.bashrc指令（此方式仅对当前、及之后的登陆用户有效）。








http://t.zoukankan.com/likewithyou-p-5836560.html





========================================
|-- 编译含 math 库的文件时，要加入 -lm 库 (动态共享库)
----------------------------------------

1. 测试代码

$ vim test3.c 
#include<stdio.h>
#include<math.h>

void t1(){
  double y=hypot(4.0, 3.0);
  printf("1value of x=%f\n", y);
}

void t2(){
  double x=4.0;
  double y=hypot(x, 3.0);
  printf("2value of x=%f\n", y);
}

int main(){
  t1();
  t2();
}

直接编译报错:
$ gcc -std=c11 test3.c -o out
/usr/bin/ld: /tmp/ccjkySqe.o: in function `t2':
test3.c:(.text+0x72): undefined reference to `hypot'
collect2: error: ld returned 1 exit status





2. 查到说 math 库编译时要加 -lm 

Due to math library are not integrated in the standard gcc library because of integration issues with the kernel. you have to use -lm while compiling the code

https://stackoverflow.com/questions/20664683/error-undefined-reference-to-math-functions


$ gcc -std=c11 test3.c -o out -lm
$ ./out 
1value 5.000000
2value 5.000000



在 man gcc 中查找，发现这两个是并列的，-lpthread or -lm 
也就是说这2个库是需要在编译时指定的。

Do not use the C library or system libraries tightly coupled with it when linking.  Still link with the startup files, libgcc or toolchain provided language support libraries such as libgnat, libgfortran or libstdc++ unless options preventing their inclusion are used as well.  This typically removes -lc from the link command line, as well as system libraries that normally go with it and become meaningless when absence of a C library is assumed, for example -lpthread or -lm in some configurations.  This is intended for bare-board targets when there is indeed no C library available.













========================================
Linux 下的 C语言 编译
----------------------------------------


========================================
|- gcc 编译选项
----------------------------------------

g++(gcc)编译选项
-shared ：指定生成动态链接库。
-static ：指定生成静态链接库。

-fPIC ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。

-L. ：表示要连接的库所在的目录。

-l：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。

-Wall ：生成所有警告信息。

-ggdb ：此选项将尽可能的生成gdb的可以使用的调试信息。

-g ：编译器在编译的时候产生调试信息。

-c ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件)。

-Wl,options ：把参数(options)传递给链接器ld。如果options中间有逗号,就将options分成多个选项,然后传递给链接程序。


-I  (大写的i)参数是用来指定头文件目录
-I ( i 的大写)  ：指定头文件路径（相对路径或绝对路径，建议相对路径）
-i ：指定头文件名字 (一般不使用，而是直接放在**.c 文件中通过#include<***.h> 添加)
-L ：指定连接的动态库或者静态库路径（相对路径或觉得路径，建议相对路径）
-l (L的小写)：指定需要链接的库的名字（链接 libc.a :-lc  链接动态库：libc.so  : -lc   
	注意：-l后面直接添加库名，省去“lib”开头和“.so”或“.a”结尾）；同名时，优先使用动态库。


通过 ldd 命令查看生成的 目标文件链接的动态库，使用方法： ldd  ***.o








2. R 包的编译命令

理解这几行编译命令和参数: //todo

gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -c Rinit.c -o Rinit.o
gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -c access.c -o access.o
gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -c constructors.c -o constructors.o
gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -c layout.c -o layout.o
gcc -I"/data/public/R-4.1.1/lib/R/include" -DNDEBUG   -I/usr/local/include   -fpic  -g -O2  -c utils.c -o utils.o
gcc -shared -L/data/public/R-4.1.1/lib/R/lib -L/usr/local/lib -o network.so Rinit.o access.o constructors.o layout.o utils.o -L/data/public/R-4.1.1/lib/R/lib -lR









========================================
|-- main 函数中的 return 与 错误码
----------------------------------------
1. main 函数的完整形式

$ cat 04_hello.c
#include <stdio.h>
int main(int argc, char* argv[]){
	printf("Hello, world!\n");
	return 0;
}

编译并执行

$ gcc 04_hello.c -o 04.out && ./04.out
Hello, world!


linux 是怎么判断 && 前的命令执行结束了呢？就是看返回值0。
如果返回值不是0，则是报错。


最后一条执行的返回值是0，就是我们编译好的C程序的返回值。
$ echo $?
0



2. 返回其他错误码

(1) 比如返回 101 
场景：合并另个字符串，如果输入的字符串小于2个，则报错 101 

$ cat 05_return_101.c
#include <stdio.h>
#include<string.h>
int main(int argc, char* argv[]){
	if(argc<3){
		return 101;
	}
	printf("input: |%s|, |%s|\n", argv[1],  *(argv+2));

	char c1[10], c2[10];
	strcpy(c1, argv[1]);
	strcpy(c2, argv[2]);
	printf("c1=|%s|, c2=|%s|\n", c1, c2);

	strcat(c1, c2);
	printf("combined: '%s'\n", c1);
	return 0;
}

不提供参数时:
$ ./a.out 
$ echo $? # 前一个命令的返回值
101

$ ./a.out && echo "OK" # 前一个不返回0，则&&后不能连续执行
$


再试试提供2个参数时
$ ./a.out this Dog
input: |this|, |Dog|
c1=|this|, c2=|Dog|
combined: 'thisDog'
$ echo $?
0

$ ./a.out this Cat && echo "OK" 
input: |this|, |Cat|
c1=|this|, c2=|Cat|
combined: 'thisCat'
OK


ref:https://www.imooc.com/video/6207




========================================
|-- 命令行参数 int main(int argc, int* argv[]);
----------------------------------------


1. 使用场景
执行程序时，可以从命令行传值给 C 程序。
这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。



2. 实现方式

命令行参数是使用 main() 函数参数来处理的，其中，
- argc 是指传入参数的个数，
- argv[] 是一个指针数组，指向传递给程序的每个参数。

下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：


#include <stdio.h>
int main(int argc, char *argv[]){
	for(int i=0; i<argc; i++){
		printf("input paras[%d]=%s\n", i, *(argv+i) );
		//printf("input paras[%d]=%s | %s\n", i, *(argv+i), argv[i]);
	}
	return 0;
}

输出结果:
$ ./a.out some times
input paras[0]=./a.out
input paras[1]=some
input paras[2]=times

第0个参数是脚本本身，后面是其余的参数。
为了获得用户传入的参数，可以从下标1开始。



如果传入带空格的字符串呢？用引号隔开
$ ./a.out some times "a book"
input paras[0]=./a.out | ./a.out
input paras[1]=some | some
input paras[2]=times | times
input paras[3]=a book | a book






========================================
|-- 标准输入输出流及错误流(stdin/stdout/stderr) 与 重定向
----------------------------------------

1. linux 基本概念

stdin  0  默认是键盘
stdout  1  默认是显示器终端
stderr  2  



2. C语言示例

(1) 常见形式
$ cat 06_cio.c
#include<stdio.h>
int main(){
	int a;
	printf("input a number:");
	scanf("%d", &a);
	printf("hello world! you input: %d\n", a);
	return 0;
}

运行后，系统会自动提供一个指针，指向标准输出流。


(2) 手动指定输出设备
$ cat 07_cio_stdout.c
#include<stdio.h>
int main(){
	//fprintf(fp, "xx %c $d", char1, 20);
	fprintf(stdout, "please input a %s:\n", "number");
	// 等同于 
	printf("please input a %s:\n", "number");
	
	int a;
	//scanf("%d", &a);
	// 等价于
	//fscanf(fp,"%s%s%s%s%s%s",&c1,&c2,&c3,&c4,&c5,&c6);
	fscanf(stdin, "%d", &a);
	printf("your input is %d\n", a);
	
	//错误流，记着返回一个非0整数。
	if(a<0){
		fprintf(stderr, "the value must be positive! But you input %d\n", a);
		return 1;
	}
		
	return 0;
}


测试
$ ./a.out
please input a number:
please input a number:
-12
your input is -12
the value must be positive! But you input -12

$ echo $?
1


(3) 尝试重定向 1(默认) 也就是标准输出流 到文件。
$ ./a.out >1.log #是一样的效果，重定向左侧默认是1.
$ ./a.out 1>1.log
20

$ cat 1.log 
please input a number:
please input a number:
your input is 20
发现两个输出方式printf(), fprintf()，都重定向到了文件。


ii) 也可以使用追加模式，这样每次新增的内容都在最后，老内容不被覆盖。
$ ./a.out >>1.log
1
$ cat 1.log 
please input a number:
please input a number:
your input is 20
please input a number:
please input a number:
your input is 1



(4) 尝试重定向 2 也就是标注错误流 到文件 
$ ./a.out 1>1.log 2>err.log
-10

$ cat err.log
the value must be positive! But you input -10


(5) 输入 重定向：使用文件输入数字，而不是键盘
$ cat num.log
11
$ ./a.out <num.log
please input a number:
please input a number:
your input is 11


(6) 3个设备全部重定向到文件
$ ./a.out 1>1.log 2>err.log <num.log
没有报错。


尝试输入一个不存在的文件
$ ./a.out 1>1.log 2>err.log <num2.log
$ cat err.log 
-bash: num2.log: No such file or directory





========================================
|-- C语言与 管道 |
----------------------------------------

1. linux 示例

$ ls /etc/ | grep ab
anacrontab
crontab
crypttab
fstab
mtab

前一个命令的输出，作为下一个命令的输入，这个起连接作用的就是管道。




2. 给出任意多个整数，求平均值。
(1) 输入总数，n，求平均数
$ cat 08_mean.c
#include<stdio.h>
int main(){
	int sum, n;
	//printf("please input sum,n:");
	scanf("%d,%d", &sum, &n);
	if(n<=0){
		fprintf(stderr, "Error: N>0\n");
		return 1;
	}
	float mean=sum/n;
	//printf("sum=%d, n=%d, mean=%f\n", sum, n, mean);
	printf("%f", mean);
	return 0;
}

$ gcc 08_mean.c -o mean.out
$ ./mean.out 
80,5 回车
16.000000




(2) 接收用户的输入，求总数和n
$ cat 08_count.c 
#include<stdio.h>
int main(){
	int flag=1;
	int i;
	int count=0;
	int sum=0;
	while(flag){
		scanf("%d", &i);
		if(0==i) break; //输入0则停止
		count++;
		sum+=i;
	}
	printf("%d,%d", sum, count);
	return 0;
}

$ gcc 08_count.c -o count.out
$ ./count.out 
1
2
3
0
6,3


(3) 两个连起来使用

$ ./count.out | ./mean.out
$ ./count.out | ./mean.out
10
20
0
15.000000



========================================
|-- C_INCLUDE_PATH, LIBRARY_PATH, LD_LIBRARY_PATH (动态链接库路径)
----------------------------------------
C函数库的分类：静态库、共享库、动态链接库。
区别：
    1.静态库的链接应用是在编译时期完成的，程序在运行时与静态库再无瓜葛，移植方便。
    2.静态库使用浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
	3.如果静态库更新了，所以使用它的应用程序都需要重新编译、发布。
	 （对于客户端来说，可能一个很小的改动，却导致整个程序重新下载，全量更新）。共享库将一些程序升级变得简单。
	
    4.共享库把对一些库函数的链接载入推迟到程序运行的时期。
    5.共享库实现了进程之间的资源共享,节省了空间。
    6.共享库可以真正做到链接载入完全由程序员在程序代码中控制（动态加载）。



1. 定义
利用系统的环境变量。

(1) 对于头文件的搜索路径:
C_INCLUDE_PATH=<your include path>;
export C_INCLUDE_PATH


(2) 对于库文件的搜索路径:
LIBRARY_PATH=<your lib path>;
export LIBRARY_PATH


(3) 对于链接程序ld使用的库文件搜索路径：
LD_LIBRARY_PATH=<your ldlib path>;
export LD_LIBRARY_PATH

LIBRARY_PATH is used by gcc before compilation to search for directories containing libraries that need to be linked to your program.

LD_LIBRARY_PATH is used by your program to search for directories containing the libraries after it has been successfully compiled and linked.

EDIT:As pointed below, your libraries can be static or shared. If it is static then the code is copied over into your program and you don't need to search for the library after your program is compiled and linked. If your library is shared then it needs to be dynamically linked to your program and that's when LD_LIBRARY_PATH comes into play.

开发(编译)时，设置 LIBRARY_PATH, 以便gcc能够找到编译时需要的动态链接库。

发布(运行)时，设置 LD_LIBRARY_PATH, 以便程序加载运行时能够自动找到需要的动态链接库。




2. 修改的位置
(1) 对所有用户有效在/etc/profile增加以下内容。

(2) 只对当前用户有效在Home目录下的。
.bashrc或.bash_profile里增加下面的内容。

export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH




3. 创建 shared libraries
在启动时加载。

gcc -shared -Wl,-soname,your_soname \
    -o library_name file_list library_list

gcc -shared -o libmySharedLib.so mySharedLib.o  
    (-shared表明创建一个能被其它目标文件链接的共享库)


(1) 创建 so 文件
$ vim a.c 
int myAdd(int a, int b){
	return(a+b);
}

$ vim b.c 
int myMultiply(int a, int b){
	return(a*b);
}

$ gcc -fPIC -g -c -Wall a.c
$ gcc -fPIC -g -c -Wall b.c
$ gcc -shared -Wl,-soname,libMyStuff.so.1 \
	-o libMyStuff.so.1.0.1 a.o b.o -lc
库的文件名是 libMyStuff.so.1.0.1。
库的名字是 libMyStuff.so.1，记住，后面有用到。


参数解释：
$ gcc --help
-c		Compile and assemble, but do not link #只编译和组装，不连接
-g 选项，可以生成一个debug模式的可执行文件
	debugging information (-g)
	generate warnings (-Wall)
	compilation generates object files (using -c)

-fpic 编译器就生成位置无关目标码.适用于共享库(shared library).
-fPIC 编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.


检查:
$ pwd
/home/wangjl/local/myXX

$ ls -lth
total 28K
-rwxrwxr-x. 1 wangjl wangjl 9.0K Jul  6 05:20 libMyStuff.so.1.0.1
-rw-rw-r--. 1 wangjl wangjl 2.6K Jul  6 05:20 b.o
-rw-rw-r--. 1 wangjl wangjl 2.6K Jul  6 05:19 a.o
-rw-rw-r--. 1 wangjl wangjl   46 Jul  6 05:19 b.c
-rw-rw-r--. 1 wangjl wangjl   41 Jul  6 05:19 a.c



(2) 在C代码中使用该库
$ vim libMyStuff.h 
int myAdd(int a, int b);
int myMultiply(int a, int b);


$ vim test.c 
#include<stdio.h>
#include "libMyStuff.h"

int main(){
	int x=3, y=5;
	printf("%d+%d=%d\n", x,y, myAdd(x,y));
	printf("%d*%d=%d\n", x,y, myMultiply(x,y));
	return 0;
}

使用库进行编译
$ gcc -L ./ test.c
/tmp/ccFPN10B.o: In function `main':
test.c:(.text+0x21): undefined reference to `myAdd'
test.c:(.text+0x49): undefined reference to `myMultiply'
collect2: error: ld returned 1 exit status


编译2:还是报错
$ ln -s libMyStuff.so.1.0.1 libMyStuff.so
$ gcc -l libMyStuff test.c
/usr/bin/ld: cannot find -llibMyStuff
collect2: error: ld returned 1 exit status

编译3: 通过
$ gcc libMyStuff.so.1.0.1 test.c -o test.out


运行1：
$ ./test.out #报错
./test.out: error while loading shared libraries: libMyStuff.so.1: cannot open shared object file: No such file or directory

运行2：
$ export LIBRARY_PATH=$LIBRARY_PATH:/home/wangjl/local/myXX
$ ./test.out  #报错
./test.out: error while loading shared libraries: libMyStuff.so.1: cannot open shared object file: No such file or directory


运行3:
$ ln -s libMyStuff.so.1.0.1 libMyStuff.so.1 #必须
$ ./test.out

$ ./test.out
3+5=8
3*5=15


再次编译、运行：
$ gcc libMyStuff.so.1.0.1 test.c -o test2.out
$ ./test2.out 
3+5=8
3*5=15


再次编译、运行
gcc -o testSharedLib testSharedLib.c -lmySharedLib -L.
   （注意：lmySharedLib来自于libmySharedLib.so，所以在上一步生成.so文件时，必须带前缀lib，否则这里找不到lmySharedLib。
$ ln -s libMyStuff.so.1.0.1 libMyStuff.so
$ gcc -o test3 test.c -lMyStuff -L.
$ ./test3
3+5=8
3*5=15





(3) 在R中使用该库 (失败)
$ R
> dyn.load("/home/wangjl/local/myXX/libMyStuff.so.1.0.1")
> .C("myAdd", 3, 5)
[[1]]
[1] 3

[[2]]
[1] 5
无法调用。

> .Call("myAdd", a, y)

 *** caught segfault ***
address 0x6a3a863, cause 'memory not mapped'

Possible actions:
1: abort (with core dump, if enabled)
2: normal R exit
3: exit R without saving workspace
4: exit R saving workspace






4. 创建 Dynamically Loaded (DL) Libraries
运行过程中加载的库。

https://blog.csdn.net/shenhuan1104/article/details/79166149






ref:
https://stackoverflow.com/questions/4250624/ld-library-path-vs-library-path
https://www.shuzhiduo.com/A/ke5j6BDo5r/
https://tldp.org/HOWTO/Program-Library-HOWTO/
https://www.it610.com/article/1291589798045229056.htm








========================================
|-- gcc -O0 -O1 -O2 -O3 四级优化选项及每级分别做什么优化
----------------------------------------
GCC has well over a hundred individual optimization flags and it would be insane to try and describe them all

几百项优化，其中几个常见的。

幸而gcc提供了从O0-O3以及Os这几种不同的优化级别供大家选择，在这些选项中，包含了大部分有效的编译优化选项，并且可以在这个基础上，对某些选项进行屏蔽或添加，从而大大降低了使用的难度


$ gcc -o basic_function_linux.so -shared -fPIC -O2 basic_function.c # Linux



1. -O0： 不做任何优化，这是默认的编译选项。 

-O和-O1： 对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。 





2. -O2： 是比O1更高级的选项，进行更多的优化。Gcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。 

O2打开所有的O1选项，并打开以下选项： 




3. -O3： 比O2更进一步的进行优化。

在包含了O2所有的优化的基础上，又打开了以下优化选项： 


4. -Os： 主要是对程序的尺寸进行优化。

打开了大部分O2优化中不会增加程序大小的优化选项，并对程序代码的大小做更深层的优化。（通常我们不需要这种优化）Os会关闭如下选项： -falign-functions -falign-jumps -falign-loops  -falign-labels   -freorder-blocks   -fprefetch-loop-arrays  



优化代码有可能带来的问题 

1．调试问题：正如上面所提到的，任何级别的优化都将带来代码结构的改变。例如：对分支的合并和消除，对公用子表达式的消除，对循环内load/store操作的替换和更改等，都将会使目标代码的执行顺序变得面目全非，导致调试信息严重不足。 

2．内存操作顺序改变所带来的问题：在O2优化后，编译器会对影响内存操作的执行顺序。例如：-fschedule-insns允许数据处理时先完成其他的指令；-fforce-mem有可能导致内存与寄存器之间的数据产生类似脏数据的不一致等。对于某些依赖内存操作顺序而进行的逻辑，需要做严格的处理后才能进行优化。例如，采用volatile关键字限制变量的操作方式，或者利用barrier迫使cpu严格按照指令序执行的。






ref: 
https://blog.csdn.net/qq_31108501/article/details/51842166










========================================
【动态链接库的管理】运行时找不到libxx.so怎么办？ //todo
----------------------------------------

1. 安装 gsl 库时install后的提醒

提示：有几种找到ld的方法，要采用其中之一。
Libraries have been installed in:
   /home/wangjl/.local/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
   - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution
   - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking
   - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
   - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.






2. 几个命令来排查原因

怎么生成动态链接库？ gcc

ldd libxx.so 查看该库的依赖是否加载完全？

strings libxx.so 查看库是否冒充的?
ldconfig 配置动态 ？




3. 案例
https://blog.csdn.net/whatday/article/details/98052518
如果使用自己手动生成的动态链接库.so文件，但是这个.so文件，没有加入库文件搜索路劲中，程序运行时可能会出现找不到动态链接库的情形。

可以通过ldd命名来查看可执行文件依赖的动态链接库，如下(其中D为可执行程序)：
$ ldd 某个程序
可能提示某个.so文件没有找到

(1)在系统中查找这个文件(当然要保证系统中已经有这个.so文件，只是查找路径没有设置正确而已)：
　　sudo find / -name libjson_linux-gcc-4.6_libmt.so
　　结果：/home/liu/Desktop/jsoncpp-src-0.5.0/libs/linux-gcc-4.6/libjson_linux-gcc-4.6_libmt.so
(2)将.so文件路径的目录添加到/etc/ld.so.conf
 　　sudo vim /etc/ld.so.conf
　　文件末尾新添加一行，/home/liu/Desktop/jsoncpp-src-0.5.0/libs/linux-gcc-4.6
(3)使得修改生效
　　sudo /sbin/ldconfig

这样就不会有那个找不对.so文件的错误啦。

也可以设置到局部：
# for python3
export PATH=/home/wangjl/soft/python3/bin:$PATH
export LD_LIBRARY_PATH=/home/wangjl/soft/python3/lib/:$LD_LIBRARY_PATH








动态链接库的管理 https://blog.csdn.net/qq_38125626/article/details/115332433
LD 文件：规则详解 https://blog.csdn.net/shenjin_s/article/details/88712249
linux ldconfig命令,环境变量文件配置详解
	https://winycg.blog.csdn.net/article/details/80572735

CentOS下如何添加动态链接库?
	http://www.gimoo.net/t/1802/5a966f9c932be.html
	http://www.vzidc.com/news/content/4657.html
	https://www.yisu.com/zixun/411945.html
	https://www.csdn.net/tags/MtTacg4sOTYwMzMtYmxvZwO0O0OO0O0O.html

CentOS自定义动态链接库目录 https://blog.csdn.net/weixin_43885541/article/details/118698640
centos 联合编译动态连接库详解 https://www.oocolo.com/179177.html
【Linux命令】ldconfig动态链接库管理命令 http://t.zoukankan.com/HeiDi-BoKe-p-11671629.html
Linux动态链接库隔离,LINUX动态链接库高级应用 https://blog.csdn.net/weixin_35544017/article/details/116873152








========================================
|-- ldd( list dynamic dependencies )
----------------------------------------
$ ldd /home/wangjl/.local/lib/libgsl.so
	linux-vdso.so.1 =>  (0x00007ffdef3f0000)
	libm.so.6 => /lib64/libm.so.6 (0x00007f0b6c338000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f0b6bf6a000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f0b6cb19000)




========================================
|-- strings - print the strings of printable characters in files.
----------------------------------------
$ strings /home/wangjl/.local/lib/libgsl.so






========================================
|-- ldconfig命令: 配置动态链接库 
----------------------------------------
ldconfig命令的作用主要是在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。

缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令ldconfig，此执行程序存放在/sbin目录下。

ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。

语法格式:  ldconfig [参数]

ldconfig [-v|--verbose] [-n] [-N] [-X] [-f CONF] [-C CACHE] [-r ROOT] [-l] [-p|--print-cache] [-c FORMAT] [--format=FORMAT] [-V] [-?|--help|--usage] path...


-v或--verbose：用此选项时，ldconfig将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的连接的名字。
-n：用此选项时,ldconfig仅扫描命令行指定的目录，不扫描默认目录（/lib、/usr/lib），也不扫描配置文件/etc/ld.so.conf所列的目录。
-N：此选项指示ldconfig不重建缓存文件（/etc/ld.so.cache），若未用-X选项，ldconfig照常更新文件的连接。
-X：此选项指示ldconfig不更新文件的连接，若未用-N选项，则缓存文件正常更新。
-f CONF：此选项指定动态链接库的配置文件为CONF，系统默认为/etc/ld.so.conf。
-C CACHE：此选项指定生成的缓存文件为CACHE，系统默认的是/etc/ld.so.cache，此文件存放已排好序的可共享的动态链接库的列表。
-r ROOT：此选项改变应用程序的根目录为ROOT（是调用chroot函数实现的）。选择此项时，系统默认的配置文件/etc/ld.so.conf，实际对应的为ROOT/etc/ld.so.conf。如用-r /usr/zzz时，打开配置文件/etc/ld.so.conf时，实际打开的是/usr/zzz/etc/ld.so.conf文件。用此选项，可以大大增加动态链接库管理的灵活性。
-l：通常情况下,ldconfig搜索动态链接库时将自动建立动态链接库的连接，选择此项时，将进入专家模式，需要手工设置连接，一般用户不用此项。
-p或--print-cache：此选项指示ldconfig打印出当前缓存文件所保存的所有共享库的名字。
-c FORMAT 或 --format=FORMAT：此选项用于指定缓存文件所使用的格式，共有三种：old(老格式)，new(新格式)和compat（兼容格式，此为默认格式）。
-V：此选项打印出ldconfig的版本信息，而后退出。
-? 或 --help 或 --usage：这三个选项作用相同，都是让ldconfig打印出其帮助信息，而后退出。





执行动态链接库管理命令：
刷新动态链接库缓存文件 /etc/ld.so.cache。
# sudo ldconfig

追加库文件/usr/local/mysql/lib到/etc/ld.so.conf文件中：
# echo "/usr/local/mysql/lib" >>/etc/ld.so.conf 
# ldconfig -v | grep mysql



$ ldconfig -v | wc
ldconfig: Can't stat /libx32: No such file or directory
ldconfig: Path `/usr/lib' given more than once
ldconfig: Path `/usr/lib64' given more than once
ldconfig: Can't stat /usr/libx32: No such file or directory
ldconfig: Can't create temporary cache file /etc/ld.so.cache~: Permission denied
   1042    3112   45096

$ ldconfig -v | head
前4行同上，略。
/usr/lib64//bind9-export:
	libisccfg-export.so.160 -> libisccfg-export.so.160.2.1
	libisc-export.so.169 -> libisc-export.so.169.0.3
	libirs-export.so.160 -> libirs-export.so.160.0.5
	libdns-export.so.1102 -> libdns-export.so.1102.1.2
/usr/lib64/dyninst:
	libsymtabAPI.so.9.3 -> libsymtabAPI.so.9.3.1
	libsymLite.so.9.3 -> libsymLite.so.9.3.1
	libstackwalk.so.9.3 -> libstackwalk.so.9.3.1
	libpcontrol.so.9.3 -> libpcontrol.so.9.3.1










2. ldconfig几个需要注意的地方：

往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到。

想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到。

比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，新的library才能在程序运行时被找到。

如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。

ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。

总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。

再有，诸如libdb-4.3.so文件头中是会含有库名相关的信息的（即含“libdb-4.3.so”，可用strings命令查看），因此仅通过修改文件名以冒充某已被识别的库（如libdb-4.8.so）是行不通的。为此可在编译库的Makefile中直接修改配置信息，指定特别的库名。






Ref:
原文来自：http://man.linuxde.net/ldconfig
https://www.linuxprobe.com/ldconfig-command.html
https://linux265.com/course/linux-command-ldconfig.html










========================================
CMake //ing
----------------------------------------
官方教程(12个步骤): https://cmake.org/cmake/help/latest/guide/tutorial/index.html


如果有很多文件、组件，甚至第三方库，则手动make会十分繁琐。
自动构建工具有很多，vs自己的，也有 android的 gradle等。

本文讲 c/c++ 的一个构建工具 CMake，它本身不带编译工具，需要提前安装 gcc。

基本流程: 
CMake -> 
	CMakeLists.txt -> 
		vs code 工程配置文件 *.sin
		Makefile 
		.xcodeProj
		...


1. 官网资料 
https://cmake.org/
口号: Build with CMake. Build with Confidence.

说明: CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.

CMake 是开源、跨平台的工具家族，用于构建、测试和打包软件。

https://github.com/Kitware/CMake



(2) 安装 
$ sudo apt install cmake

$ cmake --version
cmake version 3.16.3

CMake suite maintained and supported by Kitware (kitware.com/cmake).

(3) 版本差异

# 古代 cmake 2.x 版本
mkdir -p build 
cd build 
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j4
make install 
cd ..


# 现在 cmake 3.x 版本(简化、灵活)
cmake -B build -DCMAKE_BUILD_TYPE=Release 
cmake --build build --parallel 4
cmake --build build --target install










2. 最简例子
(1) 单文件 源码
$ cat main.cpp
#include<iostream>
int main(){
	std::cout << "hello, world!" << std::endl;
	return 0;
}

$ g++ main.cpp 
$ ./a.out 
hello, world!
$ rm a.out

(2) 同目录下新建配置文件
$ cat CMakeLists.txt #必不可少的3行
cmake_minimum_required(VERSION 3.10) #最低的cmake版本
project(Test1)                 #项目名字，也就是编译后的名字
add_executable(Test1 main.cpp)  #添加源码文件


说明: 
add_executable(main, main.cpp)
也可以分2条写
add_executable(main)
target_sources(main PUBLIC main.cpp)



(3) 使用 CMake 两步构建

=> step1: 配置项目
$ cmake -S . -B build
$ tree build/  #查看生成的目录树


=> step2: 构建项目
$ cmake --build build
Scanning dependencies of target Test1
[ 50%] Building CXX object CMakeFiles/Test1.dir/main.cpp.o
[100%] Linking CXX executable Test1
[100%] Built target Test1


运行生成的文件
$ ./build/Test1 
hello, world!








========================================
|-- cmake 命令的更多参数 和 CMakeLists.txt 文件的写法
----------------------------------------

3. cmake 命令的参数(这个和 4.配置文件紧密结合)
$ cmake --help
-S <path-to-source>          = Explicitly specify a source directory. 源码目录
-B <path-to-build>           = Explicitly specify a build directory.  build目录
--build <dir>                = Build a CMake-generated project binary tree. 构建文件放在这个目录

(1) -D 指定配置变量（又称缓存变量）
-D <var>[:<type>]=<value>    = Create or update a cmake cache entry. 
	配置阶段才能用。
	指定构建类型: $ cmake -B build -D CMAKE_BUILD_TYPE=Release
	还可以指定 Debug 类型。一般指定 Release，编译器会自动开启各种优化。

CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，用于控制构建类型，值可以是：
	Debug 调试模式，完全不优化，生成调试信息，方便调试程序
	Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢
	MinSizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积
	RelWithDebInfo 带调试信息发布，生成文件比 Release 更大，因为带有调试的符号信息
	默认空字符窗，相当于 Debug 模式。
	对应的编译器选项上的区别:
		Debug: `-O0 -g`
		Release: `-O3 -DNDEBUG`
		MinSizeRel: `-Os -DNDEBUG`
		RelWithDebInfo: `O2 -g -DNDEBUG`
		注意: 定义了 -DNDEBUG 宏会使 assert 被去除掉。


为了改变 Debug 这个默认值，可以在配置文件前3行加上：
if (NOT CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE Release)
endif()





(2) -G 指定要用的生成器
-G <generator-name>          = Specify a build system generator.
	$ cmake -G Ninja -B build #这是更快的编译器。Ninja是转为性能优化的构建系统，它和CMake结合都是行业标准了。
		可能需要安装 $ pip install ninja -i https://pypi.douban.com/simple/
		有趣的是，cmake也可以通过pip安装 $ pip install cmake -i https://pypi.douban.com/simple/
			$ cmake --version  #cmake version 3.24.1
		$ rm -rf build/  #如果用Ninja构建报错，需要删掉中间文件，重新构建
		$ cmake -G Ninja -B build
		$ cmake --build build
		[2/2] Linking CXX executable Test1
		$ ls build/
		build.ninja  CMakeCache.txt  CMakeFiles  cmake_install.cmake  rules.ninja  Test1

耗时对比
$ time cmake --build build #使用 Ninja
[2/2] Linking CXX executable Test1

real	0m0.324s  #快了点
user	0m0.255s
sys	0m0.070s


$ time cmake --build build  #使用 Makefile
Scanning dependencies of target Test1
[ 50%] Building CXX object CMakeFiles/Test1.dir/main.cpp.o
[100%] Linking CXX executable Test1
[100%] Built target Test1

real	0m0.420s
user	0m0.315s
sys	0m0.090s















4. cmake的配置文件更多规则
(1)
$ cat CMakeLists.txt #必不可少的3行之外，又增加了很多其他句子
cmake_minimum_required(VERSION 3.10) #最低的cmake版本
project(Blackhole)                 #项目名字，也就是编译后的名字

find_package(imgui REQUIRED)   #找包 imgui，必须找到，找不到就报错
find_package(glm REQUIRED)

file(GLOB SRC_FILES
	"${PROJECT_SOURCE_DIR}/src/*.h"
	"${PROJECT_SOURCE_DIR}/src/*.cpp"
	"${PROJECT_SOURCE_DIR}/src/*.c"
	"${PROJECT_SOURCE_DIR}/src/*.cc"
)

add_executable(${CMAKE_PROJECT_NAME} ${SRC_FILES})  #添加源码文件


# 链接第三方库
target_link_library(${CMAKE_PROJECT_NAME} PRIVATE imgui::imgui)


# 然后是文件复制





(2) 多个c++源文件怎么办？

$ cat CMakeLists.txt #必不可少的3行
cmake_minimum_required(VERSION 3.10) #最低的cmake版本
project(Test1)                 #项目名字，也就是编译后的名字


add_executable(main, main.cpp)

#1) 逐个添加源码
add_executable(main)
target_sources(main PUBLIC main.cpp other.cpp) 
 


#2) 使用set设置变量来添加源文件
add_executable(main)
set(sources main.cpp other.cpp other.h)
target_sources(main PUBLIC ${sources}) 


#3) 使用GLOB自动查找某目录下的指定扩展名文件
add_executable(main)
file(GLOB sources *.cpp *.h)
target_sources(main PUBLIC ${sources}) 


为了防止文件删除、改名后不及时更新，建议加上 CONFIGURE_DEPENDS 选项：添加新文件时，自动更新变量
add_executable(main)
file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)
target_sources(main PUBLIC ${sources}) 


#4) 带有子文件夹怎么办？列举可能的文件夹和后缀组合
add_executable(main)
file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)
target_sources(main PUBLIC ${sources}) 


或者 用 aux_source_directory 自动搜集需要的文件后缀名
add_executable(main)
aux_source_directory(. sources) #获取 ./ 目录下的源码文件，保存在 sources 中
aux_source_directory(mylib sources)  #获取 ./ 目录下的源码文件，保存在 sources 中
target_sources(main PUBLIC ${sources}) 



#5) GLOB 换成 GLOB_RECURSE 自动包含所有子文件夹下的文件
add_executable(main)
file(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)
target_sources(main PUBLIC ${sources})

这样有个问题，由于 build/ 也在当前目录，里面有一些中间文件，也会被包含进来，导致冲突。
解决办法：把源码文件和 build 文件放在不同的目录中。比如把build放在其他目录 /tmp/build，或者把源码放在 /src 下。




3) 






(100) 怎么下载第三方库？
- 直接下载
- 有一个类似于pyhton 的pip的工具：微软的 vcpkg
	$ vcpkg install imgui
	CentOS7.9 yum找不到 vcpkg。Ubuntu 20.04 apt也找不到。看演示，是win下的cmd。






ref:
https://www.bilibili.com/video/BV16P4y1g7MH/?spm_id_from=333.337.search-card.all.click
	看到 21'









========================================
GNU symbolic debugger,简称「GDB 调试器」
----------------------------------------
1. GDB工具简介

(1)gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。

一般来说，GDB主要帮助你完成下面四个方面的功能：
- 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
- 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
- 当程序被停住时，可以检查此时你的程序中所发生的事。
- 你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。

(2) GDB调试一定要是可执行文件而不是.c文件
要用gcc进行编译，具体的命令如下：
$ gcc -g -O0 源文件.c -o 输出的目标文件

参数解释：
-g,-O参数缺一不可
加上-g 选项，会保留代码的文字信息，便于调试。
-O0 就是不做编译优化。
	比如没使用的变量，编译器优化后直接删掉了，不在内存中初始化。



加上-g选项以后，gcc在编译是会做以下额外的操作：
- 创建符号表，符号表包含了程序中使用的变量名称的列表。
- 关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行。


(3) Ubuntu 默认已经安装了
$ gdb --version
GNU gdb (Ubuntu 8.2-0ubuntu1~18.04) 8.2
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.





2. 尝试使用 gdb 调试程序

(1) 交换值：失败版本
$ cat 01_swap.c 
#include<stdio.h>
void swap(int x, int y){
  int tmp=x;
  x=y;
  y=x;
  printf("in swap(): a=%d, b=%d\n", x,y);
}

int main(){
  int a=10, b=20;
  printf("a=%d, b=%d\n", a,b);
  swap(a, b);
  printf("a=%d, b=%d\n", a,b);
  return 0;
}


2) 编译与执行
$ gcc -g 01_swap.c -o 01_swap.out

$ ./01_swap.out 
a=10, b=20
in swap(): a=20, b=10
a=10, b=20


3) gdb运行
$ gdb 01_swap.out

l 或 list 列出源代码，再按回车，继续显示
(gdb) l
11        printf("a=%d, b=%d\n", a,b);
12        swap(a, b);
13        printf("a=%d, b=%d\n", a,b);
14        return 0;
15      }

单步调试: 
(gdb) start

查看变量值，p, print:
(gdb) p b
$2 = 0

执行下一行
(gdb) n
输出下一行的行号和内容。

查看变量值，p, print:
(gdb) p b
$4 = 20

(gdb) n
a=10, b=20   ## 这有实参的值
12        swap(a, b);
到函数这一行了，查看函数内部，使用s 
(gdb) s
swap (x=10, y=20) at 01_swap.c:3  #这是形参的值
3         int tmp=x;

查看堆栈，有2个编号，目前是最上面的有效
(gdb) bt
#0  swap (x=20, y=20) at 01_swap.c:5
#1  0x00005555555546c4 in main () at 01_swap.c:12

切换到主函数，主函数还在第12行没动。
(gdb) f 1
#1  0x00005555555546c4 in main () at 01_swap.c:12
12        swap(a, b);

在这里检查变量
(gdb) p a
$7 = 10
(gdb) p b
$8 = 20

这时，子函数中的变量是不能访问的
(gdb) p x
No symbol "x" in current context.

切换回子函数，子函数执行到5行了(第5行还没有执行)
(gdb) bt
#0  swap (x=20, y=20) at 01_swap.c:5
#1  0x00005555555546c4 in main () at 01_swap.c:12
(gdb) f 0
#0  swap (x=20, y=20) at 01_swap.c:5
5         y=tmp;
(gdb) p x
$9 = 20
(gdb) p y
$10 = 20

还可以查看变量的地址
(gdb) p &x
$11 = (int *) 0x7fffffffdd3c


退出 
(gdb) q





(2) 交换值，使用指针：成功的版本
$ cat 01_swap2.c 
#include<stdio.h>
void swap(int* x, int* y){
  int tmp=*x;
  *x=*y;
  *y=tmp;
  printf("in swap(): a=%d, b=%d\n", *x,*y);
}

int main(){
  int a=10, b=20;
  printf("a=%d, b=%d\n", a,b);
  swap(&a, &b);
  printf("a=%d, b=%d\n", a,b);
  return 0;
}

编译执行，成功交换了值
$ gcc -g 01_swap2.c -o 01_swap2.out
$ ./01_swap2.out 
a=10, b=20
in swap(): a=20, b=10
a=20, b=10





2) 使用 gdb 调试
$ gdb 01_swap2.out
(gdb) start

多次输入 next ，直到执行到函数
(gdb) n
a=10, b=20
12        swap(&a, &b);


进入子函数内部s，发现传递的确实是指针。指针相差4个字节，就是int类型的sizeof。
(gdb) s
swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
3         int tmp=*x;

(gdb) p x
$3 = (int *) 0x7fffffffdd60
(gdb) p *x
$5 = 10

回到主函数
(gdb) bt
#0  swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
#1  0x000055555555474b in main () at 01_swap2.c:12
(gdb) f 1
#1  0x000055555555474b in main () at 01_swap2.c:12
12        swap(&a, &b);

查看变量 a的地址 == 子函数中的指针x。也就是他们指向的是同一个内存块。
(gdb) p a
$6 = 10
(gdb) p &a
$7 = (int *) 0x7fffffffdd60


回到子函数
(gdb) f 0
#0  swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
3         int tmp=*x;
执行到交换值后
(gdb) n
5         *y=tmp;
(gdb) n
6         printf("in swap(): a=%d, b=%d\n", *x,*y);

(gdb) p *x
$8 = 20
(gdb) p *y
$9 = 10

回到主函数，检查变量，发现也交换过了。
(gdb) f 1
#1  0x000055555555474b in main () at 01_swap2.c:12
12        swap(&a, &b);
(gdb) p a
$10 = 20
(gdb) p b
$11 = 10








3. GDB常用的调试命令
一大波命令来袭，hold,或者jump
（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h
（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r
（gdb）start：单步执行，运行程序，停在第一执行语句
（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l
（gdb）set：设置变量的值
（gdb）next：单步调试（逐过程，函数直接执行）,简写n
（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s
（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt
（gdb）frame：切换函数的栈帧,简写f
（gdb）info：查看函数内部局部变量的数值,简写i
（gdb）finish：结束当前函数，返回到函数调用点
（gdb）continue：继续运行,简写c
（gdb）print：打印值及地址,简写p
（gdb）quit：退出gdb,简写q
（gdb）break+num：在第num行设置断点,简写b
（gdb）info breakpoints：查看当前设置的所有断点
（gdb）delete breakpoints num：删除第num个断点,简写d
（gdb）display：追踪查看具体变量值
（gdb）undisplay：取消追踪观察变量
（gdb）watch：被设置观察点的变量发生修改时，打印显示
（gdb）i watch：显示观察点
（gdb）enable breakpoints：启用断点
（gdb）disable breakpoints：禁用断点
（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元
（gdb）run argv[1] argv[2]：调试时命令行传参



(1)函数的调用

call name 调用和执行一个函数

(gdb) call rect(2,3)
$12 = 6


(2) 按地址打印值
(gdb) p *0x7fffffffdd50
$19 = 3


(3) 内存各部分的起始位置在哪里？

有一组专用的gdb变量可以用来检查和修改计算机的通用寄存器，gdb提供了目前每一台计算机中实际使用的4个寄存器的标准名字：
$pc ： 程序计数器
$fp ： 帧指针（当前堆栈帧）
$sp ： 栈指针
$ps ： 处理器状态

测试: 
(gdb) p $pc
$18 = (void (*)()) 0x5555555546dc <rect+50>
(gdb) p $fp
$19 = (void *) 0x7fffffffdd08
(gdb) p $sp
$20 = (void *) 0x7fffffffdd08
(gdb) p $ps
$21 = [ PF IF ]


(4) 你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：

x/

n、f、u是可选的参数。

n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。
  u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。
  当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。

表示一个内存地址。

n/f/u三个参数可以一起使用。例如：

命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。






## 查看栈内存起始地址
(gdb) p $sp  
$7 = (void *) 0x7fffffffdd08

## 打印栈开始的前40个字(160个字节)
(gdb) x/40x $sp
0x7fffffffdd08: 0xffffdd30      0x00007fff      0x55554719      0x00005555
0x7fffffffdd18: 0x756e6547      0x00000003      0x00000009      0x00000000
0x7fffffffdd28: 0xf7dd7660      0x00007fff      0xffffdd80      0x00007fff
0x7fffffffdd38: 0x55554777      0x00005555      0x00000001      0x00000000
0x7fffffffdd48: 0x555547fd      0x00000003      0x00000004      0x00007fff
0x7fffffffdd58: 0xffffdd4c      0x00007fff      0xffffdd50      0x00007fff
0x7fffffffdd68: 0x55755014      0x00005555      0x555546e1      0x00005555
0x7fffffffdd78: 0x88589500      0xa161f7f7      0x555547b0      0x00005555
0x7fffffffdd88: 0xf7a05b97      0x00007fff      0x00000001      0x00000000
0x7fffffffdd98: 0xffffde68      0x00007fff      0x00008000      0x00000001











以上就是GDB的命令其中的部分，下面列详细写一些基础常用的命令：
 **list **
list 可写为l,可以列出所调试程序的代码

list+linenumber 可以列出linenumber附近的代码
$ list 20

list function 可以列出函数上下文的源程序



run & quit
在GDB中如何将程序运行起来，此时只要输入run命令,就可以将命令跑起来
而quit则是退出GDB调试
break




(1)GDB查看，执行汇编语言
查看汇编 disassemble

下面就是查看的汇编代码




ref:
https://blog.csdn.net/awm_kar98/article/details/82840811
https://blog.csdn.net/lxb_champagne/article/details/5282316






========================================
|-- 内存管理：堆内存、栈内存的差异，静态变量、局部变量
----------------------------------------
1. 计算机中数据表示方法
计算机使用二进制，电路只有通电、不通电2个状态。
	而二进制写出来又太长，所以经常使用16进制打印，比如内存地址。
	2进制和16进制的转换很方便，就是4位2进制->压缩到1位16进制。
人类使用的是十进制，因为人有十个手指头。




2. 内存管理概述

(1) 计算机内存

1 byte = 8 bits;
字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位(8-bits)。

字符(Character)计算机中使用的字母、数字、字和符号，比如'A'、'B'、'$'、'&'等。
一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。


8 bit = 1B (1 byte 1个字节)  一个字节存放8个二进制位的数据。
1024 byte=1K =2**10
1024 K=1M    =2**20
1024 M=1G    =2**30
1024 G=1T    =2**40
1024 T=1PB   =2**50
1024 P=1EB   =2**60

32位操作系统只能识别4G内存，为什么？
因为地址总线是32位，也就是寻址空间是32位。
	32位指的是：给内存编号只能编到32个二进制位。
	32根地址总线就有2**32个状态：(2**10)*(2**10)*(2**10)*(2**2)=4*k*k*k=4*k*M=4G;
		2**32/1e9=4.294967296

那么 64 位操作系统最多支持多少内存呢？
	头疼 2**64=(2**10)*(2**10)*(2**10)*(2**10)*(2**10)*(2**10)*(2**4)=16KKKKKK=16KKKG=16GG=16x10**18
		2**64/1e18=18.446744073709553
		也即是说 16KMG=16MT 的内存条，远超过了我们市面上能买到的内存总数。
	4位二进制对应一个16进制位，所以64位的内存地址，写成16进制是16位，从0-9a-f。
	0x开头，从最低的 16个0，到最高的16个f。








(2) linux 内存

根据Linux内核相关文档描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。
所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）

用户使用的是后32位，也就是8个16进制位。
其他是操作系统使用的。
内存按照大部分分为
- 系统内核 Kernal Space
- Unused 自由可分配内存。
- User space
	- Stack 栈
	- Mapping Area
	- Heap 堆
	- BSS 
	- data 数据段：定义的 const 常量，全局变量。内存编号大于 代码段。
	- code 代码段：源代码。编号处于低位。


对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：
Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）
Data：这里存放的是初始化过的全局变量
BSS：这里存放的是未初始化的全局变量
Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存
Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长
Stack：这是栈区域，自高地址向低地址增长


一般来说，malloc所申请的内存主要从Heap区域分配





(3) 页与地址构成
在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。

所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下
********页号(52bit)******| 偏移(12bit)
           *页号(20bit)**| 偏移(12bit)
		   
上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。


ref: https://www.cnblogs.com/Commence/p/5785912.html










(100) 我测试的，64位ubuntu，指针占了8位，为什么不是16位?
#include<stdio.h>
int main(){
  int *p, i=100;
  p=&i;
  printf("i=%d, p=%p, len(p)=%ld\n", *p, p, sizeof(p));
}

$ ./a.out 
i=100, p=0x7ffd91c7b4ac, len(p)=8



指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，
譬如以前是16位地址，指针即为2个字节，
现在一般是32位系统，所以是4个字节，
以后64位，则就为8个字节。










3. 看一下C语言的各个组分都保存在内存内的什么位置。

(1) 实例代码
$ cat 02_mem.c 
//求正方形、长方形面积
//为了检查各个变量在内存中的位置，加入很多无关变量。
#include<stdio.h>

int global =0;
int rect(int a, int b){
	static int count=0;
	count++;
	global++;
	int s=a*b;
	return s;
}

int square(int a){
	static int count =0;
	count++;
	global++;
	int s=rect(a, a);
	return s;
}

int main(){
	int a=3, b=4;
	int *pa=&a, *pb=&b;
	int *pglobal=&global;
	int (*psquare)(int a)=&square;
	int s=(*psquare)(a);
	printf("%d\n", s);
}

$ gcc -g 02_mem.c
$ ./a.out
9



(2) gdb 调试 

$ gdb a.out
(gdb) start
Temporary breakpoint 1 at 0x729: file 02_mem.c, line 22.
Starting program: /data/wangjl/test/C/a.out 

Temporary breakpoint 1, main () at 02_mem.c:22
22      int main(){


当按几下next时，可以看到代码，这就是内存中的代码段，
不过，C语言语法不允许直接操作代码段。
(gdb) n
25              int *pglobal=&global;

(gdb) n
28              printf("%d\n", s);


除了代码编译后存在代码段以外，
- 当前调用了哪个函数呢？
- 当前调用的函数运行到多少行？
- 并且这个函数中有哪些变量，这些变量的值是什么？
这些信息都记录在栈中。栈是内存中的编号比较高的位置。

(gdb) p a
$1 = 3
(gdb) p &a
$3 = (int *) 0x7fffffffdd4c
(gdb) p pa
$2 = (int *) 0x7fffffffdd4c
## 变量名只是一个代号。变量的本质就是内存。


(gdb) p &pa ## 指向指针的指针
$4 = (int **) 0x7fffffffdd58
(gdb) p *(&pa)  ## 指向变量的指针
$5 = (int *) 0x7fffffffdd4c
(gdb) p **(&pa)
$6 = 3
(gdb) p *pa
$7 = 3

C语言中所有的变量都是有类型的。
int 类型保存整数。
指针保存的就是内存地址。
指针的本质就是地址。





(3) 代码段：保存函数，编号最小。
我们比较一下各种变量的内存编号的大小

(gdb) p &rect
$8 = (int (*)(int, int)) 0x5555555546aa <rect>
(gdb) p &square
$9 = (int (*)(int)) 0x5555555546e1 <square>
(gdb) p &main
$10 = (int (*)()) 0x555555554721 <main>

说明函数加载顺序：先加载的 main，然后是 rect，最后是 square。
而连续加载的函数内存编号相减，就是上一个占用的内存空间。





(4) 数据段：全局变量、常量 

(gdb) p &global
$12 = (int *) 0x555555755014 <global>

这个比代码段要大，说明 数据段 在 代码段 之上。


按照变量声明的顺序查看其地址
(gdb) list
23              int a=3, b=4;
24              int *pa=&a, *pb=&b;
25              int *pglobal=&global;
26              int (*psquare)(int a)=&square;
27              int s=(*psquare)(a);
28              printf("%d\n", s);
29      }

(gdb) p &a
$13 = (int *) 0x7fffffffdd4c
(gdb) p &b
$14 = (int *) 0x7fffffffdd50
(gdb) p &pa
$15 = (int **) 0x7fffffffdd58
(gdb) p &pb
$16 = (int **) 0x7fffffffdd60
(gdb) p &pglobal
$21 = (int **) 0x7fffffffdd68
(gdb) p &psquare
$22 = (int (**)(int)) 0x7fffffffdd70

(gdb) p psquare  ##这是指向函数的指针
$17 = (int (*)(int)) 0x5555555546e1 <square>

(gdb) p &s
$19 = (int *) 0x7fffffffdd54

(gdb) q
退出。

可见a占4位，首地址加4就是b的地址。
中间间隔4，why? 往后找 变量s在这4位上。可能是C语言编译时优化了，把相同类型的变量放一起声明。
然后声明的指针变量 pa，pb，pglobal，psquare，保存的地址，其本身的内存地址各占8字节。





(5) 栈(stack)内存
在代码段、数据段、堆中声明的变量，先声明的地址小，后来的大。
而栈则相反，先声明的大，越后来越小。

重新执行到函数调用部分
$ gdb a.out
(gdb) start

(gdb) n
27              int s=(*psquare)(a);


i)进入函数
(gdb) s
square (a=3) at 02_mem.c:16
16              count++;

(gdb) bt # 查看栈，预先不知道要放到栈中多少个变量，最先分配的栈地址最大，往后越来越小。
#0  square (a=3) at 02_mem.c:16
#1  0x0000555555554777 in main () at 02_mem.c:27

(gdb) n
18              int s=rect(a, a);

函数内又调用了一个函数，目前都在#0  square (a=3) at 02_mem.c:16 内部
(gdb) p &s
$1 = (int *) 0x7fffffffdd2c



ii) 再次进入函数
(gdb) s
rect (a=3, b=3) at 02_mem.c:8
8               count++;

查看栈，这时最早的是最底部的 main(内存编号最大)，然后是 square 内存编号略小。
栈的最上面始终是当前正在执行的函数。
栈的特点：先进后出。只有顶部一个出口/入口。
(gdb) bt
#0  rect (a=3, b=3) at 02_mem.c:8
#1  0x0000555555554719 in square (a=3) at 02_mem.c:18
#2  0x0000555555554777 in main () at 02_mem.c:27


(gdb) n
10              int s=a*b;
(gdb) n
11              return s;

(gdb) p &s
$2 = (int *) 0x7fffffffdd04
## 对比上一层 i) 中的 &s，发现这个后入栈的 s 的内存编号更小。

(gdb) p &count
$3 = (int *) 0x555555755018 <count>
## 这个静态变量，内存地址和前面几个变量都不一样，这是在堆中。





iii) 切换到#1栈，就是函数square内部
(gdb) f 1
#1  0x0000555555554719 in square (a=3) at 02_mem.c:18
18              int s=rect(a, a);

(gdb) p &count
$4 = (int *) 0x55555575501c <count>

在正方形和长方形面积函数中都有一个叫 count 的静态变量，他们是2个独立的变量，内存地址不同。


(gdb) p &global
$5 = (int *) 0x555555755014 <global>





iv) 切换回#0栈，就是rect内部

(gdb) f 0
#0  rect (a=3, b=3) at 02_mem.c:11
11              return s;
(gdb) p &global
$6 = (int *) 0x555555755014 <global>

这个全局变量，地址是一样的。

静态变量、全局变量、常量，都在数据段中，内存地址编号比较小。
所以函数可以调用很多次，但是函数内的静态变量都是指向数据段的，是可以保留值的。




## 查看栈内存起始地址
(gdb) p $sp  
$7 = (void *) 0x7fffffffdd08


## 打印栈开始的前40个字(160个字节)
(gdb) x/40x $sp
0x7fffffffdd08: 0xffffdd30      0x00007fff      0x55554719      0x00005555
0x7fffffffdd18: 0x756e6547      0x00000003      0x00000009      0x00000000
0x7fffffffdd28: 0xf7dd7660      0x00007fff      0xffffdd80      0x00007fff
0x7fffffffdd38: 0x55554777      0x00005555      0x00000001      0x00000000
0x7fffffffdd48: 0x555547fd      0x00000003      0x00000004      0x00007fff
0x7fffffffdd58: 0xffffdd4c      0x00007fff      0xffffdd50      0x00007fff
0x7fffffffdd68: 0x55755014      0x00005555      0x555546e1      0x00005555
0x7fffffffdd78: 0x88589500      0xa161f7f7      0x555547b0      0x00005555
0x7fffffffdd88: 0xf7a05b97      0x00007fff      0x00000001      0x00000000
0x7fffffffdd98: 0xffffde68      0x00007fff      0x00008000      0x00000001









========================================
|-- gdb 查看 函数指针
----------------------------------------
1. 函数指针 

$ gdb a.out 
(gdb) start

(gdb) n
26              int (*psquare)(int a)=&square;
(gdb) n
27              int s=(*psquare)(a);
(gdb) bt
#0  main () at 02_mem.c:27


进入函数内部
(gdb) s
square (a=3) at 02_mem.c:16
16              count++;
(gdb) bt
#0  square (a=3) at 02_mem.c:16
#1  0x0000555555554777 in main () at 02_mem.c:27

回到主函数 
(gdb) f 1
#1  0x0000555555554777 in main () at 02_mem.c:27
27              int s=(*psquare)(a);

这是一个指向函数的指针
(gdb) p psquare 
$3 = (int (*)(int)) 0x5555555546e1 <square>  #指向堆中的函数
(gdb) p &psquare  
$1 = (int (**)(int)) 0x7fffffffdd70  #这个指针本身在栈中保存

尝试打印其指向的内容：解引用
(gdb) p *psquare 
$4 = {int (int)} 0x5555555546e1 <square> #不懂为什么是这个形式 //todo


尝试通过这个函数的指针调用该函数
(gdb) call (*psquare)(20)
$2 = 400











========================================
|-- 指针与内存: 指针、数组、字符串
----------------------------------------
CPU做了什么，内存发生了什么变化？

1. 数组的本质

(1) 示例程序
$ cat 03_mem_array.c
#include<stdio.h>
int main(){
	int a=3;
	int  b=2;
	int arr[3];
	arr[0]=1;
	arr[1]=20;
	arr[2]=300;
	int *p=&a, i;
	int N=10;
	for(i=0; i<N; i++){
		printf("*p=%d\n", *p);
		p++;
	}
	printf("== ==\n");
	p=&a;
	for(i=0; i<N; i++){
		printf("p[%d]=%d\n",i, p[i]);
	}
}
上下打印的值完全相同，也就是说：数组就是指针。
arr == &arr[0]



(2) 编译执行
$ gcc -g -O0  03_mem_array.c -o a.out0
$ gcc -g  03_mem_array.c -o a.out

参数-O0表示不编译优化，结果文件可能略大。
-rwxrwxr-x 1 wangjl wangjl 11008 Jul 25 21:56 a.out
-rwxrwxr-x 1 wangjl wangjl 11008 Jul 25 21:56 a.out0
$ md5sum a.out*
d9a6fd1ac496ca7db8cfc261545c3dce  a.out
4c2900c395789379f0365e56566b4a9c  a.out0



$ gcc -g 03_mem_array.c
$ ./a.out
*p=3
*p=1
*p=2
*p=10
*p=1353044336
*p=32767
*p=2138310128
*p=1
*p=20
*p=300
== ==
p[0]=3  //a
p[1]=1  //i
p[2]=2  //b
p[3]=10  //N
p[4]=1353044320
p[5]=32767
p[6]=2138310128
p[7]=1
p[8]=20
p[9]=300


为什么连续声明的变量a=3,b=2不连续？
为什么变量和数组中间有间隔？
这个都需要使用 gdb 查看内存找答案。


(3) gdb 调试 
$ gdb a.out
(gdb) start

连续执行几个next，
(gdb) n
*p=3
13                      p++;


(gdb) p &a
$1 = (int *) 0x7fffffffdd50
(gdb) p &b
$2 = (int *) 0x7fffffffdd58
(gdb) p &N
$3 = (int *) 0x7fffffffdd5c

(gdb) p &i
$4 = (int *) 0x7fffffffdd54
(gdb) p i
$8 = 0

发现原来a和b之间的是变量i。

(gdb) p *p #解指针，取值
$11 = 3
(gdb) p p  #指针指向的地址，就是 &a
$9 = (int *) 0x7fffffffdd50
(gdb) p &p  #指针本身存放的位置
$10 = (int **) 0x7fffffffdd60
(gdb) whatis p # 查看p的类型，是 int指针
type = int *


(gdb) p &arr[0]
$5 = (int *) 0x7fffffffdd6c
(gdb) p &arr[1]
$6 = (int *) 0x7fffffffdd70
(gdb) p &arr[2]
$7 = (int *) 0x7fffffffdd74


打印栈的前12个位置，
第一行4个: a=3, i=0, b=2, N=10
第二行4个: 前三个不知道是啥。
	前两个是指针p本身在内存中的位置 &p，倒着放的。
		第三个不知道啥，可能是指针类型 int。//todo 
	第四个是数组第一个元素 arr[0]=1
第三行前两个: arr[1]=20, arr[2]=300

(gdb) x/12x $sp
0x7fffffffdd50: 0x00000003      0x00000000      0x00000002      0x0000000a
0x7fffffffdd60: 0xffffdd50      0x00007fff      0x555545f0      0x00000001
0x7fffffffdd70: 0x00000014      0x0000012c      0x355a2500      0x17c15553


x表示要输出内存的值，12x就是输出12个16进制， $sp 就是从这个位置开始输出。
还可以d指定按照10进制输出，更直观了，但是指针变量 p 就乱了。
(gdb) x/12d $sp
0x7fffffffdd50: 3       0       2       10
0x7fffffffdd60: -8880   32767   1431651824      1
0x7fffffffdd70: 20      300     895100160       398546259





2. 数组与指针：任何使用数组的地方都可以使用指针代替。

方便 p++ 做指针偏移时，按照int类型递增。
p += 3 则表示指针向下移动 int 的3倍，就是4*3=12个。
甚至更厉害的数组样偏移 p[3]=200 直接赋值。


(1) 使用指针操作数组

$ cat 04_array_pointer.c
#include<stdio.h>
int main(){
	int arr[]={1,20,303, 444};
	int *p=arr;
	//使用指针改变值
	p[3]=505;
	for(int i=0; i<4; i++){
		//使用指针下标，输出数组
		printf("p[%d]=%d\n", i, p[i]);
	}
	for(int i=0; i<4; i++){
		//使用指针偏移，输出数组
		printf("*(p+%d)=%d\n", i, *p);
		p++;
	}
	return 0;
}


输出:
p[0]=1
p[1]=20
p[2]=303
p[3]=505  //被修改过。
*(p+0)=1
*(p+1)=20
*(p+2)=303
*(p+3)=505







========================================
|-- 字符数组(字符串)、二维字符数组(字符串数组)
----------------------------------------
1. 字符串在内存中就是字符构成的数组，遇到\0结束。

(1) 示例代码
$ cat 05_string_pointer.c 
#include<stdio.h>
int main(){
	char str[]="hello";
	char *str2="world";
	char str3[10];
	printf("input a string\n");
	scanf("%s", str3);
	printf("str is %s\n", str);
	printf("str2 is %s\n", str2);
	printf("str3 is %s\n", str3);
	return 0;
}

$ gcc -g 05_string_pointer.c 
$ ./a.out 
input a string
what is your name
str is hello
str2 is world
str3 is what  #只读取到空格就停了



(2) 开始调试
$ gdb a.out
(gdb) start


多次按next:
(gdb) n
input a string
7               scanf("%s", str3);
(gdb) n
what
8               printf("str is %s\n", str);

这时查看类型
(gdb) p str
$1 = "hello"
(gdb) p &str
$2 = (char (*)[6]) 0x7fffffffdd68
(gdb) p &str2
$3 = (char **) 0x7fffffffdd60
(gdb) p str2
$4 = 0x5555555548a4 "world"
(gdb) p &str3
$5 = (char (*)[10]) 0x7fffffffdd6e


发现str, str3是装着指针的数组，
(gdb) p &str[0]
$15 = 0x7fffffffdd68 "hello"
(gdb) p &str[1]
$16 = 0x7fffffffdd69 "ello"
(gdb) p &str[2]
$17 = 0x7fffffffdd6a "llo"
(gdb) p &str[3]
$18 = 0x7fffffffdd6b "lo"
(gdb) p &str[4]
$19 = 0x7fffffffdd6c "o"
(gdb) p &str[5]
$20 = 0x7fffffffdd6d ""


str2是指向指针的指针，真实字符串在代码段(不是堆吗？看能否修改吧)中
(gdb) x/6c 0x5555555548a4
0x5555555548a4: 119 'w' 111 'o' 114 'r' 108 'l' 100 'd' 0 '\000'
(gdb) p &str2[0]
$23 = 0x5555555548a4 "world"
(gdb) p &str2[1]
$24 = 0x5555555548a5 "orld"
(gdb) p &str2[2]
$25 = 0x5555555548a6 "rld"





(3) 字符串可以使用字符数组形式直接编辑
尝试把中间某个字符修改为结束符\0.

$ cat 06_string_end.c
#include<stdio.h>
int main(){
	char str[]="this is";
	char str3[10]="OK";
	printf("%s\n", str);
	//使用指针操作提前终止
	str[3]='\0';
	printf("%s\n", str);
	
	int i;
	for(i=0; i<8; i++){
		printf("%c\n", str[i]);
	}
	return 0;
}

$ ./a.out 
this is
thi
t
h
i

 
i
s

按照数组，逐个字符可以都打印出来，\0就是一个空行。




(4) 如果第一个字符接收的输入过长，则会覆盖掉接下来的内存块。
$ cat 07_str_overwrite.c 
#include<stdio.h>
int main(){
	char str[]="hello";
	char *str2="world";
	char str3[10];
	printf("input a string\n");
	scanf("%s", str);
	printf("str is %s\n", str);
	printf("str2 is %s\n", str2);
	printf("str3 is %s\n", str3);
	return 0;
}

$ ./a.out 
input a string
nihao
str is nihao
str2 is world
str3 is 


2) 如果输入超过5个字符呢，会覆盖掉str3
$ ./a.out 
input a string
1234567890
str is 1234567890
str2 is world
str3 is 7890

可见，str会从指针开始的位置，读到\0；
str3 也是。所以他们的后半段是重叠的。








2. 字符串数组本质：二维数组
$ cat 08_2d_array.c
#include<stdio.h>
int main(){
	char str[][5]={"this", "is", "dog"};
	int i=0;
	for(;i<3;i++){
		printf("str[%d]=%s \t%p\n", i, str[i], &str[i]);
	}
	return 0;
}

$ gcc -g 08_2d_array.c
$ ./a.out 
str[0]=this     0x7ffee4d421e9
str[1]=is       0x7ffee4d421ee
str[2]=dog      0x7ffee4d421f3

(2) 进行调试
$ gdb a.out 
运行命令 start, 多次 n后:
(gdb) n
5               for(;i<3;i++){

检查 str 的内存结构：
(gdb) p str
$1 = {"this", "is\000\000", "dog\000"}
(gdb) p &str
$2 = (char (*)[3][5]) 0x7fffffffdd69
(gdb) p &str[0]
$3 = (char (*)[5]) 0x7fffffffdd69
(gdb) p &str[0][0]
$4 = 0x7fffffffdd69 "this"

(gdb) p &str[1]
$5 = (char (*)[5]) 0x7fffffffdd6e
(gdb) p &str[2]
$6 = (char (*)[5]) 0x7fffffffdd73
(gdb) p &str[2][0]
$7 = 0x7fffffffdd73 "dog"

可见二维数组占用的空间是连续的，可以认为是线性的一排。
第一维是字符串数组，3个；
第二维是每个字符串内部的字符数组，每个占5位。

在内存中的结构为：
(gdb) x/15x 0x7fffffffdd69
0x7fffffffdd69: 0x73696874      0x00736900      0x6f640000      0x00000067
0x7fffffffdd79: 0x1d252cb4      0x60069490      0x55555547      0x97000055
0x7fffffffdd89: 0xfff7a05b      0x0100007f      0x00000000      0x68000000
0x7fffffffdd99: 0xffffffde      0x0000007f      0x01000080
(gdb) x/15c 0x7fffffffdd69
0x7fffffffdd69: 116 't' 104 'h' 105 'i' 115 's' 0 '\000'        105 'i' 115 's' 0 '\000'
0x7fffffffdd71: 0 '\000'        0 '\000'        100 'd' 111 'o' 103 'g' 0 '\000'        0 '\000'








========================================
Valgrind：查找内存泄露利器 (缺点：巨慢) //todo 
----------------------------------------
Valgrind这个名字取自北欧神话中英灵殿的入口。
Valgrind的最初作者是Julian Seward，他于2006年由于在开发Valgrind上的工作获得了第二届Google-O'Reilly开源代码奖。


1. 简介
(1) Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。

官网：https://www.valgrind.org/
源码：https://sourceware.org/git/?p=valgrind.git
文档：https://www.valgrind.org/docs/

安装 Valgrind
$ sudo apt install valgrind

$ valgrind --version
valgrind-3.13.0


(2)关于：https://www.valgrind.org/info/about.html
With Valgrind's tool suite you can automatically detect many memory management and threading bugs, avoiding hours of frustrating bug-hunting, making your programs more stable. You can also perform detailed profiling to help speed up your programs.


(3) 为什么用？
最近老是遇上各种奇奇怪怪的core dump，不太会分析的情况下看到了这款工具。
Valgrind可以检测内存泄漏和内存越界，还可以分析cache的使用等，灵活轻巧而又强大。   

Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。
你可以在它的环境中运行你的程序来监视内存的使用情况，比如C 语言中的malloc和free。


(4) 想要从源头杜绝内存泄漏，最直接的方式是时刻牢记
内存分配函数Xalloc( malloc, calloc, realloc) 和内存释放函数 free 必须成对出现。

但是在一些比较复杂的c语言程序中，甚至包含很多文件，有很多循环和分支，我们往往无法逐一验证内存分配函数和内存释放函数的配对。

这时候就需要工具了，valgrind就是其中之一。





2. Valgrind的主要功能
Valgrind工具包包含多个工具，如 Memcheck, Cachegrind, Helgrind, Callgrind, Massif。下面分别介绍个工具的作用。

Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。

Callgrind。它主要用来检查程序中函数调用过程中出现的问题。

Cachegrind。它主要用来检查程序中缓存使用出现的问题。

Helgrind。它主要用来检查多线程程序中出现的竞争问题。

Massif。它主要用来检查程序中堆栈使用中出现的问题。

Extension。可以利用core提供的功能，自己编写特定的内存调试工具。



(1) 使用 Valgrind 十分简单，只要执行valgrind theprogram，它就会运行你的程序，随后打印出你的程序运行时出现的所有错误。

valgrind 的命令一般都很长，不过可以用到了再查。

$ valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./a.out

--tool=memcheck 表示选择工具 memcheck
--leak-check=yes 表示退出后搜索内存泄漏
--show-reachable=yes 相当于 --show-leak-kines=all 显示所有类型的内存泄漏

注意：想要输出正确的行号信息，程序必须使用 -g 选项编译。




(2) 测试 正例：内存正常

$ cat 09_valgrind.c
#include <stdio.h>
/* Warning: This program is wrong on purpose. */
int main(){
    int age = 10;
    int height;

    printf("I am %d years old.\n");
    printf("I am %d inches tall.\n", height);
    return 0;
}

两个经典错误：
- 没有初始化height变量
- 没有将age变量传入第一个printf函数

$ gcc -Wall -g 09_valgrind.c -o a.out
09_valgrind.c: In function ‘main:.
09_valgrind.c:7:19: warning: format ‘%d’ expects a matching ‘int’ argument [-Wfor]at=
     printf("I am %d years old.\n");
                  ~^
$ ./a.out 
I am 1326168792 years old.
I am 0 inches tall.

输出很乱，不知道怎么看
$ valgrind ./a.out
$ valgrind --track-origins=yes ./a.out
==14322== Memcheck, a memory error detector
==14322== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14322== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==14322== Command: ./a.out
==14322==
I am -16777768 years old.
==14322== Conditional jump or move depends on uninitialised value(s) //未初始化的值
==14322==    at 0x4E9896A: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
==14322==    by 0x10867F: main (09_valgrind.c:8)
==14322==
==14322== Use of uninitialised value of size 8
==14322==    at 0x4E948FB: _itoa_word (_itoa.c:179)
==14322==    by 0x4E97F9D: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
==14322==    by 0x10867F: main (09_valgrind.c:8)
==14322==
==14322== Conditional jump or move depends on uninitialised value(s) //未初始化的值
==14322==    at 0x4E94905: _itoa_word (_itoa.c:179)
==14322==    by 0x4E97F9D: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
...
I am 0 inches tall.
==14322==
==14322== HEAP SUMMARY:
==14322==     in use at exit: 0 bytes in 0 blocks
==14322==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==14322==
==14322== All heap blocks were freed -- no leaks are possible
==14322==
==14322== For counts of detected and suppressed errors, rerun with: -v
==14322== Use --track-origins=yes to see where uninitialised values come from
==14322== ERROR SUMMARY: 5 errors from 5 contexts (suppressed: 0 from 0)

解释：
- 左边显示类似行号的数字（14322）表示的是 Process ID
- 最上面是 valgrind 的版本信息
- 中间是 valgrind 通过运行被测试程序，发现的内存问题。通过阅读这些信息，可以发现：
	发生错误时的函数堆栈，以及具体的源代码行号。
	非法写操作的具体地址空间。
- 最下面是对发现的内存问题和内存泄露问题的总结。
	内存泄露的大小 0 bytes，本程序没有内存泄漏。in use at exit: 0 bytes in 0 blocks



(3) 测试3 反例：内存不释放
需要分配内存的，但是不释放的例子。

$ cat 12.c
#include<stdio.h>
#include<stdlib.h>
int main(){
	int i, arr[]={1,27,34};
	int *p=malloc( sizeof(int) * 3);
	for(i=0; i<3; i++){
		p[i]=arr[i];
		printf("%d->%d\n", i, *(p+i));
	}
	return 0;
}

$ gcc 12.c
$ ./a.out
0->1
1->27
2->34

$ ./a.out 
0->1
1->27
2->34



$ valgrind ./a.out
版本信息略。
0->1
1->27
2->34
==32065== 
==32065== HEAP SUMMARY:
==32065==     in use at exit: 12 bytes in 1 blocks
==32065==   total heap usage: 2 allocs, 1 frees, 1,036 bytes allocated
==32065== 
==32065== LEAK SUMMARY:
==32065==    definitely lost: 12 bytes in 1 blocks //泄漏了12字节( int * 3)
==32065==    indirectly lost: 0 bytes in 0 blocks
==32065==      possibly lost: 0 bytes in 0 blocks
==32065==    still reachable: 0 bytes in 0 blocks
==32065==         suppressed: 0 bytes in 0 blocks
==32065== Rerun with --leak-check=full to see details of leaked memory
==32065== 
==32065== For counts of detected and suppressed errors, rerun with: -v
==32065== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


按照最后几行的提示，再试
$ valgrind --tool=memcheck --leak-check=full ./a.out
版本信息略。
0->1
1->27
2->34
==32584== 
==32584== HEAP SUMMARY:
==32584==     in use at exit: 12 bytes in 1 blocks
==32584==   total heap usage: 2 allocs, 1 frees, 1,036 bytes allocated
==32584== 
==32584== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1
==32584==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==32584==    by 0x10872F: main (in /data/wangjl/test/linux_C/a.out)
==32584== 
==32584== LEAK SUMMARY:
==32584==    definitely lost: 12 bytes in 1 blocks
==32584==    indirectly lost: 0 bytes in 0 blocks
==32584==      possibly lost: 0 bytes in 0 blocks
==32584==    still reachable: 0 bytes in 0 blocks
==32584==         suppressed: 0 bytes in 0 blocks
==32584== 
==32584== For counts of detected and suppressed errors, rerun with: -v
==32584== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)




(4) 测试4：内存越界
#include<stdio.h>
#include<stdlib.h>
int main(){
	int i;
	int len = 4;
	int *pt = (int*)malloc(len*sizeof(int)); //返回的是空指针，可以主动转换为某个类型
	int *p = pt;

	for(i=0;i<len;i++){
		*p=i;
		p++;
	}

	*p = 5;
	return 0;
}

$ gcc -g 13.c

$ valgrind --tool=memcheck --leak-check=full ./a.out
...
==4109== 
==4109== Invalid write of size 4  //非法写入4个字节
==4109==    at 0x10869D: main (13.c:15) //位置是第15行 *p = 5;
==4109==  Address 0x522d050 is 0 bytes after a block of size 16 alloc'd
==4109==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==4109==    by 0x108669: main (13.c:7)
==4109== 
==4109== 
==4109== HEAP SUMMARY:
==4109==     in use at exit: 16 bytes in 1 blocks //程序退出后还有16字节没有释放
==4109==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==4109== 
==4109== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1
==4109==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==4109==    by 0x108669: main (13.c:7)
==4109== 
==4109== LEAK SUMMARY:
==4109==    definitely lost: 16 bytes in 1 blocks
==4109==    indirectly lost: 0 bytes in 0 blocks
==4109==      possibly lost: 0 bytes in 0 blocks
==4109==    still reachable: 0 bytes in 0 blocks
==4109==         suppressed: 0 bytes in 0 blocks
==4109== 
==4109== For counts of detected and suppressed errors, rerun with: -v
==4109== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)




ref:
https://blog.csdn.net/andylauren/article/details/93189740
https://zhuanlan.zhihu.com/p/56538645







========================================
|-- malloc 函数详解 (与free函数连用)
----------------------------------------

1. 简介
#include<stdlib.h>
C 库函数 void *malloc(size_t size) 【在堆上】分配所需的内存空间，并返回一个指向它的指针。

参数
size -- 内存块的大小，以字节为单位。

返回值
该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。



(2) 关于malloc以及相关的几个函数
#include <stdlib.h>(Linux下)

void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);


如果分配成功：则返回指向被分配内存空间的指针
不然，返回空指针NULL。
同时，当内存不再使用的时候，应使用free（）函数将内存块释放掉。
关于：void *,表示未确定类型的指针。C，C++规定，void *类型可以强转为任何其他类型的的指针。

关于void *的其他说法：其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。
void * p1;
int *p2;
p1 = p2;


(3) malloc：
malloc分配的内存大小至少为size参数所指定的字节数
malloc的返回值是一个指针，指向一段可用内存的起始地址
多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉
malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）
实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）

malloc和free函数是配对的，如果申请后不释放就是内存泄露;如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以，释放多少次都是可以的）


简单的说：
malloc 函数其实就是在内存中：找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看malloc函数中参数size的具体内容。

我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的 是逻辑上的连续，其它的，操作系统会帮着我们处理的。







2. 实例 
$ cat 10_malloc.c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int main(){
	char *str;
	//最初的内存分配
	str= (char *) malloc(6);
	strcpy(str, "hello");
	printf("string=%s, address=%p\n", str, str);
	
	// 重新分配内存，更大空间
	str=(char *) realloc(str, 25);
	strcat(str, " world!");
	printf("string=%s, address=%p\n", str, str);
	
	//释放内存
	free(str);
	
	return 0;
}

$ gcc -g 10_malloc.c
$ ./a.out 
string=hello, address=0x55782a276260
string=hello world!, address=0x55782a276690



(2) 使用 gdb 跟踪查看内存位置
$ gdb a.out
(gdb) start

(gdb) n
8               strcpy(str, "hello");
(gdb) n
9               printf("string=%s, address=%p\n", str, str);

指针str本身在 栈 上，但是指向的位置编号较小，应该是在堆上。
(gdb) p str
$1 = 0x555555756260 "hello"
(gdb) p &str
$2 = (char **) 0x7fffffffdd78


重新分配内存后：
(gdb) n
string=hello, address=0x555555756260
12              str=(char *) realloc(str, 25);
(gdb) n
13              strcat(str, " world!");

指针本身存储的位置不变，但是指向的地址变了。
(gdb) p str
$1 = 0x555555756690 "hello"
(gdb) p &str
$2 = (char **) 0x7fffffffdd78


(gdb) n
string=hello world!, address=0x555555756690
17              free(str);
(gdb) x/15c 0x555555756690
0x555555756690: 104 'h' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '  119 'w' 111 'o'
0x555555756698: 114 'r' 108 'l' 100 'd' 33 '!'  0 '\000'        0 '\000'        0 '\000'



free执行后，内存中的值被清空了
(gdb) n
19              return 0;
(gdb) x/15c 0x555555756690
0x555555756690: 0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'
0x555555756698: 114 'r' 108 'l' 100 'd' 33 '!'  0 '\000'        0 '\000'        0 '\000'











ref:
https://www.cnblogs.com/Commence/p/5785912.html
https://www.runoob.com/cprogramming/c-function-malloc.html

















========================================
《POSIX 线程编程》：C 与多线程 //todo
----------------------------------------

1. 实例引入

$ cat multi_thread.c
#include <stdio.h>   
#include <pthread.h>  
#include <time.h>
//#include <windows.h>//使用Sleep的头
#include <unistd.h>

int g_number = 0;

#define MAX_COUNT 10000

//pthread_mutex_t mut;

void *counter3(void* args) {
	int i = 1;
	while (i <= MAX_COUNT / 4) {
		//pthread_mutex_lock(&mut);
		g_number++;
		//pthread_mutex_unlock(&mut);
		printf("hi,i am pthread 3, my g_number is [%d]\n", g_number);
		//Sleep(1);// 单位ms
		//sleep(1);// 单位s
		i++;
	}
}

void *counter4(void* args) {
	int j = 1;
	while (j <= MAX_COUNT / 4) {
		//pthread_mutex_lock(&mut);
		g_number++;
		//pthread_mutex_unlock(&mut);
		printf("hi,i am pthread 4, my g_number is [%d]\n", g_number);
		//sleep(1);
		j++;
	}
}

int main() {
	printf("没加互斥锁：非线程安全的\n");
	//pthread_mutex_init(&mut, NULL);
	pthread_t t3;
	pthread_t t4;
	pthread_create(&t3, NULL, counter3, NULL);
	pthread_create(&t4, NULL, counter4, NULL);

	getchar(); //这句不加就不显示任何数字，直接结束了。
	return 0;
}

在linux上执行gcc thread.c,  结果出现编译错误undefined reference to 'pthread_create'。由于pthread库不是标准linux库， 所以出错。 改为gcc thread.c -lpthread 即可。

$ gcc multi_thread.c -lpthread
$ ./a.out 
没加互斥锁：非线程安全的
hi,i am pthread 3, my g_number is [1]
hi,i am pthread 4, my g_number is [2]
... 很快就出现不同步的情况了
hi,i am pthread 4, my g_number is [13]
hi,i am pthread 3, my g_number is [13]
hi,i am pthread 3, my g_number is [14]
hi,i am pthread 4, my g_number is [14]
... 可能需要重复多次才能看到
hi,i am pthread 3, my g_number is [34]
hi,i am pthread 4, my g_number is [35]
hi,i am pthread 3, my g_number is [35]
或者输出到文件。

去掉sleep函数，输出到文件，检查是否有重复数字
$ awk -F'[' '{print $2}' 0.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | head
      2 1029
      2 1066
      2 1074
      2 1173
      2 1236
      2 1250
      2 1282
$ awk -F'[' '{print $2}' 0.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | awk '$1>1'|wc
    116     232    1481




(2) 尝试加互斥锁
把原文的互斥锁的注释打开。

互斥对象是这样工作的。如果线程 a 试图锁定一个互斥对象，而此时线程 b 已锁定了同一个互斥对象时，线程 a就将进入睡眠状态。一旦线程 b 释放了互斥对象（通过 pthread_mutex_unlock() 调用），线程 a就能够锁定这个互斥对象（换句话说，线程 a 就将从 pthread_mutex_lock()函数调用中返回，同时互斥对象被锁定）。同样地，当线程 a 正锁定互斥对象时，如果线程 c 试图锁定互斥对象的话，线程 c也将临时进入睡眠状态。对已锁定的互斥对象上调用 pthread_mutex_lock()的所有线程都将进入睡眠状态，这些睡眠的线程将“排队”访问这个互斥对象。

通常使用 pthread_mutex_lock() 和 pthread_mutex_unlock()来保护数据结构。这就是说，通过线程的锁定和解锁，对于某一数据结构，确保某一时刻只能有一个线程能够访问它。可以推测到，当线程试图锁定一个未加锁的互斥对象时，POSIX线程库将同意锁定，而不会使线程进入睡眠状态。

注意：全局变量的操作都要放到互斥锁中，否则可能出现累加互斥了，但是打印没有互斥的情况，输出还是有重复数字。

$ cat multi_thread2.c
#include <stdio.h>   
#include <pthread.h>  
#include <time.h>
//#include <windows.h>//使用Sleep的头
#include <unistd.h>

int g_number = 0;

#define MAX_COUNT 10000

pthread_mutex_t mut;

void *counter3(void* args) {
	int i = 1;
	while (i <= MAX_COUNT / 4) {
		pthread_mutex_lock(&mut);
		g_number++;
		printf("hi,i am pthread 3, my g_number is [%d]\n", g_number);
		pthread_mutex_unlock(&mut);
		//Sleep(1);// 单位ms
		//sleep(1);// 单位s
		i++;
	}
}

void *counter4(void* args) {
	int j = 1;
	while (j <= MAX_COUNT / 4) {
		pthread_mutex_lock(&mut);
		g_number++;
		printf("hi,i am pthread 4, my g_number is [%d]\n", g_number);
		pthread_mutex_unlock(&mut);
		//sleep(1);
		j++;
	}
}

int main() {
	printf("加互斥锁：线程安全的\n");
	pthread_mutex_init(&mut, NULL);
	pthread_t t3;
	pthread_t t4;
	pthread_create(&t3, NULL, counter3, NULL);
	pthread_create(&t4, NULL, counter4, NULL);

	getchar();
	return 0;
}

$ gcc multi_thread2.c -lpthread
$ ./a.out 
hi,i am pthread 4, my g_number is [2]
hi,i am pthread 3, my g_number is [1]
hi,i am pthread 4, my g_number is [3]
hi,i am pthread 3, my g_number is [4]
hi,i am pthread 4, my g_number is [5]
hi,i am pthread 3, my g_number is [6]
hi,i am pthread 4, my g_number is [7]
hi,i am pthread 3, my g_number is [8]
...
hi,i am pthread 3, my g_number is [27]
hi,i am pthread 4, my g_number is [28]
hi,i am pthread 3, my g_number is [29]
hi,i am pthread 4, my g_number is [30]
顺序可能会变(比如2,1)，但是值没有重复的。


去掉sleep函数，输出到文件，检查是否有重复数字
$ awk -F'[' '{print $2}' 1.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | head
     1 
      1 1
      1 10
      1 100
      1 1000
      1 1001

$ awk -F'[' '{print $2}' 1.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | awk '$1>1'|wc
 0       0       0

小结：之前把g++放到锁内，把printf放到锁外，还是有重复的。要把全局对象的操作都放到锁内，才能保证输出没有重复。






2. pthread_create() 函数

pthread_create是（Unix、Linux、Mac OS X）等操作系统的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
pthread_create的返回值表示成功，返回0；表示出错，返回表示-1。

函数原型声明：
#include <pthread.h>
int pthread_create(
	pthread_t *restrict tidp,   //新创建的线程ID指向的内存单元。
	const pthread_attr_t *restrict attr,  //线程属性，默认为NULL
	void *(*start_rtn)(void *), //新创建的线程从start_rtn函数的地址开始运行
	void *restrict arg //默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。
);


(1) 传递参数注意的问题
问题：
避免直接在传递的参数中传递发生改变的量，否则会导致结果不可测。
即使是只再创造一个单线程，也可能在线程未获取传递参数时，线程获取的变量值已经被主线程进行了修改。

通常解决方案：
重新申请一块内存，存入需要传递的参数，再将这个地址作为arg传入。


(2) 使用时注意防止内存泄漏
在默认情况下通过pthread_create函数创建的线程是非分离属性的，由pthread_create函数的第二个参数决定，在非分离的情况下，当一个线程结束的时候，它所占用的系统资源并没有完全真正的释放，也没有真正终止。

只有在pthread_join函数返回时，该线程才会释放自己的资源。
或者是设置在分离属性的情况下，一个线程结束会立即释放它所占用的资源。

如果要保证创建线程之后，确保无内存泄漏，必须采用如下方法来规范pthread_create的使用:


1)设置线程是detached（分离属性的）
void run() { 
    return;
} 

int main(){ 
    pthread_t thread; 
    pthread_attr_t attr; 
    pthread_attr_init( &attr ); 
    pthread_attr_setdetachstate(&attr,1); 
    pthread_create(&thread, &attr, run, 0); //第二个参数决定了分离属性

    //...... 
    return 0; 
}
也有人不赞成这样做，原因：


2) 配套使用pthread_join()函数
pthread_join()函数会一直阻塞调用线程，直到指定的线程终止。当pthread_join()返回之后，应用程序可回收与已终止线程关联的任何数据存储空间。
但是，同时需要注意，一定要和上面创建的某一线程配套使用，这样还可以起到互斥的作用。否则多线程可能抢占CPU资源，导致运行结果不确定。

牛客一道题目： 下面程序输出结果是什么？（不能确定）

#include<stdio.h>
#include<string.h>
#include <pthread.h>

void* print1(void* data){
    printf("1 ");
}

void* print2(void* data){
    printf("2 ");
}

void* print3(void* data){
    printf("3 ");
}

int main(void){
    pthread_t t,t1,t2;

    pthread_create(&t,0,print1,NULL);
    pthread_create(&t1,0,print2,NULL);
    pthread_create(&t2,0,print3,NULL);

    pthread_join(t,NULL);
    pthread_join(t1,NULL);
    pthread_join(t2,NULL);
    printf("\n");
	return 0;
}

$ gcc 03.c -lpthread

执行10次，顺序都不一样。
$ seq 1 10|while read id; do ./a.out; done;
1 2 3 
2 1 3 
1 3 2 
1 2 3 
1 2 3 
1 2 3 
1 3 2 
1 2 3 
1 3 2 
2 1 3

对于大多数多线程，可能并不要求返回顺序，因为每个任务都有些差异。
但是如果要求返回顺序，则需要设置阻塞。

int main(void){
    pthread_t t,t1,t2;

    pthread_create(&t,0,print1,NULL);
    pthread_join(t,NULL);
    
	pthread_create(&t1,0,print2,NULL);
    pthread_join(t1,NULL);
	
    pthread_create(&t2,0,print3,NULL);
    pthread_join(t2,NULL);

    printf("\n");
	return 0;
}
执行顺序保证了，因为pthread_join阻塞着，等结束才能继续。
$ seq 1 10|while read id; do ./a.out; done;
1 2 3 
1 2 3 



函数原型：
int pthread_join(
	pthread_t tid, //需要等待的线程,指定的线程必须位于当前的进程中，而且不得是分离线程
	void **status  //线程tid所执行的函数返回值（返回值地址需要保证有效），其中status可以为NULL
);
pthread非linux系统的默认库， 需手动链接-线程库 -lpthread

返回值：
调用成功返回0.
ESRCH 描述: 没有找到与给定的线程ID 相对应的线程。（如果多个线程等待同一个线程终止，则所有等待线程将一直等到目标线程终止。然后一个等待线程成功返回。其余的等待线程将失败返回ESRCH错误）
EDEADLK 描述: 将出现死锁，如一个线程等待其本身，或者线程A和线程B 互相等待。
EINVAL 描述: 与给定的线程ID相对应的线程是分离线程。




ref:
https://blog.csdn.net/gisxs/article/details/17115981






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
