c语言入门

什么是预处理、什么是表达式、什么是语句、什么是函数、什么是操作符、什么是数据类型。


编译环境：
$ gcc --version
gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


在线编译环境
https://www.tutorialspoint.com/compile_c_online.php







========================================
简介与资料
----------------------------------------
1. C语言能干啥？
小工具：比如 linux 下的ls和cd等
高性能工具：nginx(C) 是 apache(C++) 10倍以上性能。



2. 资料
(1). 视频资料
浙大翁凯老师 https://www.icourse163.org/course/ZJU-199001
https://www.bilibili.com/video/BV19W411B7w1?p=115



《C语言学习攻略》：http://www.imooc.com/course/programdetail/pid/37
#1.入门
C语言入门 https://www.imooc.com/learn/249
	主要知识点：初始C程序、数据类型、运算符、语句结构、函数和数组。
#2.中级
《Linux C语言编程基本原理与实践》： http://www.imooc.com/view/248 
#3.核心是指针与内存、结构体
《Linux C语言指针与内存》： http://www.imooc.com/view/394
《Linux C语言结构体》： http://www.imooc.com/view/409







(2). 文字资料 (教程、博客等)
1) 英文资料
https://www.geeksforgeeks.org/c-programming-language/?ref=ghm
the_c_programming_language_2.pdf


2) 中文资料
c语言入门这一篇就够了-学习笔记(一万字) https://blog.csdn.net/qq_23079443/article/details/81108901 没有指针

C 语言教程 https://www.runoob.com/cprogramming/c-tutorial.html
C快速入门教程 https://www.jianshu.com/p/92e8279de2fc
C语言网教程 https://www.dotcpp.com/course/517

谭浩强 的C语言书 也挺好。

笨办法学C，整体结构还是挺好的
	https://github.com/wizardforcel/lcthw-zh  资源地址
	https://wizardforcel.gitbooks.io/lcthw/content/preface.html
	https://wizardforcel.gitbooks.io/lcthw/content/ex17.html 目前进度



C语言经典100例题: https://www.runoob.com/cprogramming/c-100-examples.html


C语言算法博客： https://blog.csdn.net/lalor

http://c.biancheng.net/c/  (有些付费)学习C语言，除了要学习语法，还要学习内存、字符编码、调试技巧以及编程思维。





3. 计算机知识结构
https://www.zhihu.com/question/454220559/answer/1885130153





4. 环境搭建
虚拟机装ubuntu。

emacs
vim









========================================
第1章 导言
----------------------------------------
学习顺序：
C语言入门 -> Linux C语言编程基本原理与实践 -> Linux C语言指针与内存 -> Linux C语言结构体

C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。



1. 典型的C程序结构

#include<stdio.h> 
int main()
{
    /*在双引号中间输入Hello World*/ 
    printf("Hello World");
    return 0; 
}

注：在最新的C标准中，main函数前的类型为int而不是void

c语言的具体结构
简单来说，一个C程序就是由若干头文件和函数组成。
 - #include <stdio.h>就是一条预处理命令, 它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。
 - 函数就是实现代码逻辑的一个小的单元。
 - 每一句必须有分号结尾，一行可以写多句；


注释：
	多行注释：  /* 多行注释内容 */ 
	单行注释：  //注释一行

标识符
C语言规定，标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线。在使用标识符时还有注意以下几点：
	(1)标识符的长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符。 
	(2)标识符是严格区分大小写的。例如Imooc和imooc 是两个不同的标识符。 
	(3)标识符最好选择有意义的英文单词组成做到"见名知意"，不要使用中文。
	(4)标识符不能是C语言的关键字。想了解更多C语言关键字的知识，请查阅WIKI。





2. 书写格式

(1) Java 风格的
while (x == y){
	something();
}

倾向于这种。

(2) K&R (UNIX Kernel) Style
int main()
{
	something();
}

我感觉这种太浪费空行了！信息密度太低。
除非老板按行付工资。












========================================
|-- printf 打印彩色文字和背景
----------------------------------------
1. 好用的函数

void demo1(){
    //printf("\033[nmyour text\033[0m\n");
    // font color
    printf("\033[31m red text\033[0m\n");
    printf("\033[32m green text\033[0m\n");
    printf("\033[33m yellow text\033[0m\n");
    printf("\033[34m blue text\033[0m\n");
    printf("\033[35m purple text\033[0m\n");
    printf("\033[36m dark green text\033[0m\n");
    printf("\033[37m white text\033[0m\n");
    // background
    printf("\033[41;37m red_bg, white_color text\033[0m\n");
    printf("\033[42;33m green_bg, yellow_color text\033[0m\n");
    // in one line
    printf("\033[45;33m%s\033[0m\033[47;30m%s\033[0m\n", "What day is it today?", "Today is Monday.");
}



(1) 写成C函数
void print_red(char arr[]){
    printf("\033[31m%s\033[0m", arr);
}

void print_yellow(char arr[]){
    printf("\033[33m%s\033[0m", arr);
}


(2) in C++
cout << "\033[33m" << str << "\033[0m" << endl;


(3) 支持 shell 命令
$ echo -e "\033[31msome text\033[0m"
红色字体

(4) pyhton 打印 
>>> print("\033[1;31;40m您输入的帐号或密码错误！\033[0m")   #标准写法   
上方代码的输出格式为：字体高亮，红色前景，黄色背景      PS：前景色也就是字体的颜色

>>> print("\033[0;31m%s\033[0m" % "输出红色字符")　　  标准写法






2. 更多样式

printf("\033[nmyour text\033[0m\n");
printf("\033[31m red text\033[0m\n");

printf("\033[42;33m green_bg, yellow_color text\033[0m\n");

30:黑
红色	绿色	黄色	蓝色	紫色	深绿色	白色
31m	    32m	   33m	   34m	   35m	  36m	 37m
38 打开下划线,设置默认前景色 
39 关闭下划线,设置默认前景色 

# 字背景颜色范围:40--49
40 黑色背景 
41 红色背景 
42 绿色背景 
43 棕色背景 
44 蓝色背景 
45 品红背景 
46 孔雀蓝背景 
47 白色背景 
48 不知道什么东西
49 设置默认背景色


(1) 显示方式
0（默认值）、1（高亮，即加粗）、4（下划线）、7（反显）

前景色: 30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（梅色）、36（青色）、37（白色） 
背景色: 40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（梅色）、46（青色）、47（白色）

(2) 可以组合使用
33[0m      默认字体正常显示，不高亮
33[32;0m      红色字体正常显示  
33[1;32;40m  显示方式: 高亮    字体前景色：绿色  背景色：黑色
33[0;31;46m  显示方式: 正常    字体前景色：红色  背景色：青色 








ref: https://blog.csdn.net/u013554213/article/details/102831883














========================================
第2章 类型、运算符与表达式
----------------------------------------


1. 变量的定义
变量定义的一般形式为：数据类型 变量名;
多个类型相同的变量：数据类型 变量名, 变量名, 变量名...;

#include<stdio.h> 
int main()
{
	int age=10;
    printf("I am %d years old! \n", age);
    return 0; 
}

# I am 10 years old! 
变量名和标识符的命名规范完全相同。%d在后面会有详细讲解

注意:在定义中不允许连续赋值，如int a=b=c=5;是不合法的。

变量的赋值分为两种方式：
	- 先声明再赋值  int num; num=100;
	- 声明的同时赋值 int num=10;



2. 基本数据类型
C语言中，数据类型可分为4大类：
	基本数据类型
		|-整型 int
			|--短整形 short int (int可省略)
			|--长整形 long int (int可省略)
			|--无符号整形 unsigned short int (int可省略)
			|--无符号长整形 unsigned long int (int可省略)
		|-字符型 char
		|-实型(浮点型)
			|--单精度型 float
			|--双精度型 double
			|--长双精度型 long double
	构造数据类型
		|-枚举类型
		|-数组类型
		|-结构体类型
		|-共用体烈性
	指针类型
	空类型

注：int、short int、long int是根据编译环境的不同，所取范围不同。而其中short int和long int至少是表中所写范围，但是int在表中是以16位编译环境写的取值范围。
另外 c语言int的取值范围在于他占用的字节数 ，不同的编译器，规定是不一样。
ANSI标准定义int是占2个字节，TC是按ANSI标准的，它的int是占2个字节的。但是在VC里，一个int是占4个字节的。

注：C语言中不存在字符串变量，字符串只能存在字符数组中，这个后面会讲。



3.格式化输出语句
printf("输出格式符"，输出项);
%d 带符号十进制整数
%c 单个字符
%s 字符串
%f 6位小数

例如:
int a=10;
printf("a=%d", a); 
输出:
a=10 


如果要输出多个变量的并指定变量的位置时候，格式符还可以连用，变量之间需要用逗号隔开
#include <stdio.h>
int main(){
    int age = 18;
	float height = 1.85;
	char unit = 'm';
	printf("小明今年%d岁\n", age);
	printf("小明身高%f%c\n", height, unit);
	printf("小明现在慕课网上学习IT技术"); 
	return 0;
}
输出:
小明今年18岁
小明身高1.850000m
小明现在慕课网上学习IT技术





4.常量
值不发生改变的量称为常量。C语言的常量可以分为直接常量和符号常量。

直接常量:
printf("%d\n",100); //整型常量
printf("%f\n",3.1415); //实型常量
printf("%c\n",'A'); //字符常量
printf("I love C"); //字符串常量

在C语言中，可以用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，其一般形式为：
#define 标识符 常量值 

#include <stdio.h>
# define PI 3.1415926535897932
int main()
{
	printf("圆周率: %f\n", PI);
	return 0;
}
输出:
圆周率: 3.141593
# 换成 %d， 输出就很怪异: 圆周率: 487130584

注意：常量是不可改变的






5.类型转换

#自动类型转换
char -> int -> double 
自动转换发生在不同数据类型运算时，在编译的时候自动完成。自动转换遵循的规则就好比小盒子可以放进大盒子里面一样。
#include<stdio.h>
int main()
{
	char c='a';
	int x=c;
	printf("x=%d\n",x);
	return 0;
}
# x=97

注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换



#强制类型转换
强制类型转换是通过定义类型转换运算来实现的。其一般形式为： (数据类型) (表达式) 
#include <stdio.h>
int main()
{
    double num = 2.5; //定义浮点型变量num并赋值为2.5
    int num2=(int)num;
    printf("num的整数部分是%d\n", num2);  
	// 或者只用一句 printf("num的整数部分是%d\n", (int)num); 
    return 0;
}
#num的整数部分是2


在使用强制转换时应注意以下问题：
1、数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。
2、转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。
3、强制转换后的运算结果不遵循四舍五入原则。





6.运算符 
#include <stdio.h>
int main()
{
    int a,b,c,d;
    double result;
    a = 1;
    b = 2;
    c = 3;
    d = 4;
    result = a + b - c * d;    //在这里体验哦~
    printf("%f\n", result);
    return 0;
}


6.1 算术运算符
除了 +-*/外， 求余（模运算）%， 自增++， 自减--
注：C语言中没有乘方这个运算符

#include <stdio.h>
int main()
{
    int x,y;
    x = 10;
    y = -3;
    printf("x+y=%d\n", x+y); 
    printf("x-y=%d\n", x-y);
    printf("x*y=%d\n", x*y);
    printf("x/y=%d\n", x/y);
    printf("x%%y=%d\n",x%y);  
    return 0;    
}
输出：
x+y=7
x-y=13
x*y=-30
x/y=-3
x%y=1

模运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。

//自增运算
#include <stdio.h>
int main()
{
    int x = 0;
    printf("0x=%d\n", x); //0
    printf("1x=%d\n",++x); //先自增，在显示值 1
    printf("2x=%d\n", x); //1
    printf("3x=%d\n",x++); //1先给值，再自增
    printf("4x=%d\n", x); //2
    
    return 0;
}
输出:
0x=0
1x=1
2x=1
3x=1
4x=2


6.2 ※ 赋值运算符
基本的 =
复合的 +=、-=、*=、/=、%=

int a = 3;
a += 5;
分析：定义整型变量a并赋值为3，a += 5;这个算式就等价于a = a+5; 将变量a和5相加之后再赋值给a

#include <stdio.h>
int main()
{
    int x = 10;
    int y = 10;
    //使用简单赋值语句实现x乘以2。
    x=x*2;
    //使用复合赋值语句实现y乘以2。
    y*=2;
    printf("x=%d\n", x);
    printf("y=%d\n", y);
    return 0;
}

注意：复合运算符中运算符和等号之间是不存在空格的。


6.3 ※ 关系运算符
关系表达式的值是“真”和“假”，在C程序用整数1和0表示。

#include <stdio.h>
int main()
{
    int x=5;
    int y=5;
    int z=10;
    printf("x=%d;y=%d;z=%d; \n",x,y,z);
    printf("x是否大于y:%d\n", x>y ); //x是否大于y
    printf("y是否大于等于x:%d\n", y>=x); //y是否大于等于x
    printf("y是否小于z:%d\n",   y<z ); //y是否小于z
    printf("z是否小于等于x:%d\n",  z<=x ); //z是否小于等于x
    printf("z是否等于x+y:%d\n", z==(x+y)); //z是否等于x+y
    return 0;
}
输出:
x=5;y=5;z=10; 
x是否大于y:0
y是否大于等于x:1
y是否小于z:1
z是否小于等于x:0
z是否等于x+y:1

注意：>=，<=，==，!=这种符号之间不能存在空格。




6.4 ※ 逻辑运算符
&& 与
|| 或
! 非



6.5 ※ 三目运算符 / 也叫三元运算符
表达式1 ? 表达式2 : 表达式3; 

#include <stdio.h>
int main()
{
    //定义小编兜里的钱
    double money = 12; 
    //定义打车回家的费用
    double cost =  11.5;  
    printf("小编能不能打车回家呢："); 
    //输出y小编就打车回家了，输出n小编就不能打车回家
    printf("%c", money>=cost?'y':'n' );
    return 0;
}



6.6 逗号表达式
从左到右依次计算，赋值的话取最右侧那个值。

经典案例：逗号表达式的值
#include<stdio.h>
int main(){
        //int a=b=c=5; // 是不合法的！
        int a,b,c;
        a=b=c=1;
        c=(a=10, b=2*a+5, a+a*b+c);
        printf("a=%d, b=%d, c=%d\n", a,b,c);
        return 0;
}
输出： 
a=10, b=25, c=261





6.x 优先级
优先级别为1的优先级最高，优先级别为10的优先级别最低。
记住最高优先级别的，在开发中就会无敌啦~()

口诀：括号最大 > 逻辑非! > 算数运算符 > 关系运算符 > 逻辑与&& > 逻辑或|| > 赋值运算符
同一优先级的运算符，运算次序由结合方向所决定。
详细查阅： https://blog.csdn.net/coder_pig/article/details/37650817








========================================
第3章 控制流 - break和continue语句
----------------------------------------
1.if分支
#include <stdio.h>
int main() 
{       
    int height = 185;
    if(height>=180){
        printf("OK");
    }
	return 0;
}


1.2 if-else分支
#include <stdio.h>
int main() 
{
    int year = 2019; //今年是2019年
    //能被4整除但不能被100整除，或者能被400整除的数。
    if( (year%4==0 && year%100!=0) || (year%400==0) ){
        printf("今年%d是闰年",year);
    }else{
        printf("今年%d是平年",year);
    }
    return 0;
}
输出:今年2019是平年


1.3 多重if-else语句
#include <stdio.h>
int main() 
{
    int score = 7200;
    //完善一下代码
    if(score>=10000){
        printf("钻石玩家");
    }
    else if(score>=5000 && score<10000){
        printf("白金玩家");    
    }
    else if(score>=1000 && score<5000){
        printf("青铜玩家");     
    }
    else{
        printf("普通玩家");    
    }
    return 0;
}
输出: 白金玩家



1.4 嵌套if-else语句
#include <stdio.h>
int main() 
{
    int sale=120; //销售业绩为120万
    int year=1; //刚刚进入公司1年
    
    if(sale>100){
        if(year>2){
            printf("优秀员工奖");
        }else{
            printf("sale达标，但不够2年");
        }
    }else{
        printf("sale不够");
    }
    return 0;
}
# sale达标，但不够2年






1.5 分支结构之switch语句
小明参加期末考试，分数等级分为A-D,等级划分方式如下：
90<=分数<=100 ,等级为A。
80<=分数<90 ,等级为B。
60<=分数<80 ,等级为C。
分数<60 ,等级为D。
小明期末考试分数为87分，在代码编辑器中完善代码使其输出结果为： 等级B 

#include <stdio.h>
int main() 
{
    int score = 87; //考试分数为87分 
    score /= 10;
    
    switch(score)
    {
        /*想想以下代码为什么用这种方式；
          这种方式的好处？*/
        case 10:
        case 9:
            printf("等级A");
            break;
        case 8:
            printf("等级B");
            break;  //这里必须加break语句          
        case 7:
        case 6: 
            printf("等级C");
            break; 
        default:
            printf("等级D");
            break;    
    }
    return 0;
}


switch语句时还应注意以下几点：
 - 在case后的各常量表达式的值不能相同，否则会出现错误。
 - 在case子句后如果没有break;会一直往后执行一直到遇到break;才会跳出switch语句。
 - switch后面的表达式语句只能是整型或者字符类型。
 - 在case后，允许有多个语句，可以不用{}括起来。
 - 各case和default子句的先后顺序可以变动，而不会影响程序执行结果。
 - default子句可以省略不用。




1.6 switch与if语句的应用
请使用switch语句和if...else语句，计算2008年8月8日这一天，是该年中的第几天。
程序分析：以5月1日为例，应该先把前4个月的天数加起来，然后再加上1天即本年的第几天。
特殊情况：在计算闰年的时候，2月是29天。

#include <stdio.h>
int main() 
{ 
    /* 定义需要计算的日期 */
    int year = 2008;
    int month = 8;
    int day = 8;
    /*
     * 请使用switch语句，if...else语句完成本题
     */
    int days=0;
    int i=0,sum=0;
    for(i=1; i<month;i++){
        switch(i){
            case 4:
            case 6:
            case 9:
            case 11:
                days=30;
                break;
            case 2:
                if( (year%100!=0 && year%4==0) ||(year%400==0) ){
                    days=29; //闰年
                }else{
                    days=28; //平年
                }
                break;
            default:
                days=31;
        }
        sum+=days;
        printf("%d月有%d天,月末是全年的第%d天；\n",i,days,sum);
    }
    sum+=day;
    printf("%d\n",sum);

	return 0;
}



1.7 臭名远扬之goto语句(能不用就别用，就当不存在该语句)
goto 语句标号;

输完3就跳出循环。
#include <stdio.h>
int main()
{
    int sum = 0;
    int i;
    for(i=1; i<=10; i++)
    {
        printf("%d\n", i);
        if(i==3)    //数完3就跳出循环体
          goto END;    //使用goto语句跳到标识符
    }
    END: printf("结束for循环了....");  //添加标识符
    return 0;    
}






2. while循环
#include <stdio.h>
int main()
{
    int i,sum=0;
    i=1;
    while( i<=100 ) //循环条件
    {
        sum=sum+i;
        i+=1;//改变循环变量
    }
    printf("100以内所有整数之和为：%d\n", sum);
    return 0;
}
# 100以内所有整数之和为：5050


2.2 do-while循环(至少会循环一次)
注意：使用do-while结构语句时，while括号后必须有分号。
#include <stdio.h>
int main()
{
    int number=200;
    int year=2014;
    do{
      year++;     
      number*=1.2; //每年20%扩招人数
    }while(number<1000); //do-while最后要有分号结尾
    printf("到%d年招工规模突破1000人\n", year);
    return 0;
}
# 到2023年招工规模突破1000人



2.3 for循环(一)
#include <stdio.h>
int main()
{
    // 定义变量sum, num
    int sum, num;  
    sum = 0;
    for(num = 0; num<=100; num++) //for循环条件与num的变化值
    {
        sum+=num; //计算每次数字之间的和sum
    }
    printf("100以内数的和为：%d", sum);
    return 0;
}
# 100以内数的和为：5050


2.4 for循环(二)
在for循环中，表达式1是一个或多个赋值语句，它用来控制变量的初始值；
表达式2是一个关系表达式，它决定什么时候退出循环；
表达式3是循环变量的步进值，定义控制循环变量每循环一次后按什么方式变化。
这三部分之间用分号(;)分开。
可以省略部分，但是分号不能省略。


输出所有水仙花数字。
所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数，如：153就是一个水仙花数，153=1*1*1+5*5*5+3*3*3。
#include <stdio.h>
int main(){
	int a1=0, a2=0, a3=0, sum=0;
	int i=100;
	for(i=100;i<=999;i++){
		a1=i/100; //百位
		a2=i/10%10; //十位
		a3=i%10; //个位
		sum=a1*a1*a1 + a2*a2*a2 + a3*a3*a3;
		if(sum==i){
			printf("%d \n",i);
		}
	}
	return 0;
}
输出:
153 
370 
371 
407



2.5 三种循环比较
while、do-while和for三种循环在具体的使用场合上是有区别的，如下：
1、在知道循环次数的情况下更适合使用for循环；
2、在不知道循环次数的情况下适合使用while或者do-while循环，如果有可能一次都不循环应考虑使用while循环，如果至少循环一次应考虑使用do-while循环。
但是从本质上讲，while,do-while和for循环之间是可以相互转换的。

例1： 计算1+2+3+...+100的值?
#include <stdio.h>
int main()
{
    /* 小伙伴们：选择你们认为最合理的循环结构完成功能吧 */
    int sum = 0;  //定义计算结果变量sum
    int i = 1;    //定义循环数字变量i
    
    //1.使用while循环
    while(i<=100)
    {
        sum+=i;
        i++;
    }
    printf("while: %d \n", sum);
    
    

    i = 1;  //重新初始化变量i
    sum=0;
    //2.do-while循环
    do{
        sum+=i;
        i++;
    }while(i<=100);
    printf("do-while: %d \n", sum);
    
    
    
    i = 1;  //重新初始化变量i
    sum=0;
    //3.使用for循环
    for(i=1;i<=100;i++)
    {
        sum+=i;
    }  
    printf("for: %d\n",sum); 
    
    return 0;    
}
输出: 
while: 5050 
do-while: 5050 
for: 5050




例2：使用循环计算1-2+3-4+5-6+…-100的值？就是偶数前是负号，奇数前是正号。
#include <stdio.h>
int main()
{
    /* 小伙伴们：
           选择你们认为最合理的循环结构完成功能吧 */
    int sum = 0;  //定义计算结果变量sum
    int i = 1;    //定义循环数字变量i
    int flag = 1; //定义符号状态变量flag
    
    //1.使用while循环
    while(i<=100)
    {
        flag=i%2==0?-1:1;
        sum+=i*flag;
        i++;
    }
    printf("while: %d \n", sum);
    
    

    i = 1;  //重新初始化变量i
    sum=0;
    //2.do-while循环
    do{
        flag=i%2==0?-1:1;
        sum+=i*flag;
        i++;
    }while(i<=100);
    printf("do-while: %d \n", sum);
    
    
    
    i = 1;  //重新初始化变量i
    sum=0;
    //3.使用for循环
    for(i=1;i<=100;i++)
    {
        flag=i%2==0?-1:1;
        sum+=i*flag;
    }  
    printf("for: %d\n",sum); 
    
    return 0;    
}
输出:
while: -50 
do-while: -50 
for: -50




2.6 多重循环
打印图形
    *
   ***
  *****
 *******
#include <stdio.h>
int main()
{
    int i, j, k;
    for(i=1; i<5; i++)
    {
        /* 观察每行的空格数量，补全循环条件 */
        for(j=i ;j<5 ;j++)  
        {
            printf(" ");    //输出空格
        }
        /* 观察每行*号的数量，补全循环条件 */
        for(k=0;k<2*i-1 ;k++) 
        {
            printf("*");   //每行输出的*号
        }
        printf("\n");     //每次循环换行
    }
    return 0;
}
 
使用for循环打印九九乘法表
#include <stdio.h>
int main() 
{ 
    // 定义相乘数字i,j以及结果result
    int i, j, result;
    /*使用for循环解决本题相对简单哦~ */
     for(i=9;i>0;i--){
         for(j=1;j<=i;j++){
             printf("%d*%d=%d\t",i,j,i*j);
         }
         printf("\n");
     }
    return 0;
}


2.7 循环结束语句 break
使用break语句时注意以下几点：
1、在没有循环结构的情况下，break不能用在单独的if-else语句中。
2、在多层循环中，一个break语句只跳出当前循环。

求100以内的质数(所谓素数就是只能被1和它本身整除的整数:2,3,5,7,13,...):
#include <stdio.h>
int main()
{
    int m, n;
    for(m=2; m<=100; m++)
    {
        for(n=2; n<m; n++)
        {
            if( m%n==0 )       //什么条件下跳出当前循环
               break;           //这里应该退出当前循环了
        }       
        if(m == n)   //n循环结束后，如果m=n的话就输出m
            printf("%d  ", m);
     }  
     printf("\n");
     return 0;    
}
# 2  3  5  7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71  73  79  83  89  97


2.8 循环结束语句 continue
continue语句的作用是结束本次循环开始执行下一次循环。
break语句与continue语句的区别是：break是跳出当前整个循环，continue结束本次循环开始下一次循环。 

计算1到20之间不能被3整除的数字之和。
运算结果为： sum=147 
#include <stdio.h>
int main()
{
    int i, sum;
    for(i=1, sum=0; i<=20; i++)
    {
        if(i%3==0)    //能被3整除这个条件如何写呢？
        {
            continue; //应该用哪个循环结束语句呢？
        }      
        sum += i;
    }
    printf("sum=%d\n", sum);
    return 0;    
}



2.9 练习
打印如下字母组成的图形：
A
BC
DEF
GHIJ
KLMNO
PQRSTU

#include<stdio.h>
int main()
{
        int i,j,c=0;
        for(i=1;i<=6;i++){
                for(j=1;j<=i;j++){
                        printf("%c",(char)(65+c) );
                        c++;
                }                       
                printf("\n");                   
        }
        return 0;
}





========================================
第4章 函数与程序结构 - c中函数都是并列的，可以嵌套调用，不允许嵌套定义(main函数内除外)
----------------------------------------
https://www.imooc.com/code/5434

1. 自定义函数与调用函数
函数的一般结构：
[数据类型说明] 函数名称([参数列表]){
	执行代码块;
	return(表达式);
}
注意：
1)、[]包含的内容可以省略，数据类型说明省略，默认是int类型函数；
参数省略表示该函数是无参函数，参数不省略表示该函数是有参函数；
2)、函数名称遵循标识符命名规范；
3)、自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;


函数调用的一般形式为： 函数名（[参数]）; 
注意：
1)、对无参函数调用的时候可以将[]包含的省略。
2)、[]中可以是常数，变量或其它构造类型数据及表达式，各参数之间用逗号分隔。

#include <stdio.h>
/* 自定义整型函数 sayLove() */
int sayLove()
{
    //在这里输入输出语句printf，输出内容为I Love imooc 
   printf("I Love imooc\n");
   return 0;
}
/* 主函数 */
int main()
{
    sayLove();
    return 0;
}




2.局部与全局
C语言中的变量，按作用域范围可分为两种，即局部变量和全局变量。
(1)局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。
(2)全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。

#include <stdio.h>
int x = 77;
void fn1()
{
    printf("fn1(): x=%d\n", x);       
}
int main()
{
    int x = 10;
    if(x>0)
    {
        int x = 100; //这里不写int则覆盖函数内定义的x=10
        x /= 2;
        printf("if语句内, x=%d\n", x);       
    }
    printf("main方法内, x=%d\n", x);
    fn1();
    return 0;
}
输出:
if语句内, x=50
main方法内, x=10
fn1(): x=77




3.变量存储类别
C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。
1)静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。
2)动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。

C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。

1)、用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式。
2)、用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。

注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；
静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。

3)、为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。
注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。

4)、用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。

#include <stdio.h>
void fn()
{
    static int x = 1;   //定义静态局部变量，只初始化一次
    x*=2;
    printf("fn x=%d\n",x);     
}

int main()
{
    int i;
    for(i=0;i<5;i++)
    {
        fn();
    }
    extern int x;      //调用外部变量
    printf("x=%d\n",x);
    return 0;
}
int x=100;

输出:
fn x=2
fn x=4
fn x=8
fn x=16
fn x=32
x=100






4.内部函数与外部函数
在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：
 static [数据类型] 函数名（[参数]） 
这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。

在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：
 extern [数据类型] 函数名([参数]) 
C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。


test.c 
#include <stdio.h>
static void say(){ //这里为什么必须加static?否则会报错printLine没有明确定义？
    printLine();
    printf("I love imooc\n");
    printf("good good study!\n");
    printf("day day up!\n");
    printLine();
}


hello.c 
#include <stdio.h>
#include "test.c"   //引用test.c文件
extern void printLine()     //extern 可加可不加
{
   printf("**************\n");   
}

int main()
{
    say();
    return 0;
}
输出:
**************
I love imooc
good good study!
day day up!
**************

如果把test.c中的函数去掉static，则该文件不需要被引用到hello.c中，也就是注释掉include "test.c" 也可以正常运行。

首先都要修改printLine()为extern，然后有两个方法:
方法1. #include "test.c"作用就是被引入到hello.c，引入进去相当与hello.c的一部分，所以将say()改为static,调用内部函数。
方法2. 删除#include "test.c"，直接调用say().因为say()默认是extern,外部函数是可以直接调用的。

我使用自己的gcc测试，发现还需要在test.c第二行添加一行。
extern void printLine(); //下文将要使用的函数，要在使用前声明。










========================================
|-- 参数 
----------------------------------------
1.有参函数和无参函数的唯一区别在于：函数（）中多了一个参数列表。

#include <stdio.h>
/* 考虑一下哪个输出该用无参函数哪个输出该用有参函数呢？ */
int say1(){
    printf("小明学习\n");
    return 0;
}

int say2(int n){
    printf("小明学习了%d门课程\n", n);
    return 0;
}

int main()
{
    say1();
    say2(3);
    return 0;
}





2 形参与实参
形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；
实参是在调用时传递该函数的参数。


函数的形参和实参具有以下特点：
- 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。
- 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。
在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。





3.函数返回值
1). 函数的值只能通过return语句返回主调函数。return语句的一般形式为：
  return 表达式   或者为：  return (表达式);
2). 函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。
3). 没有返回值的函数，返回类型为void。如果小刚算了一会没有返回结果的话，那么用代码表示就是：
注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;








========================================
|-- 递归函数
----------------------------------------
######################## 开始使用 sublime编辑和运行C代码。



一句话总结递归：自我调用且有完成状态。
https://www.imooc.com/code/5504

例1: 阶乘
#include<stdio.h>
int factorial(int n){
	if(n<0){
		printf("输入错误！\n");
		return 0;
	}else if(n==0 ||n==1){
		return 1;
	}else{
		return n*factorial(n-1);
	}
}

int main(){
	//
	int n=5;
	printf("%d的阶乘=%d\n", n, factorial(n));
	return 0;
}
输出:
5的阶乘=120



例2:猴子第一天摘下N个桃子，当时就吃了一半，还不过瘾，就又多吃了一个。第二天又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第10天在想吃的时候就剩一个桃子了,问第一天共摘下来多少个桃子？并反向打印每天所剩桃子数。

#include<stdio.h>
int getPeachNumber(int day){
	int sum=0;
	if(day==10){
		sum=1;
	}else{
		sum=(getPeachNumber(day+1)+1)*2; 
	}
	printf("第%d天吃之前桃子个数：%d\n", day, sum);
	return sum;
}

int main(){
	getPeachNumber(1);
	return 0;
}
输出:
第10天吃之前桃子个数：1
第9天吃之前桃子个数：4
第8天吃之前桃子个数：10
第7天吃之前桃子个数：22
第6天吃之前桃子个数：46
第5天吃之前桃子个数：94
第4天吃之前桃子个数：190
第3天吃之前桃子个数：382
第2天吃之前桃子个数：766
第1天吃之前桃子个数：1534


例3:有5个人坐在一起，问第5个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第3个人，又说比第2人大两岁。问第2个人，说比第1个人大两岁。最后 问第1个人，他说是10岁。请问第5个人多大？
#include<stdio.h>
int getAge(int num){
	int age=0;
	if(num==1){
		age=10;
	}else{
		age=getAge(num-1)+2; 
	}
	printf("第%d个人年龄是：%d\n", num, age);
	return age;
}

int main(){
	int age=getAge(5);
	printf("第5个人的年龄是%d岁", age); 
	return 0;
}
输出:
第1个人年龄是：10
第2个人年龄是：12
第3个人年龄是：14
第4个人年龄是：16
第5个人年龄是：18
第5个人的年龄是18岁

















========================================
第5章 指针与数组
----------------------------------------
1.是一块连续的，大小固定并且里面的数据类型一致的内存空间，它还有个好听的名字叫数组。可以将数组理解为大小固定，所放物品为同类的一个购物袋，在该购物袋中的物品是按一定顺序放置的。

我们来看一下如何声明一个数组： 数据类型 数组名称[长度]; 

数组只声明也不行啊，看一下数组是如何初始化的。说到初始化，C语言中的数组初始化是有三种形式的，分别是：
1)、 数据类型 数组名称[长度n] = {元素1,元素2…元素n};
2)、 数据类型 数组名称[] = {元素1,元素2…元素n};
3)、 数据类型 数组名称[长度n]; 数组名称[0] = 元素1; 数组名称[1] = 元素2; 数组名称[n-1] = 元素n;

我们将数据放到数组中之后又如何获取数组中的元素呢？
获取数组元素时： 数组名称[元素所对应下标]; 
如：初始化一个数组 int arr[3] = {1,2,3}; 那么arr[0]就是元素1。

注意：
1)、数组的下标均以0开始；
2)、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；
3)、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；
4)、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。

#include <stdio.h>
int main()
{
    //第一种形式
    int arrFirst[3] ={1,2,3};
    //第二种形式
    int arrSecond[] = {4,5,6};
    //第三种形式
    int arrThird[3];
    //给arrThird数组每个元素初始化
    arrThird[0]=10;
    arrThird[1]=11;
    arrThird[2]=12;
    //输出第一个数组中的第二个元素
    printf("%d\n", arrFirst[1]);
    //输出第二个数组中的第二个元素
    printf("%d\n", arrSecond[1]);
    //输出第三个数组中的第二个元素
    printf("%d\n", arrThird[1]);
    return 0;
}
输出:
2
5
11



2.数组的遍历
数组遍历时要注意以下几点：
1)、最好避免出现数组越界访问，循环变量最好不要超出数组的长度;
2)、C语言的数组长度一经声明，长度就是固定，无法改变，并且C语言并不提供计算数组长度的方法。
由于C语言是没有检查数组长度改变或者数组越界的这个机制，可能会在编辑器中编译并通过，但是结果就不能肯定了，因此还是不要越界或者改变数组的长度;
#include <stdio.h>
int main()
{
    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    //对数组arr遍历
    for(int i=0;i<10;i++){
        printf("%d\n",arr[i]);
    }
    return 0;
}
输出:
0
1
2
3
4
5
6
7
8
9



3.数组作为函数参数
https://www.imooc.com/code/5638

数组作为函数参数时注意以下事项：
1)、数组名作为函数实参传递时，函数定义处作为接收参数的数组类型形参既可以指定长度也可以不指定长度。
2)、数组元素作为函数实参传递时，数组元素类型必须与形参数据类型一致。


例1：数组是按照地址传递的，在函数中修改其值，原始数组也被修改了。
#include<stdio.h>
void fn(int arr[]){
	int i;
	for(i=0;i<5;i++){
		arr[i]=arr[i]*2;//函数中修改形式参数的值
		printf("arr[%d]=%d, ",i, arr[i]);
	}
}

int main(){
	int i;
	
	int myArr[5]={0,1,2,3,4};
	fn(myArr);
	printf("\n");

	//原数组也被修改了
	for(i=0;i<5;i++){
		printf("myArr[%d]=%d, ",i, myArr[i]);
	}
	return 0;
}


例2：找出指定数组中的最大值，并把其替换为另一个数组的第一个值。
#include <stdio.h>
void replaceMax(int arr[],int value)
{
    int max = arr[0];
    int index = 0;
    int i;
    for(i=1;i<5;i++)
    {
        if(arr[i]>max)
        {
            max=arr[i]; //将数组中较大的数赋值给max
            index = i;  //记录当前索引
        }                
    }  
    arr[index] = value;
}

int main()
{
    int arr1[] = {10,41,3,12,22};
    int arr2[] = {1,2,3,4,5};
    int i;
    replaceMax(arr1,arr2[0] ); //将数组arr1和数组arr2的第一个元素传入函数中
    for(i=0;i<5;i++)
    {
        printf("%d ",arr1[i]);                
    }
    return 0;    
}
输出: 10 1 3 12 22 


例3： 查找数组中是否包含某个值，下表是多少？
#include <stdio.h>
int getIndex(int arr[5],int value)
{
    int i;
    int index=-1;
    for(i=0;i<5;i++)
    {
       /* 请完善数组查询功能 */
       if(arr[i]==value){
           index=i;
           break;
       }
    }
    return index;
}

int main()
{
    int arr[5]={3,12,9,8,6};
    int value = 8;
    int index = getIndex(arr, value);      //这里应该传什么参数呢？
    if(index!=-1)
    {
        printf("%d在数组中存在，下标为：%d\n",value,index);             
    }
    else
    {
        printf("%d在数组中不存在。\n",value);    
    }
    return 0;    
}
输出: 8在数组中存在，下标为：3



========================================
|-- 字符串与数组
----------------------------------------
1.字符串就是由多个字符组合而成的一段话。

在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。一般有以下两种格式：
1、char 字符串名称[长度] = "字符串值";
2、char 字符串名称[长度] = {'字符1','字符2',...,'字符n','\0'};

注意：
1、[]中的长度是可以省略不写的；
2、采用第2种方式的时候最后一个元素必须是'\0'，'\0'表示字符串的结束标志；
3、采用第2种方式的时候在数组中不能写中文。
在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);

#include <stdio.h>
/* 定义say函数 */
void say(char string[]) //数组参数应该怎么写呢？
{
    printf("%s\n",string); //打印字符串
}

int main()
{
    //定义字符串数组
    char string[] = "我在慕课网上学习IT技能！";
    say(string); //调用say函数输出字符串
    return 0;
}




========================================
|-- 字符串函数
----------------------------------------

使用string.h提供的字符串操作函数： 
strlen(a)：返回字符串的长度，不包括字符串结束的标记’\0’
strcmp(a,b)：将a，b两个字符串从左到右对每个字符，按照ASCII码的值进行比较，直到出现不同的或者’\0’，终止比较，如果内容一样，返回0；大于返回正整数，小于则返回负整数；
strcpy(a,b)：将b的字符串复制到a中，会覆盖
strcat(a,b)：将字符串b的内容拼接到a的后面



1.strlen("abc") //3 获得字符串的长度
strlen()获取字符串的长度，在字符串长度中是不包括‘\0’而且汉字和字母的长度是不一样的。
#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	printf("str1的长度是%d\n", (int)strlen(str1));
	printf("str2的长度是%d\n", (int)strlen(str2));
	return 0;
}
输出:
str1的长度是6
str2的长度是9



2.strcmp("ab","ab"); //1 比较字符串
strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小。
#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	printf("str1和str2比较：%d\n", strcmp(str1,str2));
	printf("字符串比较1: %d\n", strcmp("ab","ab"));
	printf("字符串比较2: %d\n", strcmp("ab","ac"));
	printf("字符串比较3: %d\n", strcmp("ab","aa"));
	return 0;
}
输出:
str1和str2比较：1
字符串比较1: 0
字符串比较2: -1
字符串比较3: 1



3.strcpy(s1, "abc"); //字符串拷贝
strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝，

#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	strcpy(str2," is a cat");
	printf("str1=%s \nstr2=%s;\n", str1, str2);
	return 0;
}
输出:
str1=旺财 
str2= is a cat;



4.strcat(s1, "abc"); //把后一个字符串拼接到第一个字符串后面
strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串。

#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	strcat(str1," is not a cat.");
	//strcat(str1, str2); //这样为什么不行？//done
	printf("str1=%s \nstr2=%s;\n", str1, str2);
	return 0;
}
输出:
str1=旺财 is not a cat. 
str2= is a dog;

因为str1空间不够，如果添加str[100]，则上文strcat(str1, str2);就不会报错。




5.atoi("100"); //100 字符串转换为整数

#include<stdio.h>
#include <stdlib.h>
int main(){
	char str1[]="100";
	int num=atoi(str1);
	printf("str1=%s \nnum=%d;\n", str1, num+2);
	return 0;
}
输出:
str1=100 
num=102;


例1: 把s2复制给s1(长度足够)，s3链接到s1后面，输出“我爱,慕课网”
#include <stdio.h>
#include <string.h>
int main()
{
    char s1[100]="";
    char s2[]="我爱,";
    char s3[]="慕课网";
    /*在以下补全代码*/
    strcpy(s1,s2);
    strcat(s1,s3);
    printf("%s\n",s1);
    return 0;    
}



========================================
|-- 输入输出函数 printf, scanf 与 puts, gets的区别
----------------------------------------


printf()函数
printf()函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出信息。在编写程序时经常会用到此函数。printf()函数的调用格式为:
printf("<格式化字符串>", <参量表>);
其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以"%"开始, 后跟一个或几个规定字符,用来确定输出内容格式。



scanf()函数
scanf()函数是格式化输入函数, 它从标准输入设备(键盘) 读取输入的信息。其调用格式为:
scanf("<格式化字符串>", <地址表>);
格式化字符串包括以下三类不同的字符;
1. 格式化说明符: 格式化说明符与printf()函数中的格式说明符基本相同。
2. 空白字符: 空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符。
3. 非空白字符: 一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。
地址表是需要读入的所有变量的地址, 而不是变量本身。这与printf()函数完全不同, 要特别注意。各个变量的地址之间同","分开。



puts()函数
puts()函数用来向标准输出设备(屏幕)写字符串并换行, 其调用格式为:
puts(s); 其中s为字符串变量(字符串数组名或字符串指针)。
puts()函数的作用与语printf("%s\n", s)相同。


gets()函数
gets()函数用来从标准输入设备(键盘)读取字符串直到回车结束, 但回车符不属于这个字符串。其调用格式为:
gets(s); 其中s为字符串变量(字符串数组名或字符串指针)。
gets(s)函数与scanf("%s", &s)相似, 但不完全相同, 使用scanf("%s", &s)函数输入字符串时存在一个问题, 就是如果输入了空格会认为输入字符串结束,空格后的字符将作为下一个输入项处理, 但gets() 函数将接收输入的整个字符串直到回车为止。

gets()函数实现字符串的输入，其调用形式为：gets(字符数组)；
puts()函数实现字符串的输出，其调用形式为：puts(字符数组)；



printf scanf是格式化输入输出函数：更清晰标准
puts gets是非格式化输入输出函数 ：编译后代码少, 相对占用内存也小, 从而提高了速度, 同时使用也比较方便。






========================================
|-- 多维数组
----------------------------------------
https://www.imooc.com/code/5636

1.定义
数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];
num[行数][列数]

例如：int num[3][3]={{1,2,3},{4,5,6},{7,8,9}};
这样定义了一个名称为num，数据类型为int的二维数组。其中第一个[3]表示第一维下标的长度，就像购物时分类存放的购物；第二个[3]表示第二维下标的长度，就像每个购物袋中的元素。

我们可以把上面的数组看作一个3×3的矩阵。
num[0][0]=1;	num[0][1]=2;	num[0][2]=3;
num[1][0]=4;	num[1][1]=5;	num[1][2]=6;
num[2][0]=7;	num[2][1]=8;	num[2][2]=9;


多维数组的初始化与一维数组的初始化类似也是分两种：
1)、数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}};
2)、数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值;


多维数组初始化要注意以下事项：
1)、采用第一种始化时数组声明必须指定【列】的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；
也就是以下是合法的:
int x[][3]={{0},{1},{1,2,3}};
int x[4][3]={{1,2,3},{1,2,3},{1,2,3},{1,2,3}}
int x[][3]={1,2,3,4}; //会有warning。自动计算总个数4除以列数3得到1.3，也就是2行。x[1][0]=4
而以下是错误的:
int x[4][]={{1,2,3},{1,2,3},{1,2,3},{1,2,3}};//二维数组定义的时候，可以不指定行的数量，但是必须指定列的数量。

2)、采用第二种初始化时数组声明必须同时指定行和列的维数。



例: 给arr1和arr2数组元素初始化为10,20,30，40。第一行元素为10和20，第二行元素为30和40。
#include <stdio.h>
int main()
{
    //使用第一种方式初始化方式声明并初始化二维数组arr1
    int arr1[2][2]={{10,20},{30,40}};
    
    //使用第二种方式初始化方式声明并初始化二维数组arr2
    int arr2[2][2];
    arr2[0][0]=10;
    arr2[0][1]=20;
    arr2[1][0]=30;
    arr2[1][1]=40;
    //
    return 0;    
}




2.遍历：嵌套循环

例:现有三行三列的二维数组int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};，编写程序实现计算对角线元素之和。
#include <stdio.h>
int main()
{
    int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
    int i,j;
    int sum=0;
    for(i=0;i<3;i++)
    {
       for(j=0;j<3;j++){
           if(i==j || i+j==2){
               sum+=arr[i][j];
           }
       }
    }
    printf("对角线元素之和是：%d\n",sum);
    return 0;    
}
输出:
对角线元素之和是：25




例： 在一个长度为10的整型数组里面，保存了班级10个学生的考试成绩。要求编写5个函数，分别实现计算考试的总分，最高分，最低分，平均分和考试成绩降序排序。

#include <stdio.h>
#define N 10
int max(int arr[N]){
    int max=arr[0];
    int i;
    for(i=0; i<10;i++){
    	if( arr[i]>max){
    		max=arr[i];
    	}
    }
    return max;
}
int min(int arr[N]){
    int min=arr[0];
    int i;
    for(i=0; i<10;i++){
    	if( arr[i]<min){
    		min=arr[i];
    	}
    }
    return min;
}
int mean(int arr[N]){
	int i=0,sum=0;
	for(;i<N;i++){
		sum+=arr[i];
	}
	return sum/N;
}
void sort(int arr[N]){
	int temp,i,j;
	for(i=0;i<N-1;i++){
		for(j=i+1;j<N;j++){
			if(arr[i]<arr[j]){
				temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
			}
		}
	}
}
int main()
{
    int score[N]={67,98,75,63,82,79,81,91,66,84};
    printf("max=%d\n", max(score));
    printf("min=%d\n", min(score));
    printf("mean=%d\n", mean(score));
    sort(score);
    int i=0;
    for(;i<N;i++){
    	printf("%d, ", score[i]);
    }
    printf("\n");
    return 0;
}
输出： 
max=98
min=63
mean=78
98, 91, 84, 82, 81, 79, 75, 67, 66, 63, 



========================================
|-- 数组的排序算法
----------------------------------------
1. 冒泡法排序
相邻元素两两比较，将较大的数字放在后面，直到将所有数字全部排序。
#include <stdio.h>
int main()
{
    double arr[10]={1.78, 1.67, 1.82, 1.79, 1.85, 1.75, 1.86, 1.77, 1.81, 1.80};
    int i,j;
    printf("\n************排队前*************\n");
    for(i=0;i<10;i++)
    {
        if(i != 9)   
            printf("%.2f, ", arr[i]);  //%.2f表示小数点后精确到两位
        else
            printf("%.2f", arr[i]);    //%.2f表示小数点后精确到两位
    }
    for(i=8; i>=0; i--)
    {
        for(j=0;j<=i;j++) //i=8,arr[j+1]=arr[9]就是最后一个
        {
            if(arr[j]>arr[j+1] )      //当前面的数比后面的数大时
            {
                double temp;    //定义临时变量temp
                temp=arr[j];     //将前面的数赋值给temp
                arr[j]=arr[j+1];    //前后之数颠倒位置
                arr[j+1]=temp;  //将较大的数放在后面    
            }
        }
    }
    printf("\n************排队后*************\n");
    for(i=0;i<10;i++)
    {
        if(i != 9)   
            printf("%.2f, ", arr[i]);  //%.2f表示小数点后精确到两位     
        else
            printf("%.2f", arr[i]);    //%.2f表示小数点后精确到两位
    }
    return 0;    
}





2. 找出最大的，和第一个交换；再找剩下的最大的，和第二个交换
(1) 示例1
#include<stdio.h>
//打印数组
void printArr(int arr[]){
	int i;
	printf("[");
	for(i=0;i<5;i++){
		printf("%d, ", arr[i]);
	}
	printf("]\n");
}

void sortBubble(int arr[]){
	int i,j,tmp;
	for(i=0;i<4;i++){
		for(j=i;j<5;j++){
			if(arr[i]>arr[j]){
				tmp=arr[i];
				arr[i]=arr[j];
				arr[j]=tmp;
			}
		}
	}
}

int main(){
	int myArr[5]={100,21,2000,63,4,};
	printArr(myArr);
	sortBubble(myArr);
	printArr(myArr);
	return 0;
}




(2) 示例2: 更通用的写法，是传入数组长度
$ cat 07_arr_sort.c
#include<stdio.h>

void printArr(double arr[], int len){
  printf("[");
  for(int i=0; i<len; i++){
    //printf("arr[%d]=%2.1f\n", i, arr[i]);
    if(i<len-1){ printf("%2.1f, ", arr[i]); }
    else{ printf("%2.1f", arr[i] ); }
  }
  printf("]\n");
}

void sort(double arr[], int len){
 for(int i=0; i<len; i++){
  for(int j=i; j<len; j++){
    if( arr[i] > arr[j]){
      double tmp=arr[i];
      arr[i]=arr[j];
      arr[j]=tmp;
    }
   }
 }
}

int main(){
  double arr2[]={1.1, 1, 4.5, -5, 20, -2.1, 10, 2001, 1.3, -300};
  printArr(arr2, 10);
  sort(arr2, 10);
  printArr(arr2, 10);
}

$ gcc 07_arr_sort.c
$ ./a.out 
[1.1, 1.0, 4.5, -5.0, 20.0, -2.1, 10.0, 2001.0, 1.3, -300.0]
[-300.0, -5.0, -2.1, 1.0, 1.1, 1.3, 4.5, 10.0, 20.0, 2001.0]








========================================
|-- sizeof 与数组: 变量占了多少内存？
----------------------------------------
使用了sizeof关键字来问C语言这些东西占多少个字节。
在初始化之前，C就确定了每个元素占用的空间，则全部数组长度确定后，这个数组占用的位置也是可以计算的。


1. 可以通过 sizeof() 知道每个变量占了多少内存空间
int a1=sizeof(int); //4
int a2=sizeof(1);  //4

int arr[]={1,2,3,400};
int a3=sizeof(arr); //16

char arr2[][5]={"this", "is", "good"};
printf("arr2: %ld, first ele: %ld\n", sizeof(arr2), sizeof(arr2[0])); // 15  5


int var=100;
int *ptr=&var;
int **pptr=&ptr;
printf("sizeof(var)=%ld, sizeof(ptr)=%ld, sizeof(pptr)=%ld\n",sizeof(var), sizeof(ptr), sizeof(pptr)); 
//sizeof(var)=4, sizeof(ptr)=8, sizeof(pptr)=8
指针占了8位。








2. 可以通过 sizeof 知道数组测长度

# include<stdio.h>
int main(){
	int arr1[]={1,2,3,4,100};
	char arr2[][5]={"this", "is","a","book"};

	int N1=sizeof(arr1) / sizeof(1);
	printf("len(arr1)=%d\n", N1);
	for(int i=0; i<N1; i++){
		printf("arr1[%d] = %d \n", i, arr1[i]);
	}

	int N2=sizeof(arr2)/ sizeof( arr2[0] );
	printf("\nlen(arr2)=%d\n", N2);
	for(int j=0; j<N2; j++){
		printf("arr2[%d]=%s\n", j, arr2[j]);
	}
	
	return 0;
}

运行后
len(arr1)=5
arr1[0] = 1 
arr1[1] = 2 
arr1[2] = 3 
arr1[3] = 4 
arr1[4] = 100 

len(arr2)=4
arr2[0]=this
arr2[1]=is
arr2[2]=a
arr2[3]=book








========================================
指针
----------------------------------------

变量前加&获得其指针: int a=10; &a 就是指向a的指针地址，是一个16进制数。
指针前加*就获得了该值: int *p; 则p是指向int的指针变量(16进制数)，而*p则是该指针地址对应的int值。



1.学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

#include <stdio.h>
 
int main ()
{
   int  var1;
   char var2[10];
 
   printf("var1 变量的地址： %p\n", &var1  );
   printf("var2 变量的地址： %p\n", &var2  );
 
   return 0;
}

window输出:
var1 变量的地址： 000000000061FE4C
var2 变量的地址： 000000000061FE42

Ubuntu输出:
var1 变量的地址： 0x7ffe6a0f83b8
var2 变量的地址： 0x7ffe6a0f83be

下文指针部分，我们按照Ubuntu输出记录和分析。




2.什么是指针？
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type *var-name;
如 
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;     /* 一个字符型的指针 */

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。


2.如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
   printf("Address of var variable: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );
   return 0;
}
输出:
Address of var variable: 0x7ffc34c740fc
Address stored in ip variable: 0x7ffc34c740fc
Value of *ip variable: 20


3.C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

实例
#include <stdio.h>

int main ()
{
   int  *ptr = NULL;
   printf("ptr 的地址是 %p\n", ptr  );
   return 0;
}
输出:ptr 的地址是 (nil)
win10的输出是: ptr 的地址是 0000000000000000


在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */







========================================
第6章 结构体
----------------------------------------
1. C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。



2. 定义结构
为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;

tag 是结构体标签。
member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。
variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;


在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：

(1)无tag.
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;


(2) 无variable-list，后面可以单独声明变量名。
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;


(3) 也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;


在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&s1，则是非法的。



结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。



(4)此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;
};

(5)此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};



如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：

(6)
struct B;    //对结构体B进行不完整声明

//结构体A中包含指向结构体B的指针
struct A
{
    struct B *partner;
    //other members;
};

//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
    struct A *partner;
    //other members;
};







3. 结构体变量的初始化
和其它类型变量一样，对结构体变量可以在定义时指定初始值。

(1) 定义和声明变量、初始化同时进行
#include<stdio.h>
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
} book = {"C 语言", "谭浩强","编程语言", 1002};

int main(){
	printf("title: %s\n", book.title);
	printf("author: %s\n", book.author);
	printf("subject: %s\n", book.subject);
	printf("book_id: %d\n", book.book_id);
}
输出:
title: C 语言
author: 谭浩强
subject: 编程语言
book_id: 1002




(2) 定义和声明变量分开
$ vim test4.c 
#include<stdio.h>
typedef struct Point{
    double x, y;
} Point;

int main(){
	Point p1={0.0,3.0}, p2={4.0,0.0};
	printf("p1(%f, %f), p2(%f, %f)\n", p1.x, p1.y, p2.x, p2.y);
	return 0;
}









4.访问结构成员
(1) 结构体对象访问成员
为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。

上个例子刚用过。再举一个例子。
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
 
   /* 输出 Book1 信息 */
   printf( "Book 1 title : %s\n", Book1.title);
   printf( "Book 1 author : %s\n", Book1.author);
   printf( "Book 1 subject : %s\n", Book1.subject);
   printf( "Book 1 book_id : %d\n", Book1.book_id);
 
   return 0;
}

输出： 
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407


(2) 结构体指针访问成员: p->name 

$ vim test5.c
#include<stdio.h>
typedef struct Point{
    double x, y;
} Point;

int main(){
	Point p1={0.0,3.0}, *pp1=&p1;
	//printf("p1:%p, &p1:%p \n", p1, &p1); // warning: format ‘%p’ expects argument of type ‘void *’, but argument 2 has type ‘Point’
	printf("&p1:%p, pp1:%p \n", &p1, pp1);
	printf("p1(%f, %f), pp1(%f, %f)\n", p1.x, p1.y, pp1->x, pp1->y);
	return 0;
}

$ gcc test5.c
$ ./a.out 
&p1:0x7fff8e767510, pp1:0x7fff8e767510 
p1(0.000000, 3.000000), pp1(0.000000, 3.000000)











5.结构作为函数参数
把结构作为函数参数，传参方式与其他类型的变量或指针类似。
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printBook( Book1 );
 
   /* 输出 Book2 信息 */
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}


(2) 结构体内定义字符指针
#include<stdio.h>
// 结构体作为函数参数
struct Student{
  char *name;
  int age;
};

void printS(struct Student s){
  printf("name:%s, age:%d, pointer:%p\n", s.name, s.age, &s);
}

int main(){
  struct Student s1={"Tom", 21};

  printf("name:%s, age:%d, sizeof:%ld\n", s1.name, s1.age, sizeof(s1));

  s1.name = "Smith";
  printS(s1);
  
  s1.age += 20;
  printS(s1);
  return 0;
}

输出 
name:Tom, age:21, sizeof:16
name:Smith, age:21, pointer:0x7ffd97b9c2f0
name:Smith, age:41, pointer:0x7ffd97b9c2f0








6. 指向结构的指针
您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似： struct Books *struct_pointer;

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面：
struct_pointer = &Book1;

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符：struct_pointer->title;

让我们使用结构指针来重写上面的实例，
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &Book1 );
 
   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &Book2 );
 
   return 0;
}
void printBook( struct Books *book )
{
   printf( "Book title : %s\n", book->title);
   printf( "Book author : %s\n", book->author);
   printf( "Book subject : %s\n", book->subject);
   printf( "Book book_id : %d\n", book->book_id);
}










========================================
|-- 位域
----------------------------------------
1.
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

典型的实例：
- 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。
- 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。


位域的定义和位域变量的说明
位域定义与结构定义相仿，其形式为：
struct 位域结构名 
{
 位域列表
};

其中位域列表的形式为：类型说明符 位域名: 位域长度 

例如：
struct bs{
    int a:8;
    int b:2;
    int c:6;
}data;
说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。


让我们再来看一个实例：
struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;
在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。






2. 对于位域的定义尚有以下几点说明：
(1)一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：

struct bs{
    unsigned a:4;
    unsigned  :4;    /* 空域 */
    unsigned b:4;    /* 从下一单元开始存放 */
    unsigned c:4
}
在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。


(2)由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。


(3)位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：
struct k{
    int a:1;
    int  :2;    /* 该 2 位不能使用 */
    int b:3;
    int c:2;
};

从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。






3. 位域的使用
位域的使用和结构成员的使用相同，其一般形式为：
	位域变量名.位域名
	位域变量名->位域名

位域允许用各种格式输出。

#include<stdio.h>
int main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit->a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit->b&=3;    /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */
    pbit->c|=1;    /* 使用了复合位运算符"|="，相当于：pbit->c=pbit->c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);    /* 用指针方式输出了这三个域的值 */
	
	return 0;
}
输出： 
1,7,15
0,3,15


上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。




例2： 
#include <stdio.h>
#include <string.h>
 
struct
{
  unsigned int age : 3;
} Age;
 
int main( )
{
   Age.age = 4;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 7;
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( "Age.age : %d\n", Age.age );
 
   return 0;
}

当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：
Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0







========================================
|-- 共用体
----------------------------------------
1. C 共用体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

定义共用体
为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];

union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

union Data
{
   int i;
   float f;
   char  str[20];
} data;





2.
现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：

实例
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   printf( "Memory size occupied by data : %d\n", sizeof(data));
 
   return 0;
}

当上面的代码被编译和执行时，它会产生下列结果：
Memory size occupied by data : 20






3. 访问共用体成员
为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

例1：
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");
 
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：
data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming

在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。




例2：
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   printf( "data.i : %d\n", data.i);
   
   data.f = 220.5;
   printf( "data.f : %f\n", data.f);
   
   strcpy( data.str, "C Programming");
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：
data.i : 10
data.f : 220.500000
data.str : C Programming

在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。



========================================
|-- 枚举类型 //todo
----------------------------------------
https://blog.csdn.net/coder_pig/article/details/78252898




========================================
|-- typedef 关键字，给类型定义别名 //todo
----------------------------------------
基本用法
typedef oldName newName;

1. 可以给常规变量类型取别名

typedef  int myInt;
myInt a=12;
printf("sizeof: %ld, %ld\n", sizeof(myInt), sizeof(a));

输出: sizeof: 4, 4



2. 可以给 结构体 重命名

struct person{
	int id;
	char *name;
}

type



ref:
https://blog.csdn.net/liitdar/article/details/80069638






========================================
第7章 文件IO(输入与输出)
----------------------------------------
https://blog.csdn.net/coder_pig/article/details/78262020

C系统在处理文本文件或二进制文件时，并不区分类型，都看成是字符流，按字节进行处理。 

输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。 本章讨论流式文件的打开、关闭、读、写、 定位等各种操作。

在Ｃ语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。
FILE *指针变量标识符；



1.文本文件的使用方式
FILE *fp;
fp = fopen(filename, mode);
fclose(fp);

mode读写字符	作用
“r”	只读方式打开一个文本文件,只允许度数据,不存在则打开失败
“w”	只写方式打开或建立一个文本文件,只允许写数据
“a”	追加的方式打开一个文本文件,可在文件尾写数据,不存在则创建一个
“r+”	读写方式打开一个文本文件,允许读写,不存在,打开失败
“w+”	读写方式打开或建立一个文本文件,允许读写
“a+”	读写方式打开文本文件,在文件末尾追加数据,不存在则创建一个




2. 读写字符函数 fputc(char1, fp), fgetc(char1, fp)
(1)示例1: 写入文本文件2行字符串。
#include<stdio.h>
#include<string.h>
#include <stdlib.h>
int main(){
  FILE *fp; //文件指针
  // 打开文件，指针相当于一个吸管，可以操作文件
  fp=fopen("backup/test1.txt", "w");
  if(fp == NULL){
    printf("file open failed!\n");
    exit(1);
  }

  // 写入字符，一个一个写入，所以要先获取长度
  char str[]="this is a line.\nthis is the 2nd line.\n";
  int index=0, N=strlen(str);
  while( index < N ){
    fputc( str[index++], fp);
  }
  //关闭文件
  fclose(fp);
  printf("write %d char into file.\n", N);
  return 0;
}

#try1: 报错: implicit declaration of function ‘exit’
查exit在哪个头文件 $ man exit 结果是 #include <stdlib.h>，引入该头文件即可。




(2) 示例2: 读文本文件，并打印出来
#include<stdio.h>
#include<stdlib.h>
int main(){
  // 打开文件，获取句柄
  FILE *fp;
  char c;
  int n=0;
  fp=fopen("backup/test1.txt", "r");
  if(fp == NULL){
    printf("file open failed!\n");
    exit(1);
  }
  // 读取并打印文件
  //EOF是文件结尾的标志，此处判断是否到文件结尾
  while ((c=fgetc(fp)) != EOF ){
    printf("%c", c);
    n++;
  }
  printf("Read a file of length: %d\n", n);
  // 关闭文件
  fclose(fp);
  return 0;
}




3. 读写字符串函数 fputs(str1, fp), fgets(str1, n, fp)
(1) fputs(str1, fp) 向文件写入字符串
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(){
	char str[]="通过fputs方法写入文件\n";
	FILE *fp = fopen("backup/test2.txt","w");
	if(fp==NULL){
		printf("open file failed!\n");
		exit(1);
	}
	fputs(str, fp);
	fclose(fp);
	printf("写入长度%ld\n", strlen(str));
	return 0;
}



(2) fgets(str1, fp) 读取文件
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(){
	char str[50];
	FILE *fp = fopen("backup/test2.txt","r");
	if(fp==NULL){
		printf("open file failed!\n");
		exit(1);
	}
	/*fgets(str, 20, fp);
	printf("len=%ld: %s\n", strlen(str), str);*/
	//这里写3是因为,汉字是占2个字节的
	int n=0;
	while( fgets(str, 2, fp)!= NULL ){
		printf("%s", str);
		n+=2;
	}
	printf("reading: len=%d\n", n);
	fclose(fp);
	return 0;
}





3. 格式化读(fprintf)写(fscanf)函数

这个和前面学的scanf和printf使用方法是一样的，不过前者们是针对内存中的数据的！
而后者是针对文件读写的，
fprintf是将控制台的内容打印到文件中，所以是写入。
fscanf则是将文件的内容输入到控制台，所以是读取。

(1) fprintf(fp, "xx %c $d", char1, 20) 写入文件
#include<stdio.h>
#include<stdlib.h>
int main(){
	char msg[]="Henan suffered a flood last week.";
	int day=23;
	FILE *fp=fopen("backup/test3.txt", "w");
	if( fp == NULL ){
		printf("open file failed!\n");
		exit(1);
	}
	fprintf(fp, "msg: %s; day: %d\n", msg, day);
	fclose(fp);
	printf("writing to file with fprintf() finished!\n");
	return 0;
}


(2) fscanf(fp,"%s%s%s%s%s%s",&c1,&c2,&c3,&c4,&c5,&c6); 读出文件
#include<stdio.h>
#include<stdlib.h>
int main(){
	//char msg[33];
	char msg[6][10];
	int day;
	FILE *fp=fopen("backup/test3.txt", "r");
	if( fp == NULL ){
		printf("open file failed!\n");
		exit(1);
	}
	//fscanf(fp, "msg: %s; day: %d\n", msg, &day); //结果不对，感觉遇到空格就停了
	fscanf(fp, "msg: %s %s %s %s %s %s day: %d\n", 
			msg[0],msg[1],msg[2],msg[3],msg[4],msg[5], &day);
	fclose(fp);
	printf("reading from file with fscanf() finished!\n");
	
	for(int i=0; i<6; i++){
			printf("read %d: |%s|\n", i, msg[i]);
	}
	printf("read: day=|%d|\n", day);
	return 0;
}







========================================
|-- 二进制文件的读写
----------------------------------------
使用 wb, rb, ab 等标识符，表示二进制文件写、读、追加。


1. 数据块方式写入(fwrite())与读取(fread())

将学生信息存储到结构体中，然后通过fwrite()函数将结构体内容写入文件中;
在通过fread()函数读取出来

(1) fwrite(*data, sizeof(data), 1, fp)函数写 结构体到文件
#include<stdio.h>
#include<stdlib.h>
typedef struct{
	int id;
	char name[20];
	int age;
} STU;

int main(){
	STU stu;
	FILE *fp;
	char c;
	//内容是逐条追加的
	if( (fp=fopen("backup/test4.data","ab")) == NULL ){
		printf("open file failed!\n");
		exit(1);
	}
	//键盘录入学生信息
	while(1){
		printf("请输入学号:"); scanf("%d", &stu.id);
		printf("\n请输入姓名:"); scanf("%s", stu.name); //数组本身就是指针，再加&会有警告
		printf("\n请输入年龄:"); scanf("%d", &stu.age);
		//参数依次是: 数据起始地址,每次写入的数据块的字节数,数据块的数目,文件指针
		fwrite(&stu, sizeof(stu), 1, fp );
		printf("\nContinue input?(Y/N)\n");
		getchar(); //这个是干啥的？
		c=getchar();
		if(c=='y' || c=='Y') continue;
		else break;
	}
	fclose(fp);
	return 0;
}



(2) fread()函数读取二进制文件
#include<stdio.h>
#include<stdlib.h>
typedef struct{
	int id;
	char name[20];
	int age;
} STU;

int main(){
	STU stu;
	FILE *fp;
	if( (fp=fopen("backup/test4.data", "rb")) == NULL ){
		printf("open file failed!\n");
		exit(1);
	}
	//读取存储的学生信息
	printf("output file content:\n");
	printf("学号\t姓名\t年龄\n"); //这里不对齐，以后再调整
	//从fp指向的二进制文件读取数据,每次读取大小为size个字节的数据  
    //执行 1 次；最后将这些数据保存到结构体变量的地址内存中  
    //返回值正常时是读取的数据库个数(count)的值,否则返回0(错误或文件尾)
	while( fread(&stu, sizeof(stu), 1, fp) == 1 ){
		printf("%-15d%-15s%-15d\n", stu.id, stu.name, stu.age);
	}
	fclose(fp);
	return 0;
}

注释:
# printf("%15d %13.4f\n",angle,y);
# 以整型（长度为15）、浮点型（长度为13，小数点后4位）的形式输出angle与y这两个变量的值
"%-15d"表示输出文字靠左对齐，空格留在右侧。







2. 字写入(putw(n,fp))/读取(getw(fp))函数
(1) putw(n,fp)：以二进制的形式将一个int类型的数据写入到fp所指向的二进制文件中。
n为写入的整数,执行正常返回写入的整数,否则返回EOF
# include<stdio.h>
int main(){
	FILE *fp;
	fp=fopen("backup/test5.data","wb");
	int arr[]={10,2,30,-40};
	for(int i=0; i<4; i++){
		printf("%d ", arr[i]);
		putw(arr[i], fp);
	}
	fclose(fp);
	printf("saved with putw()\n");
	return 0;
}




(2) getw(fp):从fp指向的二进制文件中以二进制的方式读取一个字。
执行正常返回所读取的二进制整数,否则返回EOF

# include<stdio.h>
int main(){
	FILE *fp;
	fp=fopen("backup/test5.data","rb");
	int arr[4];
	for(int i=0; i<4; i++){
		arr[i]=getw(fp);
		printf("%d ", arr[i]);
	}
	fclose(fp);
	printf("read with getw()\n");
	return 0;
}








ref:
https://blog.csdn.net/coder_pig/article/details/78262020







========================================
第8章 UNIX系统接口 //todo
----------------------------------------
1. 好书推荐：《UNIX 环境高级编程第二版》

UNIX编程人员的圣经，历久弥新
Stevens名著新版，重新焕发青春
Dennis Ritchie作序推荐


书中除了介绍UNIX文件和目录、标准I/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了多个应用示例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。

(1) 目录结构：https://www.ituring.com.cn/book/650
1、UNIX基础知识
2、UNIX标准化及实现
3、文件I/O
4、文件和目录
5、标准I/O库
6、系统数据文件和信息
7、进程环境
8、进程控制
9、进程关系
10、信号
11、线程
12、线程控制
13、守护进程
14、高级I/O
15、进程间通信
16、网络IPC：套接字
17、高级进程间通信
18、终端I/O
19、伪终端
20、数据库函数库
21、与网络打印机通信

(2) 作者与译者
W.Richard Stevens
备受赞誉的技术作家，生前著有多种经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP/IP详解》（三卷本）和本书第1版。

尤晋元
上海交通大学计算机科学及工程系教授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究；在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。










========================================
附录: 标准库
----------------------------------------
https://www.runoob.com/cprogramming/c-standard-library.html








========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
