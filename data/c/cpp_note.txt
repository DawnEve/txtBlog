cpp_note
主要是为学习和使用 Rcpp 服务




cpp的精髓就在于转化和复现。因为快，所以可以时间来换空间，来弥补架构的缺陷。

各种层面的延时调用和抽象分发、汇聚，现在根本就没人懂，也不点赞。然后就没人写这类的文章和回答，结果cpp板块在知乎的搜索页上都消失了。2017年还好好的。

图像处理:
音视频开发
网游服务器: 
网络软件: 跨平台、重量级的ACE库，是C++语言最重要的成果之一，在企业、部门、军方都有应用。
Qt: Adobe Photoshop, Opera, Skype, VirtualBox, KDE桌面等。
	Qt提供一种叫做 signals/slots 的安全类型来替代 callback，使得各个元件之间的协同工作变得十分简单。


STL模板库、tcmalloc内存管理机制

Portable C++ /ASIO/Boost了解一下，自己写 epoll/kqueue/IOCP绝对写不过这些有水平的库的。

C++写过：五子棋、内存监控工具、压缩工具。
	以及比较复杂的数据结构
	实现网络编程的并发模型
	一定要





========================================
招聘: rpc
----------------------------------------
C++高级开发工程师(无锡)
职位描述：
1.本科及以上学历，计算机、电子、通信及相关专业；
2.具有5年以上C++编程经验；
3.熟悉Linux操作系统，熟练使用gdb、VS等开发调试工具；
4.具备网络、存储IO、RPC、KV数据库等2种及以上相关技术的开发能力；
5. 3个以上的项目开发经历，有SPDK、bRPC、文件系统开发经验者优先考虑；
6.良好的代码风格及文档能力，有自主学习能力，良好的团队合作意识及积极向上的心态。
7.优秀者薪资、福利面议。













========================================
c++教程与知识天梯
----------------------------------------
1. 入门版
很多对于会的人是常识的东西，对于初学者就是无法理解、很难的概念。

快速入门课 https://www.imooc.com/code/23173

文字: https://www.runoob.com/cplusplus/cpp-tutorial.html
	http://www.codebaoku.com/it-c/it-c-253771.html

视频: https://www.bilibili.com/video/BV1Tb411j7uM
	本人配合《C++ prime》看，看书感觉难懂的就来看视频，结果感觉效果十分显著
	黑马C/C++教程: 张涛老师Qt课程 https://www.bilibili.com/video/BV1jK4y1s73T?p=639
	黑马C++_13移动打车项目 https://www.bilibili.com/video/bv1G7411m7XQ


1)翁凯老师无论是 C、C++、Java 的视频都讲得非常深入浅出，只能说水平越是高的人讲的课越容易明白。
	https://study.163.com/course/introduction/271005.htm
	本课程以C++语言来介绍面向对象程序设计的原理和方法，
	内容包括面向对象程序设计基本原理和C++特有的语言特性。
	大致的章节包括基本理论、类与对象、构造与清除、函数、引用、继承与多态、拷贝构造、运算符重载、异常、模板和流等。
	本课程不涉及具体的C++开发环境，也不会涉及图形程序设计和网络程序设计等。

2)侯捷老师的八部曲：
侯捷C++ 标准 11 -14
侯捷STL 和 泛型编程
侯捷C++ 内存管理
侯捷C++面向对象高级开发
侯捷STL与泛型编程
侯捷 C++ Startup 揭密：C++ 程序的生前和死后

陈硕第三套、Linux CC++网络编程实践-陈硕


3) 书籍推荐
https://github.com/itwanger/toBeBetterJavaer/blob/master/docs/xuexiluxian/ccc.md
学习 C++ 语法，首推《C++ Primer 第五版》



(2) 经典书单
C++
《A Tour of C++》
《Accelerated C++》
	https://blog.csdn.net/weixin_30325071/article/details/96452452
《C++ primer》  # 注意:《C++ primer plus》是一本垃圾，讲的是一个披着 c++ 外衣的C语言。
《STL源码解析》
《Effective C++》
《深度探索C++对象模型》
《C++设计与演化》






2. 核心知识点 第一层
(1) 第一层，通识
共同的、最基本的那些概念：变量、常量、类型、循环、判断、数组、字符串、对象、输入输出等

然后还有 C++ 中一些特有的东西，比如命名空间 namespace、引用、模板等。

以及如何使用一些 STL 中的类库，比如 string、vector、find 之类的东西。

然后就是辅以大量的练习。
	就那种 C++ 教程的课后练习题就足够了，类似水仙花数、四则运算计算器之类的东西。


(2) 第一层，cpp入门
到这里，你对 C++ 包含了哪些知识点大概有了一个整体的印象。并且能够写上百行左右的程序，但是还是很难写出一个优秀的类。

接下来需要进行全面和深入的学习，算是真正的入门：
《Accelerated C++》（美国斯坦福大学的经典教材）  
《C++ Primer》（大而全）  
《The C++ Programming Language》（C++之父 Bjarne Stroustrup 所著） 
这三本，其实各有优缺点，第一本优点是简短，仅仅两三百页，只有最为核心和主干的知识点。
而后两本则都是大而全，尤其是《The C++ Programming Language》。
这两本区别在于，一个是 C++ 大师所著，一本是 C++ 之父所著。

网上有人说 《C++Primer》是目前市面上唯一一本真正的从入门到精通的书，适合初学者；
《C++ Programming language》 是C++专家自学指南，顾名思义，适合有较深厚 C++ 功底的读者。
所以我推荐的顺序是：《Accelerated C++》->《C++ Primer》->《The C++ Programming Language》


对于这种上前页大部头我推荐的阅读方式是，以主题为划分，比如 C++ Primer 就明确的分为了：
	C++ 基础
	C++ 标准库
	类设计者的工具
	高级主题

如果有一定的基础的话，可以看着目录，看一些自己感兴趣的章节，完全没有必要从第一页开始挨着挨着读。

入门结束你应该掌握以下内容：
	基础语言
	类与面向对象
	输入输出
	字符串处理（类库和正则表达式）
	容器类库
	泛型算法

看着只有几个关键字，实际上每个展开都有很多内容需要学习。
学习过程中把后面的每一个练习题都自己敲一遍，自己多思考对比一下。
多用代码去验证自己的想法，尤其是指针、引用、构造、析构这些地方。
学习 C++ 以及日常开发一定要记得这几个网站，可以随时查阅一些语法的用法和标准库：
	cppreference
	cplusplus
	isocpp





更细的颗粒度:

C++ 基础语法: 数据类型与声明，标识符与关键字，常量与变量，运算符(算术/关系/逻辑)，初等表达式/lambda 表达式;
C++ 基本词法: 
	最基本容器--数组 
	指针: const 指针, 	函数指针, 	各类指针分析, 	避免野指针
	防止内存泄漏，智能指针的使用
	C++内存分配方式，字符串，Redis项目字符串处理
C++ 基本句法: 
	赋值、判断与循环
	函数基础，内联函数，递归函数的本质，枚举类型，
	结构体：包容一切
	联合体：高效组合
	类与面向对象
	命名空间
C++ 高级语法:
	类型转换
	异常 exception
	IO 最难设计的模块
	文件操作
	多线程-C++新标准的应用
	模板编程应用
C++ 编程思想进阶：
	再议class
	运算符重载 
	深拷贝与浅拷贝
	面向对象的思想、误区
	常见面向对象设计模式
	模板编程：C++精髓
C++ 高效编程进阶：
	STL常见容器：顺序容器、关联容器
	算法 Algorithm
	函数对象 Function Objects 
	迭代器 Iterators
	生成器 Allocators
	C++ 的内存分配问题
	STL 的整体架构和思想
	更安全使用字符串： STL string
	C++ 的 stream
	C++ 的瑞士军刀: boost 库
	C++ 最新标准/陷阱和经验
	C++ 中常见的编程范式


项目：实现一个屏幕矩阵截图功能。目标是 PicPick
	https://blog.csdn.net/hhy321/article/details/121548612




浏览菜鸟教程，没记住的部分：
	特殊字符常量需要加反斜杠 \\ 表示 \, \? 表示?
	
	Lambda 函数与表达式 cpp-functions.html

	C++ 随机数 cpp-numbers.html
	C++ 指针 cpp-pointers.html
	C++ 引用 cpp-references.html
	日期和时间 cpp-date-time.html
	输入和输出(错误和日志流) cpp-basic-input-output.html
	结构体(结构体作为函数参数、指向结构体的指针): cpp-data-structures.html
	
	
	类和对象: cpp-classes-objects.html
	










3. 怎么精通？C++是不是落伍了？
C++在刚毕业的年轻人简历里都是精通，工作两年后就是略懂了
写了十几年我都只敢熟练



CPP 现在招聘真没限制年龄。 就是后继无人。 使用起来比其他语言繁琐多了。
那是你不了解现代c++,特别是加上boost已经非常强了


c++已经过时了，十年才能入门的语言早该被淘汰了，十个小时就能入门的语言才是好语言。
卷就是这么卷起来的，其次现在新的那些语言很难用于大型实时游戏和一些驱动，运行效率确实太慢


游戏底层还有c++ 最后一块地

既然都说到"底层"了，有哪个不是C++？操作系统，编译器，浏览器，驱动，图形，图像……
整个底层都没人做了




(2) 前置、后置

c++，数据结构，操作系统，数据库，计算机网络等等计算机基础知识。

尽可能早点刷oj,leetcode等等，找到学校ACM团队，尽早的参加或者了解比赛。

有机会进去靠谱老师的实验室，就尽早去；前提得是靠谱，去了能学到东西，学不到就千万别去。关键课程尽量考试考高分，比如c语言程序设计基础，java，数据结构，操作系统，计算机网络，高数等等。其他科目，如果你想拿奖学金，也可以去花时间刷分数。















========================================
|-- C++初学者必看的50个建议 绝对经典
----------------------------------------

1.把C++当成一门新的语言学习（和C没啥关系！真的。）；
2.看《Thinking In C++》，不要看《C++编程思想》；
3.看《The C++ Programming Language》和《Inside The C++ Object Model》,不要因为他们很难而我们自己是初学者所以就不看；
4.不要被VC、BCB、BC、MC、TC等词汇所迷惑——他们都是集成开发环境，而我们要学的是一门语言；
5.不要放过任何一个看上去很简单的小编程问题——他们往往并不那么简单，或者可以引伸出很多知识点；
6.会用Visual C++，并不说明你会C++；

7.学class并不难，template、STL、generic programming也不过如此——难的是长期坚持实践和不遗余力的博览群书；
8.如果不是天才的话，想学编程就不要想玩游戏——你以为你做到了，其实你的C++水平并没有和你通关的能力一起变高——其实可以时刻记住：学C++是为了编游戏的；

9.看Visual C++的书，是学不了C++语言的；

10.浮躁的人容易说：XX语言不行了，应该学YY；——是你自己不行了吧！？
11.浮躁的人容易问：我到底该学什么；——别问，学就对了；
12.浮躁的人容易问：XX有钱途吗；——建议你去抢银行；
13.浮躁的人容易说：我要中文版！我英文不行！——不行？学呀！
14.浮躁的人容易问：XX和YY哪个好；——告诉你吧，都好——只要你学就行；
15.浮躁的人分两种：a)只观望而不学的人；b)只学而不坚持的人；

16.把时髦的技术挂在嘴边，还不如把过时的技术记在心里；
17.C++不仅仅是支持面向对象的程序设计语言；
18.学习编程最好的方法之一就是阅读源代码；
19.在任何时刻都不要认为自己手中的书已经足够了；
20.请阅读《The Standard C++ Bible》(中文版：标准C++宝典)，掌握C++标准；
21.看得懂的书，请仔细看；看不懂的书，请硬着头皮看；
22.别指望看第一遍书就能记住和掌握什么——请看第二遍、第三遍；
23.请看《Effective C++》和《More Effective C++》以及《Exceptional C++》；

24.不要停留在集成开发环境的摇篮上，要学会控制集成开发环境，还要学会用命令行方式处理程序；
25.和别人一起讨论有意义的C++知识点，而不是争吵XX行不行或者YY与ZZ哪个好；
26.请看《程序设计实践》，并严格的按照其要求去做；
27.不要因为C和C++中有一些语法和关键字看上去相同，就认为它们的意义和作用完全一样；

28.C++绝不是所谓的C的“扩充”——如果C++一开始就起名叫Z语言，你一定不会把C和Z语言联系得那么紧密；
29.请不要认为学过XX语言再改学C++会有什么问题——你只不过又在学一门全新的语言而已；
30.读完了《Inside The C++ Object Model》以后再来认定自己是不是已经学会了C++；
31.学习编程的秘诀是：编程，编程，再编程；

32.请留意下列书籍：《C++面向对象高效编程（C++ Effective Object-Oriented Software Construction）》《面向对象软件构造(Object-Oriented Software Construction)》《设计模式（Design Patterns）》《The Art of Computer Programming》；

33.记住：面向对象技术不只是C++专有的；
34.请把书上的程序例子亲手输入到电脑上实践，即使配套光盘中有源代码；
35.把在书中看到的有意义的例子扩充；

36.请重视C++中的异常处理技术，并将其切实的运用到自己的程序中；

37.经常回顾自己以前写过的程序，并尝试重写，把自己学到的新知识运用进去；
38.不要漏掉书中任何一个练习题——请全部做完并记录下解题思路；
39.C++语言和C++的集成开发环境要同时学习和掌握；
40.既然决定了学C++,就请坚持学下去，因为学习程序设计语言的目的是掌握程序设计技术，而程序设计技术是跨语言的；
41.就让C++语言的各种平台和开发环境去激烈的竞争吧，我们要以学习C++语言本身为主；
42.当你写C++程序写到一半却发现自己用的方法很拙劣时，请不要马上停手；请尽快将余下的部分粗略的完成以保证这个设计的完整性，然后分析自己的错误并重新设计和编写（参见43）；

43.别心急，设计C++的class确实不容易；自己程序中的class和自己的class设计水平是在不断的编程实践中完善和发展的；
44.决不要因为程序“很小”就不遵循某些你不熟练的规则——好习惯是培养出来的，而不是一次记住的；
45.每学到一个C++难点的时候，尝试着对别人讲解这个知识点并让他理解——你能讲清楚才说明你真的理解了；
46.记录下在和别人交流时发现的自己忽视或不理解的知识点；
47.请不断的对自己写的程序提出更高的要求,哪怕你的程序版本号会变成Version 100.XX；
48.保存好你写过的所有的程序——那是你最好的积累之一；
49.请不要做浮躁的人；
50.请热爱C++!










========================================
|-- g++ 编译技巧 //ing
----------------------------------------
1. 把宏展开
Qt，ue4
嵌套宏定义，好几十行的宏，怎么看得懂？
g++ -E -P -I./include fileName 










========================================
环境搭建与 hello world 编译
----------------------------------------
2. 运行环境
(1) win7 本
忘了啥时候安装的了，看输出信息，是 Strawberry perl 自带的。
如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。

打开 git bash
$ g++ --version
g++.exe (x86_64-posix-seh, Built by strawberryperl.com project) 7.1.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$ g++ -v
Using built-in specs.
COLLECT_GCC=C:\Strawberry\c\bin\g++.exe
COLLECT_LTO_WRAPPER=C:/Strawberry/c/bin/../libexec/gcc/x86_64-w64-mingw32/7.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
Configured with: ../../../src/gcc-7.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libstdcxx-pch --disable-libstdcxx-debug --disable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpc=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-isl=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-pkgversion='x86_64-posix-seh, Built by strawberryperl.com project' CFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CXXFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CPPFLAGS=' -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' LDFLAGS='-pipe -fno-ident -L/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/lib -L/opt/build/prerequisites/x86_64-zlib-static/lib -L/opt/build/prerequisites/x86_64-w64-mingw32-static/lib '
Thread model: posix
gcc version 7.1.0 (x86_64-posix-seh, Built by strawberryperl.com project)








3. 运行示例

(1) 最简单的程序
$ cat main.cpp 
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}

(2)编译
$ gcc main.cpp -lstdc++ -o main

最简单的编译方式：
$ g++ main.cpp

由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：
$ ./a.exe
Hello, world!



(3) 指定输出文件 -o
通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：
$ g++ helloworld.cpp -o helloworld

执行 helloworld:
$ ./helloworld.exe
Hello, world!



(4) 如果是多个 C++ 代码文件，如 xx1.cpp、xx2.cpp，编译命令如下：

$ g++ xx1.cpp xx2.cpp -o xx
生成一个 xx 可执行文件。


(5) g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：
$ g++ -g -Wall -std=c++11 main.cpp









========================================
|-- 非root权限安装新版 gcc
----------------------------------------
发布标准:
C++98
C++03
C++11
C++17
C++20

C++没有GC 垃圾回收。


1. 搜索 c++ 11 对应的gcc版本
gcc 4.7 之后，才支持c11.

$ gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

貌似我的 CentOS7.9 默认版本已经支持了。

$ ls -lth  /usr/lib/gcc/x86_64-redhat-linux/4.8.5/
total 5.0M
lrwxrwxrwx. 1 root root   30 Jun 24 21:16 libobjc.so -> ../../../../lib64/libobjc.so.4
drwxr-xr-x. 3 root root 4.0K Jun 24 21:16 include
drwxr-xr-x. 2 root root 4.0K Jun 24 21:16 32
lrwxrwxrwx. 1 root root   37 Jun 24 21:06 libstdc++.so -> ../../../../lib64/libstdc++.so.6.0.19
drwxr-xr-x. 2 root root   86 Jun 24 21:06 finclude
...

$ vim demo.cpp 
#include<iostream>
int main(){
	printf("this is c++\n");
	return 0;
}

$ ls xx
ls: cannot access xx: No such file or directory
$ echo $?
2

$ ls 
01  v1
$ echo $?
0


$ g++ -g -Wall -std=c++11 demo.cpp
$ ./a.out 
this is c++







2. 最新版 gcc 12.1.0
https://www.programmerall.com/article/32361000992/

(1) 下载
http://ftp.gnu.org/gnu/gcc/
http://ftp.gnu.org/gnu/gcc/gcc-12.1.0/

$ wget http://ftp.gnu.org/gnu/gcc/gcc-12.1.0/gcc-12.1.0.tar.gz
$ tar zxvf gcc-12.1.0.tar.gz


(2) 安装
这里由于没有root权限，需要把 --prefix=后的路径改成自己路径，如/home/users/liqiang/gcc-9.3.0

$ cd gcc-12.1.0
$ ./configure --prefix=/home/wangjl/software/gcc-12.1.0 --enable-shared --enable-threads=posix --enable-languages=c,c++,fortran --disable-multilib

报错: configure: error: Building GCC requires GMP 4.2+, MPFR 3.1.0+ and MPC 0.8.0+.

$ ./contrib/download_prerequisites

gmp-6.2.1.tar.bz2: OK
mpfr-4.1.0.tar.bz2: OK
mpc-1.2.1.tar.gz: OK
isl-0.24.tar.bz2: OK
All prerequisites downloaded successfully.


前面的句子是否有用?
$ mkdir build
$ cd build
$ ../configure --prefix=/home/wangjl/software/gcc-12.1.0 --enable-shared --enable-threads=posix --enable-languages=c,c++,fortran --disable-multilib
$ make -j64 #多线程，否则巨慢！ 20:25-->20:45
### -j6 十分耗时 20:00-->20:24 ctrl+C改为64核

$ make install

Libraries have been installed in:
   /home/wangjl/software/gcc-12.1.0/lib/../lib64




(3) 加入环境变量
打开.bashrc
$ vim ~/.bashrc

添加以下三条，需要把路径改成自己的
export PATH=~/software/gcc-12.1.0/bin:$PATH
export LD_LIBRARY_PATH=~/software/gcc-12.1.0/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=~/software/gcc-12.1.0/lib64:$LD_LIBRARY_PATH

激活环境
$ source ~/.bashrc

查看版本
$ gcc --version

gcc (GCC) 12.1.0
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



使用老版本的gcc:
$ whereis gcc
gcc: /usr/bin/gcc /usr/lib/gcc /usr/libexec/gcc /data/jinwf/wangjl/software/gcc-12.1.0/bin/gcc /usr/share/man/man1/gcc.1.gz

$ /usr/bin/gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)
Copyright (C) 2015 Free Software Foundation, Inc.


(4) 清理
$ cd ../..
$ mv gcc-12.1.0 gcc-12.1.0-Can-Delete
过几天没啥异常，这个就可以删除了。


(5) 测试
源码文件
$ cat main.cpp 
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world! from c++" << endl;
    return 0;
}


使用c++11标准编译，两个版本的编译器都正常工作。
$ /usr/bin/g++ -g -Wall -std=c++11 main.cpp
$ ./a.out 
Hello, world! from c++

$ g++ -g -Wall -std=c++11 main.cpp
$ ./a.out 
Hello, world! from c++



使用c++17标准，只有新的g++可以编译:
$ /usr/bin/g++ -g -Wall -std=c++17 main.cpp
g++: error: unrecognized command line option ‘-std=c++17’

$ g++ -g -Wall -std=c++17 main.cpp
$ ./a.out 
Hello, world! from c++



https://www.csdn.net/tags/MtjaUg5sODMyODItYmxvZwO0O0OO0O0O.html








========================================
|-- 15个最常用的GCC编译器参数 //todo
----------------------------------------
https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/







========================================
|-- vsCode 配置 C++
----------------------------------------
1. 已经安装过 Strawberry perl 自带的一套 g++ 编译器。

其实，最后选择的ssh链接服务器，是利用 server 的g++环境。
$ g++ --version
g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



2. 安装插件
点击左侧 插件图标，搜索并安装: 第一个是vscode推荐的，剩下两个是看博客推荐的。
	C/C++ Extension Pack  | v1.2.0
	code Runner  | v0.11.7 跑代码
	C/C++  | v1.7.1 代码提示




3. 写代码 
$ pwd
/home/wangjl/data/project/linux_C/cpp

在编辑器中写，有自动提示补齐。
$ cat cpp/a1.cpp
#include<iostream>
using namespace std;

int main(){
    cout << "Welcome to my vscode C++ world!" << endl;
    return 0;
}




4. 点右上角 三角 Run code 
底下控制台输出3行:
[Running] cd "/home/wangjl/data/project/linux_C/cpp/" && g++ a1.cpp -o a1 && "/home/wangjl/data/project/linux_C/cpp/"a1
Welcome to my vscode C++ world!

[Done] exited with code=0 in 0.314 seconds






5. 我们用objdump -t c1.o命令来查看一下c1.o的符号表

$ objdump -t c1.out

c1.out:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000318 l    d  .interp	0000000000000000              .interp
0000000000000338 l    d  .note.gnu.property	0000000000000000              .note.gnu.property
0000000000000358 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
000000000000037c l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
00000000000003a0 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000000003c8 l    d  .dynsym	0000000000000000              .dynsym
0000000000000470 l    d  .dynstr	0000000000000000              .dynstr
00000000000004f4 l    d  .gnu.version	0000000000000000              .gnu.version
...




6. gcc 编译器的选项

g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：

$ g++ -g -Wall -std=c++11 main.cpp



g++ 常用命令选项
选项	解释
-ansi	只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。
-c	只编译并生成目标文件。
-DMACRO	以字符串"1"定义 MACRO 宏。
-DMACRO=DEFN	以字符串"DEFN"定义 MACRO 宏。
-E	只运行 C 预编译器。
-g	生成调试信息。GNU 调试器可利用该信息。
-IDIRECTORY	指定额外的头文件搜索路径DIRECTORY。
-LDIRECTORY	指定额外的函数库搜索路径DIRECTORY。
-lLIBRARY	连接时搜索指定的函数库LIBRARY。
-m486	针对 486 进行代码优化。
-o	FILE 生成指定的输出文件。用在生成可执行文件时。
-O0	不进行优化处理。
-O	或 -O1 优化生成代码。
-O2	进一步优化。
-O3	比 -O2 更进一步优化，包括 inline 函数。
-shared	生成共享目标文件。通常用在建立共享库时。
-static	禁止使用共享连接。
-UMACRO	取消对 MACRO 宏的定义。
-w	不生成任何警告信息。
-Wall	生成所有警告信息。






========================================
头文件的作用与用法
----------------------------------------

xx.h 文件
	可以定义数据类型，保证一致性
	节省代码，提高效率
	保密和代码重用: 只给用户提供头文件和二进制库。


引用方式:
	系统提供的 #include <iostream.h> 新标准是省略.h后缀: #include <iostream>
	自己编写的 #include "xx.h"


防止被重复包含，可以在 .h 文件中使用 
#ifndef HEADER_NAME
#define HEADER_NAME
//... some macros
#endif




1. 第一个版本，函数和输出写到一个文件
$ vim a1.c
#include<stdio.h>
int add(int a, int b){
	return a+b;
}

int main(){
	int a=add(3,5);
	printf("result=%d\n", a);
}

$ g++ a1.c -o a1.out
$ ./a1.out 
result=8



2. 第二个版本：函数和调用写到2个文件中
注意：调用函数前，必须要有函数声明。

$ vim b1.c
#include<stdio.h>
int add(int a, int b);

int main(){
	int a=add(20,5);
	printf("result=%d\n", a);
}

$ vim b2_fun.c
int add(int a, int b){
	return a+b;
}


编译和调用
$ g++ b1.c b2_fun.c -o b1.out
$ ./b1.out 
result=25





3. 第三个版本：函数和头文件分别写，调用文件引用头文件

$ vim c1.c 
#include<stdio.h>
#include "c1.h"

int main(){
	int a=add(20,5); //调用函数1
	a=del(a, 7);  //调用函数2
	printf("result=%d\n", a);
}


头文件
$ vim c1.h 
#define PI 3.14
int add(int a, int b);
int del(int a, int b);


函数文件
$ vim c1_fun.c 
int add(int a, int b){
	return a+b;
}


int del(int a, int b){
	return a-b;
}


(1) 一般的编译
$ g++ c1.c c1_fun.c -o c1.out
执行
$ ./c1.out 
result=18



(2) 保密编译方式 

先把机密代码 c1_fun.c 编译成中间文件 c1_fun.o
$ g++ -c c1_fun.c -o c1_fun.o

这时把 c1_fun.o 和 c1.h 给用户，用户可以查看 c1.h 调用该二进制库，并进行二次编译:
$ g++ c1.c c1_fun.o -o c1.out2
$ ./c1.out2
result=18



ref: https://zhuanlan.zhihu.com/p/387773355





========================================
** cpp 项目: 屏幕截图功能 //todo
----------------------------------------


搜索: https://so.csdn.net/so/search?q=c%2B%2B%20%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7&t=blog&u=&spm=1035.2249.3001.8104

相关的: 
	https://blog.csdn.net/chenlycly/article/details/121197726







========================================
** cpp 项目2: 超大图片(800Mb的空间转录组图片)浏览器 //todo
----------------------------------------






========================================
** cpp 项目3: mp3 复读机播放器(学英语)，最好适配手机版 //todo
----------------------------------------






========================================
入门篇
----------------------------------------
https://www.runoob.com/cplusplus/cpp-stl-tutorial.html
https://github.com/0voice/cpp_new_features





========================================
|-- 变量名、注释、数据类型、变量定义、变量作用域、常量、存储类
----------------------------------------

1. 变量名
字母或下划线开头，后面可以是字母、下划线、数字。

2. 注释
/*多行注释*/
// 单行注释



3. 数据类型 

(1)内置7种基本数据类型

类型	关键字
布尔型	bool
字符型	char
整型	int
浮点型	float
双浮点型	double
无类型	void
宽字符型	wchar_t

一些类型可以加修饰符
signed
unsigned
short
long

怎么查询数据类型占了多少字符？
cout << "sizeof short:" << sizeof(short) << endl; //2


还有其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等。



(2) typedef 给已有类型取别名
typedef type newname; 


(3) 枚举类型 
枚举类型的一般形式为：enum enum-name { list of names } var-list; 


enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;



如：定义只能使用这几种颜色。color 是变量类型，变量名是c，第二行c的值是 blue。
	enum color { red, green, blue } c;
	c = blue;
	cout << "c=" << c << endl; //2
	//再定义一个变量
    Color c2=red;
    cout << "c2=" << c2 << endl; //0

enum-name 是枚举类型的名称。
list of names 是逗号分隔的名称，默认情况下第一个名称的值是0，第二个名称的值是1，类推。
但是可以定义初始值


enum color { red, green=5, blue };
在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。



枚举的作用就是防止输错，并且名称有意义。比如星期、月份就很适合使用枚举类型。
    //定义值的枚举，前面的值不变，后面默认比前面递增1
    enum Week {Mon, Tue, Wed=13, Thu, Fri, Sat, Sun};
    Week w1=Mon, w2=Fri;
    cout << "\nw1=" << w1 << endl; //0
    cout << "w2=" << w2 << endl; //15
	cout << "size of enum:" << sizeof(w2) << endl; //4 看这个大小，还是当 int 存储的



4. 变量定义

如何定义、声明和使用各种类型的变量。

(1) 变量定义
告诉编译器 变量的类型，变量的名字。
type variable_list;
type variable_name = value; //赋初始值

实例: 
int i, j, k=3;


(2) extern 关键字
当您使用多个文件且只在其中一个文件中定义变量时, 使用 extern 关键字在任何地方声明一个变量。

extern int d = 3, f = 5;    // d 和 f 的声明 

可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
//todo 声明 定义 啥区别？ 看例子:

#include<iostream>
using namespace std;

//变量声明，可以多次声明，在多个文件种声明
extern int a,b;
extern float f;

int main(){
    //变量定义，只能在某一个文件被定义一次
    int a,b;
    float f;

    //实际初始化
    a=10;
    b=20;
    f=10.1/3.0;

    cout << a+b << endl;
    cout << f << endl;

    return 0;
}

变量声明：用于向程序表明变量的类型和名字。
变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
定义也是声明：当定义变量时我们声明了它的类型和名字。




5. 函数声明
开头声明函数，而函数定义可以在任何地方。

#include<iostream>
using namespace std;

//函数声明
int add(int x, int y); //如果不提前声明，就要在使用前定义。

int main(){
    cout<< add(10, 8) << endl;

    return 0;
}

//函数定义
int add(int a, int b){
    return a+b;
}




6. 变量作用域
在函数或一个代码块内部声明的变量，称为局部变量。
	它们只能被函数内部或者代码块内部的语句使用。

在所有函数外部声明的变量，称为全局变量。
	全局变量的值在程序的整个生命周期内都是有效的。

在函数参数的定义中声明的变量，称为形式参数。

先来讲解声明是局部变量和全局变量。

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。


(2) 初始化
当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。
定义全局变量时，系统会自动初始化为下列值：
数据类型	初始化默认值
int	0
char	'\0'
float	0
double	0
pointer	NULL

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。




7. 常量
常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

使用 #define 预处理器。
使用 const 关键字。强烈推荐 const。

#define WIDTH 25  //不是c++语句，编译前预处理掉了，不加分号结尾
const int HEIGHT = 4; //加分号结尾

请注意，把常量定义为大写字母形式，是一个很好的编程实践。




8. 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：
auto  默认。auto 只能修饰局部变量。
register 
static
extern
mutable

(2)
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

(3) static 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

#include<iostream>
using namespace std;

// 全局静态变量
static int count = 10;

void func1(void){
    static int i=2; //局部静态变量
    i++;
    cout << "i=" <<i << 
        ", count=" << count << endl; //内部可以使用全局变量
}

int main(){
    while(count--){
        func1();
    }
    //cout << "i=" << i << endl; //报错 i 未声明。局部变量只能用在局部: 函数内或块内
    return 0;
}


(4) extern 是用来在另一个文件中声明一个全局变量或函数。
extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候.
可以修饰变量声明或函数声明。

(5) mutable 存储类
mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。
它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。





========================================
|-- 运算符 //todo
----------------------------------------


http://www.codebaoku.com/cpp/cpp-operators.html











========================================
读书笔记：重述《Effective C++》 //好难，走马观花过一遍，然后就知道打基础的重要性了
----------------------------------------
https://normaluhr.github.io/2020/12/31/Effective-C++/

共55条意见和建议。


1. 让自己习惯 c++
(1) c++ 是一个联邦语言。分4大块，有些使用习惯并不一致。

(2),(3) 尽可能使用 const 而不是 #define 来定义常量。

太复杂，先跳过3. //todo 指针、类、引用

(4) 使用前要初始化。//todo 构造函数的初始化、赋值 的区别。



2. 构造/析构/赋值运算
(5) 


















========================================
C++ openCV
----------------------------------------
1.图形库
(1) GUI
Cross-Platform C++ GUI Library: https://github.com/wxWidgets/wxWidgets

(2) 2D 库
https://www.cairographics.org/

(3) 游戏 game
https://www.sfml-dev.org/





2. C++ OpenCV学习笔记
https://www.cnblogs.com/horacle/p/13167749.html









========================================
C++ 实验课
----------------------------------------

视频 https://www.zhihu.com/zvideo/1351617689794777088
https://www.zhihu.com/question/269536272/answer/2238975620



践课的安排如下：
1.用C语言模仿面向对象的整型循环队列编程，
2.用C++的运算符重载、深拷贝及移动语义等进行整型循环队列编程，
3.通过继承一个队列及聚合一个队列对象实现栈的模拟编程，
4.使用变参模板实现超级矩阵类，
5.使用VS2019+Qt插件开发公交转乘GUI程序。

后面的实验题目依赖于前一个实验，目的是减少学生的编程工作量，让同学体会新概念的加入所带来的变化，从而能更快更好地掌握和应用新概念。
第4题第5题难度逐渐加大，
第5题同时具备数学建模＋面向对象建模＋三层视图图形用戸界面开发。

实验1的目的在于培养学生使用C进行面向对象的程序设计；
实验2的目的在于使学生理解类、重载、深拷贝、移动拷贝、虚函数、强制类型转换等概念；
实验3的目的在于让学生掌握继承、聚合对象的方法，运用深拷贝、移动语义时如何保证宏观与微观实现的一致性、以及如何防止基类函数的不当调用破坏派生类对象的多态特性；实验4的目的在于让学生掌握模板实例化、异常处理等概念，有能力的学生掌握概念、约束、变参类型的处理方法，能够模仿MATLAB的矩阵不限维、降维及块赋值运算；

实验5锻炼学生建立公交转乘数学模型的能力，以及面向对象的建模能力，掌握基于Qt的图形用户界面的三层视图开发方法，基本能够开发商业级应用程序。

详细解答参见《C++程序设计精要教程学习指导与习题解答》，难题可扫二维码进入视频讲解，所有实例、习题及实验代码可以下载。这些实验均提供自动评测评分程序，检查并提示学生按面向对象的方法编程。测评库也可从人民邮电出版社下载。









========================================
|-- lab 1.用C语言模仿面向对象的整型循环队列编程，
----------------------------------------

实验1. 题目要求

整型队列是一种先进先出的存储结构，对其进行的操作通常包括：向队列尾部添加一个整型元素、从队列首部移除一个整型元素等。整型循环队列类型Queue及其操作函数采用非面向对象的C语言定义，请将完成上述操作的所有如下函数采用C语言编程， 然后写一个main函数对队列的所有操作函数进行测试，请不要自己添加定义任何新的函数成员和数据成员。


#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

struct Queue{
	int* const elems; //elems申请内存用于存放队列的元素
	const int max; //elems申请的最大元素个数max
	int head, tail; //队列头head和尾tail，队空head=tail;初始head=tail=0
};

void initQueue(Queue *const p, int m); //初始化p指队列：最多申请m个元素
void initQueue(Queue *const p, const Queue&s); //用s深拷贝初始化p指队列
void initQueue(Queue *const p, Queue&&s); //用s移动初始化p指队列
int number (const Queue *const p); //返回p指队列的实际元素个数
int size(const Queue *const p); //返回p指队列申请的最大元素个数max
Queue*const enter(Queue*const p, int e); //将e入队列尾部，并返回p
Queue*const leave(Queue*const p, int &e); //从队首出元素到e，并返回p
Queue*const assign(Queue*const p, const Queue&q); //深拷贝赋s给队列并返回p
Queue*const assign(Queue*const p, Queue&&q); //移动赋s给队列并返回p
char*print(const Queue *const p, char*s);//打印p指队列至s并返回s
void destroyQueue (Queue *const p); //销毁p指向的队列

编程时应采用VS2019开发，并将其编译模式设置为X86模式以便评测程序库测试，其他需要注意的事项说明如下：

（1）用initQueue(Queue *const p, int m)对p指向的队列初始化时， 为其elems分配m个整型元素内存，并初始化max为m，以及初始化head=tail=0。

（2）对于initQueue(Queue *const p, const Queue& q)初始化，用已经存在的对象q深拷贝构造新对象*p时，新对象*p不能和对象q的elems共用同一块内存，新对象*p的elems需要分配和q为elems分配的同样大小的内存，并且将已经存在q的elems的内容深拷贝至新分配的内存；新对象*p的max、head、tail应设置成和已经存在的对象s相同。

（3）对于initQueue(Queue *const p, Queue&& q)初始化，用已经存在的对象q移动构造新对象，新对象使用对象q为elems分配的内存快，并将其max、head、tail设置成和s的对应值相同，然后将s的elems设置为空表示内存已经移动给新对象，将s的max、head、tail设置为0。

（4）对于Queue*const assign(Queue*const p, const Queue&q)深拷贝赋值，用等号右边的对象q深拷贝赋值给等号左边的对象，等号左边的对象如果已经有内存则应先释放以避免内存泄漏，然后分配和对象q为elems分配的同样大小的内存，并且设置其max、head、tail和q的对应值相同。

（5）对于Queue*const assign(Queue*const p, Queue&&q)移动赋值，若等号左边的对象为elems分配了内存，则先释放改内存一面内存泄漏，然后使用等号右边对象q为elems分配的内存，并将其max、head、tail设置成和对象q的对应值相同；对象q的elems设置为空指针以表示内存被移走给等号左边的对象，同时其max、head、tail均应设置为0。

（6）队列应实现为循环队列，当队尾指针tail快要追上队首指针head时，即如果满足(tail+1)%max=head，则表示表示队列已满，故队列最多存放max-1个元素；而当head=tail时则表示队列为空。队列空取出元素或队列满放入元素均应抛出异常，并且保持其内部状态不变。

（7）打印队列时从队首打印至队尾，打印的元素之间以逗号分隔。







========================================
|-- lab 2.用C++的运算符重载、深拷贝及移动语义等进行整型循环队列编程
----------------------------------------
实验2. 题目要求

整型队列是一种先进先出的存储结构，对其进行的操作通常包括：向队列尾部添加一个整型元素、从队列首部移除一个整型元素等。整型循环队列类QUEUE及其操作函数采用面向对象的C++语言定义，请将完成上述操作的所有如下函数采用C++语言编程， 然后写一个main函数对队列的所有操作函数进行测试，请不要自己添加定义任何新的函数成员和数据成员。

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

class QUEUE{
	int* const elems; //elems申请内存用于存放队列的元素
	const int max; //elems申请的最大元素个数为max
	int head, tail; //队列头head和尾tail，队空head=tail;初始head=tail=0

	public:
	QUEUE(int m); //初始化队列：最多申请m个元素
	QUEUE(const QUEUE& q); //用q深拷贝初始化队列
	QUEUE(QUEUE&& q)noexcept; //用q移动初始化队列
	virtual operator int() const noexcept; //返回队列的实际元素个数
	virtual int size() const noexcept; //返回队列申请的最大元素个数max
	virtual QUEUE& operator<<(int e); //将e入队列尾部，并返回当前队列
	virtual QUEUE& operator>>(int& e); //从队首出元素到e，并返回当前队列
	virtual QUEUE& operator=(const QUEUE& q);//深拷贝赋值并返回被赋值队列，不要调用~QUEUE()，不要调用new(this) QUEUE(q)
	virtual QUEUE& operator=(QUEUE&& q)noexcept;//移动赋值并返回被赋值队列
	virtual char * print(char *s) const noexcept;//打印队列至s并返回s
	virtual ~QUEUE(); //销毁当前队列
}

编程时应采用VS2019开发，并将其编译模式设置为X86模式以便评测程序库测试，其他需要注意的事项说明如下：

（1）用QUEUE(int m)对队列初始化时， 为其elems分配m个整型元素内存，并初始化max为m，以及初始化head=tail=0。

（2）对于QUEUE(const QUEUE& q)深拷贝构造函数，在用已经存在的对象q深拷贝构造新对象时，新对象不能共用已经存在的对象q的elems内存，新对象的elems需要分配和q为elems分配的同样大小的内存，并且将q的elems的内容深拷贝至新对象分配的内存；新对象的max、head、tail应设置成和q的对应值相同。

（3）对于QUEUE(QUEUE&& q)移动构造函数，在用已经存在的对象q移动构造新对象时，新对象接受使用对象q为elems分配的内存，并且新对象的max、head、tail应设置成和对象q的对应值相同；然后对象q的elems设置为空指针以表示内存被移走，同时其max、head、tail均应设置为0。

（4）对于QUEUE& operator=(const QUEUE& q)深拷贝赋值函数，在用等号右边的对象q深拷贝赋值等号左边的对象时，等号左边的对象若为elems分配了内存，则应先释放内存以避免内存泄漏。等号左边的对象不能共用对象q的elems的同一块内存，应为其elems分配和q为elems分配的同样大小的内存，并且将q的elems存储的内容拷贝至等号左边对象分配的内存；等号左边对象的max、head、tail应设置成和q的对应值相同。

（5）对于QUEUE& operator=(QUEUE&& q)noexcept移动赋值函数，在用已经存在的对象q移动赋值给等号左边的对象时，等号左边的对象若为elems分配了内存，则应先释放内存以避免内存泄漏。等号左边的对象接受使用q为elems分配的内存，并且等号左边的对象的max、head、tail应设置成和对象q的对应值相同；对象q的elems然后设置为空指针以表示内存被移走，同时其max、head、tail均应置为0。

（6）队列应实现为循环队列，当队尾指针tail快要追上队首指针head时，即如果满足(tail+1)%max=head，则表示表示队列已满，故队列最多存放max-1个元素；而当head=tail时，则表示队列为空。队列空取出元素或队列满放入元素均应抛出异常，并且保持其内部状态不变。

（7）打印队列时从队首打印至队尾，打印的元素之间以逗号分隔。




========================================
|-- lab 3.通过继承一个队列及聚合一个队列对象实现栈的模拟编程
----------------------------------------
实验3. 题目要求

整型栈是一种先进后出的存储结构，对其进行的操作通常包括：向栈顶压入一个整型元素、从栈顶弹出一个整型元素等。整型栈类STACK采用之前定义的两个QUEUE类模拟一个栈，其操作函数采用面向对象的C++语言定义，请将完成上述操作的所有如下函数采用C++语言编程， 然后写一个main函数对栈的所有操作函数进行测试，请不要自己添加定义任何新的函数成员和数据成员。

class STACK : public QUEUE {
	QUEUE q;
	public:
	STACK(int m); //初始化栈：最多存放2m-2个元素
	STACK(const STACK& s); //用栈s深拷贝初始化栈
	STACK(STACK&& s)noexcept; //用栈s移动拷贝初始化栈
	int size()const noexcept; //返回栈的容量即2m
	operator int() const noexcept; //返回栈的实际元素个数
	STACK& operator<<(int e); //将e入栈，并返回当前栈
	STACK& operator>>(int& e); //出栈到e，并返回当前栈
	STACK& operator=(const STACK& s); //深拷贝赋值并返回被赋值栈
	STACK& operator=(STACK&& s)noexcept;//移动赋值并返回被赋值栈
	char * print(char *b)const noexcept; //从栈底到栈顶打印栈元素
	~STACK()noexcept; //销毁栈
};

编程时应采用VS2019开发，并将其编译模式设置为X86模式以便评测程序库测试，其他需要注意的事项说明如下：

（1）在用STACK(int m)对栈初始化时， 为其基类和成员q的elems分配m个整型元素内存，并初始化基类和成员q的max为m，以及初始化对应的head=tail=0。

（2）对于STACK(const STACK& s)深拷贝构造函数，在用已经存在的对象s深拷贝构造新对象时，新对象不能共用s的基类和成员q为elems分配的内存，新对象要为其基类和成员q的elems分配和s为其基类和成员q的elems分配的同样大小的内存，并且将s相应的elems的内容深拷贝至新对象为对应elems分配的内存；新对象应设置其基类和成员q的max、head、tail和s的对应值相同。

（3）对于STACK(STACK&& s)noexcept移动拷贝构造函数，在用已经存在的对象s移动构造新对象时，新对象接受使用s为其基类和成员q的对应elems分配的内存，并且新对象的max、head、tail应和s的基类和成员q的对应值相同；s的基类和成员q的elems设置为空指针以表示内存被移走，同时其对应的max、head、tail均应置为0。

（4）对于STACK& operator=(const STACK& s)深拷贝赋值函数，在用等号右边的对象s深拷贝赋值等号左边的对象s时，等号左边对象的基类和成员q不能共用s的基类和成员q为elems分配的内存，若等号左边的对象为其基类和成员q的elems分配了内存，则应先释放掉以避免内存泄漏，然后为其elems分配和s为其基类和成员q的elems分配的同样大小的内存，并且将s对应两个elems的内容拷贝至等号左边对象对应两个elems的内存；等号左边对象中的max、head、tail应设置成和s中基类和成员q的对应值相同。

（5）对于STACK& operator=(STACK&& s)noexcept移动赋值，在用等号右边的对象s移动赋值给等号左边的对象时，等号左边的对象如果已经为其基类和成员q中的elems分配了内存，则应先释放以避免内存泄漏，然后接受使用s的基类和成员q为elems分配的内存，并且等号左边对象中的max、head、tail应和s中基类和成员q中的对应值相同；s中基类和成员q的elems设置为空指针以表示内存被移走，同时其对应的max、head、tail均应设置为0。

（6）栈空弹出元素或栈满压入元素均应抛出异常，并且保持其内部状态不变。

（7）打印栈时从栈底打印到栈顶，打印的元素之间以逗号分隔。




========================================
|-- lab 4.使用变参模板实现超级矩阵类
----------------------------------------
实验4. 题目要求1

矩阵MAT是行列定长的二维数组。常见的矩阵运算包括矩阵的加、减、乘、转置和赋值等运算。请对矩阵MAT类中的所有函数成员编程，并对随后给出的main( )函数进行扩展，以便完成矩阵及其重载的所有运算符的测试。输出矩阵元素时整数用”%6ld” 或”%6lld”打印，浮点数用”%8f”或”%8lf”打印，最后一行用换行符结束”\n”。请用评测程序库测试，自已至少要测试两种实例类MAT<int>和MAT<long long>。

#define _CRT_SECURE_NO_WARNINGS
#include <iomanip>
#include <exception>
#include <typeinfo>
#include <string.h>
using namespace std;

template <typename T>

class MAT {
	T* const e; //指向所有整型矩阵元素的指针
	const int r, c; //矩阵的行r和列c大小

	public:
	MAT(int r, int c);//矩阵定义，不要用malloc
	MAT(const MAT& a); //深拷贝构造，同上
	MAT(MAT&& a)noexcept; //移动构造
	virtual ~MAT()noexcept;//不要用free
	virtual T* const operator[ ](int r);//取矩阵r行的第一个元素地址，r越界抛异常
	virtual MAT operator+(const MAT& a)const; //矩阵加法，不能加抛异常
	virtual MAT operator-(const MAT& a)const; //矩阵减法，不能减抛异常
	virtual MAT operator*(const MAT& a)const; //矩阵乘法，不能乘抛异常
	virtual MAT operator~()const; //矩阵转置
	virtual MAT& operator=(const MAT& a); //深拷贝赋值运算，不要用free、malloc
	virtual MAT& operator=(MAT&& a) noexcept; //移动赋值运算
	virtual MAT& operator+=(const MAT& a); //“+=”运算
	virtual MAT& operator-=(const MAT& a); //“-=”运算
	virtual MAT& operator*=(const MAT& a); //“*=”运算
	//print输出至s并返回s：列用空格隔开，行用回车结束
	virtual char*print(char*s)const noexcept;
};

int main(int argc, char*argv[])//请扩展测试
{
	MAT<int> a(1, 2), b(2, 2), c(1, 2);
	char t[2048];
	a[0][0] = 1; //初始化矩阵元素
	a[0][1] = 2; //等价于“*(a.operator[ ](0)+1)=2;”即等价于“*(a[0]+1)=2;”
	a.print(t); //初始化矩阵后输出该矩阵

	b[0][0] = 3; b[0][1] = 4; //调用T* const operator[ ](int r)初始化数组元素
	b[1][0] = 5; b[1][1] = 6;
	b.print(t);

	c = a * b; //测试矩阵乘法运算
	c.print(t);

	(a + c).print(t); //测试矩阵加法运算
	c = c - a; //测试矩阵减法运算
	c.print(t);

	c += a; //测试矩阵“+=”运算
	c.print(t);

	c = ~a; //测试矩阵转置运算
	c.print(t);

	return 0;
}



========================================
|-- lab 4.题目要求2（高级概念可选题）
----------------------------------------
实验4. 题目要求2（高级概念可选题）

MATLAB矩阵可以有任意多维，仅在矩阵只有两维时可以进行乘法运算，以及奇异值分解svd等运算。MATLAB矩阵在进行sum及区块等运算时会自动降维。试模仿MATLAB定义任意多维超级矩阵类SMAT，因为其元素类可以为任何类型，例如为矩阵块实例类，故它应该可以支持由矩阵块构成的矩阵的运算。头文件SMAT.h用于说明类型信息，SMAT.cpp用于定义相关类的函数成员。SMAT.h如下所示：

#pragma once
#include <list> //以处理{1，3}等形式列表
#include <typeinfo>
#include <iostream>
using namespace std;

class DIM { //可用1及{1，3}等形成维列表
	int* d, n; //d存维列表的值，n存维数
	public:
	DIM(int x); //单个元素形成维列表
	DIM(const std::list<int>&); //{1,3}维列表
	DIM(const DIM&); //深拷贝构造
	DIM(DIM&&) noexcept; //移动构造
	DIM& operator=(const DIM&);//深拷赋值
	DIM& operator=(DIM&&)noexcept;//移动=
	int& operator[ ](int x); //取维x的界值d[x]
	operator int ( )const; //返回维数n
	~DIM( ) noexcept; //析构函数
};

template <typename T> struct SVD;//类型参数同SMAT一致，以便被SMAT实例化
template <typename T>
class SMAT { //定义超级矩阵SMAT
	T** const e; //存放超级矩阵元素
	long z; //e的元素总个数
	int *d; //矩阵各维的界
	const int n; //矩阵总维数
	bool o; //原生矩阵对e[i]进行new T，否则自其它矩阵拷贝e[i]

	public:
	SMAT( ); //无参构造函数
	//以下构造函数第1维的界为f，剩余维的界为args，提示用sizeof...(Args)
	template <typename ...Args>
	SMAT(int f, Args...args) requires conjunction_v<is_same<int, Args>...>;
	SMAT(const SMAT&); //深拷贝构造：得到原生矩阵
	SMAT(SMAT&&) noexcept; //移动构造：得到原生矩阵
	operator T& ( ); //当矩阵只有唯一一个元素时取其值
	SMAT operator[ ](int x); //访问x行元素得到降维的超级矩阵，得到非原生超级矩阵
	SMAT operator[ ](std::list<DIM> x); //取块操作得到可能降维的超级矩阵，得到非原生超级矩阵
	SMAT operator+(const SMAT&)const; //超级矩阵的加法：产生新的原生矩阵
	SMAT operator-(const SMAT&)const; //超级矩阵的减法：产生新的原生矩阵
	SMAT operator*(const SMAT&)const; //仅当只有两维时的矩阵乘法：产生新的原生矩阵
	SMAT& operator=(const T&); //当矩阵只有一个元素时对矩阵赋值
	SMAT& operator=(const SMAT&); //深拷贝赋值：产生原生矩阵
	SMAT& operator=(SMAT&&) noexcept; //移动赋值：保持原有原生矩阵属性不变
	SMAT sum(int x)const; //类似MATLAB的sum求和运算：产生新的原生矩阵
	SVD<T> svd( )const; //类似MATLAB的svd奇异值分解：产生新的原生矩阵
	void print( ); //打印矩阵
	~SMAT( ) noexcept; //析构原生矩阵时，执行delete e[i]，否则不执行
};

template <typename T>
struct SVD { SMAT<T> s, v, d; };

注意，应在SMAT.cpp的尾部强制实例化类模板，即对要用的超级矩阵类模板强制实例化，否则在其它地方实例化类模板有可能失败，对每个类型实参T仅需构造函数为不同维数产生多个实例函数。例如，紧接上述类模板说明，进行强制实例化如下：

template SMAT<int>; //产生零维整型数组实例类及构造等函数
template SMAT<int>::SMAT(int); //产生一维整型数组构造函数
template SMAT<int>::SMAT(int, int); //产生二维整型数组构造函数
template SMAT<int>::SMAT(int, int, int); //产生三维整型数组构造函数
template SMAT<double>::SMAT(int, int); //产生二维双精度型数组实例类及构造函数

然后，利用如下主函数main( )对该超级矩阵进行测试。main的部分测试内容如下，可根据需要自行添加矩阵求和等其它测试。

int main( )
{
	SMAT<int> m(3); //定义一维整型矩阵
	SMAT<int>a(3,3);//二维整型矩阵
	SMAT<int> e(2, 3);
	SMAT<int> n(3, 3, 3);
	a[0][0] = 1; a[0][1] = 2; a[0][2] = 3;
	a[1][0] = 4; a[1][1] = 5; a[1][2] = 6;
	a[2][0] = 7; a[2][1] = 8; a[2][2] = 9;
	auto [s,v,d]=a.svd( );//MATLAB的SVD函数
	std::list<int> b={0,2};//用于矩阵取块操作
	e = a[{0, DIM({1,2})}];//模拟矩阵取块操作
	e[0][0] = 11;
	int z = e[0][0];
	e = a[{ 1, 2 }];
	e = e * a;
	e.print( );
	return 0;
}




========================================
|-- lab 5.使用VS2019+Qt插件开发公交转乘GUI程序
----------------------------------------
实验5. 题目要求

假定所有公交车辆从起点到终点都是双向非环路的，且双向线路的所有停靠站点都对应相同。设有M路公交路线，第j路公交路线有Nj个站点。所有公交线路累计共有S个站点，第k个站点的坐标为（Xk，Yk），所有坐标均以米为单位标注。邻近站点之间的距离指的是站点坐标之间的欧几里得距离。现有一人处于起点坐标（Xb，Yb），此人需要步行到最近站点乘车，下车后要步行到达的终点坐标为（Xe，Ye），而他特别不愿意走路，能坐公交就尽量坐公交。假定公交转乘时的步行距离为0，试编程求他从起点（Xb，Yb）到终点（Xe，Ye）的转乘次数最少的乘坐线路。

所有公交线路的站点坐标存放于“stops.txt”文件，其中第1行为站点总个数，第2行为第1个站点的坐标，第3行为第2个站点的坐标，以此类推。可用图形化的界面显示站点及公交线路。“stops.txt”文件的内容如下。
39
235 27
358 29
480 34
155 36
222 64
282 62
413 60
457 63
483 60
560 69
131 87
349 61
314 97
420 107
487 125
620 107
666 79
186 107
270 120
350 141
383 148
370 164
442 179
496 171
555 167
651 155
775 184
678 272
208 156
296 161
356 190
493 202
490 229
504 262
457 269
249 196
155 190
103 171
112 241

所有公交线路信息存放于“lines.txt”文件，其中第1行为公交线路总数，第2行为每条公交线路的站点总数，第3行为线路1经过的站点编号（对应站点坐标参见“stops.txt”），第4行为线路2经过的站点编号，以此类推。“lines.txt”文件的内容如下。

6
13 11 8 9 7 7
1 6 13 20 22 21 14 8 3 9 15 24 32
4 5 6 12 7 8 9 10 16 26 28
11 18 19 20 21 23 33 34
38 37 36 31 23 24 25 26 27
2 12 13 19 29 37 39
30 31 35 33 25 16 17

采用Dijkstra最短路径算法是不合适的，因为它仅考虑了站间距离，而未考虑沿公交线路行驶的约束。通过类型抽象形成站点、公交线路、转乘站点、转乘线路、转乘矩阵、公交系统等类，输入上述文件初始化站点和线路对象，然后通过图形化的界面显示站点和线路地图。用户用鼠标左键在地图上设定起点、鼠标右键确定终点，按照设定的最少转乘或者最短距离选项规划出从起点步行到最近站点上车、到离终点最近站点下车步行到终点的线路，在地图上用不同颜色显示规划线路若干秒，然后消除并恢复原始地图线路的颜色。

假设单位的信息存储在“organization.txt”文件，第1列存放单位名称，第2列单位坐标。“organization.txt”文件中的格式如下，可自己添加更多单位或坐标。

华中科技大学 990, 370
华乐山庄 500, 340
光谷中心花园 631, 367
光谷街北路 766, 472

用户可输入“华科大”或“华中科大”查询其所在位置，在编缉框中输入单位名称，在其下拉列表框中使用最大公共子串算法，进行模糊匹配以过滤掉相似度为0的名字，将剩下单位名按相似度从高到低排序，找到“华中科技大学”及其坐标。若加载一个汉字拼音字典，同时支持汉字输入和汉字拼音字首输入，并同时支持两种输入的模糊匹配则更好。在确定始发单位坐标和终点单位坐标后，按照设定的最少转乘或者最短距离选项规划线路，并在地图上用不同颜色显示规划线路若干秒，然后自动消除并恢复原始地图线路的颜色。

答案和代码参见《C++程序设计精要教程学习指导与习题解答》，实验5视频全程讲解参见34～36讲，实验自动评测程序库等资源可从人民邮电出版社下载。







========================================
《深入理解计算机系统（原书第三版）》
----------------------------------------
1. 书名
Computer Systems：A Programmer’s Perspective（所以它又被称为 CSAPP）
个人习惯把它翻译为程序员所需了解的计算机系统知识，尽管土了些，但更名副其实。


深入理解计算机系统 是我读过的最优秀的计算机系统导论型作品，它创造性的把操作系统，计算机组成结构，数字电路，以及编译原理这些计算机基础学科中的核心概念汇集在一起。

从而覆盖了指令集体系架构，汇编语言，代码优化，计算机存储体系架构，链接，装载，进程，以及虚拟内存这些程序员所需了解的关键计算机系统知识。

如果想打下扎实的计算机基础又不想把操作系统计算机结构编译原理这些书统统读一遍，阅读 深入理解计算机系统 是最有效率的方式。


2.注意

这是一门“这是一门 “稍有深度” 的计算机系统导论课程”，关于这本书的学习指南，这可以看下这篇文章：如何深入理解计算机系统？

最好拿出 1-2 个月的时间快速集中读完这本书，战线拉太长怕你看不下去了，学习过程中也可以记录一些思维导图，便于自己复习回顾。



3.最后：

这本书有 7 个配套的 Lab，是这本书的精华所在，强烈建议配合书一起服用，效果最佳，记忆最深刻。

其中我觉得最有意思的一个 Lab 就是 拆弹：CSAPP，拆弹到一点！！！




https://zhuanlan.zhihu.com/p/357200951
笔记: https://zhuanlan.zhihu.com/p/455061631






========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------


