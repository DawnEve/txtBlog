hinkPHP框架入门实战教程
http://study.163.com/course/introduction/702007.htm#/courseDetail

资深设计大师：http://blog.csdn.net/wuyanwen888?viewmode=contents


========================================
457 为什么使用框架？
----------------------------------------
为什么使用框架？
按照代码规范，MVC架构。
个人使用的优势：1.效率高；2.安全性高；3.稳定性好；
	新手需要基础扎实。需要修改，不好用的时候扩充。
企业团队和公司使用框架的优势：
		1.团队协作能力强；2.降低培训成本；3.去技术人员化；4.便于维护；  

		学习原生、框架、二次开发。自己制作框架。是个递进的过程。




========================================
458 thinkPHP安装与配置
----------------------------------------
文件结构。
	入口文件。检测版本、是否debug模式、应用模块、引入框架入口。
	一个应用就是一个网站，一个应用下有若干模块。模块是实现功能的地方。

	这是完整路径：http://tp.dawneve.cc/index.php/Home/Index/index
	
配置文件有多层，后面的会覆盖前面的配置。
	1.惯例配置（位于ThinkPHP/Conf/convention.php）：不建议修改。
	2.应用配置（默认位于Application/Common/Conf/config.php）：如果更改了公共模块的名称的话，公共配置文件的位置也相应改变。
	3.模式配置（ Application/Common/Conf/config_应用模式名称.php）：模式配置文件是可选的。
	4.调试配置：如果开启调试模式的话，则会自动加载框架的调试配置文件（位于ThinkPHP/Conf/debug.php）和应用调试配置文件（位于Application/Common/Conf/debug.php）
	5.状态配置：
	每个应用都可以在不同的情况下设置自己的状态（或者称之为应用场景），并且加载不同的配置文件。举个例子，你需要在公司和家里分别设置不同的数据库测试环境。那么可以这样处理，在公司环境中，我们在入口文件中定义：
		define('APP_STATUS','office');那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/office.php）。
	如果我们回家后，我们修改定义为：
		define('APP_STATUS','home');那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/home.php）。
	状态配置文件是可选的。
	6.模块配置：每个模块会自动加载自己的配置文件（位于Application/当前模块名/Conf/config.php）。



========================================
459 thinkPHP 模块化和URL模式
----------------------------------------
一般建立一个应用，应用之下设置2个模块。
	在入口文件如下定义，可以修改默认模块、默认控制器、默认操作
	//改成加载admin模块。默认加载的是Index模块
	//$_GET['m']='Admin';
	//改成加载admin控制器。默认加载的是Index控制器
	//$_GET['c']='Admin';

	
URL的默认1是pathInfo模式：
	http://tp.dawneve.cc/Index/login/usr/wjl/psw/123
	//模块化操作：模块/控制器/动作/参数
	function login($usr,$psw){
		echo 'index: Admin->login';
		echo '<hr>usr: ',$usr;
		echo '<hr>psw: ',$psw;
	}

	//修改pathinfo模式默认的分隔符/为-:
	模块的配置文件：
	//设置pathinfo模式的默认分隔符
	'URL_PATHINFO_DEPR'=> '-',
	之后访问：http://tp.dawneve.cc/Index-login-usr-wjl-psw-123
URL的0是普通模式：
	配置：'URL_MODEL'=>0,
	
	访问：http://tp.dawneve.cc/index.php?m=Home&c=Index&a=login&usr=wjl&psw=123
		  http://tp.dawneve.cc/index.php/Admin/Index/login.html?id=12
	
	
	修改键值对名称：模块m、控制器c、操作a
	配置文件：
	//修改键值对名称：模块m、控制器c、操作a
	//VAR_MODULE只能在应用配置文件中设置,其他参数可以则也可以在模块配置中设置 
	'VAR_MODULE'=>'mm',
	'VAR_CONTROLLER'=>'cc',
	'VAR_ACTION'=>'aa',
	访问：http://tp.dawneve.cc/index.php?mm=Admin&cc=Index&aa=login&usr=wjl&psw=123
3 REWRITE模式 
REWRITE模式是在PATHINFO模式的基础上添加了重写规则的支持，可以去掉URL地址里面的入口文件index.php，但是需要额外配置WEB服务器的重写规则。
	目前最清爽的写法，还有一个index.php，怎么办？
		http://tp.dawneve.cc/index.php/Admin/Index/login.html?id=12
	怎么把index.php去掉呢？
	[ Apache ]
1.httpd.conf配置文件中加载了mod_rewrite.so模块 
2.AllowOverride None 将None改为 All 
3.把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下 
<IfModule mod_rewrite.c>
 RewriteEngine on 
 RewriteCond %{REQUEST_FILENAME} !-d 
 RewriteCond %{REQUEST_FILENAME} !-f 
 RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
</IfModule>

	然后就可以了：
		http://tp.dawneve.cc/Index/login/usr/wjl/psw/123
		http://tp.dawneve.cc/Admin/Index/login.html?id=123
		
	其他服务器：iis和Nginx可以参考手册。
3 兼容模式：用不成pathinfo模式的情况，一般不用。
 
 
4.测试URL模式是如何影响U方法生成URL的格式的。
现在Home/Conf/config.php中设置
	//URL的模式
	'URL_MODEL'=>0,
	
再在控制器中定义BlogController.class.php 
	function login(){
		//C('URL_MODEL', 0);
		echo C('URL_MODEL') . ' - ';
	    echo U('User/login');
	}
访问 http://tp.dawneve.cc/blog/login后结果分别是：
	//0 - /index.php?m=&c=user&a=login
	//1 - /index.php/user/login.html
	//2 - /user/login.html
	//3 - /index.php?s=/user/login.html
	





========================================
460 thinkPHP模型初步(上)
----------------------------------------
1.先建表：
CREATE TABLE `think_user` (
  `id` int(10) NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user` varchar(20) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `add_time` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
2.插入数据：
insert into think_user(user,email,add_time)values
('张三','zhangs@qq.com','1451294372'),
('李四','lis@163.com','1451294372'),
('王二','wange@qq.com','1451294372'),
('Jim','jim@163.com','1451294372'),
('Tom','tom@live.com','1451294372'),
('Smith','smith@gmail.com','1451294372');


insert into think_user(user,email,add_time)values
('timoc','timoc@yahoo.com','1451294972');


3.连接数据库，在配置文件中写：
	//PDO连接方式是默认的，已经无法设置了。http://www.kancloud.cn/manual/thinkphp/1731
	//数据库配置信息
	'DB_TYPE'   => 'mysql', // 数据库类型
	'DB_HOST'   => '127.0.0.1', // 服务器地址
	'DB_NAME'   => 'think', // 数据库名
	'DB_USER'   => 'root', // 用户名
	'DB_PWD'    => '', // 密码
	'DB_PORT'   => 3306, // 端口
	'DB_PARAMS' =>  array(), // 数据库连接参数
	'DB_PREFIX' => 'think_', // 数据库表前缀 
	'DB_CHARSET'=> 'utf8', // 字符集
	'DB_DEBUG'  =>  TRUE, // 数据库调试模式 开启后可以记录SQL日志
===
	
4.	//页面调试开关
	'SHOW_PAGE_TRACE' => true,

5.可以使用默认db配置，也可以不用：
注意要引入 use Think\Model;//引入类文件命名空间
	function model(){
		echo 'model';
		$user=new Model('User','think_');
		dump($user->select());
	}
	
	function model2(){
		echo 'model2';
		//用于调用不是配置文件指定的数据库时
		$user=new Model('User','t_', 'mysql://root:@localhost:3306/test#utf8');
		dump($user->select());
	}
http://tp.dawneve.cc/index/model
http://tp.dawneve.cc/index/model2

6. 如果不想引入命名空间，则可以使用M方法：
	function model(){
		echo 'model';
		$user=M('User','think_');// 第三个参数是数据库链接信息
		dump($user->select());
	}
http://tp.dawneve.cc/index/model

	'DB_CONFIG2' => 'mysql://root:1234@localhost:3306/thinkphp';
	$user= new \Home\Model\BlogModel('blog','think_','DB_CONFIG2');
	dump($user->select());


7.配合UserModel类使用。
在Model文件夹下建立一个空的模型类：
<?php
namespace Home\Model;
use Think\Model;
class UserModel extends Model{
}

然后在控制器中写：
	use Home\Model\UserModel;
	
	function model3(){
		echo 'model3';
		//用于调用不是配置文件指定的数据库时
		$user=new UserModel();
		dump($user->select());
	}
访问：http://tp.dawneve.cc/index/model3
发现也是执行了
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` [ RunTime:0.0000s ]
2个语句。

也就是模型类和数据表一一对应，如：
模型类	对应的数据表
UserModel	think_user
UserTypeModel	think_user_type
 
8.在模型类中修改表前缀、表前缀
class UserModel extends Model{
	//protected $tablePrefix='t_';//修改表前缀
	//protected $tableName='abc';//修改表名 'think.think_abc' doesn't exist
	//protected $trueTableName='abc';//修改表真名 'think.abc' doesn't exist
	protected $dbName='test';//修改数据库名 'test.think_user' doesn't exist 
}


========================================
461 thinkPHP模型初步(下)
----------------------------------------
M() 不需要加载具体的模型类；速度会更快。
D() 必须配合模型类。

1.使用D()方法：

控制器中定义：
	function model4(){
		echo 'model4';
		//D方法
		$user=D('User');
		dump($user->select());
	}
模型类中定义：
<?php
namespace Home\Model;
use Think\Model;
class UserModel extends Model{
	protected $tablePrefix='t_';//修改表前缀
	protected $dbName='test';//修改数据库名 'test.think_user' doesn't exist 
}
访问：http://tp.dawneve.cc/index/model4
相应的sql语句：
SHOW COLUMNS FROM `test`.`t_user` [ RunTime:0.0010s ]
SELECT * FROM test.t_user [ RunTime:0.0000s ]

如果把模型类清空，则相应的sql语句：（注意数据库名和表前缀都变了！）
SHOW COLUMNS FROM `think_user` [ RunTime:0.0030s ]
SELECT * FROM `think_user` [ RunTime:0.0000s ]


2.怎么确定D方法来自UserModel呢？
在UserModel模型中添加构造函数：
	public function __construct(){
		parent::__construct();//调用父类的构造函数
		echo '[from UserModel->__construct()]<hr>';
	}
在控制器中定义：
	function model4(){
		echo 'model4';
		//D方法
		$user=D('User');
		dump($user->select());
	}
访问：http://tp.dawneve.cc/index/model4
调用的sql语句：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` [ RunTime:0.0000s ]
	
如果控制器中使用M()方法时：
	function model4(){
		echo 'model4';
		//D方法
		$user=M('User');
		dump($user->select());
	}	
访问：http://tp.dawneve.cc/index/model4	
并没有触发构造函数。

3. 同时D函数还有智能的地方：
我们删掉当前模块下的UserModel类，则会到同应用下的Common模块下寻找Model类，
<?php
namespace Common\Model;
use Think\Model;
class UserModel extends Model{
	function __construct(){
		parent::__construct();
		echo '[From common]';
	}
}
用D方法。
访问：http://tp.dawneve.cc/index/model4
触发构造函数，和sql语句：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` [ RunTime:0.0000s ]

4.如果把Common下的Model/UserModel类也删除呢？
发现没有触发构造函数，但是有sql语句。说明执行的Model基类。

5. 如果跨模块调用Model怎么办呢？
如前台模块想调用后台模块的Model:
Admin模块下有：
<?php
namespace Admin\Model;
use Think\Model;
class UserModel extends Model{
	function __construct(){
		parent::__construct();
		echo '[From Admin: Model]';
	}
}


控制器：
	function model5(){
		echo 'model5';
		//D方法
		$user=D('Admin/User');//调用其他模块的Model。
		dump($user->select());
	}
访问：http://tp.dawneve.cc/index/model5
结果触发了构造函数和sql语句。

6.想使用原生sql语句怎么办？
控制器如下：
	function model6(){
		echo 'model6';
		$user=M();//空M方法，可以使用原生sql查询。不用D，因为D会创建一个空Model再执行查询，速度慢
		dump($user->query('show tables;'));
		//dump($user->query('show databases;'));
	}
访问：http://tp.dawneve.cc/index/model6
触发的sql语句：
show tables; [ RunTime:0.0000s ]


7.字段缓存、应用缓存[todo:字段缓存如何做到的？]
这里先介绍字段缓存：第一次访问mysql时系统缓存表的字段，再次访问时直接从缓存文件读取。
（1）先关闭debug模式：首页入口文件中注释掉：
	// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false
	//define('APP_DEBUG',True);
（2）注意好runtime文件夹的变化：
访问：http://tp.dawneve.cc/index/model5
在Runtime/Data/_fields文件夹下看到一个think.think_user.php文件
里面的内容如下：
a:6:{i:0;s:2:"id";i:1;s:4:"user";i:2;s:5:"email";i:3;s:8:"add_time";s:3:"_pk";s:2:"id";s:5:"_type";a:4:{s:2:"id";s:7:"int(10)";s:4:"user";s:11:"varchar(20)";s:5:"email";s:12:"varchar(100)";s:8:"add_time";s:11:"varchar(30)";}}

同时注意到，第二次刷新时：http://tp.dawneve.cc/index/model5
仅触发了一条sql语句：
SELECT * FROM `think_user` [ RunTime:0.0000s ]
通过IO获取比通过数据库获取要快！有助于提高效率。

8.关闭缓存：
配置：
	//关闭字段缓存
	'DB_FIELDS_CACHE'=>false,//开启了调试模式，自动关闭字段缓存。这一句貌似没用。
控制器：
	function model7(){
		echo 'model7';
		$user=M('User');//缓存与否的影响
		dump( $user->getDbFields() );
	}
访问：http://tp.dawneve.cc/index/model7
发现没有触发sql语句。显示：
model7
array(4) {
  [0] => string(2) "id"
  [1] => string(4) "user"
  [2] => string(5) "email"
  [3] => string(8) "add_time"
}

然后调整表结构：
mysql> alter table think_user add modi_time varchar(30);
mysql> desc think_user;
+-----------+--------------+------+-----+---------+----------------+
| Field     | Type         | Null | Key | Default | Extra          |
+-----------+--------------+------+-----+---------+----------------+
| id        | int(10)      | NO   | PRI | NULL    | auto_increment |
| user      | varchar(20)  | YES  |     | NULL    |                |
| email     | varchar(100) | YES  |     | NULL    |                |
| add_time  | varchar(30)  | YES  |     | NULL    |                |
| modi_time | varchar(30)  | YES  |     | NULL    |                |
+-----------+--------------+------+-----+---------+----------------+
5 rows in set (0.00 sec)

而此时访问：http://tp.dawneve.cc/index/model7
依旧没有触发sql语句，显示：
model7
array(4) {
  [0] => string(2) "id"
  [1] => string(4) "user"
  [2] => string(5) "email"
  [3] => string(8) "add_time"
}

可见字段缓存依旧有效。除非删除掉缓存文件：
think\Runtime\Data\_fields\think.think_user.php
再刷新，就能看到新数据modi_time了：
model7
array(5) {
  [0] => string(2) "id"
  [1] => string(4) "user"
  [2] => string(5) "email"
  [3] => string(8) "add_time"
  [4] => string(9) "modi_time"
}


9. 也可以手工定义数据表字段的方式获取，可以提高性能，避免IO开销。
关闭调试模式时。
Model类中添加：
		protected $fields=array('id','user','email','_pk'=>'id');//其中_pk指定主键。
		
控制器：
	function model8(){
		echo 'model8';
		$user=D('User');//手工指定缓存字段，需要在Model类中自定义。使用D方法。
		dump( $user->getDbFields() );
	}
访问：http://tp.dawneve.cc/index/model8
结果没有触发sql语句，没有生成缓存文件，显示：
model8[from UserModel->__construct()]
array(3) {
  [0] => string(2) "id"
  [1] => string(4) "user"
  [2] => string(5) "email"
}

10.还可以在Model中指定数据类型，相当于验证：
模型中：
	//type定义每个字段的类型，可以永远字段验证。
	protected $fields=array('id','user','email','_pk'=>'id',
		'type'=>array('id'=>'smallint', 'user'=>'varchar')	);
	
访问：http://tp.dawneve.cc/index/model8
输出：
model8[from UserModel->__construct()]
array(4) {
  [0] => string(2) "id"
  [1] => string(4) "user"
  [2] => string(5) "email"
  ["type"] => array(2) {
    ["id"] => string(8) "smallint"
    ["user"] => string(7) "varchar"
  }
}

11.我们重新回到调试模式。


========================================
462 thinkPHP SQL查询语句（上）
----------------------------------------
基本查询、表达式查询。

1.打开调试模式
在UserCotroller中定义控制器：
	function select(){
		echo 'User->select():';
		$user=M('User');
		dump( $user->select() );//查询所有值
	}
访问：http://tp.dawneve.cc/user/select
结果：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` [ RunTime:0.0010s ]

2.where语句
控制器：
	function select2(){
		echo 'User->select():';
		$user=M('User');
		dump( $user->where('id=1')->select() );//查询id=1的条目
	}
访问：http://tp.dawneve.cc/user/select2
sql语句：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE ( id=1 ) [ RunTime:0.0000s ]

3.复杂where语句
	function select3(){
		echo 'User->select():';
		$user=M('User');
		dump( $user->where('id>=1 and email like "%qq.com"')->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` WHERE ( id>=1 and email like "%qq.com" ) [ RunTime:0.0000s ]


	function select3(){
		echo 'User->select():';
		$user=M('User');
		dump( $user->where('id>4 or email like "%qq.com"')->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0030s ]
SELECT * FROM `think_user` WHERE ( id>4 or email like "%qq.com" ) [ RunTime:0.0010s ]



4.使用数组索引方式访问：【推荐使用数组形式，更快】
	function select4(){
		echo 'User->select(4):';
		$user=M('User');
		$condition['id']=1;
		$condition['user']='tom';
		$condition['_logic']='or';//使用数组方式定义where条件
		dump( $user->where($condition)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE `id` = 1 OR `user` = 'tom' [ RunTime:0.0000s ]


5.使用对象的方式索引：
	function select5(){
		echo 'User->select(5):';
		$user=M('User');
		
		$condition=new \stdClass();//必须使用顶层命名空间
		$condition->id=1;
		$condition->user='tom';
		$condition->_logic='or';//使用对象方式定义where条件
		dump( $user->where($condition)->select() );//复杂where语句
	}
访问：http://tp.dawneve.cc/user/select5
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` WHERE `id` = 1 OR `user` = 'tom' [ RunTime:0.0000s ]


6.表达式查询
	//表达式查询
	function select6(){
		echo 'User->select(6):';
		$user=M('User');
		
		$map['id']=array('eq',1);
		
		dump( $user->where($map)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE `id` = 1 [ RunTime:0.0000s ]


	//表达式查询
	function select7(){
		echo 'User->select(7):';
		$user=M('User');
		
		$map2['id']=array('lt',3);
		$map2['user']=array('eq','Tom');
		$map2['_logic']='or';
		
		dump( $user->where($map2)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE `id` < 3 OR `user` = 'Tom' [ RunTime:0.0000s ]


	//表达式查询
	function select7(){
		echo 'User->select(7):';
		$user=M('User');
		
		$map2['id']=array('lt',3);
		$map2['user']=array('like','%i%');
		$map2['_logic']='or';
		
		dump( $user->where($map2)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE `id` < 3 OR `user` LIKE '%i%' [ RunTime:0.0000s ]


	//表达式查询
	function select7(){
		echo 'User->select(7):';
		$user=M('User');
		
		$map2['id']=array('lt',3);
		$map2['user']=array('notlike','%i%');
		$map2['_logic']='or';
		
		dump( $user->where($map2)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE `id` < 3 OR `user` NOT LIKE '%i%' [ RunTime:0.0000s ]



	//表达式查询
	function select7(){
		echo 'User->select(7):';
		$user=M('User');
		$map2['user']=array('like',array('%i%','%o%'),'and');
		
		dump( $user->where($map2)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SELECT * FROM `think_user` WHERE (`user` LIKE '%i%' AND `user` LIKE '%o%') [ RunTime:0.0010s ]

$map2['id']=array('between','1,3');//字符串形式
SELECT * FROM `think_user` WHERE `id` BETWEEN '1' AND '3' [ RunTime:0.0000s ]

$map2['id']=array('between',array(2,4));//数组形式
SELECT * FROM `think_user` WHERE `id` BETWEEN 2 AND 4 [ RunTime:0.0010s ]

$map2['id']=array('notbetween',array(2,4));
//$map2['id']=array('not between',array(2,4)); //这种形式也行
SELECT * FROM `think_user` WHERE `id` NOT BETWEEN 2 AND 4 [ RunTime:0.0000s ]

$map2['id']=array('in','1,3,4');
SELECT * FROM `think_user` WHERE `id` IN ('1','3','4') [ RunTime:0.0000s ]

$map2['id']=array('not in','1,3,4');
SELECT * FROM `think_user` WHERE `id` NOT IN ('1','3','4') [ RunTime:0.0010s ]


	//自定义查询
	function select8(){
		echo 'User->select(8):';
		$user=M('User');
		$map3['id']=array('exp','>=3');
		dump( $user->where($map3)->select() );//复杂where语句
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` WHERE `id` >=3 [ RunTime:0.0000s ]



========================================
463. thinkPHP sql查询（下）
----------------------------------------
1. 组合查询
	//组合查询
	function where(){
		echo 'User->where():';
		$user=M('User');
		$map3['_string']='id>5';//字符串查询条件
		dump( $user->where($map3)->select() );//复杂where语句
	}
SELECT * FROM `think_user` WHERE ( id>5 ) [ RunTime:0.0000s ]


	//组合查询 |
	function where2(){
		echo 'User->where2():';
		$user=M('User');
		$map3['id|email']=array('eq','3');//&是and，|是or
		dump( $user->where($map3)->select() );//复杂where语句
	}
SELECT * FROM `think_user` WHERE ( `id` = '3' OR `email` = '3' ) [ RunTime:0.0010s ]

2.统计查询
	//统计查询
	function where3(){
		echo 'User->where3():';
		$user=M('User');

		dump( $user->count() );
	}
访问：http://tp.dawneve.cc/user/where3
SELECT COUNT(*) AS tp_count FROM `think_user` LIMIT 1 [ RunTime:0.0000s ]


	//统计查询
	function where3(){
		echo 'User->where3():';
		$user=M('User');

		dump( $user->count('id') );//8
		dump( $user->count('email') );//8
	}
SELECT COUNT(id) AS tp_count FROM `think_user` LIMIT 1 [ RunTime:0.0000s ]
SELECT COUNT(email) AS tp_count FROM `think_user` LIMIT 1 [ RunTime:0.0000s ]


	//统计查询
	function where4(){
		echo 'User->where4():';
		$user=M('User');

		dump( $user->max('id') );//8
	}
SELECT MAX(id) AS tp_max FROM `think_user` LIMIT 1 [ RunTime:0.0080s ]


3.动态查询【借助于php5语言新特性】
	//动态查询getBy
	function dynamic(){
		echo 'User->dynamic():';
		$user=M('User');

		dump( $user->getByAddTime('1451294372') );
	}
SELECT * FROM `think_user` WHERE `add_time` = '1451294372' LIMIT 1 [ RunTime:0.0000s ]
	

命名规则：
可见对应关系中，getByAddTime对应字段为`add_time` 
需要在php中使用驼峰发命名，在mysql中使用下划线命名。

	//动态查询getFieldBy
	function dynamic2(){
		echo __method__;
		$user=M('User');
		dump( $user->getFieldByUser('Tom','id') );
	}
SELECT `id` FROM `think_user` WHERE `user` = 'Tom' LIMIT 1 [ RunTime:0.0000s ]

4.原生sql查询
	//sql查询：读
	function sql(){
		echo __method__;
		$user=M('User');
		dump( $user->query('select * from think_user;') );
	}
select * from think_user; [ RunTime:0.0000s ]


	//sql查询：写
	function sql2(){
		echo __method__;
		$user=M('User');
		dump( $user->execute('update think_user set modi_time="1451294972" where id=1;') );
	}
update think_user set modi_time="1451294972" where id=1; [ RunTime:0.0950s ]


========================================
464 thinkPHP sql连贯操作（上）
----------------------------------------
1.连贯操作
	function lg(){
		echo __method__;
		$user=M('User');
		dump( $user->where('id>5')->select() );//连贯操作
	}
SELECT * FROM `think_user` WHERE ( id>5 ) [ RunTime:0.0230s ]

2.加上order语句
	function lg2(){
		echo __method__;
		$user=M('User');
		dump( $user->where('id>4')->order('user DESC')->select() );//连贯操作
	}
SELECT * FROM `think_user` WHERE ( id>4 ) ORDER BY user DESC [ RunTime:0.0010s ]

3.加上limit语句
	function lg3(){
		echo __method__;
		$user=M('User');
		dump( $user->where('id>4')->order('user DESC')->limit(2)->select() );//连贯操作
	}
SELECT * FROM `think_user` WHERE ( id>4 ) ORDER BY user DESC LIMIT 2 [ RunTime:0.0000s ]


	function lg4(){
		echo __method__;
		$user=M('User');
		dump( $user->select(array(
			//'where'=>'id>5',//
			'where'=>array('id'=>array('neq',5)),
		)) );//连贯操作
	}
SELECT * FROM `think_user` WHERE `id` <> 5 [ RunTime:0.0010s ]

4.在select中添加参数
	function lg4(){
		echo __method__;
		$user=M('User');
		dump( $user->select(array(
			//'where'=>'id>5',//
			'where'=>array('id'=>array('neq',5)),
			'order'=>'user desc',
		)) );//连贯操作
	}
SELECT * FROM `think_user` WHERE `id` <> 5 ORDER BY user desc [ RunTime:0.0000s ]

5.使用in限制条件
	function lg5(){
		echo __method__;
		$user=M('User');
		dump( $user->where('id in(1,3,4,5)')->select() );//连贯操作
	}
SELECT * FROM `think_user` WHERE ( id in(1,3,4,5) ) [ RunTime:0.0000s ]

select()是显示说有条目；
find()是只显示一条数据。
delete(5)删除。

6.where可以多次调用。
	function lg6(){
		echo __method__;
		$user=M('User');
		$map['user']='Jim';
		$map['_logic']='Or';
		dump( $user->where($map)->where('id in(1,3)')->select() );//连贯操作
	}
SELECT * FROM `think_user` WHERE `user` = 'Jim' OR ( id in(1,3) ) [ RunTime:0.0000s ]

7.field指定需要返回到字段
	function lg7(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->field('id,user,email')->select() );//连贯操作field
	}
SELECT `id`,`user`,`email` FROM `think_user` [ RunTime:0.0160s ]

8.取出email字段左边5位
	function lg8(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->field(array('id','LEFT(email,5)'))->select() );//取出email字段左边5位
	}	
SELECT `id`,LEFT(email,5) FROM `think_user` [ RunTime:0.0000s ]

9.取出email字段左边5位，并重新命名字段
	function lg9(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->field(array('id','LEFT(email,5) as left5Email'))->select() );//取出email字段左边5位，并重新命名字段
	}	
SELECT `id`,LEFT(email,5) as left5Email FROM `think_user` [ RunTime:0.0300s ]

或者用数组指向来取别名：
dump( $user->field(array('id','LEFT(email,5)'=>'left5Email2'))->select() );//取出email字段左边5位，并重新命名字段
SELECT `id`,LEFT(email,5) AS `left5Email2` FROM `think_user` [ RunTime:0.0000s ]

10.limit用法
	function lg10(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->limit(2,1)->select() );//limit用法，从第2条开始，取出1条，就是3
	}
SELECT * FROM `think_user` LIMIT 2,1 [ RunTime:0.0000s ]


或者
dump( $user->limit(2)->select() );//limit用法，表示多少条

SELECT * FROM `think_user` LIMIT 2 [ RunTime:0.0000s ]


11.page用法
	function page(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->page(3,2)->select() );//分页的page：5、6
	}
每页2条，第三页就是从（3-1）*2起，选取2个：	
SELECT * FROM `think_user` LIMIT 4,2 [ RunTime:0.0000s ]

12.table用于切换表
	function table(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		dump( $user->table('test.t_user')->select() );//用于切换表
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SHOW COLUMNS FROM `test`.`t_user` [ RunTime:0.0780s ]
SELECT * FROM test.t_user [ RunTime:0.0590s ]
多查询一次。

或者：
dump( $user->table('__USER__')->select() );//用于切换表
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SHOW COLUMNS FROM `think_user` [ RunTime:0.0010s ]
SELECT * FROM `think_user` [ RunTime:0.0000s ]
多查询一次。todo?
dump( $user->table('__user__')->select() );//报错，也即是不能用小写。
请用'__USER__'代替think_user表。


dump( $user->table('__INFO__')->select() );//用于切换表
提示：Table 'think.think_info' doesn't exist 




再建立一个表
CREATE TABLE `think_info` (
  `id` int(10) NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `uid` int(10) DEFAULT NULL,
  `height` double(10,3) DEFAULT NULL,
  `weight` double(10,3) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into think_info(uid,height,weight)values
(1,183,80.5),
(2,150,90.8),
(3,172,67.3),
(4,163,54.3);




建立这个表之后：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]
SHOW COLUMNS FROM `think_info` [ RunTime:0.0010s ]
SELECT * FROM `think_info` [ RunTime:0.0000s ]


13.多表查询
在模块下定义一个函数：
Home/common/function.php
//排错
function MyDump($s,$isDetail=false){
	echo '<pre>';
	if($isDetail){
		var_dump($s);
	}else{
		print_r($s);
	}
	echo '</pre>';
}


	function table2(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		MyDump( $user->field('a.id,b.id')->table('__USER__ as a,__INFO__ as b')->select() );//多表查询
	}
SHOW COLUMNS FROM `think_user` [ RunTime:0.0030s ]
SHOW COLUMNS FROM `think_user` [ RunTime:0.0110s ]
SELECT a.id,b.id FROM think_user as a,think_info as b [ RunTime:0.0000s ]

或者：
MyDump( $user->field('a.id,b.id')->table(array('think_user'=>'a', 'think_info'=>'b'))->select() );//多表查询
SELECT a.id,b.id FROM `think_user` `a`,`think_info` `b` [ RunTime:0.0000s ]

========================================
465 thinkPHP sql连贯操作（下）
----------------------------------------
1.alias别名
	function table3(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		MyDump( $user->alias('a')->select() );//别名
	}
SELECT * FROM think_user a [ RunTime:0.0010s ]

2.group分组
	function table4(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('Info');
		MyDump( $user->field('id,SUM(weight) as sum')->group('uid')->select() );//别名
	}
SHOW COLUMNS FROM `think_info` [ RunTime:0.0020s ]
SELECT `id`,SUM(weight) as sum FROM `think_info` GROUP BY uid [ RunTime:0.0280s ]

3.添加注释
	function table5(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('Info');
		MyDump( $user->comment('查找身高体重')->select() );//添加注释
	}
仅仅是在sql中添加了一条注释：
SELECT * FROM `think_info` /* 查找身高体重 */ [ RunTime:0.0000s ]

4.join连接查询
	function table6(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		MyDump( $user->join('think_info ON think_user.id = think_info.uid ')->select() );//多表查询
	}
默认是：
SELECT * FROM `think_user` INNER JOIN think_info ON think_user.id = think_info.uid [ RunTime:0.0380s ]

MyDump( $user->alias('a')->field('a.id,a.user,b.height,b.weight')->join('think_info b ON a.id= b.uid')->select() );//内连接
SELECT a.id,a.user,b.height,b.weight FROM think_user a INNER JOIN think_info b ON a.id= b.uid [ RunTime:0.0010s ]

可以在join中添加第二个参数
MyDump( $user->alias('a')->field('a.id,a.user,b.height,b.weight')->join('think_info b ON a.id= b.uid','RIGHT')->select() );//右链接
SELECT a.id,a.user,b.height,b.weight FROM think_user a RIGHT JOIN think_info b ON a.id= b.uid [ RunTime:0.0010s ]

MyDump( $user->alias('a')->field('a.id,a.user,b.height,b.weight')->join('think_info b ON a.id= b.uid','LEFT')->select() );//左链接
SELECT a.id,a.user,b.height,b.weight FROM think_user a LEFT JOIN think_info b ON a.id= b.uid [ RunTime:0.0200s ]


5.UNION合并两个结果
	function table7(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		MyDump( $user->field('id')->union('select id from __INFO__')->select() );//UNION
	}

6.distinct('user')返回不重复的列

7.cache缓存内容：首次sql查询，第二次读取缓存内容
	function cache(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=M('User');
		MyDump( $user->select() );//cache
	}
没有缓存的时候：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0230s ]
SELECT * FROM `think_user` [ RunTime:0.0010s ]

改成：
		MyDump( $user->cache(true)->select() );//cache
之后，再刷新几次，发现sql语句只有一个了：
SHOW COLUMNS FROM `think_user` [ RunTime:0.0020s ]

8.命名范围
就是要把sql语句写到model中。


再建立一个表
CREATE TABLE `think_news` (
  `id` int(10) NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `uid` int(10) NOT NULL,
  `title` varchar(100) DEFAULT NULL,
  `content` text DEFAULT NULL,
  `add_time` varchar(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into think_news(uid,title,content,add_time)values
(1,'php7 is released','php7 content','1451629825'),
(2,'thinkPHP is released','thinkPHP content','1451629826'),
(4,'ci is released','ci content','1451629827'),
(4,'cakePHP is released','cakePHP content','1451629828');

注释掉对news模块的动态域名解析。

开始定义model：
<?php
namespace Home\Model;
use Think\Model;
class NewsModel extends Model{
	protected $_scope=array(
		'sql1'=>array(
			'where'=>array('id>1'),
		),
		'sql2'=>array(
			'order'=>array('add_time'=>'DESC'),
			'limit'=>2,
		),
		
	);

	function __construct(){
		parent::__construct();//这一句一定要加上！
		echo '<h1>from news model.</h1>';
	}
}

写模型：
	function scope(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=D('news');
		//MyDump( $user->scope()->select() );//SELECT * FROM `think_news` [ RunTime:0.0010s ]
		//MyDump( $user->scope('sql1')->select() );//SELECT * FROM `think_news` WHERE ( id>1 ) [ RunTime:0.0140s ]
		MyDump( $user->scope('sql2')->select() );//SELECT * FROM `think_news` ORDER BY `add_time` DESC LIMIT 2 [ RunTime:0.0440s ]
	}
SHOW COLUMNS FROM `think_news` [ RunTime:0.0530s ]
SELECT * FROM `think_news` ORDER BY `add_time` DESC LIMIT 2 [ RunTime:0.0010s ]


默认模型
	protected $_scope=array(
		'sql1'=>array(
			'where'=>array('id>1'),
		),
		'sql2'=>array(
			'order'=>array('add_time'=>'DESC'),
			'limit'=>2,
		),
		
		'default'=>array(
			'where'=>array('id>=1'),
		),
		
	);
调用：
	function scope(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=D('news');
		//MyDump( $user->scope()->select() );//SELECT * FROM `think_news` [ RunTime:0.0010s ]
		//MyDump( $user->scope('sql1')->select() );//SELECT * FROM `think_news` WHERE ( id>1 ) [ RunTime:0.0140s ]
		MyDump( $user->scope()->select() );//SELECT * FROM `think_news` ORDER BY `add_time` DESC LIMIT 2 [ RunTime:0.0440s ]
	}
sql语句：
SHOW COLUMNS FROM `think_news` [ RunTime:0.0030s ]
SELECT * FROM `think_news` WHERE ( id>=1 ) [ RunTime:0.0230s ]


或者这样直接调用sql语句
	function scope2(){
		echo '<hr>namespace:',__namespace__;
		echo '<hr>class:',__class__;
		echo '<hr>method:',__method__;
		
		$user=D('news');
		//MyDump( $user->scope()->select() );//SELECT * FROM `think_news` [ RunTime:0.0010s ]
		//MyDump( $user->scope('sql1')->select() );//SELECT * FROM `think_news` WHERE ( id>1 ) [ RunTime:0.0140s ]
		MyDump( $user->sql2()->select() );//SELECT * FROM `think_news` ORDER BY `add_time` DESC LIMIT 2 [ RunTime:0.0440s ]
	}	
SHOW COLUMNS FROM `think_news` [ RunTime:0.1250s ]
SELECT * FROM `think_news` ORDER BY `add_time` DESC LIMIT 2 [ RunTime:0.0000s ]




