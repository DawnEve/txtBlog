docker笔记

http://www.imooc.com/video/14623

下面开始本教程。
本教程能让你了解docker最基本的概念和操作。更细节的还需要看文档。

准备：
你需要熟悉基本的linux命令，同时有一个用于练习的用root权限的linux系统。可以是：
1.一个能登陆联网的ubuntu16.04服务器的终端。终端可以使linux命令行、windows下的git bash、windows下的putty等。服务器可以是虚拟机、物理主机、云主机。
2.或者 一台安装有ubuntu1604的联网电脑。


这个网页版测试挺好玩的 https://labs.play-with-docker.com/

docker image 仓库:
	https://quay.io/
	https://hub.docker.com/




========================================
docker 权威书籍
----------------------------------------
https://github.com/eduleboss/the-best-docker-books


一、《Docker: Up & Running》2015
https://www.oreilly.com/library/view/docker-up/9781491917565/

1. Learn how Docker simplifies dependency management and deployment workflow for your applications
简化依赖和部署流程

2. Start working with Docker images, containers, and command line tools
镜像、容器、命令行工具

3. Use practical techniques to deploy and test Docker-based Linux containers in production
生产环境下部署和测试docker容器

4. Debug containers by understanding their composition and internal processes
通过理解他们的构成和内部过程，调试容器

5. Deploy production containers at scale inside your data center or cloud environment
批量部署生产容器，在数据中心或云环境

6. Explore advanced Docker topics, including deployment tools, networking, orchestration, security, and configuration
docker高级话题： 部署工具，网络，编排，安全性和配置。




二、每天5分钟玩转Docker容器技术
容器技术是继大数据和云计算之后又一炙手可热的新技术，未来一段时间非常流行。

本书共分为三部分。
第一部分介绍容器技术生态环境。
第二部分是容器核心知识，包括架构、镜像、容器、网络和存储。
第三部分是容器进阶知识，包括多主机管理、跨主机网络方案、监控、日志管理和数据管理。









========================================
日常使用docker
----------------------------------------
1.常用语句
(1). 列举主机上的镜像 $ docker images

(2). 当你运行一个容器时，你可以这样指定一个带标签的镜像：
$ docker run -t -i ubuntu:14.04 /bin/bash
如果你想运行一个ubuntu 12.04镜像，你可以使用
$ docker run -t -i ubuntu:12.04 /bin/bash
不指定tag则默认使用 ubuntu:latest 镜像

(3). 获得一个新的镜像 $ docker pull centos

(4). 查找镜像 
官网搜索: hub.docker.com
命令行查询: $ docker search sinatra

docker公司提供或建立、验证和支持的。这类镜像可以用一个单词识别，比如 ubuntu
用户创建的镜像，有创建者的用户名前缀识，比如 training/sinatra 

查询标签
其实有更简单的v1 API，这个输出信息比较少，结果可以直接肉眼看。
$ curl -L -s https://registry.hub.docker.com/v1/repositories/biocontainers/vcftools/tags
[{"layer": "", "name": "0.1.14"}, {"layer": "", "name": "0.1.15"}, {"layer": "", "name": "v0.1.14_cv1"}, {"layer": "", "name": "v0.1.14_cv2"}, {"layer": "", "name": "v0.1.15_cv1"}, {"layer": "", "name": "v0.1.15_cv2"}, {"layer": "", "name": "v0.1.16-1-deb_cv1"}]
==> chrome 浏览器 F12 console:
> t2=[...]
> for(var i=0; i<t2.length; i++){console.log(t2[i].name)}
结果
v0.1.16-1-deb_cv1
v0.1.14_cv2
v0.1.15_cv2
v0.1.14_cv1
v0.1.15_cv1
0.1.14
0.1.15


(5). 拉取镜像 $ docker pull training/sinatra
默认是下载 training/sinatra:latest 
最好是指定标签。


(6). 运行镜像 
docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。
中间是选项。

$ docker run -t -i training/sinatra /bin/bash
root@a8cb6ce02d85:/#


(7)从主机中移除镜像  $ docker rmi training/sinatra
注意：从host中移除镜像，请确认没有基于该镜像的容器处于激活状态。


(8) 把对容器的修改提交为新的镜像版本
查看修改过的镜像的id (无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分)
$ docker ps -l

提交修改
$ docker commit 70de learn/ubuntu:20.04.vim
sha256:05df9b7565...

commit命令可以使用更多参数：-m指定评论（和git类似），-a指定此次更新的作者。
$ docker commit -m "install vim" -a "Robin Smith" 70de learn/ubuntu:20.04.vim2
sha256:31491...


查看构建镜像所用过的命令
$ docker history php:5.6.33-apache
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
9b87aacce8e4   3 years ago   /bin/sh -c #(nop)  CMD ["apache2-foreground"]   0B        
<missing>      3 years ago   /bin/sh -c #(nop)  EXPOSE 80/tcp                0B        
<missing>      3 years ago   /bin/sh -c #(nop) WORKDIR /var/www/html         0B        
<missing>      3 years ago   /bin/sh -c #(nop) COPY file:24613ecbb1ce6a09…   1.35kB    
<missing>      3 years ago   /bin/sh -c #(nop)  ENTRYPOINT ["docker-php-e…   0B   
...



(9) 检查容器IP地址等信息
$ docker inspect 98dd








2.启动故障排查
https://askubuntu.com/questions/977961/unit-docker-service-could-not-be-found
报错
$ sudo docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

查2点：
1)该sock文件是否是docker组？不是的话设置是。
srw-rw---- 1 root docker 0 Sep 12 23:13 /var/run/docker.sock

2)当前用户是否为docker组？不是的话加进去
$ id
uid=1001(wangjl) gid=1001(wangjl) groups=1001(wangjl),1004(docker)

$ sudo groupadd docker #添加docker用户组
$ sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中
Adding user wangjl to group docker

$ newgrp docker #更新用户组
$ groups #or $ id


3) 重启一下服务
$ sudo snap services
Service         Startup  Current   Notes
docker.dockerd  enabled  inactive  -

$ sudo snap start docker
Started.

$ sudo snap services
Service         Startup  Current  Notes
docker.dockerd  enabled  active   -






3.被断电重启工作站后，怎么恢复docker服务？
$ docker ps -a
$ docker start 72d
$ docker start b06

然后进入docker内部，启动apache 服务
$ sudo docker exec -it 72d bash
# service apache2 restart 
# exit













========================================
|-- docker 国内仓库
----------------------------------------
1.在中国，由于网络环境的特殊性，使用国外的Docker仓库可能会遇到访问速度慢或者无法访问的问题。因此，国内有一些常用的Docker仓库，如下：

1). 阿里云容器镜像服务（https://cr.console.aliyun.com/）：阿里云提供的容器镜像服务，速度快且稳定。可以通过阿里云账号登录并使用。

2). 腾讯云镜像仓库（https://cloud.tencent.com/document/product/457/9117）：腾讯云提供的容器镜像服务，同样速度较快。需要腾讯云账号登录并使用。

3). 网易云镜像仓库（https://c.163.com/hub#/m/home/）：网易云提供的容器镜像服务，速度也较快。需要网易云账号登录并使用。

4). DaoCloud镜像加速器（https://www.daocloud.io/mirror#accelerator-doc）：DaoCloud提供的镜像加速器，可以加速访问Docker Hub的速度。可以通过申请DaoCloud账号并设置镜像加速器来使用。

以上是一些常见的国内Docker仓库，可以根据个人需求选择合适的仓库来加速Docker镜像的拉取和推送。




2. 2024.7 国内镜像都不能用了
这个还能用：
$ sudo vim  /etc/docker/daemon.json
{
	"registry-mirrors": ["https://dockerhub.icu"]
}

$ sudo systemctl daemon-reload #重启守护进程
$ sudo systemctl restart docker


ref: 
时间: 2023-09-26  https://sg-info.cn/article/show/20193






========================================
|-- CentOS 7.9 安装最新版的 docker, 并把当前用户加入 docker 组
----------------------------------------
1. 安装 
$ sudo yum install -y yum-utils
$ sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
$ sudo yum install docker-ce docker-ce-cli containerd.io
根据提示，按两次y。

$ docker --version
Docker version 20.10.18, build b40c2f6
这是最新版，可以用了。


(2) 配置国内镜像加速
$ sudo vim /etc/docker/daemon.json 
{
  "registry-mirrors": [
    "http://hub-mirror.c.163.com",
    "https://registry.cn-hangzhou.aliyuncs.com"
  ]
}

$ sudo systemctl daemon-reload #重启守护进程
$ sudo systemctl restart docker








2. 把用户添加到docker组

(0) 新建用户
根据需要，把用户 tom 加入了 docker 组，就能免 sudo 使用 docker命令了。
$ usr=tom
$ sudo usermod -G docker ${usr}

查看某个用户是否在 docker 组
$ id tom




(1) 通过将用户添加到docker用户组可以将sudo去掉
https://linuxhandbook.com/docker-permission-denied/

1).查看自己是否在docker分组
$ cat /etc/group | grep docker # 查找 docker 组，确认其是否存在
## docker:x:978:hou,rqfu

# 如果 docker 组不存在，则添加之。查到了就不用添加该组
$ sudo groupadd docker 



2).添加自己到docker组
$ groups # 列出自己的用户组，确认自己在不在 docker 组中


将当前用户添加到 docker 组
$ sudo gpasswd -a ${USER} docker
Adding user wangjl to group docker

$ newgrp docker #更新用户组，或者重新登录，才能看到分组的变化

查看当前用户所在的组
$ groups 
docker jinwf
或者 id 命令 
$ id
uid=1017(wangjl) gid=980(docker) groups=980(docker),1001(jinwf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023



3) 重启 docker 服务
$ sudo service docker restart
Or
$ systemctl daemon-reload



4) 可以使用了
$ docker images
REPOSITORY                     TAG             IMAGE ID       CREATED         SIZE
gcc                            latest          feaa519db663   12 days ago     1.27GB




========================================
|-- /var/lib/docker目录迁移: 容器的存储目录
----------------------------------------
docker用起来简单，但是要用到实际线上业务当中细节问题往往影响整个系统的稳定，比如docker容器在物理机上的数据卷问题。docker默认的根目录是/var/lib/docker，容器使用一段时间后会发现该目录所占磁盘会非常大，小到几个G，大到上百G，而/var/lib/docker所在的分区往往不大，此时就需要将该目录迁移到一个物理空间比较大的分区中，并修改docker的默认根目录。

$ docker --version
Docker version 20.10.15, build fd82621


$ sudo docker info
Docker Root Dir: /var/lib/docker
Registry: https://index.docker.io/v1/




1. 停止docker服务。
$ sudo systemctl stop docker
或 
$ sudo service docker stop
$ service docker status




2. 创建新的docker目录
执行命令df -h,找一个大的磁盘。 我在 /home目录下面建了 /home/docker/lib目录，执行的命令是：
## mkdir -p /home/docker/lib

$ sudo mkdir /data/docker
$ sudo mkdir /data/docker/lib



3. 迁移 /var/lib/docker 目录下面的文件到 /home/docker/lib：
## rsync -avz /var/lib/docker /home/docker/lib/

$ sudo rsync -avz /var/lib/docker /data/docker/lib/
实际位置从 /var/lib/docker 变为 /data/docker/lib/docker
耗时: 14:25-->


还有人用 -P 参数: rsync -avzP /var/lib/docker/ /data/lib/docker





4、(跳过，可能是老方案，不一定可用了) 配置 /etc/systemd/system/docker.service.d/devicemapper.conf
查看 devicemapper.conf 是否存在。如果不存在，就新建。
$ sudo mkdir -p /etc/systemd/system/docker.service.d/
$ sudo vim /etc/systemd/system/docker.service.d/devicemapper.conf


然后在 devicemapper.conf 写入：（同步的时候把父文件夹一并同步过来，实际上的目录应在 /home/docker/lib/docker ）
[Service]
ExecStart=
ExecStart=/usr/bin/dockerd  --graph=/data/docker/lib/docker
#ExecStart=/usr/bin/dockerd  --graph=/home/docker/lib/docker




5. 修改
$ cat /etc/docker/daemon.json 
{
  "data-root": "/data/docker/lib/docker"
}



添加国内的源:
$ cat /etc/docker/daemon.json 
{
  "data-root": "/data/docker/lib/docker",
  "registry-mirrors": ["http://hub-mirror.c.163.com"]
}

或者 华中科技大学的源:
"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]



6.  重新加载 docker

# sudo systemctl daemon-reload  #加载配置文件
# sudo systemctl restart docker.service #重启服务
# sudo systemctl enable docker  #允许开机启动


$ sudo service docker start




7. 配置核查

docker info 命令检查Docker 的根目录.它将被更改为 /home/docker/lib/docker

$ sudo docker info | grep Root
 Docker Root Dir: /data/docker/lib/docker




8. 启动成功后，再确认之前的镜像还在：

$ docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
AAA/AAA               v2                  7331b8651bcc        27 hours ago        3.85GB
BBB/BBB               v1                  da4a80dd8424        28 hours ago        3.47GB


9、 确定容器没问题后删除 /var/lib/docker/ 目录中的文件。
$ sudo mv /var/lib/docker /var/lib/docker-can-delete
先重命名文件，放几周再删掉。

$ ls -lth /var/lib/ | grep docker
drwx--x---. 15 root           root            200 May 10 14:04 docker-can-delete
drwxr-xr-x.  2 root           root              6 May  6 13:42 docker-engine









==> 完成后可能出现的错误
1：docker-runc not installed on system
   解决：
cd /usr/libexec/docker/
ln -s docker-runc-current docker-runc


2. Unknown runtime specified docker-runc
    解决：
#特别注意：/var/lib/docker/containers/为docker默认的主目录，比如我们刚才迁移到了新的目录，这里也要跟着改
grep -rl 'docker-runc' /var/lib/docker/containers/ | xargs sed -i 's/docker-runc/runc/g'
systemctl stop docker
systemctl start docker

3. $ docker run -it -d ubuntu:14.04 bash
edf0a67bab483976a937c62659f1c22b86bce1e914866c5577af94f16ae20db9
docker: Error response from daemon: failed to start shim: mkdir /var/lib/containerd/io.containerd.runtime.v2.task/moby/edf0a67bab483976a937c62659f1c22b86bce1e914866c5577af94f16ae20db9: no space left on device: unknown.
这是磁盘满了，没办法，加硬盘吧。










========================================
|-- docker中使用bioconductor的R包  
----------------------------------------
R包的镜像资源：
https://hub.docker.com/r/bioconductor/
http://bioconductor.org/help/docker/


下载镜像（耗时步骤）
$ docker pull dawneve/bioconductor_core2
也可以下载官方镜像
下载的镜像可以改名字，比如nginx名字太长，改简单点。
# docker tag hub.c.163.com/library/nginx dawneve/nginx


查看镜像
$ docker images



##
To open a Bash shell on the container:
$ docker run -ti dawneve/bioconductor_core2 bash
Note: The docker run command is very powerful and versatile. For full documentation, type docker run --help or visit the help page.


To run R from the command line:
$ docker run -ti dawneve/bioconductor_core2 R


一般需要做个地址映射：
$ docker run -ti -v /home/wangjl/:/home/wangjl/ dawneve/bioconductor_core2 bash





##
To run RStudio Server:
$ docker run -it -p 8080:8787 -v /home/wangjl/docker_R:/home/wangjl/ -d dawneve/bioconductor_core2
然后使用主机的IP进行访问 http://IP:8080
-p端口映射  -p 实体机器:镜像内
-v文件映射  -v 实体机器:镜像内




##
进入已经运行的docker容器：
先查找容器ID
$ docker ps
CONTAINER ID        IMAGE                        COMMAND             CREATED             STATUS              PORTS               NAMES
7639e26e324a        dawneve/bioconductor_core2   "bash"              4 hours ago         Up 4 hours          8787/tcp            lucid_poincare

$ docker exec -it 7639e26e324a /bin/bash
或者简写为
$ docker exec -it 7639e bash #id可以用前几个字符，只要不产生歧义

直接 ctrl + d 或者直接输入 exit 退出即可。





##
here are two ways to modify these images:
	1. Making changes in a running container and then committing them using the docker commit command.
	2. Using a Dockerfile to declare the changes you want to make.
The second way is the recommended way. Both ways are documented here.
https://docs.docker.com/get-started/




========================================
|-- 安装docker版的wordpress (做文件和端口映射)
----------------------------------------
https://hub.docker.com/r/library/wordpress/


1.拉取镜像 
$ sudo docker pull wordpress:latest



2.准备数据库

登录上述docker版的mysql数据库
G:\xampp\mysql\bin> mysql -h y.biomooc.com -P 7070 -u root -p

新建 wordpress数据库；
> create database wordpress;

如果你想允许用户wp从ip为任何的主机连接到mysql服务器，并使用123456作为密码
> GRANT ALL PRIVILEGES ON *.* TO 'wp'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
> flush privileges;



3.启动wordpress容器
$ sudo docker run -it --name some-wordpress -e WORDPRESS_DB_HOST=y.biomooc.com:7070 -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=123456 -p 8080:80 -d wordpress
秒退。

$ sudo docker ps #发现这些容器都刚运行就退出了
$ sudo docker ps -a|grep Exited #查询容器ID
批量删除Docker中已停止的容器
$ sudo docker ps -a|grep Exited | cut -d" " -f 1 | xargs sudo docker rm

最后加一个长期执行的命令就可以了，bash：
$ sudo docker run -it --name some-wordpress -e WORDPRESS_DB_HOST=y.biomooc.com:7070 -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=123456 -p 8080:80 -d wordpress bash

进入docker内部
$ sudo docker exec -it 716c bash
启动apache服务器
# service apache2 restart 

# pwd
/var/www/html
# rm -rf *
# cp -r /usr/src/wordpress/* . #复制wordpress文件到www目录

浏览器打开 y.biomooc.com:8080

填写数据库信息：
DB: wordpress
usr: root 
psw: xxx
host: 192.168.2.120:7070
table_prefix:wp_





进入docker内部，使用head/tail/cat命令修改 wp-config.php中数据库一行，改为：
define('DB_HOST', 'p:192.168.2.120:7070');

可以正常访问web页面。











************
* 以下部分可以不看
************
4.排错
(1)使用p解决频繁链接失败的问题。
https://stackoverflow.com/questions/3210270/php-mysqli-connection-randomly-fails-with-cannot-assign-requested-address

<?php
$link = mysqli_connect('p:192.168.2.120:7070', 'wp', '123456');
if (!$link) {
die('Could not connect: ' . mysqli_error());
}
echo 'Connected successfully';
mysqli_close($link);
?>



(2)ERR_CONNECTION_RESET 连接已重置
https://blog.csdn.net/y472360651/article/details/79127285

尝试修改 C:\windows\system32\drivers\etc\hosts

加上服务器ip 域名，例如 
74.125.39.99 chrome.google.com
然后，访问就没问题了！





5.设置wordpress的尝试过程
进入docker内部
$ sudo docker exec -it 0e027 bash

(1)# find / -name "*wordpress*" 2>/dev/null
/usr/src/wordpress
...

(2)# find / -name "*apache*" 2>/dev/null
/etc/apache2
/etc/apache2/apache2.conf
...


(3)# service apache2 status #原来是apache服务没开
# service apache2 restart

再次访问y.biomooc.com:8080 ，提示
Forbidden
You don't have permission to access / on this server.
Apache/2.4.25 (Debian) Server at y.biomooc.com Port 8080

然后用cat命令新建一个/var/www/html/index.html文件，访问y.biomooc.com:8080显示该index.html文件。


(4)docker系统竟然没有文本编辑器，也安装不上去，有博客说需要更新系统
https://www.cnblogs.com/zr520/p/6083436.html

# apt-get update #这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。等更新完毕以后再敲命令：apt-get install vim
总是更新失败。
没办法，用head和cat命令编辑文件吧。。。

文件在本机读写出现问题，所以不能文件映射！//todo




========================================
谁在用docker? 怎么用？
----------------------------------------
1.docker是什么？
docker打包了代码及其运行环境，像虚拟机但更轻量化、更方便移植。
可用于可重复性研究，持续集成等。
免安装，拉取过来即可运行。解决了“在你电脑上能运行，在我的电脑上为什么运行不来啊？”的痛点。


2.有paper已经在推荐docker： 
Nature Biotechnology 2017 
Reproducibility of computational workflows is automated using continuous analysis: 
https://www.nature.com/articles/nbt.3780
"Docker, a container technology akin to virtual machines"

3.bioconductor发布的一直有docker镜像。
Bioconductor is also available as an AMI (Amazon Machine Image) and a series of Docker images.

http://www.bioconductor.org/help/docker/


4.我的docker主页: https://hub.docker.com/u/dawneve/



========================================
|-- docker简介、目的、原理、关键词
----------------------------------------
1.
docker作用
http://www.imooc.com/video/14609
docker在京东、淘宝、腾讯都有大规模应用。
docker和git的命令很相似。


2.
什么是docker

2010 dotCloud PAAS
2013 docker开源
2014.6 Docker1.0
2014.7 C轮 $4 000万
2015.4 D轮 $9 500万
至今 Docker 1.13

docker是一个装应用和环境的容器。构建、迁移、运行。
https://www.docker.com/
官网介绍: Docker is the world’s leading software container platform. 

download: https://download.docker.com/linux/ubuntu/dists/
代码托管在github： https://github.com/docker/docker-ce

跨平台，支持win,linux,Mac.


3.
理解docker

docker思想体现在docker的logo上。
docker思想：
	集装箱;
	标准化(运输方式/存储方式/API接口);
	隔离(比虚拟机更快，数秒启动)

docker解决的问题：
	我本地运行没问题啊?!: 打包环境和代码。
	系统好卡，哪个哥们写死循环了?!: docker是隔离的，只影响自己。
	双11来了，服务器撑不住了?!: 1台扩展成上万台很容易。

docker的原理: 单独的带有namespace的进程，该进程直接在物理机上跑；


4.docker是未来吗？Container War in 2016, docker VS Rocket:  
	docker注册了自己的商标，使用该名词都很麻烦。
	spec (specification:规范) 都是自己定义的。趋向于封闭。  
	docker将要做成容器类的github。  
	openStock?


5.总结
集装箱、标准化、隔离
镜像、容器、仓库(build ship run)
docker命令pull,build,run,stop,restart,exec...



========================================
|-- 走进docker的hello world
----------------------------------------
1.
docker的三个核心词汇： build(集装箱),ship(码头),run(运行的镜像就是容器).

docker镜像(image): 就是一系列文件，包括应用和环境。
	保存到本地了。linux下的联合文件系统(unifss)
	文件分层，底层镜像image都是只读的，顶层container才是可写的。
	构建镜像的目的，是为了方便在其他机器上运行。
docker容器(container):如果需要修改底层数据，则先拷贝到顶层，修改。而查找都是从上到下的，所以以后找到的都是修改过的最新部分。
	容器是可以修改的，而镜像不能修改，决定着镜像是稳定的。
docker仓库(repo): 先把镜像传到仓库，再在其他机器从仓库拉这个镜像。
	hub.docker.com，下载着很慢。
		浏览镜像： https://hub.docker.com/explore/
		我的仓库：https://hub.docker.com/r/dawneve/
	国内镜像： 
		c.163.com 网易蜂巢找不到镜像中心的问题：
			需要登陆，然后输入地址：https://c.163.com/hub#/m/home/
		https://www.docker-cn.com/registry-mirror
		https://www.zhihu.com/question/55135855
		http://mirrors.aliyun.com/
#


2. 实例
(1)ubuntu国内的安装，docker本身在ubuntu下开发的。
检查内核版本
# uname -r
4.10.0-28-generic

(2)系统自带安装，可能不是最新版本
#apt-get install docker 

最新版的安装
#curl -s https://get.docker.com | sh 

(3)安装好后查看版本
$ docker -v
$ docker --version
Docker version 19.03.8, build afacb8b

$ docker version
Client: Docker Engine - Community
 Version:           19.03.8
 API version:       1.40
 Go version:        go1.12.17
 Git commit:        afacb8b
 Built:             Wed Mar 11 01:27:04 2020
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.8
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.17
  Git commit:       afacb8b
  Built:            Wed Mar 11 01:25:42 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.13
  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429
 runc:
  Version:          1.0.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683



老版本的:
#docker version
Client:
 Version:      17.06.0-ce
 API version:  1.30
 Go version:   go1.8.3
 Git commit:   02c1d87
 Built:        Fri Jun 23 21:23:31 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.06.0-ce
 API version:  1.30 (minimum version 1.12)
 Go version:   go1.8.3
 Git commit:   02c1d87
 Built:        Fri Jun 23 21:19:04 2017
 OS/Arch:      linux/amd64
 Experimental: false

 
(4)拉取第一个docker镜像
#docker pull[option] NAME[:TAG] 拉取镜像
# docker pull hello-world
# docker pull dawneve/ping:latest
latest: Pulling from dawneve/ping
271134aeb542: Already exists
bb8612de0ef8: Pull complete
Digest: sha256:4ce09a01b4193e90d1314b470fc30e670ed619de5b5deb6d148294f10ae76446
Status: Downloaded newer image for dawneve/ping:latest


(5)#docker images [options] [repository][:tag] 查看本地多少镜像
# docker images
REPOSITORY       TAG     IMAGE ID	    CREATED	     SIZE
ubuntu	   latest  14f60031763d	2 weeks ago	 120MB
busybox	  latest  efe10ee6727f	2 weeks ago	 1.13MB
bioconductor/release_core2   latest  75b1bf6ef48b	3 weeks ago	 1.71GB
hello-world      latest  1815c82652c0	7 weeks ago	 1.84kB
learn/tutorial   latest  a7876479f1aa	4 years ago	 128MB

dawneve/ping	latest	5bd062e39404	17 months ago	139MB


(6)运行第一个docker容器
# docker run [options] IMAGE[:TAG] [COMMAND][ARG...]
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon. |客户端连接daemon
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.|daemon本地找不到，就从docker仓库拉取
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading. |daemon用该镜像创建容器，产生该文本
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.|daemon把信息输出给客户端，也就是那你的终端。

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

参数说明：
 -i : –interactive，交互界面。
 -t : –tty，伪终端界面。


Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/


还可以在容器内运行命令
# docker run dawneve/ping
hi
# docker run dawneve/ping ping baidu.com #测试ping命令
PING baidu.com (123.125.114.144) 56(84) bytes of data.
64 bytes from 123.125.114.144: icmp_req=1 ttl=54 time=5.51 ms

# docker run dawneve/ping uname -r #打印容器内系统的内核版本号
4.10.0-28-generic



========================================
|-- 查找镜像 dockers search xx
----------------------------------------
1. 简单使用

$ docker search seurat
NAME                                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
vibsinglecellnf/seurat                                                               0                    
zavolab/r-single-cell-analysis       R packages for single cell analysis: Seurat …   1                    
ngchm/rstudio-ngchm-sc               Variant of ngchm/rstudio-ngchm-bioc with sin…   0                    
satijalab/seurat                     Builds of CRAN releases of Seurat               4                    
sridnona/seurat_docker               docker image for seurat                         0                    
reetututeja/seurat                                                                   1                    
psandhey/seurat_docker                                                               1                    
mpaley/seurat_plus                   Seurat with additional packages                 0                    
shaleklab/seurat-env                 Seurat in RStudio environment with FIt-SNE a…   1                    [OK]




2. 自定义参数

$ docker search seurat4 --format "table {{.StarCount}}\t{{.Name}}\t{{.Description}}\t{{.IsOfficial}}"
STARS     NAME                                          DESCRIPTION                                     OFFICIAL
0         pnzakharov/seurat4                                                                            
0         austins2/seurat4                              R version 4.1.0 and Seurat version 4.0.3 in …   
0         irinashchukina/seurat4                                                                        
0         ghhenry/seurat4                                                                               
0         vanallenlab/seurat4-3-0_signac1-11-0_r4-1-0                                                   
0         camaralab/seurat4_monocle3                    R 4.1, Seurat4, Monocle3                        








========================================
|-- 推送与拉取镜像
----------------------------------------

1.
想推送需要有一个hub.docker.com账号。先去注册。


$ sudo apt install gnupg2 pass 先安装包，否则登录失败。
## https://stackoverflow.com/questions/50151833/cannot-login-to-docker-account/50569553


# docker login -u dawneve -p yourPassWord #登陆

# docker ps #查看容器
# docker commit 36279 dawneve/tomcat #提交一个新镜像

# docker images #查看镜像
root@ubt16:/home/wangjl# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
dawneve/bioconductor_core2   latest              5b8c5f497247        4 days ago          1.78GB
dawneve/jpress               latest              1159f08345b2        4 days ago          313MB
dawneve/tomcat               latest              b226d7ee3462        5 days ago          292MB
dawneve/nginx                latest              46102226f2fd        3 months ago        109MB
dawneve/mysql                latest              9e64176cd8a2        3 months ago        407MB


# 推送到docker hub 
# docker push dawneve/mysql
The push refers to a repository [docker.io/dawneve/mysql]

打开 hub.docker.com/u/dawneve 即可看到刚推送的镜像。






2.
拉取镜像不需要账号，只需要网络好即可。

其他地方想用该镜像，只需要拉取即可：
# docker pull dawneve/mysql 
而
# docker run -it xxx 时，如果本地找不到xxx镜像，则自动到hub.docker.com上拉取并运行该镜像。





3.当执行push或pull操作时，会为镜像生成摘要。
$ docker images --digests | head  #查看摘要
create, run, rmi以及Dockerfile的FROM镜像参考中使用摘要。比如按照摘要pull下来镜像
$ docker pull ouruser/sinatra@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf





========================================
|-- 镜像的转移和运输: 导出docker镜像到文件并压缩、 从文件解压并导入镜像
----------------------------------------
1.用途: 不同机器共享 docker 镜像。

(1)镜像的迁移，一个方法是传到仓库(公共或本地)，另一个是使用文件。
使用Docker save和Docker load命令来存储和载入镜像。

命令:
	对于容器，可以使用import和export 进行导入导出操作。
	对于已有镜像，可以使用 docker命令行的 save 和 load 命令来创建压缩包tarball。

(2) 压缩的优势
压缩后体积大幅减少。
	-rw-rw-r-- 1 wangjl wangjl  68M Apr 17 10:47 postgres_10.image.tar.gz
	-rw------- 1 wangjl wangjl 197M Apr 17 10:02 postgres_10.image.tar

	-rw-rw-r-- 1 wangjl wangjl  42M Apr 17 10:49 nginx_1.15.10.image.tar.gz
	-rw------- 1 wangjl wangjl 108M Apr 17 10:01 nginx_1.15.10.image.tar



2. 推荐导出压缩过的镜像 .tar.gz，节省磁盘空间
(1) 导出镜像并压缩：
docker save <myimage>:<tag> | gzip > <myimage>_<tag>.image.tar.gz

(2) 两个机器之间通过 scp 传输镜像文件。
$ scp from/path to/path/

(3) 解压并导入镜像：
gunzip -c <myimage>_<tag>.image.tar.gz | docker load

推荐命名后缀 <myimage>_<tag>.image.tar.gz
推荐命名间隔 <org>__<myimage>_<tag>.image.tar.gz


实例：镜像的导入和导出
$ docker save bdgenomics/rhapsody:1.9.1 | gzip > bdgenomics__rhapsody_1.9.1.image.tar.gz
$ gunzip -c bdgenomics__rhapsody_1.9.1.image.tar.gz | docker load








3. 导出未压缩过的，速度更快(跳过，一般别用)

docker save centos:latest -o /root/centos_latest.image.tar
docker rmi docker:latest
docker images
docker load -i /root/centos_latest.image.tar
docker images

导入 写法2: docker load < openjdk_8u212-jdk.image.tar
-i 是 --input 的缩写。


导入 写法3: 从tar包导入镜像，支持重命名镜像
$ cat jdk_9.0.1.tar| docker import - test/java:v9.0  
其他形式 
  docker import "jdk_9.0.1.tar" test/java:v9.0
  docker import jdk_9.0.1.tar test/java:v9.0 #推荐



(3) [可选] 第二步压缩，保留源文件:
$ gzip -c nginx_1.15.10.tar > nginx_1.15.10.tar.gz








##################################
# 之前的尝试
##################################
2. 保存镜像为文件

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB

命令 docker save -o 要保存的文件名  要保存的镜像
$ docker save -o rstudio.docker.tar  9e22c8cd092b

$ ls -lth
-rw------- 1 wangjl wangjl 1.9G Mar  3 14:19 rstudio.docker.tar


(2) 更多测试

1)或者生成gz压缩
$ docker save -o rstudio.docker.tar.gz  rocker/rstudio:latest
$ docker save -o rstudio.docker2.tar.gz  9e22c8cd092b

$ ls -lt
total 8122792
-rw------- 1 wangjl wangjl 1967693824 Mar  3 14:24 rstudio.docker2.tar.gz
-rw------- 1 wangjl wangjl 1967694848 Mar  3 14:21 rstudio.docker.tar.gz
-rw------- 1 wangjl wangjl 1967693824 Mar  3 14:19 rstudio.docker.tar

结论: 使用tag的比使用sha1的略大，而文件名是否gz结尾对大小没影响。


2) 尝试解压
$ tar zxvf rstudio.docker2.tar.gz 
gzip: stdin: not in gzip format
tar: Child returned status 1
tar: Error is not recoverable: exiting now
不能解压，说明不是个压缩文件。

# 尝试解包
$ tar -xvf rstudio.docker2.tar.gz 
解压到本文件夹内一堆数字开头的文件夹，说明就是一个tar文件，那就不要加gz结尾。

不过可以再压缩成gz文件
$ gzip -c rstudio.docker.tar > rstudio.docker0.tar.gz #-c保留原始文件

# 这下体积小了一半。
-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:32 rstudio.docker0.tar.gz




3) 最佳实践: 
- 生成的tar，压缩后得到gz文件，方便保存和传输。
- 使用tag备份，而不是image id。
$ docker save 9e22c8cd092b | gzip -c > rstudio.docker3.tar.gz  #导入时丢失tag信息
$ docker save rocker/rstudio:latest | gzip -c > rstudio.docker4.tar.gz  #最佳。带tag信息。

-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:40 rstudio.docker3.tar.gz
-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:59 rstudio.docker4.tar.gz

结论：docker save 的tar文件就可以gz压缩后备份到硬盘，或者复制到其他主机，解压后直接导入了。





3. 从文件载入镜像

docker load --input 文件
或者
docker load < 文件名
此时会导入镜像以及相关的元数据信息等。


首先使用SSH工具将文件上传到另一台服务器。

如果压缩过，则解压
$ gunzip -c rstudio.docker3.tar.gz > rstudio.docker3.tar

-rw-rw-r-- 1 wangjl wangjl 1967693824 Mar  3 14:44 rstudio.docker3.tar


############
我在本机操作的，所以先备份原来的镜像，然后删掉老镜像
$ docker tag rocker/rstudio:latest rocker/rstudio:old
$ docker rmi rocker/rstudio:latest
Untagged: rocker/rstudio:latest
$ docker images # 查看已经删掉了 rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB
############

然后通过命令载入镜像：
$ docker load < rstudio.docker3.tar
Loaded image ID: sha256:9e22c8cd092b6289d0765e08b682e2517cb7cef579baa871eec2362c9e43960d

docker images 没有发现新的镜像。主要是备份镜像的id是不变的。

如果彻底删除掉同id的image，再导入
$ docker images -a
<none>              <none>              9e22c8cd092b        11 days ago         1.95GB

$ 改名字
$ docker tag 9e22c8cd092b dawneve/rstudio
$ docker images




(2) 使用tag备份的文件导入呢？
$ docker load --input rstudio.docker.tar.gz #这个是直接导出的伪gz文件，本质是tar文件。
Loaded image: rocker/rstudio:latest

$ docker images
rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB

结论：看来使用tag备份最好！虽然略大了一点。






========================================
|-- docker中运行Nginx服务、修改docker镜像名字
----------------------------------------
(1)实践前奏：
	持久运行的容器
	前台挂起&后台运行
	进入容器内部

(2)复习命令
docker images 查看本地镜像。
docker pull 拉取镜像。
docker run 运行镜像

(3)找到并下载nginx镜像
# docker pull hub.c.163.com/library/nginx:latest

(4)查看本地镜像 
# docker images #又多了一行镜像信息
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hub.c.163.com/library/nginx   latest              46102226f2fd        3 months ago        109MB

(5)前台运行镜像
# docker run hub.c.163.com/library/nginx
发现没有任何反应。

查看后台运行的容器
新开一个终端，输入#docker ps
# docker ps
CONTAINER ID        IMAGE                         COMMAND                  CREATED              STATUS              PORTS               NAMES
3c2c46733af3        hub.c.163.com/library/nginx   "nginx -g 'daemon ..."   About a minute ago   Up About a minute   80/tcp              cranky_aryabhata
表明nginx确实在运行。

在第一个终端ctrl+C终止掉nginx后，再次docker ps查看，发现没有结果。

说明nginx最好在后台运行。

(6)后台运行容器
查看帮助文档 docker run --help
发现  -d, --detach   Run container in background and print container ID
于是，这样运行nginx容器：

# docker run -d hub.c.163.com/library/nginx
9319a08b6fd22e470c95cd80997409568f7c3b0bdf95281ab29c07208123e131
#
# docker ps
CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS               NAMES
9319a08b6fd2        hub.c.163.com/library/nginx   "nginx -g 'daemon ..."   5 seconds ago       Up 4 seconds        80/tcp              nostalgic_morse
root@ubt16:/home/wangjl#

发现容器id是一样的。

(7)进入容器内部 
#docker exec --help
Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
Run a command in a running container 在一个运行的容器内运行一条命令。
Options:
  -d, --detach               Detached mode: run command in the background
      --detach-keys string   Override the key sequence for detaching a container
  -e, --env list             Set environment variables
      --help                 Print usage
  -i, --interactive交互         Keep STDIN open even if not attached
      --privileged           Give extended privileges to the command
  -t, --tty 伪终端                  Allocate a pseudo-TTY
  -u, --user string          Username or UID (format: <name|uid>[:<group|gid>])
#docker exec 9319a08b6fd2 ls
# docker exec 9319a08b6fd2 service nginx status
nginx is running.

如果想长时间待在容器内部，则可以使用-it参数的如下命令：
root@ubt16:/home/wangjl# docker exec -it 9319a bash
root@9319a08b6fd2:/# ls #注意用户名已经变了。

查找nginx位置
root@9319a08b6fd2:~# which nginx
/usr/sbin/nginx

查看nginx服务是否运行
root@9319a08b6fd2:/# ps -ef
bash: ps: command not found
root@9319a08b6fd2:/# service nginx status
[ ok ] nginx is running.

退出容器# exit 

(8)停止镜像
# docker stop 931
931
# docker ps #已经没有运行的容器了。


(9)重新运行一个停止的容器/启动一个已经停止的容器实例
1) docker ps -a #找到停止的容器的id
2) docker start cea58c #重新运行该容器

docker ps 可以查看运行状态的容器。



(10)修改docker镜像名字
refer:https://stackoverflow.com/questions/25211198/docker-how-to-change-repository-name-or-rename-image
nginx名字太长，改简单点。
# docker tag hub.c.163.com/library/nginx dawneve/nginx
# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              1815c82652c0        7 weeks ago         1.84kB
dawneve/nginx                 latest              46102226f2fd        3 months ago        109MB
hub.c.163.com/library/nginx   latest              46102226f2fd        3 months ago        109MB





========================================
|-- docker的网络和端口映射-p参数
----------------------------------------
(1)docker网络
	pid namespace用来隔离进程用的，
	network namespace用来隔离网络的。
	网络类型：bridge有独立IP，host模式和主机一样，none时没有网络通信。
	端口映射: ech0是主机的网卡。端口映射是对bridge模式来说的。
		host模式时容器直接连接主机网卡；
		bridge模式时，容器虚拟网卡eth0与docker0网桥连接，网桥和主机eth0连；

$ ip addr
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:e1:d7:48:56 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:e1ff:fed7:4856/64 scope link 
       valid_lft forever preferred_lft forever
这是 docker 自己虚拟出来的网卡。


(2)查找端口映射的命令参数
# docker run --help  #参数太多，用port过滤一下
# docker run --help | grep port
      --expose list         Expose a port or a range of ports
      --health-retries int  Consecutive failures needed to report unhealthy
  -p, --publish list        Publish a container's port(s) to the host 开容器的一个端口到主机
  -P, --publish-all         Publish all exposed ports to random ports 容器所有端口到主机随机端口
都试试吧。

(3)尝试-p端口映射
root@ubt16:~# docker run -d -p 8080:80 dawneve/nginx # -p 主机端口:容器端口
a43468841f4280139b021ec320377a3d232b8e3c9a5c085c59b0c0e58d5a4814
root@ubt16:~# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
a43468841f42        dawneve/nginx       "nginx -g 'daemon ..."   15 seconds ago      Up 14 seconds       0.0.0.0:8080->80/tcp   mystifying_murdock

查看端口，发现主机已经监听8080端口。
root@ubt16:~# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在浏览器中输入主机IP(ubuntu下查ip用ifconfig命令)加上8080端口号，可以访问容器中的nginx服务了。
http://172.16.112.86:8080/
Welcome to nginx!

If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.

停止docker容器
# docker stop a43 
再次访问http://172.16.112.86:8080/，已经不能访问了。

(4)尝试-P端口映射
root@ubt16:~# docker run -d -P dawneve/nginx
245a25cc79ed2c3bd00d17a0509c7c51cf8989e4c9da2a69143a30bed86b2676
root@ubt16:~# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
245a25cc79ed        dawneve/nginx       "nginx -g 'daemon ..."   4 seconds ago       Up 3 seconds        0.0.0.0:32768->80/tcp   romantic_colden
#可见，docker随机在主机开一个32768映射到容器的80端口。

访问 http://172.16.112.86:32768/ ，可以看到nginx欢迎页面。




(5) 启动一个 tomcat 服务
$ docker pull tomcat:8.5.41 
$ docker run -d -p 81:8080 --name tom2 tomcat:8.5.41
使用浏览器查看，网页正常显示: http://192.168.2.120:81/

查看日志
$ docker container logs tom2
## Apache Tomcat/10.0.11

进入容器内部
$ docker exec -it tom2 bash
root@8b4b9bb40009:/usr/local/tomcat# 
# cd webapps/ROOT/
# mv index.jsp index.jsp2
# echo 'hello' >index.html
再看网页 http://192.168.2.120:81/ 显示 hello。
说明修改生效了。




========================================
|-- 运行和使用 docker版的mysql(文件映射-v)
----------------------------------------
1. 运行docker版的mysql
https://c.163.com/hub#/m/repository/?repoId=2955
# docker pull hub.c.163.com/library/mysql:latest #下载

查看网易页面上的帮助
Starting a MySQL instance is simple:
$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
... where some-mysql is the name you want to assign to your container, my-secret-pw is the password to be set for the MySQL root user and tag is the tag specifying the MySQL version you want. See the list above for relevant tags.
-e是指定环境变量

# docker run --name some-mysql3 -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest

# docker ps #最后的NAMES和设定的一样some-mysql3。
CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES
00df8c0d6559        hub.c.163.com/library/mysql:latest   "docker-entrypoint..."   13 seconds ago      Up 11 seconds       3306/tcp                 some-mysql3
f3a05abb2f2e        dawneve/jpress                       "catalina.sh run"        27 minutes ago      Up 27 minutes       0.0.0.0:8888->8080/tcp   sharp_bassi
root@ubt16:/home/wangjl/Documents#

#docker stop 00d #关掉mysql，做端口映射

# docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest
c130260481b50c03880ee034d6dafd01ca1cb72298c08e260ccb7016bf018a46

忘了创建数据库了，关掉，重启
# docker stop c1
# docker run -p 3306:3306 -e MYSQL_DATABASE=jpress_db -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest

# docker run -p 3306:3306 -e MYSQL_DATABASE=jpress_db -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest
2ff32e902b5f01710f947eba7900511b5695cae793b55a4ab7698a592928237e
# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES
2ff32e902b5f        hub.c.163.com/library/mysql:latest   "docker-entrypoint..."   3 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   nostalgic_jennings
f3a05abb2f2e        dawneve/jpress                       "catalina.sh run"        39 minutes ago      Up 39 minutes       0.0.0.0:8888->8080/tcp   sharp_bassi

#netstat -na|grep 3306 # 端口正常
tcp6       0      0 :::3306                 :::*                    LISTEN






2. 在windows上练习数据库。

1)启动ubuntu上docker中的数据库
$ sudo docker run -p 7070:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 dawneve/mysql
ee96cc19c63f5247d327b4d0010b8d0583f75a93cb1188a576339c65506e0064

解释:
 -p 是做端口映射，把主机的7070端口映射到docker上的3306.
 -d 后台运行 
 -it 进入容器内部
 -e 传入环境参数
 最后返回sha1码



2)windows下登陆数据库：
G:\xampp\mysql\bin>mysql -h y.biomooc.com -P 7070 -u root -p
解释：
 -h 是host名
 -P是指定port
 -u是mysql用户名
 -p是回车后输入密码


新建数据库wang，新建表user。
MySQL [(none)]> create database wang;
Query OK, 1 row affected (0.60 sec)

> use wang;
Database changed
> \s
...
> create table user(
    id int(4) not null primary key auto_increment,
    name char(20) not null,
    sex int(4) not null default '0',
    degree double(16,2));
Query OK, 0 rows affected (0.06 sec)

> show tables;
> desc user;

> insert into user values(1,'Tom',1,96.45),(2,'Joan',1,82.99), (3,'Wang',0, 96.59);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

> select * from user;
+----+--- ---+-----+- -------+
| id | name | sex | degree |
+----+--- ---+-----+- -------+
|  1 | Tom  |   1 |  96.45 |
|  2 | Joan |   1 |  82.99 |
|  3 | Wang |   0 |  96.59 |
+----+--- ---+-----+-- ------+
3 rows in set (0.03 sec)
重复n次如下语句，造数据。没特殊要求就重复1次好了。
> insert user(name,sex,degree) select name,sex,degree from user;


3)在ubuntu上重启该docker，则数据被重置，想保存数据，就需要做目录映射，把docker中的读写保存到ubuntu主机上。


在ubuntu上查看运行的docker的编号
$ sudo docker ps
CONTAINER ID        IMAGE
ee96cc19c63f        dawneve/mysql
进入docker文件内部，查看mysql文件：/opt/mysql_data  
$ sudo docker exec -it ee96 bash
root@ee96cc19c63f:/# find . -name "*wang*" | grep wang
./var/lib/mysql/wang
root@ee96cc19c63f:/var/lib/mysql/wang# ls -lth
total 112K
-rw-r----- 1 mysql mysql  96K Sep  6 08:36 user.ibd #2建立表格，插入数据，该文件增大。
-rw-r----- 1 mysql mysql 8.5K Sep  6 08:36 user.frm #2建立表格
-rw-r----- 1 mysql mysql   65 Sep  6 08:26 db.opt #1只有数据库时




4) docker cp命令可以实现docker容器内外文件的复制。
详情本页的专题。

$ docker cp outer.html ed7ee9:/var/www/html/  #外部文件复制到docker容器内
$ docker cp ed7ee90e50de:/var/www/html/index.html . #容器内文件复制到外部




5) 做文件映射(-v 主机目录:docker地址)吧
$ sudo docker stop ee96 
然后刚才创建的数据库数据全部消失了。

$ sudo docker run -p 7070:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql
3d08b2ab56277e32765d41e128dfa60b5cb1b8ffbf5ce371af5768d541818f14





6) 然后登陆mysql创建表格。同上述步骤2);
进入docker：
$ sudo docker exec -it 3d08 bash
docker内部能看到数据库文件：
root@3d08b2ab5627:/# cd /var/lib/mysql
root@3d08b2ab5627:/var/lib/mysql# ls -lth

在ubuntu主机上 /home/wangjl/dockerFile 也有很多数据库文件，这就是docker使用的文件。
这些文件保存在ubuntu主机上，不会随着docker的关闭或重启而消失。

我们重启 docker。
$ sudo docker restart 3d08
数据库中数据确实还在。




========================================
|-- 文件映射 -v参数
----------------------------------------
如果容器停止，则所有运行期间的数据就丢失了。
为了保存mysql运行期间的数据，可以把数据库文件映射到宿主主机上。



可以支持多个文件夹映射，映射之间用分号隔开，或者使用多个-v参数
$ docker run -p8080:80 -v /encoder/:/encoder/;/pyt_models/:/pyt_models/;/dataset/:/dataset/ -it actit_mount:latest

$ docker run -p8080:80 \ 
  -v $(pwd)/encoder/:/Docker/encoder/ \
  -v $(pwd)/pyt_models/:/Docker/pyt_models/ \
  -v $(pwd)/dataset/:/Docker/dataset/ \
  -it actit_mount:latest
#



(1)做文件映射 
# docker run -e MYSQL_ROOT_PASSWORD=123456 -d -p3306:3306 -v /opt/mysql_data:/var/lib/mysql hub.c.163.com/library/mysql

ubuntu下mysql的文件夹位置和权限：http://blog.csdn.net/wang794686714/article/details/39273385

(2)创建数据库
可以用宿主机ip登陆mysql。

mysql> create database wjl;
Query OK, 1 row affected (0.33 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wjl                |
+--------------------+
5 rows in set (0.01 sec)

发现在宿主机器上多了个wjl文件夹
root@ubt16:/opt/mysql_data# ls -tl
total 188480
drwxr-x--- 2 vboxadd vboxsf     4096 8月   6 06:16 wjl
root@ubt16:/opt/mysql_data# ls wjl
db.opt

(3)创建数据表
mysql> use wjl;
Database changed
mysql> create table goods(id int(10), name varchar(20));
Query OK, 0 rows affected (0.07 sec)

mysql> show tables;
+---------------+
| Tables_in_wjl |
+---------------+
| goods         |
+---------------+
1 row in set (0.00 sec)

在宿主机器上可见：
root@ubt16:/opt/mysql_data# ls wjl
db.opt  goods.frm  goods.ibd

(4)插入数据
mysql> insert into goods values(1,'pen');
Query OK, 1 row affected (0.01 sec)

mysql> insert into goods values(2,'apple');
Query OK, 1 row affected (0.04 sec)

mysql> select * from goods;
+------+-------+
| id   | name  |
+------+-------+
|    1 | pen   |
|    2 | apple |
+------+-------+
2 rows in set (0.72 sec)

宿主机
# ls wjl
db.opt  goods.frm  goods.ibd
root@ubt16:/opt/mysql_data# ls wjl -lt
total 112
-rw-r----- 1 vboxadd vboxsf 98304 8月   6 06:21 goods.ibd
-rw-r----- 1 vboxadd vboxsf  8586 8月   6 06:19 goods.frm
-rw-r----- 1 vboxadd vboxsf    65 8月   6 06:16 db.opt

添加一条记录
mysql> insert into goods values(3,'pie');
Query OK, 1 row affected (0.17 sec)

文件大小没变?!
root@ubt16:/opt/mysql_data/wjl# ls -lt
total 112
-rw-r----- 1 vboxadd vboxsf 98304 8月   6 06:24 goods.ibd
-rw-r----- 1 vboxadd vboxsf  8586 8月   6 06:19 goods.frm
-rw-r----- 1 vboxadd vboxsf    65 8月   6 06:16 db.opt



mysql文件简介
	ibdata是innodb引擎使用的
	如果是使用myisam引擎 则于ibdata无关  只是用frm myi myd
#



========================================
|-- 文件挂载 --mount type=bind,source=/tmp/eedqjde6,target=/TfavYp
----------------------------------------
1. 正常写法
$ docker \
    run \
    -it \
    --mount=type=bind,source=/tmp/eedqjde6,target=/TfavYp \
    --mount=type=bind,source=/tmp/3yyw1atf,target=/tmp \
    --mount=type=bind,source=/home/wangjl/test/cwl_test/Hello.java,target=/var/lib/cwl/stg0b1649c3-91bc-411e-b5d8-523aaab07ffc/Hello.java,readonly \
    --workdir=/TfavYp \
    --read-only=true \
    --user=1001:1001 \
    --rm \
    --cidfile=/tmp/bmuzwb7g/20210910161633-044329.cid \
    --env=TMPDIR=/tmp \
    --env=HOME=/TfavYp \
    openjdk:9.0.1-11-slim bash


另一种写法，效果一样
--mount type=bind,source=/data,target=/data


(2) -v 和 --mount 的区别
https://docs.docker.com/storage/bind-mounts/

1) --mount 支持挂载文件。
2) 如果宿主机上不存在某个文件夹， -v 会自动创建该文件夹，而 --mount 则直接报错。

If you use -v or --volume to bind-mount a file or directory that does not yet exist on the Docker host, -v creates the endpoint for you. It is always created as a directory.

If you use --mount to bind-mount a file or directory that does not yet exist on the Docker host, Docker does not automatically create it for you, but generates an error.

https://stackoverflow.com/questions/61316142/invalid-mount-config-for-type-bind-bind-mount-source-path-does-not-exist-ho






========================================
|-- 【debug】 docker 挂载报错: bind source path does not exist: 不要用 snap 装 docker，用 apt-get
----------------------------------------
1. 配置
$ docker --version
Docker version 20.10.8, build 3967b7d

## Ubuntu 18.04.5 LTS (GNU/Linux 4.15.0-147-generic x86_64) 

https://github.com/common-workflow-language/common-workflow-language/issues/927

(2) 其他同样的报错

https://stackoverflow.com/questions/64775609/docker-bind-source-path-does-not-exist-even-though-it-does
I fixed it by mounting the drive in a mount point in /mnt/. 
me: 可能临时文件夹不能是软链接？实验证明，可以。


https://stackoverflow.com/questions/48971065/getting-invalid-mount-config-for-type-bind-bind-source-path-does-not-exist-in

https://github.com/docker-archive/for-aws/issues/74
https://github.com/moby/moby/issues/34237
https://github.com/pterodactyl/panel/issues/1381
https://github.com/docker/docker.github.io/issues/4709


https://stackoverflow.com/questions/61316142/invalid-mount-config-for-type-bind-bind-mount-source-path-does-not-exist-ho
use -v instead of --mount





2. 我的报错 
(1) biomooc.com/linux/cwl_guide.html
$ cwl-runner arguments.cwl arguments-job.yml

INFO /home/wangjl/.local/bin/cwl-runner 3.1.20210825140344
INFO Resolved 'arguments.cwl' to 'file:///home/wangjl/test/cwl_test/arguments.cwl'
INFO [job arguments.cwl] /tmp/h6zf06_5$ docker \
    run \
    -i \
    --mount=type=bind,source=/tmp/h6zf06_5,target=/nxObrk \
    --mount=type=bind,source=/tmp/p23ipdh9,target=/tmp \
    --mount=type=bind,source=/home/wangjl/test/cwl_test/Hello.java,target=/var/lib/cwl/stg72616065-58f2-4277-a941-1a51cc29d7f0/Hello.java,readonly \
    --workdir=/nxObrk \
    --read-only=true \
    --user=1001:1001 \
    --rm \
    --cidfile=/tmp/8e1ay904/20210911105237-468410.cid \
    --env=TMPDIR=/tmp \
    --env=HOME=/nxObrk \
    openjdk:9.0.1-11-slim \
    javac \
    -d \
    /nxObrk \
    /var/lib/cwl/stg72616065-58f2-4277-a941-1a51cc29d7f0/Hello.java
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /tmp/h6zf06_5. 
See 'docker run --help'.
这里报错：说这个文件不存在。

^CTraceback (most recent call last):
  File "/home/wangjl/.local/bin/cwl-runner", line 11, in <module>
    sys.exit(main())
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/main.py", line 1249, in main
    tool, initialized_job_order_object, runtimeContext, logger=_logger
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 59, in __call__
    return self.execute(process, job_order_object, runtime_context, logger)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 148, in execute
    self.run_jobs(process, job_order_object, logger, runtime_context)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 255, in run_jobs
    job.run(runtime_context)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 852, in run
    self._execute(runtime, env, runtimeContext, monitor_function)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 343, in _execute
    default_stderr=runtimeContext.default_stderr,
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 992, in _job_popen
    monitor_function(sproc)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 869, in docker_monitor
    time.sleep(1)
KeyboardInterrupt



(2) 测试表明，该文件夹存在，但是 docker 不认
$ ls /tmp/h6zf06_5
$ 
$ ls /tmp/h6zf06_56
ls: cannot access '/tmp/h6zf06_56': No such file or directory

$ docker run -it \
    --mount type=bind,source=/tmp/h6zf06_5,target=/eMzMyO \
    --rm \
    --env=TMPDIR=/tmp \
    openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /tmp/h6zf06_5.
See 'docker run --help'.

$ docker run -it \
    --mount type=bind,source=/tmp,target=/eMzMyO \
    --rm \
    openjdk:9.0.1-11-slim bash #OK

# 难道是权限问题？
$ ls /tmp/ -lth | grep h6z
drwx------ 2 wangjl  wangjl  4.0K Sep 11 10:52 h6zf06_5 #ok

$ ls -lth / | head
drwxrwxrwt 138 root root 228K Sep 11 14:21 tmp #not OK



(3) 【不要轻易尝试这个】而使用-v 挂载则可以。可以后再用 --mount 也可以了
$ docker run -it \
    -v /tmp/h6zf06_5:/eMzMyO \
    --rm \
    --env=TMPDIR=/tmp \
    openjdk:9.0.1-11-slim bash
root@272c68f92492:/# ls /eMzMyO/

但是可以后 docker 内外的文件不能共享，ls都看不到！






3. 更多测试 
结论：只有自己的家目录可以，其他目录不行，指向其他目录的软链接也不行。

2)测试更多目录呢？
$ docker run -it --mount type=bind,source=/home/wangjl/test/cwl_test,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/wangjl/test/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/wangjl/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok 

$ docker run -it     --mount type=bind,source=/tmp/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
$ docker run -it     --mount type=bind,source=/var/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok

$ df -h | grep sd
/dev/sda2       234G  202G   20G  92% /
/dev/sda1       511M  6.5M  505M   2% /boot/efi
/dev/sdb        3.6T  2.5T  922G  74% /data

目前 / 的正常，试试 /boot/
$ docker run -it     --mount type=bind,source=/boot/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
为什么只有 /data/ 不行呢？
$ docker run -it     --mount type=bind,source=/data/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /data/.
See 'docker run --help'.

检查权限
/home/wangjl/test/cwl_test
drwxrwxr-x 4 wangjl wangjl 4.0K Sep 11 11:45 cwl_test
drwxrwxr-x 10 wangjl wangjl 4.0K Sep  9 16:53 test
drwxr-xr-x 60 wangjl  wangjl   68K Sep 11 14:23 wangjl

drwxr-xr-x   9 root root 4.0K Sep  3 15:36 home
drwxr-xr-x  10 root root 4.0K Sep  3 16:37 data # no, but same as /home


3)测试一个包含软链接的目录呢? /data/ 下都不行
$ docker run -it --mount type=bind,source=/home/wangjl/data/test/testCWL,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
报错：docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /home/wangjl/data/test/testCWL.
See 'docker run --help'.

$ ls -lth /home/wangjl/
lrwxrwxrwx  1 wangjl wangjl   12 Nov 12  2020 data -> /data/wangjl

使用绝对路径本身呢？也报错
$ docker run -it --mount type=bind,source=/data/wangjl,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /data/wangjl.
See 'docker run --help'.

4) 另一个软链接呢？
lrwxrwxrwx  1 wangjl wangjl   19 Aug 19  2020 index -> /var/www/html/index

$ docker run -it     --mount type=bind,source=/var/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
$ docker run -it     --mount type=bind,source=/var/www/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #no

drwxr-xr-x  15 root root 4.0K Jul 20  2018 var     #ok 
drwxr-xr-x  3 root root     4.0K Jul 20  2018 www #no

$ docker run -it --mount type=bind,source=/var/www/html/index,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /var/www/html/index.
See 'docker run --help'.

$ docker run -it --mount type=bind,source=/home/wangjl/index,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /home/wangjl/index.
See 'docker run --help'.


指向自己的 软链接呢？
$ cd ~
$ docker run -it     --mount type=bind,source=/home/wangjl/test,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ ln -s /home/wangjl/test/ newLinks
lrwxrwxrwx  1 wangjl wangjl   18 Sep 11 14:31 newLinks -> /home/wangjl/test/

$ docker run -it     --mount type=bind,source=/home/wangjl/newLinks,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
奇怪了，这个软链接也可以！
$ rm newLinks

$ cd ~/data
$ ln -s /home/wangjl/test/ /data/wangjl/newLinks
$ docker run -it     --mount type=bind,source=/data/wangjl/newLinks,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
只要在 /data 的都不行。



4. 难道是说有些磁盘格式不适合？
$ df -h | grep sd
/dev/sda1              511M  5.7M  506M   2% /boot/efi
/dev/sda2              234G  205G   18G  93% /
/dev/sdb               3.6T  2.5T  922G  74% /data

$ sudo fdisk -l >tmp.txt
$ grep -n sd tmp.txt
49:Disk /dev/sda: 238.5 GiB, 256060514304 bytes, 500118192 sectors
57:/dev/sda1     2048   1050623   1048576  512M EFI System
58:/dev/sda2  1050624 500117503 499066880  238G Linux filesystem
61:Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors

Disk /dev/sda: 238.5 GiB, 256060514304 bytes, 500118192 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disklabel type: gpt
Disk identifier: 50C196AA-2E44-4E72-8B08-D469A451AC0B

Device       Start       End   Sectors  Size Type
/dev/sda1     2048   1050623   1048576  512M EFI System
/dev/sda2  1050624 500117503 499066880  238G Linux filesystem

Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes

也就是说 sdb 没有分区，没有文件系统？

$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 238.5G  0 disk 
├─sda1   8:1    0   512M  0 part /boot/efi
└─sda2   8:2    0   238G  0 part /
sdb      8:16   0   3.7T  0 disk /data

$ df -lhT #看第二列，都是 ext4 格式的。
Filesystem     Type      Size  Used Avail Use% Mounted on
udev           devtmpfs   16G     0   16G   0% /dev
tmpfs          tmpfs     3.2G  4.5M  3.2G   1% /run
/dev/sda1      vfat      511M  5.7M  506M   2% /boot/efi
/dev/sda2      ext4      234G  205G   18G  93% /
/dev/sdb       ext4      3.6T  2.5T  922G  74% /data


5. 尝试不行的位置，使用 -v 
$ docker run -it     --mount type=bind,source=/data/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No

$ docker run -it     -v /data/:/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
docker: Error response from daemon: error while creating mount source path '/data': mkdir /data: read-only file system.

$ docker run -it     -v /data/wangjl:/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
docker: Error response from daemon: error while creating mount source path '/data/wangjl': mkdir /data: read-only file system.





6. 用 nsenter 进 dockerd 进程的 mount namespace 看看，/data 是否存在
【学霸】17-软件╰Jian 22:28:53 QQ群高手指教。

(1) 如果存在的话还不能访问那可能是 docker 的问题
不存在的话再看

$ ps -aux | grep docker
root        1032  0.2  0.2 2157984 91868 ?       Ssl  19:54   0:25 dockerd --group docker --exec-root=/run/snap.docker --data-root=/var/snap/docker/common/var-lib-docker --pidfile=/run/snap.docker/docker.pid --config-file=/var/snap/docker/796/config/daemon.json
root        1411  0.3  0.1 1946568 48316 ?       Ssl  19:54   0:38 containerd --config /run/snap.docker/containerd/containerd.toml --log-level error
root        1517  0.0  0.2 2048712 77528 ?       Ssl  19:54   0:04 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     73749  0.0  0.0   6432  2656 pts/1    S+   22:37   0:00 grep --color=auto docker


$ sudo nsenter -m -t1032
-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
root@sustc-HG:/# ls /data
ls: cannot access '/data': No such file or directory
root@sustc-HG:/# ls /home
chengww  hgyi  linuxbrew  wangjl  wuxc  yinch  zxl
root@sustc-HG:/# exit
logout

果然找不到 /data 目录。












7. 重装 docker 
(1) $ docker --version
Docker version 20.10.8, build 3967b7d

1) 卸载
如何干净卸载 docker: https://www.cnblogs.com/shmily3929/p/12085163.html

$ sudo apt remove docker
$ sudo apt-get autoremove docker docker-ce docker-engine  docker.io  containerd runc
$ docker --version
-bash: /usr/bin/docker: No such file or directory

$ sudo apt-get remove docker docker-engine docker.io containerd runc



2) 重新安装（这个就是snap安装步骤，不能用！）
$ sudo apt-get update

$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

$ sudo apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]

$ sudo add-apt-repository \
   "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \
  $(lsb_release -cs) \
  stable"


$ whereis docker
docker: /etc/docker /snap/bin/docker.compose /snap/bin/docker.machine /snap/bin/docker /snap/bin/docker.help

版本太古老：
$  /snap/bin/docker --version
Docker version 19.03.13, build cd8016b6bc

## 卸载 snap 安装的 Docker
$ sudo snap remove docker






3) apt 安装 
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io 

$ docker --version
Docker version 20.10.8, build 3967b7d

$ sudo service docker status #active

$ ps -aux | grep docker
root       97273  0.4  0.2 1974732 77952 ?       Ssl  23:13   0:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     97587  0.0  0.0   6432   668 pts/1    S+   23:14   0:00 grep --color=auto docker

$ whereis docker
docker: /usr/bin/docker /etc/docker /usr/libexec/docker /usr/share/man/man1/docker.1.gz

$ /usr/bin/docker --version
Docker version 20.10.8, build 3967b7d

Docker的命名空间中可以找到该硬盘
$ ps -aux | grep docker
root       97273  0.3  0.2 1975672 85152 ?       Ssl  23:13   0:01 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     98355  0.0  0.0   6432   664 pts/1    R+   23:19   0:00 grep --color=auto docker
wangjl@sustc-HG:~$ sudo nsenter -m -t97273
root@sustc-HG:/# ls /data
chengww  hgyi  lost+found  public  wangjl  wuxc  yinch  zxl
root@sustc-HG:/# ls /home
chengww  hgyi  linuxbrew  wangjl  wuxc  yinch  zxl


$ docker pull hub.c.163.com/library/node:slim
$ docker run -it     -v /data/:/eMzMyO     --rm     hub.c.163.com/library/node:slim bash #ok







8. 清理残留文件 https://www.cnblogs.com/etoumao/p/12688286.html

注意到 docker images 显示的镜像是不一样的。
也就是 snap 安装的 docker，和 apt 安装的 docker 不共享镜像文件。
他们的文件夹在哪里呢？

//todo 






###############
使用 ubuntu16 虚拟机测试一下：snap 安装的 docker 只能挂载 $HOME 目录。
$ sudo snap install docker



$ sudo fdisk -l
[sudo] password for george: 
Disk /dev/sda: 50 GiB, 53687091200 bytes, 104857600 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x82602f22

Device     Boot     Start       End   Sectors Size Id Type
/dev/sda1  *         2048 100663295 100661248  48G 83 Linux
/dev/sda2       100665342 104855551   4190210   2G  5 Extended
/dev/sda5       100665344 104855551   4190208   2G 82 Linux swap / Solaris

$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            971M     0  971M   0% /dev
tmpfs           200M   12M  189M   6% /run
/dev/sda1        48G  5.4G   40G  12% /
tmpfs           997M  272K  997M   1% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           997M     0  997M   0% /sys/fs/cgroup
00              243G  5.5G  237G   3% /media/sf_00
tmpfs           200M   72K  200M   1% /run/user/1000
/dev/sr0         56M   56M     0 100% /media/george/VBox_GAs_5.2.8











ref:
不能使用 snap 安装Docker，要用 apt-get 安装 https://github.com/moby/moby/issues/34427
https://github.com/docker/docker.github.io/issues/4709 跟帖
https://github.com/docker/docker.github.io/issues/13503 又开了一个帖










========================================
|-- docker cp 命令： Docker与外部主机互传文件
----------------------------------------
前置条件：一个已经运行的nginx容器，做过端口映射



1.把外部文件复制到docker容器中
http://qa.supermap.com/23274?show=23274

docker cp 本地主机文件路径 容器id://usr/share/nginx/html

(1)查正在运行的容器id
$ docker ps
CONTAINER ID IMAGE COMMAND  CREATED        STATUS         PORTS                    NAMES
ed7ee90e50de 9376e "bash"   12 minutes ago Up 12 minutes  0.0.0.0:7000->80/tcp     tender_meninsky

(2) 在容器内新建文件路径，现有路径可以直接用
$ docker exec -it ed7ee90 bash
# mkdir -p /var/www/html/
# exit

(3) 将外部文件拷贝到容器
$ docker cp outer.html ed7ee9:/var/www/html/

访问 http://y.biomooc.com:7000/outer.html 可以看到内容。



(4)此时，可以对容器进行提交，生成一个新的镜像，该镜像将包含添加到nginx里面的outer.html页面。
示例命令：docker commit -m '注释' 容器id 自定义镜像名
完整命令：docker commit -m 'a new nginx container with outer.html' ed7ee90e50de george/static_web:addOuterFile
sha256:1222d23b39e9a5fa9b8f7d7ae71

还有参数 -a "auther name"

(5)使用docker images列出所有的容器，可以看到容器first-nginx在其中。
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
george/static_web   addOuterFile        1222d23b39e9        46 seconds ago      151MB
george/static_web   latest              9376e822266c        2 hours ago         151MB






2.将外部主机文件拷贝到Docker容器

将nginx容器中的文件复制到本地需要调换一下参数位置。

示例命令：docker cp nginx容器id://usr/share/nginx/html/index.html 本地主机文件路径
完整命令：
$ docker cp ed7ee90e50de:/var/www/html/index.html .





========================================
|-- docker 单行运行 shell命令、指定工作目录
----------------------------------------
1. 如果是简单的一条命令，可以通过在docker run的最后写上命令的方式运行：
$ docker run -ti --network=host --name mc_controller IMAGE_NAME python3 src/controller.py


2. 如果要运行多条shell命令：
$ docker run -ti --network=host --name mc_controller IMAGE_NAME /bin/sh -c  'cd src && python controller.py'

注意最后的命令形式 bash -c 'cmd1 && cdm3'


例子:
在容器中编译java 
$ docker run -v /home/wangjl/test/cwl_test:/home/wangjl/ openjdk:9.0.1-11-slim bash -c 'cd /home/wangjl/ && javac Hello.java'



3. 更好的方法是指定工作目录  --workdir=/var/spool/cwl \

$ docker run --rm \
--volume=/home/wangjl/:/home/tom/:rw \
--volume=/data/wangjl/test/testCWL/Hello.java:/home/tom/Hello.java:ro \
--workdir=/home/tom/ \
openjdk:9.0.1-11-slim \
javac Hello.java







========================================
|-- 理解 docker 容器中的 uid 和 gid
----------------------------------------

1. 默认是使用 root 进入容器的
$ docker run --name test1 --rm -it -d -v /home/wangjl/:/home/test ubuntu:20.04 bash

$ docker exec -it test1 bash
root@1b4df2d5d33e:/# cd /home/test
root@1b4df2d5d33e:/home/test# touch 001.txt
root@1b4df2d5d33e:/home/test# exit
exit
可见，容器内使用root登录了。

$ ls -lth
total 136K
-rw-r--r--  1 root   root      0 Oct 19 10:46 001.txt
容器内创建的文件，在宿主机中查看权限，也是 root。


停止容器
$ docker stop test1






2. 怎么使用宿主机用户登录呢？添加 -u 参数
(1) 查询宿主机当前登录用户 wangjl, uid=1001
$ id
uid=1001(wangjl) gid=1001(wangjl) groups=1001(wangjl),1004(docker)

(2) 添加参数 -u 
# docker run --user 0 -d test
-u, --user string        Username or UID (format: <name|uid>[:<group|gid>])

$ docker run --name test1 -u 1001:1001 --rm -it -d -v /home/wangjl/:/home/test ubuntu:20.04 bash

$ docker exec -it test1 bash #测试表明，这里加不加 -u 1001:1001 效果一样。
I have no name!@84d106c3f8dd:/$ cd /home/test/
I have no name!@84d106c3f8dd:/home/test$ touch 002.txt
I have no name!@84d106c3f8dd:/home/test$ exit
exit

宿主机文件权限正常了
-rw-r--r--  1 wangjl wangjl    0 Oct 19 11:00 002.txt






3. 风险: docker 理论上能修改主机上的任何文件

(1) 容器内的 root 用户和宿主机上的 root 用户是同一个吗？
答案是：是的，它们对应的是同一个 uid。原因我们在前面已经解释过了：整个系统共享同一个内核，而内核只管理一套 uid 和 gid。
而且即便容器内外只共享uid和gid，不共享用户名，组名。权限是依赖id的，也就是说可以使用容器修改一些普通用户无法修改的内容。

docker run -u 可以指定宿主机运行docker命令的用户， -u指定的uid就是docker实际运行的进程拥有者。



(2) 一个 docker 组的用户，在 docker 内部修改 /etc/sudoers 文件。

$ docker run --name test1 --rm -it -v /etc/:/home/test ubuntu:20.04 bash
root@06095e8b8e4d:/# cd /home/test/
root@06095e8b8e4d:/home/test# echo "#test this" >> sudoers
root@06095e8b8e4d:/home/test# exit
exit
$ sudo tail -n 1 /etc/sudoers
#test this


完整测试了一下，把新人加入docker组，他自己确实可以拿到sudo。https://blog.csdn.net/wangjunliang/article/details/120842914
如何解决该风险？
issue: https://github.com/docker/for-linux/issues/1318#issuecomment-946433109
回答1: There is a rootless mode to prevent that。貌似还不成熟。






4. 应用

(1) 这样安装在本地的文件所有者是 root ，普通用户无法删除、更新等。
$ docker run -it --rm  --name ryan  \
-v `pwd`:`pwd`  \
-w `pwd`  node \ 
npm install --registry=https://registry.npm.taobao.org

加上 -u 1001:1001 ，前面是 id wangjl 查到的uid，冒号后面是 gid，则使用该用户进入容器内部，一切正常。








ref:
https://blog.csdn.net/zhu7478848/article/details/88824064
https://www.cnblogs.com/woshimrf/p/understand-docker-uid.html






========================================
|-- 指定工作目录 -w / --workdir
----------------------------------------
-w, --workdir string      Working directory inside the container


1. 不指定工作目录
$ docker run --rm -it -v /home/wangjl/:/home/test ubuntu:20.04 bash
root@7bc3e4457e06:/# pwd
/
root@7bc3e4457e06:/# exit
exit



2.指定工作目录后，进入容器就自动切换到工作目录

$ docker run --rm -it -v /home/wangjl/:/home/test \
-w /home/test \
ubuntu:20.04 bash

root@840d01943c9d:/home/test# pwd
/home/test


(2) 为了易读性，可以使用参数全拼
$ docker run --rm -it -v /home/wangjl/:/home/test \
--workdir /home/test \
ubuntu:20.04 bash














========================================
制作自己的docker镜像: Dockerfile文件
----------------------------------------
有两种方法更新和创建镜像：commit 变动的容器获得新镜像，或者通过Dockerfile 从现有镜像(特别是官方镜像)创建新镜像。

- commit命令是一个相当简单的扩展一个镜像的方式，但是很笨重，而且不容易在团队中分享开发进程。替代方案是使用新的命令，docker build，抓取建立镜像。
- Dockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。
不论是开发还是运维，学会编写Dockerfile几乎是必备的，这有助于你理解整个容器的运行。




FROM , 从一个基础镜像构建新的镜像
FROM ubuntu 

MAINTAINER , 维护者信息
MAINTAINER William <wlj@nicescale.com>

ENV , 设置环境变量
ENV TEST 1

RUN , 非交互式运行shell命令
RUN apt-get -y update 
RUN apt-get -y install nginx

ADD , 将外部文件拷贝到镜像里,src可以为url
ADD http://nicescale.com/  /data/nicescale.tgz

WORKDIR /path/to/workdir, 设置工作目录
WORKDIR /var/www

USER , 设置用户ID
USER nginx

VULUME <#dir>, 设置volume
VOLUME ['/data']

EXPOSE , 暴露哪些端口
EXPOSE 80 443 

ENTRYPOINT ['executable', 'param1', 'param2']执行命令，不会被覆盖，总是执行。
ENTRYPOINT ["/usr/sbin/nginx"]

CMD ["param1","param2"] 只有最后一个cmd会生效，是启动容器后执行的。会被 docker run 最后跟着的命令覆盖。
CMD ["start"]

docker创建、启动container时执行的命令，如果设置了ENTRYPOINT，则CMD将作为参数？？





Dockerfile最佳实践
 - 尽量将一些常用不变的指令放到前面
 - CMD和ENTRYPOINT尽量使用json数组方式

通过Dockerfile构建image: $ docker build csphere/nginx:1.7 .

镜像仓库Registry: 镜像从Dockerfile build生成后，需要将镜像推送(push)到镜像仓库。企业内部都需要构建一个私有docker registry，这个registry可以看作二进制的scm，CI/CD也需要围绕registry进行。

部署registry
$ mkdir /registry
$ docker run -p 80:5000 -e STORAGE_PATH=/registry -v /registry:/registry registry:2.0


推送镜像保存到仓库
假设192.168.1.2是registry仓库的地址：
$ docker tag  csphere/nginx:1.7 192.168.1.2/csphere/nginx:1.7
$ docker push 192.168.1.2/csphere/nginx:1.7






========================================
|-- Dockerfile建立nginx镜像实例( ADD/COPY, / RUN / EXPOSE )
----------------------------------------
1. 实例1：
https://dockerbook.com/TheDockerBook_sample.pdf

(1)新建文件夹
$ mkdir static_web
$ cd static_web
$ touch Dockerfile


(2) 编写内容
# Version: 0.0.1
FROM ubuntu:18.04
LABEL maintainer="george@example.com"
RUN apt-get update; apt-get install -y nginx
RUN echo 'Hi, I am in your container' \
	>/var/www/html/index.html

#添加本地文件到镜像内
ADD outer.html /var/www/html/

#暴露80端口
EXPOSE 80



解释说明：
每条指令都有一个大写的前缀声明： INSTRUCTION statement
#后的是注释。
第一行总是 指令FROM， 指明镜像来源，是ubuntu:18.04版，没有作者，表明是官方来源。
指令MAINTAINER指定维护者。
RUN指令执行一个镜像内部命令，比如安装一个包。

ADD 和 COPY 都是把文件放到新镜像中，
区别：
	ADD: 会把压缩包解压。支持来源是url的文件。



(3)docker build 建立镜像，用-t指定名字（查看帮助 docker build --help）
$ cd static_web
$ docker build -t george/static_web .  ##默认tag是latest，注意最后有一个点号

说明：
1)尽量加上-t设置镜像名字，方便后续操作；
2)镜像名字可加上标签tag: docker build -t "george/static_web:v2" .
-t表明我们的新镜像属于用户george，仓库名static_web，标签v2。

3)最后一个点号，表示在当前位置找Dockerfile，也可以指定在github上找:
## docker build -t "george/static_web:v1" github.com/turnbullpress/docker-static_web
4)Docker 1.5.0及之后，可以用-f参数指定文件路径，而且该文件可以不命名为Dockerfile了，例如
## docker build -t "george/static_web" -f /path/to/file


以下是一堆输出：
Sending build context to Docker daemon  2.048kB
Step 1/5 : FROM ubuntu:18.04
 ---> 3556258649b2
...省略
Successfully built 9376e822266c
Successfully tagged george/static_web:latest


从输出第一行看，docker首先上传build上下文：基本上就是你正在build的文件夹。
做这些是因为docker守护进程需要本地上下文来build镜像。

接下来根据 Dockerfile 的指令一步一步执行。每步提交变化，并删掉中间容器。

注意：不管什么样的存储驱动，一个镜像都不能超过127层。这个限制是全局的，以鼓励优化镜像的总体尺寸。


更多指令可以查看官方文档。为了帮助你写一个清晰、可读、可维护的Dockerfile，我们写了一个《Dockerfile最佳实践指南》。
https://docs.docker.com/develop/develop-images/dockerfile_best-practices/


(4)查看镜像，多了一个基础镜像ubuntu:18.04和一个新构建的george/static_web:latest镜像：
$ docker images
REPOSITORY         TAG     IMAGE ID      CREATED        SIZE
george/static_web  latest  9376e822266c  33 seconds ago 151MB
ubuntu             18.04   3556258649b2  2 weeks ago    64.2MB


可以在commit或build之后，给每一个已经存在的镜像添加标签。docker tag命令就可以做到。现在，为镜像george/static_web添加一个标签。
$ docker tag 9376e822266c george/static_web:devel
$ docker images
REPOSITORY         TAG     IMAGE ID      CREATED      SIZE
george/static_web  devel   9376e822266c  4 hours ago  151MB
george/static_web  latest  9376e822266c  4 hours ago  151MB

结果就是同一个image id，但是有好几个tag。
删掉旧的tag呢？
$ docker rmi george/static_web:latest
Untagged: george/static_web:latest 
该image id只剩下一个了。






(5)运行该镜像
$ sudo docker run -p 7000:80 -it 9376e /bin/bash
-i 表示交互式
-t 表示获取一个终端
-p 做端口映射，格式 物理机端口:虚拟机端口

root@01896f11caac:/# service nginx start
root@01896f11caac:/# service nginx status

使用浏览器查看主机的7000端口
http://y.biomooc.com:7000/
Hi, I am in your container

root@01896f11caac:/# exit
再访问，服务就不存在了。


#####
要想在退出容器shell后继续后台运行，可以添加-d参数。
$ docker run -it -p 7000:80 -d 9376e bash
8e4c5eb0
查看容器id: $ docker ps
进入容器
$ docker exec -it 8e4c bash
开启nginx服务
# service nginx start
# exit
访问该网址，服务还在。


(6)关闭容器
查看启动的容器id ： 运行命令 docker container ls 或 docker ps
关闭容器 ：运行命令 docker stop 容器id



容器退出后，依旧可以查其容器id: docker ps -a 
删除一个容器: docker rm 容器id

查看镜像: docker images 
删除一个镜像: docker rmi 镜像id








2. 实例2: 测试 ADD 和 COPY 的功能。
(1) 测试基础
$ docker --version
Docker version 20.10.7, build 20.10.7-0ubuntu1~18.04.1

使用小镜像
ubuntu       20.04           fb52e22af1b0   2 weeks ago   72.8MB

(2) 造压缩文件
$ echo "hello, test2" >t2.txt
$ tar -cf all.tar t2.txt
$ gzip t2.txt

$ echo "hello, test3" >t3.txt
$ tar -czf txt.tar.gz *txt

-rw-rw-r-- 1 wangjl wangjl  10K Sep 18 10:26 all.tar
-rw-rw-r-- 1 wangjl wangjl   40 Sep 18 10:26 t2.txt.gz

-rw-rw-r-- 1 wangjl wangjl  134 Sep 18 10:27 txt.tar.gz


(3) 测试 ADD 指令
$ cat Dockerfile
FROM ubuntu:20.04

WORKDIR /app
ADD all.tar /app/
ADD t2.txt.gz /app/
ADD txt.tar.gz /app/

生成镜像，镜像名字必须小写
$ docker build -t "img2:add" .

$ docker images
REPOSITORY   TAG             IMAGE ID       CREATED          SIZE
img2         add             be0653dd83c7   4 seconds ago    72.8MB

运行并查看
$ docker run --rm -it img2:add ls
t2.txt	t2.txt.gz  t3.txt

只解压tar包。
如果源文件是个归档文件（压缩文件，比如 .tar, tar.gz文件），则docker会自动帮解压。
但是.txt.gz文件是不会自动解压的。


(4) 测试 COPY 指令
COPY all.tar /app/
COPY t2.txt.gz /app/
COPY txt.tar.gz /app/

$ docker build -t "img2:copy" .
$ docker run --rm -it img2:copy ls
all.tar  t2.txt.gz  txt.tar.gz



(5) 试试下载
尝试下载百度首页吧:
$ wget www.baidu.com/index.html -O b1.html
-rw-rw-r-- 1 wangjl wangjl 2.4K Sep 18 10:13 b1.html

$ cat Dockerfile 
FROM ubuntu:20.04

WORKDIR /app
ADD t2.txt.gz /app/
ADD all.tar /app/
ADD http://www.baidu.com/index.html B1.html

$ docker build -t "img2:url" .
$ docker run --rm img2:url ls -lth
total 312K
-rw-rw-r-- 1 1000 1000   13 Sep 18 01:52 t2.txt
-rw-rw-r-- 1 root root   40 Sep 18 01:52 t2.txt.gz
-rw------- 1 root root 302K Jan  1  1970 B1.html

这个docker下载的文件好大，是wget下载的150倍。








========================================
|-- 基于tomcat镜像的Jpress展示站点: 使用 COPY 把自定义文件加入到docker镜像中
----------------------------------------
(8) 怎么把自己的文件加入到docker中？从本地或者github都行。
https://www.cnblogs.com/20143605--pcx/p/10305680.html


1.实例1 
(1)制作自己的镜像
	dockerfile
	docker build 
	Jpress: http://jpress.io/ 做演示，先下载war包。
		放到Dockerfile所在文件夹，$ cp /home/wangjl/Public/jpress-web-newest.war .
	基础镜像：登陆 https://c.163.com/hub#/m/home/
		搜索tomcat，https://c.163.com/hub#/m/search/?keyword=tomcat
		下载docker版的 https://c.163.com/hub#/m/repository/?repoId=3105
		# docker pull hub.c.163.com/library/tomcat:latest
		改个短名字# docker tag hub.c.163.com/library/tomcat dawneve/tomcat
		因为tomcat依赖jdk，所以不用担心jdk问题了。
(2)写dockerfile
网易tomcat文件的dockerfile：
https://github.com/docker-library/tomcat/blob/a227157792e94c669148c3c2a09072fb317070e0/7/jre7/Dockerfile
dockerfile命令总结：http://blog.csdn.net/yeasy/article/details/40041707


#vim Dockerfile	 #简单写一个dockerfile
#指定基础镜像
from dawneve/tomcat
#所有者
MAINTAINER Jimmy JimmyMall@live.com 

#复制本地文件到基础镜像的文件夹中(参照该镜像文档 CATALINA_HOME:   /usr/local/tomcat)
COPY jpress-web-newest.war /usr/local/tomcat/webapps

(3)建立镜像
# docker build .
Sending build context to Docker daemon   20.8MB
Step 1/3 : FROM dawneve/tomcat
 ---> b226d7ee3462
Step 2/3 : MAINTAINER Jimmy JimmyMall@live.com
 ---> Using cache
 ---> 189049f0dac0
Step 3/3 : COPY jpress-web-newest.war /usr/local/tomcat/webapps
 ---> 1159f08345b2
Removing intermediate container 1eb46d2a6ce8
Successfully built 1159f08345b2




(4)docker images查看到一个没有名字的镜像。
# docker images
REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE
<none>                         <none>              1159f08345b2        31 seconds ago      313MB
dawneve/tomcat                 latest              b226d7ee3462        15 hours ago        292MB


(5)重新构建，用-t指定名字（查看帮助 docker build --help）
# docker build . -t dawneve/jpress:latest
Sending build context to Docker daemon   20.8MB
Step 1/3 : FROM dawneve/tomcat
 ---> b226d7ee3462
Step 2/3 : MAINTAINER Jimmy JimmyMall@live.com
 ---> Using cache
 ---> 189049f0dac0
Step 3/3 : COPY jpress-web-newest.war /usr/local/tomcat/webapps
 ---> Using cache
 ---> 1159f08345b2
Successfully built 1159f08345b2
Successfully tagged dawneve/jpress:latest
# docker images #名字正常
REPOSITORY       TAG     IMAGE ID            CREATED             SIZE
dawneve/jpress   latest  1159f08345b2        8 minutes ago       313MB
dawneve/tomcat   latest  b226d7ee3462        15 hours ago        292MB



(6)运行该容器
# docker run -d -p 8888:8080 dawneve/jpress
f3a05abb2f2e64164aaf70cfd07e423e985e0a43b09840065c6c215584a9ba75

# docker ps
CONTAINER ID IMAGE          COMMAND             CREATED        STATUS        PORTS                   NAMES
f3a05abb2f2e dawneve/jpress "catalina.sh run"   6 seconds ago  Up 4 seconds  0.0.0.0:8888->8080/tcp  sharp_bassi

#netstat -na|grep 8888
tcp6       0      0 :::8888                 :::*                    LISTEN



(7)访问主机的IP:8888查看效果
http://172.16.112.86:8888/
出现tomtat欢迎页面：Apache Tomcat/8.5.16。但是访问jpress页面报错。
原来url路径名要和war包同名
http://172.16.112.86:8888/jpress-web-newest/install
发现要安装jpress还需要数据库。
能不能用docker运行一个mysql呢？



(8)开启一个mysql服务
参考 运行和使用 docker版的mysql 的第一部分。


(9)回到jpress web安装页面，填写mysql信息。

数据库名: jpress_db 将JPress安装到哪个数据库？
用户名: root 您的MySQL用户名
密码:123456 …及其密码
数据库主机:172.16.112.86 如果localhost不能用，您通常可以从网站服务提供商处得到正确的信息。
端口号:3306 Mysql默认是3306
表前缀: jpress_ 如果您希望在同一个数据库安装多个JPress，请修改前缀。

点击下一步后，设置jpress管理员用户名和密码
网站名称： jpress in docker 
admin/admin


JPress安装向导
安装完成。
安装完成！稍等几秒后自动刷新。若一直停留在此页面，请重启你的web容器。

看来需要重启web容器了。
# docker restart f3a
f3a

http://172.16.112.86:8888/jpress-web-newest/
可以访问了。
后面加admin就可以访问后台了。用户名和密码刚才设置过。




========================================
|-- ENV 启动容器时传入参数 -e USER=Tom
----------------------------------------

例1: 传入参数 -e XX=xx
$ cat s2.df 
FROM ubuntu:20.04
ENV USER friend

ENTRYPOINT echo "Welcome, $USER"
# or
## CMD echo "Welcome, $USER"


构建
$ docker build -t s2:1 -f s2.df ./

(1) 运行
$ docker run --name s2 --rm -it s2:1
Welcome, friend
然后容器结束并销毁。

(2) 传入环境变量 -e
$ docker run --name s2 -e USER="Tom" --rm -it s2:1
Welcome, Tom


(3) 最后传入 CMD 参数
$ docker run --name s2 -e USER="Tom" --rm -it s2:1 "nice"
Welcome, Tom
最后一个不起作用，why?


(4) 试试exec写法，不支持出入-e参数
$ cat s2_1.df
FROM ubuntu:20.04
ENV USER friend

ENTRYPOINT ["echo", "Welcome"]
CMD ["bash"]

$ docker build -t s2:2 -f s2_1.df ./
$ docker run --name s2 --rm -it s2:2
Welcome bash

$ docker run --name s2 --rm -it s2:2 "nice"
Welcome nice







========================================
|-- ENTRYPOINT 与 CMD: 启动docker时执行，实现服务自启动
----------------------------------------
在 Dockerfile 最后一行加上
# 容器默认启动命令
ENTRYPOINT ["service","nginx","start"]
好像不起作用！！！

ENTRYPOINT ["/usr/sbin/nginx"] #起作用




Dockerfile 有两个启动配置， CMD 和 ENTRYPOINT ， 可以在 Dockerfile 中来配置容器启动时自动执行的命令， 但是这二者有什么区别呢， 接下来总结一下。


1. 首先来看一下 CMD ， 有三种格式的配置， 分别是：
	CMD [“executable”,”param1”,”param2”] (exec 格式, 推荐的格式)
	CMD [“param1”,”param2”] (作为 ENTRYPOINT 的默认参数)
	CMD command param1 param2 (shell 格式)

在使用时， 要注意一下问题：
	包含可执行文件时， 为容器指定默认执行命令， 这个是主要用途；
	不包含可执行文件时， 必须提供 ENTRYPOINT 配置， CMD 作为默认参数；
	Dockerfile 中只能有一个 CMD 起效， 如果出现了多个， 则最后一个起效；


而 ENTRYPOINT ， 有两种格式的配置， 分别是：
	ENTRYPOINT [“executable”, “param1”, “param2”] (exec 格式, 推荐)
	ENTRYPOINT command param1 param2 (shell 格式)


CMD 和 ENTRYPOINT 两种配置格式的区别是：
	exec 格式：推荐这种格式， 使用这种模式时， 可以不需要 shell 进程， 让 Docker 应用的可执行程序成为容器的 PID 1 进程， 可以接收 Unix 信号， 比如执行 docker stop时能够接收到 SIGTERM。
	shell 格式：会始终调用一个 shell 进程， 成为 /bin/sh -c 的子命令， 可执行程序不能响应 Unix 信号。

	注意： ENTRYPOINT 使用 shell 格式 时， 会忽略 CMD 和 run 传入的参数， 如果要替换默认的 ENTRYPOINT 命令， 则需要在执行 docker run 的时候指定 --entrypoint 参数。


CMD 与 ENTRYPOINT主要区别
	•当docker run 命令中有参数时，守护进程会忽略CMD命令。
	•使用ENTRYPOINT指令不会忽略，并且会接收docker run 参数附加到命令行中。

为了使构建的容器可以正常启动，我们编写的dockerfile文件必须包含一个CMD或ENTRYPOINT指令。







2. 举例说明

(1) 一起使用时，ENTRYPOINT 与 CMD 是拼接起来运行的。

$ cat Dockerfile
FROM ubuntu:20.04
ENTRYPOINT ["ls", "-l"]
CMD ["-h", "/var/"]

构建与运行
$ docker build -t test:r1 ./
$ docker run --rm -it test:r1 
确实打印出 $ ls -lh /var/ 的结果了，但是容器立刻退出了。

问题：怎么保证容器不退出呢？



(2) 最后执行 exec "$@" 语句，能让服务长久运行

1) 最初版
$ cat Dockerfile
FROM ubuntu:20.04
COPY docker-entrypoint.sh /usr/bin/
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["ls", "-lh", "/var/"]

$ cat docker-entrypoint.sh
#!/bin/sh
cd /var/
pwd
exec "$@"

需要在宿主机上给这些文件加上可执行权限
$ chmod a+x docker-entrypoint.sh
否则报错: exec: "docker-entrypoint.sh": executable file not found in $PATH:

构建与运行
$ docker build -t test:r0 ./
$ docker run --rm -it test:r0 bash
/var
root@7277d44b8f61:/var# exit
exit
退出。

$ docker run --rm -it -d test:r0 bash
$ docker ps 
确实在运行。



2) 直接运行版
$ cat Dockerfile
FROM ubuntu:20.04
COPY docker-entrypoint.sh /home/
ENTRYPOINT ["bash", "/home/docker-entrypoint.sh"]
CMD ["ls", "-lh", "/var/"]

构建与运行
$ docker build -t test:r1 ./
$ docker run --rm -it test:r1 bash
/var
root@671bcc3b3691:/var# exit
exit

这样终于不闪退，可以持久运行了。

据说是因为 ENTRYPOINT 是pid=1的进程，它不能结束。它一旦结束整个容器就结束了。
不清楚 exec "$@" 怎么实现这一点的。





(3) 被 docker run 参数替换

$ cat 2.df
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y iputils-ping
ENTRYPOINT ["/bin/ping"]
CMD ["localhost"]

构建
$ docker build -t test:r2 -f 2.df ./

直接运行
$ docker run --rm -it test:r2
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.019 ms
^C


1)从命令行覆盖掉 CMD
$ docker run --rm -it test:r2 baidu.com
PING baidu.com (220.181.38.251) 56(84) bytes of data.
64 bytes from 220.181.38.251 (220.181.38.251): icmp_seq=1 ttl=48 time=36.8 ms
^C


2)从命令行覆盖掉 ENTRYPOINT
$ docker run --entrypoint hostname test:r2
4bbeb05dc0d1

相对而言，CMD 更容易被覆盖。



3)从命令行传入更多参数，-c 就是重复几次。
$ docker run --rm -it test:r2 localhost -c 2
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.019 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.049 ms

--- localhost ping statistics ---


4) 参数替换也挺好
使用 ENTRYPOINT 指定命令，而 CMD 指定默认参数，run时可以覆盖掉默认参数。

FROM nginx 
ENTRYPOINT ["nginx", "-c"] # 定参 
CMD ["/etc/nginx/nginx.conf"] # 变参





(4) exec 和 shell 写法的区别

$ cat 2.e.df
FROM test:r2
ENTRYPOINT ["/bin/ping", "localhost"] #推荐 exec 写法
构建
$ docker build -t test:e -f 2.e.df ./

$ cat 2.s.df
FROM test:r2
ENTRYPOINT /bin/ping localhost
构建
$ docker build -t test:s -f 2.s.df ./


#########
$ docker run --name=Exec --rm -it test:e
再打开一个终端
$ docker exec Exec ps -aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.1   4212  2352 pts/0    Ss+  13:59   0:00 /bin/ping localhost
root          54  0.0  0.1   5904  2864 ?        Rs   14:01   0:00 ps -aux
exec 格式，PID 1启动的就是ping命令。


$ docker run --name=Shell --rm -it test:s
再打开一个终端
$ docker exec Shell ps -aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.1  0.0   2616   600 pts/0    Ss+  14:02   0:00 /bin/sh -c /bin/ping localhost
root           7  0.0  0.1   4212  2320 pts/0    S+   14:02   0:00 /bin/ping localhost
root           8  0.0  0.1   5904  2908 ?        Rs   14:02   0:00 ps -aux
shell 格式，PID 1启动的是 sh 命令: /bin/sh -c，我们的ping命令作为sh的子程序运行了。


这样会导致的一个问题是，你从外部发给容器的POSIX信号，是被sh接收的，而sh命令并不会将信号转发给ping命令，会导致不能安全的关闭容器。比如用shell方法启动的容器一直在运行，我按Ctrl +C是无法停止的。
所以最好是使用exec写法。

==> 我的测试是： ctrl+C 都能使ping停止。 //todo






(5) 怎么在入口 ENTRYPOINT 新建用户？
用户名就是rstudio，指定uid和gid

$ cat Dockerfile
FROM ubuntu:20.04
ENV UID 1001
ENV GID 1001

COPY docker-entrypoint.sh /home/
ENTRYPOINT ["bash", "/home/docker-entrypoint.sh"]
CMD ["ls", "-lh", "/var/"]


$ cat docker-entrypoint.sh
#!/bin/sh
set -e

DEFAULT_USER=rstudio
# 获取docker run -e UID=1002 -e UID=1002 传递的参数 
echo $UID
echo $GID
useradd -s /bin/bash -d /home/${DEFAULT_USER} -m ${DEFAULT_USER} -u $UID -g $GID
echo "${DEFAULT_USER}:${DEFAULT_USER}" | chpasswd

cd /var/
pwd
exec "$@"


构建与运行
$ docker build -t test:r1 ./
$ docker run -e UID=1005 --rm -it test:r1 bash
1005
/var
root@d5ac588151a7:/var# ls -lth /home/
total 8.0K
drwxr-xr-x 2 rstudio rstudio 4.0K Oct 24 03:23 rstudio
-rw-r--r-- 1 root    root     243 Oct 24 03:22 docker-entrypoint.sh
root@d5ac588151a7:/var# su rstudio
rstudio@d5ac588151a7:/var$
切换用户成功！
















##############

3. 两个风格的区别 (很啰嗦，可跳过)

FROM ubuntu:20.04
# CMD Instruction
CMD ["echo", "Hello world,CMD1"] # Exec Form
CMD echo "Hello world, cmd2"      # Shell Form
# ENTRYPOINT Instruction
ENTRYPOINT ["echo", "Hello world_en1"] # Exec Form
ENTRYPOINT echo "Hello world en2"      # Shell Form


exec 风格:
	ENTRYPOINT ["executables", "parameter1", "parameter2", ...]
	CMD ["executables", "parameter1", "parameter2:, ...]

shell 风格:
	ENTRYPOINT <command> "parameter1"
	CMD <command> "parameter1"

	只有shell风格支持传入变量。
	不过可以使用脚本，在脚本中接收-e传入的变量。

	缺点是 pid不是1， docker stop 不能停止该服务。


(1) 比较两种方法的 pid

构建基础应用
$ cat n1.df
FROM ubuntu:20.04
RUN apt update && apt install -y nginx && apt clean

$ docker build -t n1:0 -f n1.df ./ 
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
n1           0         8d229f789d81   7 minutes ago    163MB

$ docker run --rm -it -p 8081:80 n1:0
root@488da1ddd53e:/# service nginx status
 * nginx is not running
root@488da1ddd53e:/# service nginx start 
 * Starting nginx nginx    [ OK ] 

服务没有开，怎么在启动的时候打开呢？


1) 使用 exec 格式启动应用 

$ cat n1.1.df
FROM n1:0
ENTRYPOINT ["nginx", "-g", "daemon off;"]

参数意义：
$ nginx -h
  -g directives : set global directives out of configuration file


$ docker build -t n1:1 -f n1.1.df ./

$ docker run --rm -it -p 8081:80 n1:1
阻塞状态，但是网页可访问。ctrl+C 则网页不可访问。

$ docker run --name N1 -d --rm -it -p 8081:80 n1:1
返回shell，网页可访问。
这是，进入容器查看进程编号
$ docker exec -it N1 sh
# top 
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  1 root      20   0   55284  11608  10172 S   0.0   0.6   0:00.03 nginx
  7 www-data  20   0   55612   3208   1484 S   0.0   0.2   0:00.00 nginx

可见，nginx的pid=1。

容器外检测:
$ ps -aux | head -n1; ps -aux | grep nginx
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      120535  0.0  0.5  55284 11608 pts/0    Ss+  20:27   0:00 nginx: master process nginx -g daemon off;
www-data  120569  0.0  0.1  55612  3208 pts/0    S+   20:27   0:00 nginx: worker process

$ docker stop 6c3c
6c3c
能使用 docker stop 关闭容器、服务。



2) 使用 shell 格式启动应用

$ cat n1.2.df
FROM n1:0
ENTRYPOINT nginx -g "daemon off;"

$ docker build -t n1:2 -f n1.2.df ./

$ docker run --name N2 -d --rm -it -p 8081:80 n1:2
$ docker exec -it N2 sh
# top
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  1 root      20   0    2616    548    476 S   0.0   0.0   0:00.02 sh
  7 root      20   0   55284  11580  10136 S   0.0   0.6   0:00.00 nginx
  8 www-data  20   0   55612   3248   1516 S   0.0   0.2   0:00.00 nginx
可见，nginx的pid不是1。
pid=1的是sh，也就是 nginx 在命令 ‘/bin/sh -c’  下运行。

容器外检测：
$ ps -aux | head -n1; ps -aux | grep nginx
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      121793  0.0  0.0   2616   548 pts/0    Ss+  20:45   0:00 /bin/sh -c nginx -g "daemon off;"
root      121823  0.0  0.5  55284 11580 pts/0    S+   20:45   0:00 nginx: master process nginx -g daemon off;
www-data  121824  0.0  0.1  55612  3248 pts/0    S+   20:45   0:00 nginx: worker process

In this way, we cannot stop a long-running ENTRYPOINT executable correctly using the ‘docker stop’ command.
我测试的可以使用 docker stop 停止容器和服务啊。




3) 使用 exec 命令
If we want to stop the executable correctly we must use the ‘exec’ before the executable in the Dockerfile as shown below:

$ cat n1.3.df
FROM n1:0
ENTRYPOINT exec nginx -g "daemon off;"

$ docker build -t n1:3 -f n1.3.df ./

$ docker run --name N3 -d --rm -it -p 8081:80 n1:3
$ docker exec -it N3 sh
# top
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  1 root      20   0   55284  11400   9948 S   0.0   0.6   0:00.02 nginx
  7 www-data  20   0   55612   3312   1584 S   0.0   0.2   0:00.00 nginx

可见，nginx 的 pid=1。



4) 使用 inspect 指令查看 
$ docker inspect N2
...
        "Path": "/bin/sh",                    
        "Args": [                     
            "-c",                     
            "nginx -g \"daemon off;\""      
        ], 
...


$ docker ps --format "table  {{.ID}} \t {{.Names}} \t {{.Command}}" --no-trunc
$ docker ps --format "table  {{.Names}} \t {{.Command}}" --no-trunc
NAMES      COMMAND
N1         "nginx -g 'daemon off;'"
N2         "/bin/sh -c 'nginx -g \"daemon off;\"'"
N3         "/bin/sh -c 'exec nginx -g \"daemon off;\"'"




(2) 命令行传入 –entrypoint 覆盖 ENTRYPOINT 指令 

$ docker run -d --entrypoint sh --name my-web4 n1:1
$ docker run -d --entrypoint sh --name my-web5 n1:2
$ docker run -d --entrypoint sh --name my-web6 n1:3

$ docker ps -a --format "table {{.Names}} \t {{.Command}}" --no-trunc
NAMES       COMMAND
my-web6     "sh"
my-web5     "sh"
my-web4     "sh"



















========================================
制作自己的docker镜像:commit命令
----------------------------------------
对于运行的容器，如果有文件有变动，则可以使用commit命令提交为新的镜像。
推荐用Dockerfile文件建立镜像。因为该方法更可重复。

# find ID of your running container:
docker ps

# create image (snapshot) from container filesystem
docker commit 12345678904b5 mysnapshot
完整形式：docker commit 12345678904b5 myusername/mysnapshot:mytag
还可以加上注释 -m。
# docker commit -m'comments here' 242 myu/myimg:testTag
sha256:edb24adf0dd2c4d9c056c62cd38ab89951c0c12a0b5c0cc53ee4f4324d8997e1

#查看新提交的镜像
# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
myu/myimg                    testTag             edb24adf0dd2        12 seconds ago      120MB

# explore this filesystem using bash (for example)
docker run -t -i mysnapshot /bin/bash

#删除镜像
如果有基于该镜像的容器在运行或停止运行，需要加上-f参数 docker rmi -f IMGidOrName。
# docker rmi myu/myimg
Error response from daemon: No such image: myu/myimg:latest
root@ubt16:/home/wangjl# docker rmi myu/myimg:testTag
Untagged: myu/myimg:testTag
Deleted: sha256:edb24adf0dd2c4d9c056c62cd38ab89951c0c12a0b5c0cc53ee4f4324d8997e1



















========================================
*** trouble shooting 排错: Docker 不能联网，报错 IPv4 forwarding is disabled. Networking will not work.
----------------------------------------

1. docker 内部无法上网
(1) Rstudio 在docker 内，但是无法访问
容器开了，容器内服务开了，host端口开了，就是访问不了。
docker run -it -d -p ${port}:8787 --name R4 \
--mount type=bind,source=/data/jinwf/,target=/docker/jinwf/ \
dawneve/seurat:4.1.0a


(2) 开一个普通的 ubuntu 测试
$ docker run -it -d ubuntu:20.04 bash
WARNING: IPv4 forwarding is disabled. Networking will not work. #这个报错怎么办？
00f037242e7f25b4eddd1e408874279bd149674a6a184cef8398ecef5b17e714

(3) 检查 docker 本身
$ docker info | grep -i ipv4
WARNING: IPv4 forwarding is disabled
WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled



2. 解决办法
配置 /etc/sysctl.conf ,添加 net.ipv4.ip_forward=1 即可

#重启服务，让配置生效
$ sudo systemctl restart network

#查看是否成功,如果返回为“net.ipv4.ip_forward = 1”则表示成功
$ sudo sysctl net.ipv4.ip_forward



















========================================
Docker network 网络
----------------------------------------
测试环境为 腾讯云 ubuntu。 110.40.254.15
$ docker --version
Docker version 20.10.9, build c2ea9bc

$ docker pull ubuntu:20.04
$ docker pull nginx:1.21.3
$ docker pull python:3.8.1


1. 简介
默认情况下容器与容器、容器与宿主机的网络是隔离开来的，

(1) 当你安装docker的时候，docker会创建一个桥接器docker0，通过它才让容器与容器、容器与宿主机之间通信。

$ ifconfig docker0
docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:ccff:fee4:4b7b  prefixlen 64  scopeid 0x20<link>
        ether 02:42:cc:e4:4b:7b  txqueuelen 0  (Ethernet)
        RX packets 4165  bytes 466072 (455.1 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 4928  bytes 403704 (394.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


(2) Docker安装的时候默认会创建三个不同的网络，你可以通过命令查看这些网络。

$ docker network --help
Usage:  docker network COMMAND
Manage networks
Commands:
  connect     Connect a container to a network 将某个容器连接到一个docker网络
  create      Create a network  创建一个docker局域网络
  disconnect  Disconnect a container from a network 将某个容器退出某个局域网络
  inspect     Display detailed information on one or more networks 显示某个局域网络信息
  ls          List networks 显示所有docker局域网络
  prune       Remove all unused networks 删除所有未引用的docker局域网络
  rm          Remove one or more networks 删除docker网络


$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
def701d48b1e   bridge    bridge    local
416fdec7fe0c   host      host      local
051fc56342ef   none      null      local



2. 默认网络
解释上文的 Name 列。
Docker内置这三个网络，运行容器时，你可以使用该 --network 标志来指定容器应连接到哪些网络。

(1) None Network
网络模式为none的，即不会为容器创建任何的网络环境。
一旦Docker Container采用了none网络模式，那么容器内部就只能使用loopback网络设备，不会再有其他的网络资源。

$ docker run -it --rm --network=none ubuntu:20.04 bash 
# ifconfig
# apt install net-tools
E: Unable to locate package net-tools
# apt update


(2) Host Network
如果你在创建容器的时候使用 --network=host 选项，那么容器会使用宿主机的网络，容器与宿主机的网络并没有隔离。

使用这种网络类型的好处就是网络性能很好，基本上跟宿主机的网络一样，它很大的弊端就是不安全。
你可以在容器中更改宿主机的网络，如果你的程序是用root用户运行的，有可能会通过Docker容器来控制宿主机的网络。
当我们在容器中执行类似ifconfig命令查看网络环境是，看到的都是宿主机上的信息。

$ docker run -it -d --network=host nginx:1.21.3
$ curl -i localhost

这里我们指定--network=host启动一个运行nginx的容器，然后在宿主机的命令行中请求localhost，在控制台中会输出nginx访问日志，其实这里并没有像以前那样通过-p或-P来暴露容器80端口。



(3) Bridge Network
桥接网络是默认的网络类型，我们可以使用下面的命令来查看默认的网络配置信息。

这儿桥接的网络名为docker0。当我们启动一个容器的时候，每个容器会有它自己的虚拟网络接口连接到docker0，并获得一个IP地址。

$ docker inspect bridge
[
    {
        "Name": "bridge",
        "Id": "def701d48b1e3dd8283f4fdc6ade61919e84437caa7d4147f16019a72ad404fe",
        "Created": "2021-10-12T10:24:49.095066709+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "81d91430ec7879c9173104d6792906c5537aa113e9be6a07b7c42cfc91754af2": {
                "Name": "reverent_buck",
                "EndpointID": "f2b20949554e71228dafc835304c11c5b5a47e61e3e1f52241249697b961d62a",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]


这儿桥接的网络名为 docker0 。当我们启动一个容器的时候，每个容器会有它自己的虚拟网络接口连接到docker0，并获得一个IP地址。
上面的 Containers 项里有所有连接到这个网络的容器，可以看到这个容器的ip地址。


(4) 还有一种container模式：使用 --net=container:NAME_or_ID 指定。
Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。

启动第一个容器，设置网络
$ docker run --rm -it -d --name=net0 -p 7777:80 nginx:1.21.3 #c2e6
$ docker inspect c2e6 | grep IPAddress
"IPAddress": "172.18.0.6",
$ docker inspect c2e6 | grep -i hostname
"Hostname": "c2e681f320d5",

$ docker exec -it c2e6 bash
root@c2e681f320d5:/# nginx -v
nginx version: nginx/1.21.3

root@c2e681f320d5:/# cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.18.0.6	c2e681f320d5



启动第二个容器，竟然是同样的hash值，但是不识别nginx命令。
$ docker run --rm -it -d --name=net1 --network=container:net0 ubuntu:20.04 bash #6783
$ docker inspect 6783 | grep IPAddress
"IPAddress": "",
$ docker inspect 6783 | grep -i hostname
"Hostname": "c2e681f320d5",

$ docker exec -it 6783 bash
root@c2e681f320d5:/# nginx -v
bash: nginx: command not found

root@c2e681f320d5:/# cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.18.0.6	c2e681f320d5






3. 端口转发
如果Docker容器不是使用none网络模式，默认是不需要再做任何配置就可以访问网络。但是，外部网络在默认情况下是不能访问容器的服务的。

(1) 容器暴露端口的2种方法

$ docker run -d -P --expose 443 nginx:1.21.3
-P选项Docker会把Dockerfile中的通过EXPOSE指令或--expose选项暴露的端口随机映射到临时端口。默认的nginx镜像的Dockerfile中会 EXPOSE 80。

查看端口映射关系
$ docker port acd64e
443/tcp -> 0.0.0.0:49153
443/tcp -> :::49153
80/tcp -> 0.0.0.0:49154
80/tcp -> :::49154

许多Linux内核预设的临时端口范围为32768 ~ 61000，你可以查看临时端口范围。
$ cat /proc/sys/net/ipv4/ip_local_port_range #32768	60999


(2) Docker会在宿主机的iptables里添加NAT规则，使得宿主机外的网络能通过宿主机ip:port使用容器提供的服务。
$ sudo iptables -t nat -L
...
Chain DOCKER (2 references)
target     prot opt source               destination         
RETURN     all  --  anywhere             anywhere            
DNAT       tcp  --  anywhere             anywhere             tcp dpt:webcache to:172.18.0.2:80
DNAT       tcp  --  anywhere             anywhere             tcp dpt:49153 to:172.18.0.3:443
DNAT       tcp  --  anywhere             anywhere             tcp dpt:49154 to:172.18.0.3:80


(3) 你也可以通过-p选项指定端口映射关系：
$ docker run -d -p 8081:80 nginx:1.21.3
这儿指定了宿主机的8081端口映射到容器的80端口。

$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                                    NAMES
323d66c04652   nginx:1.21.3   "/docker-entrypoint.…"   About a minute ago   Up About a minute   0.0.0.0:8081->80/tcp, :::8081->80/tcp    keen_ardinghelli
PORTS 这一列列出了端口映射关系。


(4) --link 连接两个不同的容器示例 (官方不推荐)
$ docker run --rm -it -v /home/vagrant/test.php:/data/test.php --link redis-server:redis  php /bin/bash
-link会在hosts文件中添加redis服务对应的ip地址
$ cat /etc/hosts
172.17.0.2	redis 41b5db2d1282 redis-server


我的测试：
先启动 python 
$ docker run --rm -it -d --name python38 python:3.8.1 bash
$ docker ps
CONTAINER ID   IMAGE          COMMAND  CREATED         STATUS         PORTS   NAMES
5f7a00b0a179   python:3.8.1   "bash"   7 minutes ago   Up 7 minutes           python38

在启动 ubuntu 
$ docker run --rm -it -v /home/wangjl/:/data/ -w /data/ --link python38:python  ubuntu:20.04 /bin/bash
root@70a89e92d007:/data# cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.18.0.5	python 5f7a00b0a179 python38  #这里有 python38 的IP地址
172.18.0.6	70a89e92d007

接着不知道干啥了













https://loocode.com/post/10107
https://www.cnblogs.com/zuxing/articles/8780661.html
https://www.cnblogs.com/leozhanggg/p/12061435.html







========================================
|-- docker不同容器间的通信: 自定义网络
----------------------------------------
https://docs.docker.com/network/

1. 自定义网络
建议使用自定义的网桥来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。

Docker提供了创建这些网络的默认网络驱动程序，你可以创建一个新的 Bridge网络，Overlay网络 或 Macvlan网络。

你还可以创建一个网络插件或远程网络进行完整的自定义和控制。

你可以根据需要创建任意数量的网络，并且可以在任何给定时间将容器连接到这些网络中的零个或多个网络。

此外，你可以连接并断开网络中的运行容器，而无需重新启动容器。当容器连接到多个网络时，其外部连接通过第一个非内部网络以词法顺序提供。




2. 实例 
实例: 创建1个网络，把2个容器放到该网络中，并测试连通性。


(1) 创建网络
$ docker network create mynet0

查看：
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
def701d48b1e   bridge    bridge    local
416fdec7fe0c   host      host      local
733b334e4634   mynet0    bridge    local #新创建的
051fc56342ef   none      null      local


(2) 拉2个镜像
$ docker pull redis:6.2.6
$ docker pull nginx:1.21.3


(3) 启动容器

运行redis容器
$ docker run --rm -itd --name redis1  --network mynet0 --network-alias redis -p 6379:6379 redis:6.2.6

运行nginx容器
$ docker run -d --name nginx1 -p 81:80 --network mynet0 --network-alias nginx --privileged=true -v /home/wangjl/root:/home/wwwroot -v /home/wangjl/logs:/home/wwwlogs nginx:1.21.3

运行容器时候加入命令 --network mynet0 --network-alias redis，
代表当然容器要加入到 mynet0 局域网络中

--network 指定使用的网络
--network-alias 设置网络别名



(4) docker 查询网络信息
查看mynet的详细信息，发现redis和nginx已在Containers容器内，属于当前mynet网络
$ docker network inspect mynet0
...
        "Containers": {
            "8e14baadb7f5f6fb6f4d61b727f50667d906d90513cade358d3c8e40a878da65": {
                "Name": "redis1",
                "EndpointID": "4a9b1752fb70d237e77c6e23952f6dc3d695963a9f39d6b2302dad151490001d",
                "MacAddress": "02:42:ac:13:00:02",
                "IPv4Address": "172.19.0.2/16",
                "IPv6Address": ""
            },
            "e6f8c203b56fde528ed64a1a4b0041640e005f19ed1102c98c9dea2c8d962181": {
                "Name": "nginx1",
                "EndpointID": "05a5051ae7f0e6c590f691fdd1380a17e80d1fe91ebb88c940e988ec87fb1fa6",
                "MacAddress": "02:42:ac:13:00:03",
                "IPv4Address": "172.19.0.3/16",
                "IPv6Address": ""
            }
        },
...


(5) 验证容器之间网络能否互相ping通
没有ping命令，需要安装 iputils-ping

$ docker exec -it nginx1 bash
root@e6f8c203b56f:/# apt update
root@e6f8c203b56f:/# apt install net-tools #貌似这个是 ifconfig的
root@e6f8c203b56f:/# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.19.0.3  netmask 255.255.0.0  broadcast 172.19.255.255

root@e6f8c203b56f:/# apt install iputils-ping
root@e6f8c203b56f:/# ping redis1
PING redis1 (172.19.0.2) 56(84) bytes of data.
64 bytes from redis1.mynet0 (172.19.0.2): icmp_seq=1 ttl=64 time=0.039 ms
64 bytes from redis1.mynet0 (172.19.0.2): icmp_seq=2 ttl=64 time=0.043 ms
^C


$ docker exec -it redis1 bash
root@8e14baadb7f5:/data# apt update
root@8e14baadb7f5:/data# apt install iputils-ping
oot@8e14baadb7f5:/data# ping nginx1
PING nginx1 (172.19.0.3) 56(84) bytes of data.
64 bytes from nginx1.mynet0 (172.19.0.3): icmp_seq=1 ttl=64 time=0.052 ms
64 bytes from nginx1.mynet0 (172.19.0.3): icmp_seq=2 ttl=64 time=0.046 ms
^C
root@8e14baadb7f5:/data# ping redis  #也可以使用网络别名
PING redis (172.19.0.2) 56(84) bytes of data.
64 bytes from 8e14baadb7f5 (172.19.0.2): icmp_seq=1 ttl=64 time=0.019 ms


通过容器id /主机名/ 网络别名 都是可以访问的。





#将容器删掉重新创建
$ docker stop nginx1
$ docker rm -f nginx1
$ docker stop redis1
$ docker rm -f redis1





(6) 使用docker network connect
同样也可以不指定网络，直接启动容器，然后使用docker network connect接入网络。

运行nginx和docker容器
$ docker run -itd --name redis2 -p 6380:6379 redis:6.2.6
$ docker run -d --name nginx2 -p 82:80 --privileged=true nginx:1.21.3

创建网络
$ docker network create mynet2

如果容器已创建好但是之前没有指定自己的网络，则使用下面命令修改：docker network connect --alias mysql my-network mysql
第一个mysql是网络别名 第二个mysql是容器名


使用docker network connect命令连接网络
加入nginx2到mynet网络
$ docker network connect mynet2 nginx2
加入redis2到mynet网络
$ docker network connect mynet2 redis2


查看mynet网络包含的容器，会发现两个容器都加入当前网络了，后面使用ping命令是能够ping通容器名称的。
$ docker network inspect mynet2
...
        "Containers": {
            "15212e6a588760e9d67d2a69ff4cf0b4edcddcd2df80cffae98c545e9406d560": {
                "Name": "nginx2",
                "EndpointID": "9d175838f541786453d9e9bb7a652601b9f05188870b8839450863fa5e4827d4",
                "MacAddress": "02:42:ac:14:00:02",
                "IPv4Address": "172.20.0.2/16",
                "IPv6Address": ""
            },
            "2dcc499fc4219fa3278754506434246c0f31070a438447351d3e61dd183cab7b": {
                "Name": "redis2",
                "EndpointID": "b5de699a79acc8b42d66d3708d315d3782160b7579d4b13c98b22a981fe196b6",
                "MacAddress": "02:42:ac:14:00:03",
                "IPv4Address": "172.20.0.3/16",
                "IPv6Address": ""
            }
        },
...



(7) docker network disconnect 将nginx移除mynet局域网络

$ docker network disconnect mynet0 nginx1
$ docker network inspect mynet0
...
        "Containers": {
            "8e14baadb7f5f6fb6f4d61b727f50667d906d90513cade358d3c8e40a878da65": {
                "Name": "redis1",
                "EndpointID": "4a9b1752fb70d237e77c6e23952f6dc3d695963a9f39d6b2302dad151490001d",
                "MacAddress": "02:42:ac:13:00:02",
                "IPv4Address": "172.19.0.2/16",
                "IPv6Address": ""
            }
        },
...

使用docker network 很方便的维护和管理docker网络，方便容器之间ip和端口交互。






(8) 再开一个 redis，加入网络，测试互相访问。
$ docker run -itd --name redis3 -p 6381:6379 redis:6.2.6
$ docker network connect mynet2 redis3


$ docker run -itd --name redis4 -p 6382:6379 redis:6.2.6
指定网络别名
$ docker network connect --alias netRedis4 mynet2 redis4
      --alias strings           Add network-scoped alias for the container

#创建nginx容器，名为mynginx,并加入到网络congnet中
$ docker run --rm -itd -p 83:80 --name nginx3 --network mynet2 nginx:1.21.3


检查运行状态
$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED             STATUS             PORTS                                       NAMES
c6b0bbb8b987   nginx:1.21.3   "/docker-entrypoint.…"   5 seconds ago       Up 5 seconds       0.0.0.0:83->80/tcp, :::83->80/tcp           nginx3
ed3923bd99fe   redis:6.2.6    "docker-entrypoint.s…"   3 minutes ago       Up 3 minutes       0.0.0.0:6382->6379/tcp, :::6382->6379/tcp   redis4
48169656186c   redis:6.2.6    "docker-entrypoint.s…"   13 minutes ago      Up 13 minutes      0.0.0.0:6381->6379/tcp, :::6381->6379/tcp   redis3
15212e6a5887   nginx:1.21.3   "/docker-entrypoint.…"   32 minutes ago      Up 32 minutes      0.0.0.0:82->80/tcp, :::82->80/tcp           nginx2
2dcc499fc421   redis:6.2.6    "docker-entrypoint.s…"   32 minutes ago      Up 32 minutes      0.0.0.0:6380->6379/tcp, :::6380->6379/tcp   redis2


检查IP地址
$ docker network inspect mynet2
redis2  172.20.0.3
redis3  172.20.0.4
redis4  172.20.0.5

nginx2 172.20.0.2
nginx3 172.20.0.6


进入到 redis2 容器中，查看hosts，并没有其他容器的IP
$ docker exec -it redis2 bash
root@2dcc499fc421:/data# cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.18.0.3      2dcc499fc421
172.20.0.3      2dcc499fc421

安装 curl 
root@2dcc499fc421:/data# apt-get update -y && apt-get install curl -yqq
通过容器名访问nginx容器
root@2dcc499fc421:/data# curl nginx2


==> 发现在同一网络中的两个容器，它们之间是可以直接使用容器名进行通信的，但容器名并不保存在/etc/hosts中，容器名直接被当作了网络内部的域名。







都连接 redis4，因为它有网络别名。


1)宿主机
$ redis-cli -h 172.20.0.5
172.20.0.5:6379> set boy "Tim"
OK
172.20.0.5:6379> get boy
"Tim"

redis4 本身呢
$ docker exec -it redis4 bash
root@ed3923bd99fe:/data# redis-cli 
127.0.0.1:6379> get boy
"Tim"


redis3 尝试使用 IP
$ docker exec -it redis3 bash
root@48169656186c:/data# redis-cli -h 172.20.0.5
172.20.0.5:6379> get boy
"Tim"


尝试使用 容器名
root@48169656186c:/data# redis-cli -h redis4    
redis4:6379> get boy
"Tim"

尝试使用 容器id，不行。
root@48169656186c:/data# redis-cli -h ed39  
Could not connect to Redis at ed39:6379: Name or service not known
not connected>

尝试使用 网络别名
root@48169656186c:/data# redis-cli -h netRedis4
netRedis4:6379> get boy
"Tim"

建议使用网络别名，就是因为重启时IP可能变化。




==> “桥接”和“NAT”的区别：
使用NAT模式可以实现在虚拟系统里访问互联网，虚拟系统无法和本局域网中的其他真实主机进行通讯。
而使用桥接模式下虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。所以Docker0是属于桥接模式。





https://blog.csdn.net/lao_pei/article/details/79157712
https://blog.csdn.net/wucong60/article/details/83757813





========================================
|-- docker 版的php: --link下容器间的通信 (现在不提倡使用)
----------------------------------------
https://www.runoob.com/docker/docker-install-php.html

不提倡使用文档: https://docs.docker.com/network/links/
The --link flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using --link.
建议使用用户自定义网络来实现容器之间的通信。
--link 特有的功能是共享环境变量。但是也有替代途径：



1. 下载php镜像 
$ docker search php
NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
php                            While designed for web development, the PHP …   6167      [OK]       
phpmyadmin/phpmyadmin          A web interface for MySQL and MariaDB.          1137                 [OK]

搜标签
$ curl -L -s https://registry.hub.docker.com/v1/repositories/php/tags > tmp
查了一下本地版本: 5.6.33

$ docker pull php:5.6.33-fpm
$ docker pull nginx:1.21.3


(2) 找说明书，写的不清楚
https://hub.docker.com/
https://hub.docker.com/_/php

$ docker run -p 80:80 --rm -it  php:5.6.33-fpm bash
root@648c0e4cd6bf:/var/www/html# pwd
/var/www/html
root@648c0e4cd6bf:/var/www/html# which php
/usr/local/bin/php


一句话打印版本号:
$ docker run -p 80:80 --rm -it  php:5.6.33-fpm php -version
PHP 5.6.33 (cli) (built: Feb 17 2018 03:00:42) 
Copyright (c) 1997-2016 The PHP Group
Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies


单行执行指定php脚本
$ cat a.php
<?php
echo "hello, from php\n";

$ docker run --rm -it -v $PWD:/var/www/html/  php:5.6.33-fpm php a.php
hello, from php



(3) 启动 php docker:
$ mkdir -p ~/nginx/www
$ docker run --rm --name myphp-fpm -v ~/nginx/www:/www  -d php:5.6.33-fpm

参数解释：
--name myphp-fpm : 将容器命名为 myphp-fpm。
-v ~/nginx/www:/www : 将宿主机中的 ~/nginx/www 挂载到容器的 /www

$ docker ps
CONTAINER ID   IMAGE            COMMAND                  CREATED          STATUS          PORTS      NAMES
6f954886b604   php:5.6.33-fpm   "docker-php-entrypoi…"   10 seconds ago   Up 9 seconds    9000/tcp   myphp-fpm

默认使用的是9000端口。


(4) 创建 nginx 配置文件

$ mkdir -p ~/nginx/conf/conf.d 
在该目录下添加文件
$ cat ~/nginx/conf/conf.d/test-php.conf
server {
    listen       80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm index.php;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    location ~ \.php$ {
        fastcgi_pass   php:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /www/$fastcgi_script_name;
        include        fastcgi_params;
    }
}

解释：
php:9000: 表示 php-fpm 服务的 URL，下面我们会具体说明。
/www/: 是 myphp-fpm 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录。




(5) 启动 nginx
查版本号
$ docker run --rm -it  nginx:1.21.3 nginx -version
nginx version: nginx/1.21.3


$ docker run --rm --name test2-php-nginx -p 8083:80 -d \
    -v ~/nginx/www:/www/:ro \
    -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \
    --link myphp-fpm:php \
    nginx:1.21.3

参数解释：
-p 8083:80: 端口映射，把 nginx 中的 80 映射到本地的 8083 端口。
~/nginx/www: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。
~/nginx/conf/conf.d: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。

--link myphp-fpm:php: 把 myphp-fpm 的网络并入 nginx，并通过修改 nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。
// todo 这个不懂


#######
--link <name or id>:alias
其中，name和id是源容器的name和id，alias是源容器在link下的别名。
--link list                      Add link to another container

探究一下怎么实现的：
进入nginx容器
$ docker exec -it test2-php-nginx /bin/bash
root@91ac94309aa6:/# env | grep -i php
PHP_NAME=/test2-php-nginx/php
PHP_PORT_9000_TCP_ADDR=172.18.0.4
PHP_ENV_PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2
PHP_PORT_9000_TCP_PROTO=tcp
PHP_ENV_GPG_KEYS=0BD78B5F97500D450838F95DFE857D9A90D90EC1 6E4F6AB321FDC07F2C332E3AC2BF0BC433CFC8B3
PHP_PORT_9000_TCP=tcp://172.18.0.4:9000
PHP_ENV_PHP_MD5=
PHP_ENV_PHP_VERSION=5.6.33
PHP_ENV_PHP_SHA256=9004995fdf55f111cd9020e8b8aff975df3d8d4191776c601a46988c375f3553
PHP_ENV_PHP_URL=https://secure.php.net/get/php-5.6.33.tar.xz/from/this/mirror
PHP_ENV_PHP_EXTRA_CONFIGURE_ARGS=--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data
PHP_PORT_9000_TCP_PORT=9000
PHP_ENV_PHP_INI_DIR=/usr/local/etc/php
PHP_ENV_PHP_LDFLAGS=-Wl,-O1 -Wl,--hash-style=both -pie
PHP_ENV_PHPIZE_DEPS=autoconf            dpkg-dev                file            g++             gcc             libc-dev                make            pkg-config              re2c
PHP_ENV_PHP_ASC_URL=https://secure.php.net/get/php-5.6.33.tar.xz.asc/from/this/mirror
PHP_PORT=tcp://172.18.0.4:9000
PHP_ENV_PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2


可见，确实有名为 PHP_NAME=/test2-php-nginx/php 的环境变量存在。




(6) 接下来我们在 ~/nginx/www 目录下创建 index.php，代码如下：
$ cat ~/nginx/www/index.php
<?php
echo phpinfo();



(7) 查看
$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                  NAMES
91ac94309aa6   nginx:1.21.3   "/docker-entrypoint.…"   2 minutes ago   Up 2 minutes   0.0.0.0:8083->80/tcp, :::8083->80/tcp  test2-php-nginx
f7e4e8813016   php:5.6-fpm    "docker-php-entrypoi…"   6 minutes ago   Up 6 minutes   9000/tcp                               myphp-fpm


$ tree nginx/
nginx/
├── conf #放配置文件
│   └── conf.d
│       └── test-php.conf
└── www #放网页文件
    ├── index2.php
    └── index.php

浏览器打开 http://宿主机ip:8083/index.php，显示 php版本详细信息。
但是其他脚本正常解析。




//无效。
有人建议: 找到php目录下的 php.ini ，将short_open_tag的值改成on
$ docker exec -it myphp-fpm bash
# php -a
php > phpinfo();
_ENV["PHP_INI_DIR"] => /usr/local/etc/php #php.ini 的位置
_ENV["PWD"] => /var/www/html  #当前文件?
php > exit


php5.6.40有如下文件。
# cat /usr/local/etc/php/php.ini | grep short_open_tag #确实是 Off
# apt update 
# apt install vim -y
# vim /usr/local/etc/php/php.ini
搜索并修改 short_open_tag = On

而 php5.6.33 没有示例文件。
/usr/local/etc/php/php.ini







(8) 安装扩展
默认php镜像中提供的扩展比较少，缺少诸如mysql、gd2等常用的扩展，这样我们就需要自己安装并启用扩展。

首先进入到php容器，用php -m命令查看本地有什么扩展。
可以使用docker-php-ext-install命令来安装扩展。
$ docker-php-ext-install mysql


扩展安装好之后就可以在php.ini中启用。
我们从phpinfo中可以看到，容器环境下默认的php.ini没有启用，可以从/usr/local/etc/php下将php.ini-development拷贝为php.ini。
通过修改php.ini中配置，启用自己需要的扩展。


下面是几个扩展安装的命令，供大家参考。
docker-php-ext-source 在容器中创建一个/usr/src/php目录
docker-php-ext-enable 启用PHP扩展，省去我们手工编辑php.ini的过程
docker-php-ext-install 安装并启用PHP扩展
docker-php-ext-configure 经常与 docker-php-ext-install 搭配，在需要自定义扩展的配置时使用





ref:
https://www.jianshu.com/p/43037ce40b00
编排与mysql扩展 https://www.cnblogs.com/cocowool/p/docker-php-dev.html
编排详解 https://www.sitepoint.com/docker-php-development-environment/





========================================
|-- 容器之间的通信实例: php 容器访问 mysql 容器
----------------------------------------

1. 拉取镜像
$ docker pull mysql:8.0
$ docker pull php:5.6-fpm
$ docker pull nginx:1.21.3

2. 启动容器
(1) 启动 mysql 容器
$ docker run --rm --name myDB -e MYSQL_ROOT_PASSWORD=123456 -d -p 7070:3306 mysql:8.0 #没解决编码问题

$ docker inspect myDB
...
            "Ports": {
                "3306/tcp": [
                    {
                        "HostIp": "0.0.0.0", #1.这里是如果用户访问宿主机IP和端口
                        "HostPort": "7070"
                    },
                    {
                        "HostIp": "::",
                        "HostPort": "7070"
                    }
                ],
                "33060/tcp": null
            },
...
"IPAddress": "172.18.0.3", #这是IP地址

$ docker port myDB #表示容器的 3306 端口对应着 外面宿主机的 7070 端口
3306/tcp -> 0.0.0.0:7070
3306/tcp -> :::7070

$ docker exec -it myDB bash
root@7b2ff9df5d45:/# mysql -h localhost -u root -p
mysql> use mysql
mysql> select Host, User from user;
+-----------+------------------+
| Host      | User             |
+-----------+------------------+
| %         | root             |
| localhost | mysql.infoschema |
| localhost | mysql.session    |
| localhost | mysql.sys        |
| localhost | root             |
+-----------+------------------+
5 rows in set (0.00 sec)
mysql> exit
Bye
root@7b2ff9df5d45:/# exit
exit



## MySQL 8 changed the default charset to utf8mb4. 
为了防止报错，需要把字符集改回 utf8.
$ docker exec -it myDB bash
root@7b2ff9df5d45:/# cat /etc/mysql/my.cnf
root@7b2ff9df5d45:/# ls -lth /etc/mysql
total 12K
drwxrwxr-x 1 root root 4.0K Oct 18 21:35 conf.d
-rw-rw-r-- 1 root root 1.1K Oct 18 21:35 my.cnf
-rw-r--r-- 1 root root 1.5K Sep 28 13:27 my.cnf.fallback

$ cat nginx/conf/my.conf
[mysqld]
collation-server = utf8_unicode_ci
character-set-server = utf8

这个也不行，试试低版本的mysql
$ docker run --rm --name myDB -e MYSQL_ROOT_PASSWORD=123456 -d -p 7070:3306 \
-v ~/nginx/conf/my.conf:/etc/mysql/conf.d/char.conf \
mysql:8.0





########## 使用老版本的
$ docker pull mysql:5.6
$ docker run --rm --name myDB0 -e MYSQL_ROOT_PASSWORD=123456 -d -p 7071:3306 mysql:5.6

$ docker inspect myDB0 | grep -i ipaddress
"IPAddress": "172.18.0.7",
后面加入网络会再获得一个ip。






(2) 启动一个 php 容器
$ mkdir -p ~/nginx/www
$ docker run --rm --name  myphp-fpm -v ~/nginx/www:/www -d php:5.6-fpm


(3) 创建网络 
$ docker network create -d bridge my-net

$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
def701d48b1e   bridge    bridge    local
416fdec7fe0c   host      host      local
d6c9841e1b0b   my-net    bridge    local
051fc56342ef   none      null      local


(4) 把这个容器加入网络
$ docker network connect my-net myDB
$ docker network connect my-net myphp-fpm

$ docker network connect my-net myDB0



(5) 还需要添加一个 nginx 容器

还需要启动一个 nginx
$ cd
$ mkdir -p nginx/www nginx/logs nginx/conf
$ cat nginx/www/index.php
<?php
  phpinfo();
?>

$ cat nginx/conf/php.conf
server {
	listen	80;
	server_name	localhost;

	location / {
		root	/usr/share/nginx/html;
		index	index.html index.htm index.php;
	}

	error_page	500 502 503 504	/50x.html;
	location = /50x.html {
		root	/usr/share/nginx/html;
	}

	location ~ \.php$ {
		fastcgi_pass	myphp-fpm:9000;
		fastcgi_index	index.php;
		# fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
		fastcgi_param	SCRIPT_FILENAME	/www/$fastcgi_script_name; 
		include		fastcgi_params;
	}
}

设置使用 myphp-fpm 的 9000 端口，作为php服务提供方。
# php文件地址在容器内的 $document_root 下，也就是  location.root 指定的 /usr/share/nginx/html。
php文件地址在容器内的 /www/ 下。



-v ~/nginx/www:/usr/share/nginx/html \

$ docker run --rm -it -d --name nginx2 \
-v ~/nginx/www:/www \
-v ~/nginx/conf:/etc/nginx/conf.d \
-p 82:80 \
--network my-net \
nginx:1.21.3
其中 -network web-net 是同一个网络，保证Nginx能和php通信。



检查 
$ docker network inspect my-net
myDB 172.21.0.2
myphp-fpm 172.21.0.3
nginx2 172.21.0.4
myDB0 172.21.0.5



可以正常访问php文件:
http://110.40.254.15:82/a2.php

$ cat a2.php 
<?php
$a=1000;
print($a);
echo "<hr>";

但是包含语句 “phpinfo();” 时失败。 //todo
phpinfo(INFO_LICENSE); #正常显示

$ docker logs myphp-fpm






(5) 在 php 中使用 mysql 5.6
$ docker exec -it myphp-fpm bash

mysql 版本
$ docker exec -it myDB0 bash
root@76640e7b6620:/# mysql --version
mysql  Ver 14.14 Distrib 5.6.51, for Linux (x86_64) using  EditLine wrapper


php的版本
root@c91ce97b781a:/var/www/html# php --version
PHP 5.6.40 (cli) (built: Jan 23 2019 00:16:13) 
Copyright (c) 1997-2016 The PHP Group
Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies


测试php的cli模式
# php -a 
php > echo "hello, php!";
hello, php!


查看 php.ini 位置
root@c91ce97b781a:/var/www/html# php -r 'phpinfo();' | grep -i conf

root@c91ce97b781a:/var/www/html# php -r "phpinfo();" | grep php.ini       
Configuration File (php.ini) Path => /usr/local/etc/php

没有，就按参考文件复制一个
root@a34f2fd6fbdb:/var/www/html# cp /usr/local/etc/php/php.ini-development /usr/local/etc/php/php.ini

编辑
root@a34f2fd6fbdb:/var/www/html# apt update
root@a34f2fd6fbdb:/var/www/html# apt install vim -y

root@a34f2fd6fbdb:/var/www/html# vim /usr/local/etc/php/php.ini

# vim /usr/local/etc/php/php.ini
extension=php_mysql.dll #取消前面的注释

安装mysql/mysqli驱动
# docker-php-ext-install mysql
# docker-php-ext-install mysqli
# php -m  | grep -i mysql
mysql
mysqli
mysqlnd



# mysql 8.0 链接失败
测试链接数据库
# php test2.php 
报错：Warning: mysql_connect(): Server sent charset unknown to the client. Please, report to the developers in /www/test2.php on line 22
就是这一行 mysql_connect()

# php -a #进入交互模式
php > mysql_connect('172.21.0.2:3306','root','123456'); 
Warning: mysql_connect(): Server sent charset unknown to the client.



# mysql 5.6 成功
php > mysql_connect('172.21.0.5:3306','root','123456'); 
Deprecated: mysql_connect(): The mysql extension is deprecated and will be removed in the future: use mysqli or PDO instead in php shell code on line 1

php> $mysqli = new mysqli("172.21.0.5:3306", "root", "123456", "mysql");
php> $result = $mysqli->query("SELECT Host, User FROM user");
php> while($obj = $result->fetch_object()){ print($obj->Host ."\t". $obj->User ."\n");  }
%       root
localhost       root


测试脚本
root@c91ce97b781a:/var/www/html# cd /www
root@c91ce97b781a:/www# php test2.php # 正常显示查询到的数组

但是网页端报错：
http://110.40.254.15:82/test2.php
Fatal error: Class 'mysqli' not found in /www/test2.php on line 22

==> 说明 cli 和 web 使用的php至少配置文件是不一致的。


是不是需要查 php 开了哪些扩展?
root@c91ce97b781a:/www# php phpinfo2.php  | grep ini --color=auto
Loaded Configuration File => /usr/local/etc/php/php.ini

root@c91ce97b781a:/www# grep mysqli /usr/local/etc/php/php.ini --color=auto
;extension=php_mysqli.dll

果真没开。使用vim去掉前面的分号。
# vim /usr/local/etc/php/php.ini
如何重启php服务呢？一启动这个容器就没了！

# ps aux | grep php-fpm | grep master | grep -v grep
# kill -USR2 32436

kill 参数解释:
https://blog.csdn.net/zhangkaiadl/article/details/92763973
INT, TERM 立刻终止
QUIT 平滑终止
USR1 重新打开日志文件
USR2 平滑重载所有worker进程并重新载入配置和二进制模块

然后网页可以看到了！
Array
(
    [0] => %	root
    [1] => localhost	root
)




$ cat test2.php #使用 mysqli 连接数据库
<?php
header('Content-Type: text/html; charset=UTF-8');
date_default_timezone_set('PRC');
?>
<title>[ Debuger ]</title>
<div class=light>[ MySQL Debuger v0.1.2 ]</div>
<style>
body,html,div,p{margin:0; padding:0;}
.red{ color:white;background:red; }
.light{color:#ddd;}
</style>

<?php
function debug($str){
	echo '<pre>';
	print_r($str);
	echo '</pre>';
}

function query($sql="show tables;"){
	print('<p class=red>'.$sql.'</p>');
	$mysqli = new mysqli('172.21.0.5:3306','root','123456', 'mysql') or die('Error: '.mysqli_error());
	$rs=$mysqli->query($sql);
	$rows=array();
	while($row=$rs->fetch_object()){
		$rows[]=$row->Host . "\t" . $row->User;
	}
	$mysqli->close();
	return $rows;
}
//debug(query());
debug(query('select Host, User from user;'));







??
端口映射的指令是什么？docker指令：docker run -p ip:hostPort:containerPort redis
使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。
$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py









========================================
通过容器为本博客创建运行环境: php + Apache or Nginx
----------------------------------------
1. 测试
(1) 拉取镜像
这个是我 win10 xampp中的apache版本。2021.10
$ docker pull httpd:2.4.29


(2) 测试 apache httpd 服务器
$ docker run --rm -dit --name my-apache-app -p 8081:80 -v "$PWD":/usr/local/apache2/htdocs/ httpd:2.4.29
浏览器测试ok。

获取配置文件
$ docker exec -it my-apache-app bash
root@6028debe2216:/usr/local/apache2# wc /usr/local/apache2/conf/extra/httpd-vhosts.conf
41  162 1467 /usr/local/apache2/conf/extra/httpd-vhosts.conf
root@6028debe2216:/usr/local/apache2# ls -lth /usr/local/apache2/htdocs/
root@6028debe2216:/usr/local/apache2# cp /usr/local/apache2/conf/extra/httpd-vhosts.conf htdocs/

$ docker stop my-apache-app




(3) 如下尝试失败 //todo

$ cat conf/httpd-vhosts.conf
<VirtualHost *:80>
    ServerAdmin webmaster@dummy-host.example.com
    DocumentRoot "/usr/local/apache2/htdocs/txtBlog"
    ServerName blog.biomooc.com
    ServerAlias blog2.biomooc.com
    ErrorLog "logs/blog.biomooc.com-error_log"
    CustomLog "logs/blog.biomooc.com-access_log" common
</VirtualHost>


添加文件映射后
$ docker run --rm -dit --name my-apache-app -p 8081:80 -v ~/nginx/www/:/usr/local/apache2/htdocs/ \
-v ~/nginx/conf/httpd-vhosts.conf:/usr/local/apache2/conf/extra/httpd-vhosts.conf \
httpd:2.4.29

修改host文件
$ docker exec -it my-apache-app bash
# echo "127.0.0.1  blog.biomooc.com" >> /etc/hosts








2. 创建 txtBlog 运行环境: apache 
(1) 基础镜像
$ docker pull php:5.6.33-apache #神器


备份
$ docker tag php:5.6.33-apache dawneve/php:5.6.33-apache
$ docker push dawneve/php:5.6.33-apache


(2) git 拉取博客文件
$ cd ~/nginx/www/
$ https://github.com/DawnEve/txtBlog.git
$ chmod 777 txtBlog

(3) 启动容器
$ docker run --rm -dit --name txtBlog-app -p 8081:80 -v ~/nginx/www/txtBlog:/var/www/html php:5.6.33-apache

(4) 查看
http://IP:8081












3. 创建 txtBlog 运行环境: nginx 
nginx         1.21.3 
php           5.6.33-fpm

(1) 使用php镜像开启php-frm应用容器，默认端口是9000
# docker run --rm -d --name myphp-fpm php:5.6.33-fpm #不指定文件映射报错，File not found.

$ docker run --rm -d --name myphp-fpm -v ~/nginx/www/txtBlog:/usr/share/nginx/html/ php:5.6.33-fpm

查 IP
$ docker inspect myphp-fpm | grep IPAddress
"IPAddress": "172.18.0.4",


(2) 启动 nginx

$ docker run --rm -p 80:80 -d --name mynginx  -v ~/nginx/www:/usr/share/nginx/www nginx:1.21.3 #不行

进入正在运行的nginx容器
$ docker exec -it mynginx bash
root@abd819f9834f:/# cd /etc/nginx/conf.d/
root@abd819f9834f:/etc/nginx/conf.d# ls
default.conf

复制出配置文件
$ docker cp mynginx:/etc/nginx/conf.d/default.conf ~/nginx/conf/default.conf

$ docker stop mynginx
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    #access_log  /var/log/nginx/host.access.log  main;

	location / {
		# 这里是重点 1: 填写nginx上的html代码路径
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

修改接下来的php部分
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

- 去掉前面的注释
- 修改IP地址 127.0.0.1 为 php 容器的ip地址(不推荐，IP会变动) 或者 容器名字（推荐）
    location ~ \.php$ {
        # root         html;
        fastcgi_pass   myphp-fpm:9000;
        fastcgi_index  index.php;
		# 这是重点2: 要填写 php-fpm 上的php代码路径
        fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html/$fastcgi_script_name;
        include        fastcgi_params;
    }


再次启动 nginx 容器
$ docker run --rm -p 8081:80 -d --name mynginx \
--mount type=bind,source=/home/wangjl/nginx/www/txtBlog,target=/usr/share/nginx/html \
--mount type=bind,source=/home/wangjl/nginx/conf/default.conf,target=/etc/nginx/conf.d/default.conf \
--link myphp-fpm:myphp-fpm \
nginx:1.21.3

浏览器检查 OK！



进容器查看工作目录
$ docker exec -it mynginx bash
# cat /etc/nginx/conf.d/default.conf









========================================
Docker数据卷(Volume): 数据共享与持久化
----------------------------------------
https://docs.docker.com/storage/volumes/


1. Docker的数据持久化主要有两种方式：
bind mount
volume
tmpfs：挂载存储在宿主机系统的内存中，而不会写入宿主机的文件系统；（一般不会用）


Docker的数据持久化即使数据不随着container的结束而结束，数据存在于host机器上——
	要么存在于host的某个指定目录中（使用bind mount），
	要么使用docker自己管理的volume（/var/lib/docker/volumes下）。






2. 文件挂载时 bind mount

bind mount自docker早期便开始为人们使用了，用于将host机器的目录mount到container中。但是bind mount在不同的宿主机系统时不可移植的，比如Windows和Linux的目录结构是不一样的，bind mount所指向的host目录也不能一样。

这也是为什么bind mount不能出现在Dockerfile中的原因，因为这样Dockerfile就不可移植了。

将host机器上当前目录下的host-data目录mount到container中的/container-data目录：
$ docker run --rm -it --name=test1 -v $(pwd)/host-dava:/container-data alpine sh

$ docker inspect test1
...
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/home/wangjl/nginx/www/host-dava",
                "Destination": "/container-data",
...


(1) 主机和容器之间的数据共享
$ docker run -v /home/adrian/data:/data [image]
-v A:B A是在主机上的地址，B是在容器中的地址，这两个地址如果不存在都会创建，一旦容器运行，AB的会完全同步。

HOST:CONTAINER:ro # 该挂载时只读模式，ro就是readonly。



有几点需要注意：
- host机器的目录路径必须为全路径(准确的说需要以/或~/开始的路径)，不然docker会将其当做volume而不是 bind mount 处理
- 如果host机器上的目录不存在，docker会自动创建该目录
- 如果container中的目录不存在，docker会自动创建该目录
- 如果container中的目录已经有内容，那么docker会使用host上的目录将其覆盖掉





3.使用volume

(1) 简介
volume也是绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes。


==> 使用Volume有什么优势呢
Volume可以在容器之间以及容器和主机之间共享和重用
Volume在某一挂载的位置被修改，所有使用该volume的地方都会同时更新
Volume的大小不会被加到容器本身上
Volume会一直存在，直到没有任何容器使用它，才能使用命令docker volume rm [volumes名字]删除


$ docker volume --help
Usage:  docker volume COMMAND
Manage volumes
Commands:
  create      Create a volume
  inspect     Display detailed information on one or more volumes
  ls          List volumes
  prune       Remove all unused local volumes
  rm          Remove one or more volumes

常用命令
# docker volume create edc-nginx-vol // 创建一个自定义容器卷
# docker volume ls // 查看所有容器卷
# docker volume inspect edc-nginx-vol // 查看指定容器卷详情信息

清理命令
# docker stop edc-nginx // 暂停容器实例
# docker rm edc-nginx // 移除容器实例
# docker volume rm edc-nginx-vol // 删除自定义数据卷



(2) 创建 volume 
$ docker volume create --help
Usage:  docker volume create [OPTIONS] [VOLUME]
Create a volume
Options:
  -d, --driver string   Specify volume driver name (default "local")
      --label list      Set metadata for a volume
  -o, --opt map         Set driver specific options (default map[])

$ docker volume create my-volume

$ docker volume ls
DRIVER    VOLUME NAME
local     51bcb9b4779a9f07c62299d82189b6bfb65aa3e4314044a74fbd128d8e930a9a
local     my-volume


查看文件所在位置 
docker下所有的volume都在host机器上的指定目录下 /var/lib/docker/volumes
这些很长的名字是没有指定名字时，docker自动创建的数据卷。
$ sudo ls -l /var/lib/docker/volumes
drwx-----x 3 root root   4096 Oct 21 17:15 51bcb9b4779a9f07c62299d82189b6bfb65aa3e4314044a74fbd128d8e930a9a
drwx-----x 3 root root   4096 Oct 22 19:35 my-volume


使用 inspect 命令查看
$ docker volume inspect my-volume
[
    {
        "CreatedAt": "2021-10-22T19:35:40+08:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-volume/_data",
        "Name": "my-volume",
        "Options": {},
        "Scope": "local"
    }
]



(3) 将my-volume挂载到container中的/mydata目录：
$ docker run -it -v my-volume:/mydata alpine sh
/ # cd /mydata/
/mydata # echo "hello world! from docker volume" > a.txt
/mydata # exit
该容器退出即销毁。


inspect 查看，没变化
$ docker volume inspect my-volume
[
    {
        "CreatedAt": "2021-10-22T19:35:40+08:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-volume/_data",
        "Name": "my-volume",
        "Options": {},
        "Scope": "local"
    }
]

可以看到，volume在host机器的目录为/var/lib/docker/volumes/my-volume/_data。
此时，如果my-volume不存在，那么docker会自动创建my-volume，然后再挂载。


查看实际地址，确实有持久化的数据文件
$ sudo ls /var/lib/docker/volumes/my-volume/_data
a.txt
$ sudo cat /var/lib/docker/volumes/my-volume/_data/a.txt
hello world! from docker volume



(4) 也可以不指定host上的volume，docker会自动创建宿主目录

$ docker run -it -v /mydata alpine sh

此时docker将自动创建一个匿名的volume，并将其挂载到container中的/mydata目录。
匿名volume在host机器上的目录路径类似于：
/var/lib/docker/volumes/300c2264cd0acfe862507eedf156eb61c197720f69e7e9a053c87c2182b2e7d8/_data



(5) 除了让docker帮我们自动创建volume，我们也可以自行创建
$ docker volume create my-volume-2

然后将这个已有的my-volume-2挂载到container中:
$ docker run -it -v my-volume-2:/mydata alpine sh


需要注意的是，与bind mount不同的是，
如果volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中。
但是如果volume中已经有内容，则会将container中的目录覆盖。


(6) 两个容器共享数据：通过宿主机的数据卷
$ docker run -it -v my-volume-2:/mydata alpine sh
/ # cd /mydata/
/mydata # echo "good," >msg.txt


$ docker run -it -v my-volume-2:/home/ ubuntu:20.04 bash
root@d2e27c40b6a2:/# cd /home/
root@d2e27c40b6a2:/home# cat msg.txt 
good,




(7) 容器和容器之间的数据共享: 使用--volumes-from，从另一个服务或容器挂载它的所有卷。

$ docker run -it -h NEWCONTAINER --volumes-from container-test debian /bin/bash

意思是，将container-test这个container中的volume挂载到当前将要运行起来的容器中。
前提是container-test中的volumes必须被创建过，但是container-test可以是被stop的，原因是volume只能被手动删除，不是随着容器停止而被删除。

参数解释：
  -h, --hostname string                Container host name 给该容器取一个主机名，就是@后的部分
  -v, --volume list                    Bind mount a volume
      --volume-driver string           Optional volume driver for the container
      --volumes-from list              Mount volumes from the specified container(s)

注意 -h 设置的就是 @后面的部分，对应文件是 /etc/hostname
$ docker run --rm -it -h NGS ubuntu:20.04 bash
root@NGS:/# cat /etc/hostname 
NGS
root@NGS:/# cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.18.0.7      NGS
root@NGS:/# exit
exit


测试:
$ docker volume ls

启动一个父容器 ccF，带有一个数据卷
$ docker run --rm -itd --name ccF -v my-volume-3:/mydata alpine sh
$ docker exec -it ccF sh
/ # cd mydata
/mydata # echo "123456" > msg.txt
/mydata # exit


启动容器 ccS1继承 ccF，使用 volumes-from命令
$ docker run --rm -itd --name ccS1 --volumes-from ccF alpine sh
$ docker exec -it ccS1 sh
/ # cd mydata/
/mydata # ls
msg.txt
/mydata # cat msg.txt 
123456

启动容器 ccS2继承 ccF，使用 volumes-from命令
$ docker run --rm -itd --name ccS2 --volumes-from ccF alpine sh
$ docker exec -it ccS2 cat /mydata/msg.txt
123456


删除父容器 ccF 后，数据卷还在
$ docker stop ccF 
$ docker exec -it ccS2 cat /mydata/msg.txt
123456


启动容器 ccS3 继承 ccS2
$ docker run --rm -itd --name ccS3 --volumes-from ccS2 alpine sh
删除容器 ccS1, ccS2后，数据还在
$ docker stop ccS1 ccS2
$ docker exec -it ccS3 cat /mydata/msg.txt
123456


小结: 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。只能手动删除。







(8) 删除数据卷

$ docker volume ls
$ docker volume rm my-volume
$ docker volume ls

删除前后查看一下，确实删了。







4. Dockerfile中的VOLUME
https://blog.csdn.net/sunxiaoju/article/details/100038588


在Dockerfile中，我们也可以使用VOLUME指令来申明contaienr中的某个目录需要映射到某个volume：

#Dockerfile
VOLUME /foo


这表示，在docker运行时，docker会创建一个匿名的volume，并将此volume绑定到container的/foo目录中，如果container的/foo目录下已经有内容，则会将内容拷贝的volume中。
也即，Dockerfile中的VOLUME /foo与docker run -v /foo alpine的效果一样。


Dockerfile中的VOLUME使每次运行一个新的container时，都会为其自动创建一个匿名的volume，如果需要在不同container之间共享数据，那么我们依然需要通过docker run -it -v my-volume:/foo的方式将/foo中数据存放于指定的my-volume中。

因此，VOLUME /foo在某些时候会产生歧义，如果不了解的话将导致问题。












========================================
Docker官方编排容器工具: Docker-Compose
----------------------------------------
1. 是什么？
如果您的应用程序需要运行多个服务，那么你就需要Docker-Compose。
Docker-Compose可以让你使用单个命令来启动所有服务。

Docker用于管理应用程序的单个容器（服务）。

Docker-Compose用于同时管理同一个应用程序下的多个容器。这个工具提供与Docker相同的功能，但允许你管理更复杂的应用程序。

docker-compose 可以通过配置文件管理一组应用的容器，
docker-compose支持容器的自动启动、自动部署、热更新、热升级，简直太爽了~~



2. 安装Docker-Compose

(1)方法一: 通过pip安装(推荐)
Note: pip version 6.0 or greater is required

需要升级到最新版的pip
$ pip3 -V
pip 9.0.3 from /usr/lib/python3.6/site-packages (python 3.6)
$ sudo python3 -m pip install --upgrade pip -i https://pypi.douban.com/simple/
$ pip3 -V
pip 21.3 from /usr/local/lib/python3.6/site-packages/pip (python 3.6)

$ pip3 install -U docker-compose -i https://pypi.douban.com/simple/

验证安装成功
$ pip3 list | grep compose
docker-compose     1.29.2


通过pip卸载
$ pip uninstall docker-compose



(2) 方法二: 直接使用二进制文件

$ curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

$ chmod +x /usr/local/bin/docker-compose
你可以通过修改URL中的版本，可以自定义您的需要的版本。


Docker Compose存放在GitHub，国内访问比较慢。你可以也通过执行下面的命令，使用国内镜像安装Docker Compose。

$ curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
$ chmod +x /usr/local/bin/docker-compose


$ uname -s
Linux
$ uname -m
x86_64



(3) 验证安装成功
$ docker-compose --version
docker-compose version 1.29.2, build unknown


(4) 添加SHELL的TAB补全
Centos
$ sudo yum install bash-completion





3. Compose 使用的三个步骤：
使用 Dockerfile 定义应用程序的环境。
使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。
最后，执行 docker-compose up 命令来启动并运行整个应用程序。


(1) 获取帮助
$ docker-compose
Define and run multi-container applications with Docker.

Usage:
  docker-compose [-f <arg>...] [--profile <name>...] [options] [--] [COMMAND] [ARGS...]
  docker-compose -h|--help

Options:
  -f, --file FILE             Specify an alternate compose file
                              (default: docker-compose.yml)
  -p, --project-name NAME     Specify an alternate project name
                              (default: directory name)

...
Commands:
  build              Build or rebuild services
  config             Validate and view the Compose file
  create             Create services
  down               Stop and remove resources
  events             Receive real time events from containers
  exec               Execute a command in a running container
  help               Get help on a command
  images             List images
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pull service images
  push               Push service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  top                Display the running processes
  unpause            Unpause services
  up                 Create and start containers
  version            Show version information and quit


执行 docker-compose [COMMAND] --help 查看具体某个命令的使用说明。



(2) Docker-Compose YAML语法使用说明
默认的模板文件是 docker-compose.yml，其中定义的每个服务都必须通过image指令指定镜像或build指令(需要 Dockerfile)来自动构建。其它大部分指令都跟docker run中的类似。

如果使用build指令，在Dockerfile中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在docker-compose.yml中再次设置。

可以去yml文件检测网站进行检测：https://www.bejson.com/validators/yaml_editor/



build:
  context: ./webapp
  dockerfile: Dockerfile-alternate
  args:
    - buildno=1
    - user=someuser

构建镜像必须指定context。context是 docker build 命令的工作目录。默认情况下，如果不额外指定 Dockerfile 的话，会将 Context 下的名为 Dockerfile 的文件作为 Dockerfile。

这个版本是 Compose specification / Compose file format
There are several versions of the Compose file format – 1, 2, 2.x, and 3.x. 
https://docs.docker.com/compose/compose-file/compose-file-v3/


$ cat docker-compose.yml 
# yaml 配置实例
version: '3'
services:
  web:
    build: .
    ports:
   - "5000:5000"
    volumes:
   - .:/code
    - logvolume01:/var/log
    links:
   - redis
  redis:
    image: redis
volumes:
  logvolume01: {}




4. 示例: mysql+php+nginx 
https://www.cnblogs.com/cocowool/p/docker-php-dev.html


(1) 拉镜像
$ docker pull nginx:1.21.3
$ docker pull php:5.6.33-fpm
$ docker pull mysql:5.6


(2) 配置文件 
在工作目录 lnmp 下准备网站根目录、Nginx配置文件目录、Nginx日志目录。

$ mkdir lnmp
$ cd lnmp
$ mkdir -p nginx/www nginx/logs nginx/conf

准备 php 文件
$ cat nginx/www/index.php 
<?php
echo "hi, 123";
//  phpinfo(); //这个不能显示，不知道愿意 //todo
phpinfo(INFO_MODULES); //ok 

phpinfo(INFO_LICENSE); //ok



准备nginx的配置文件。
$ cat nginx/conf/php.conf
server {
	listen	80;
	server_name	localhost;

	location / {
		root	/usr/share/nginx/html;
		index	index.html index.htm index.php;
	}

	error_page	500 502 503 504	/50x.html;
	location = /50x.html {
		root	/usr/share/nginx/html;
	}

	location ~ \.php$ {
		fastcgi_pass	php:9000;
		fastcgi_index	index.php;
		fastcgi_param	SCRIPT_FILENAME	/www/$fastcgi_script_name;
		include		fastcgi_params;
	}
}


(3) 编排文件
在工作目录下创建docker-compose.yml编排文件。

关于docker-compose的详细介绍可以参考：
	docker-compose 使用介绍 http://edulinks.cn/2020/04/15/20200415-docker-compose/

$ cat docker-compose.yml
version: "2.1"
services:
    nginx:
        image: nginx:1.21.3
        ports:
            - "81:80"
        volumes: 
            - /home/wangjl/lnmp/nginx/www:/usr/share/nginx/html
            - /home/wangjl/lnmp/nginx/conf:/etc/nginx/conf.d
            - /home/wangjl/lnmp/nginx/logs:/var/log/nginx
        networks:
            - lnmp-network
    php:
        image: php:5.6.33-fpm
        volumes:
            - /home/wangjl/lnmp/nginx/www:/www
        networks:
            - lnmp-network
    mysql:
        image: mysql:5.6
        ports:
            - "3306:3306"
        environment:
            - MYSQL_ROOT_PASSWORD=123456
        networks:
            - lnmp-network
networks: 
    lnmp-network:


可以通过命令查看该配置:
$ docker-compose config
内容同上，只是格式和顺序略有调整。



(4) 运行效果

将docker-compose服务组上线。
系统会自动检查容器列表，如果服务对应的容器没有创建就会自动创建，如果服务对应容器没有启动就会自动启动。

$ docker-compose up -d
Creating network "lnmp_lnmp-network" with the default driver
Creating lnmp_php_1   ... done
Creating lnmp_mysql_1 ... done
Creating lnmp_nginx_1 ... done

$ docker ps
CONTAINER ID   IMAGE            COMMAND                  CREATED          STATUS          PORTS                                       NAMES
35b9ba4836c3   nginx:1.21.3     "/docker-entrypoint.…"   19 seconds ago   Up 17 seconds   0.0.0.0:80->80/tcp, :::80->80/tcp           lnmp_nginx_1
f5460b86cb2b   mysql:5.6        "docker-entrypoint.s…"   19 seconds ago   Up 17 seconds   0.0.0.0:3306->3306/tcp, :::3306->3306/tcp   lnmp_mysql_1
04cd0a08a6b7   php:5.6.33-fpm   "docker-php-entrypoi…"   19 seconds ago   Up 18 seconds   9000/tcp                                    lnmp_php_1


(5) 浏览器打开
http://110.40.254.15:81/
hi, 123


(6) 停止这一组服务
将docker-compose服务组下线。
系统会自动检查容器列表，自动停止服务组里面的服务对应的容器，自动删除服务组里面的服务对应的容器。

$ docker-compose down
Stopping lnmp_nginx_1 ... done
Stopping lnmp_mysql_1 ... done
Stopping lnmp_php_1   ... done
Removing lnmp_nginx_1 ... done
Removing lnmp_mysql_1 ... done
Removing lnmp_php_1   ... done
Removing network lnmp_lnmp-network


(7) 可以放入我的博客

文件夹改名 $ mv txtBlog www
权限 777
$ rm my_log.txt

重启。


(8)安装扩展
默认php镜像中提供的扩展比较少，缺少诸如mysql、gd2等常用的扩展，这样我们就需要自己安装并启用扩展。

首先进入到php容器，用php -m命令查看本地有什么扩展。

可以使用docker-php-ext-install命令来安装扩展。

$ docker-php-ext-install mysql
扩展安装好之后就可以在php.ini中启用。我们从phpinfo中可以看到，容器环境下默认的php.ini没有启用，可以从/usr/local/etc/php下将php.ini-development拷贝为php.ini。通过修改php.ini中配置，启用自己需要的扩展。下面是几个扩展安装的命令，供大家参考。

docker-php-ext-source 在容器中创建一个/usr/src/php目录
docker-php-ext-enable启用PHP扩展，省去我们手工编辑php.ini的过程
docker-php-ext-install安装并启用PHP扩展
docker-php-ext-configure经常与docker-php-ext-install搭配，在需要自定义扩展的配置时使用 


(9) 更多命令
$ docker-compose stop #停止容器，但是 docker ps -a 还能看到。
$ docker-compose start  # 容器从exit重新run。 docker ps 可见

$ docker-compose top #显示正在运行的进程

查看容器端口对应的宿主机端口
$ docker-compose port nginx 80
0.0.0.0:81

查看用到的镜像列表
$ docker-compose images
 Container     Repository      Tag         Image Id       Size  
------------- ------------------ ----------------- ----------------
lnmp_mysql_1   mysql        5.6          f3b364958c23   302.5 MB
lnmp_nginx_1   nginx        1.21.3       87a94228f133   133.3 MB
lnmp_php_1     php          5.6.33-fpm   aaf299648ff3   367.4 MB


查看版本号 
$ docker-compose version
docker-compose version 1.29.2, build unknown
docker-py version: 5.0.3
CPython version: 3.6.8
OpenSSL version: OpenSSL 1.0.2k-fips  26 Jan 2017








========================================
docker service //todo
----------------------------------------






========================================
进一步学习docker
----------------------------------------
docker inspect imageID #查看分层Layers

docker 镜像的位置 
root@ubt16:/var/lib/docker/containers# pwd
/var/lib/docker/containers


Dockerfile是一个重点，有很多细节，
Dockerfile reference：https://docs.docker.com/engine/reference/builder/



1.使用容器
当你能在Docker容器中运行你的应用的时候，你就学会怎么管理那些容器了。学习怎么检查、监视和管理你的容器：
Go to Working With Containers.

2.使用docker镜像
你学完怎么使用docker，就应该进行下一步了，学习使用docker构建你自己的应用。
Go to Working with Docker Images.


3.联网的容器
目前为止你看到怎么在docker容器中构建私人应用。现在学习怎么使用docker网络构建整个应用栈。
Go to Networking Containers.


4.管理容器中的数据
现在你知道了怎么把众多docker容器连接起来，下一步就是学习怎么管理这些容器内部的数据、容量和挂载。
Go to Managing Data in Containers.


# Getting help
	- [Docker homepage](https://www.docker.com/)
	- [Docker Hub](https://hub.docker.com/)
	- [Docker blog](https://blog.docker.com/)
	- [Docker documentation](https://docs.docker.com/)
	- [Docker Getting Started Guide](https://docs.docker.com/mac/started/)
	- [Docker code on GitHub](https://github.com/docker/docker)
	- [Docker mailing list](https://groups.google.com/forum/#!forum/docker-user)
	- Docker on IRC: irc.freenode.net and channel #docker
	- [Docker on Twitter](https://twitter.com/docker)
	- Get [Docker help](https://stackoverflow.com/search?q=docker) on StackOverflow
	- [Docker.com](https://www.docker.com/)







========================================
|-- 为运行中的容器添加端口映射
----------------------------------------
简单的说，2种。
- iptables 端口转发；
- commit 容器为一个images，重新运行一个新的容器




0. 容器内启动 ssh 隧道连接宿主机

容器内运行：
from inside the Docker container I connect to my host machine by IP:
$ ssh -R 8442:localhost:8080 alex@192.168.1.238
So while the SSH shell is open, it redirects connections from my host machine port 8442 into Docker container port 8080.
对宿主的8442的访问定位给容器8080


我的测试：

(1)容器内$ ssh -R 8895:localhost:8895 wangjl@j3.biomooc.com
浏览器访问 http://j3.biomooc.com:8895/cid?cellType=time&n=5&gene=GAPDH
	确实可以了！
	容器重启后又不行了，试试方法2又可以了。

(2) iptable转发端口
还不行的可以试试这个
$ docker inspect R4 | grep IPAddress
	"IPAddress": "172.17.0.2",

将容器的8895端口映射到docker主机的8895端口
$ sudo iptables -t nat -A DOCKER -p tcp --dport 8895 -j DNAT --to-destination 172.17.0.2:8895








1.方法1：修改要端口映射的容器的配置文件(不需要重启容器)：失败

(1) 获得容器IP：将container_name 换成实际环境中的容器名
1)查看容器的名字
$ docker ps -a 

(2)查看容器的全ID
$ docker inspect 容器ID/Name | grep Id
"Id": "c93d39c35e29b0b3b1d297968e77b67bde191a675aa31cc14f99bc34e1439260",

(3)查看容器的端口映射情况
$ docker port R4
8787/tcp -> 0.0.0.0:8022
8787/tcp -> [::]:8022

(4) 修改hostconfig.json和config.v2.json文件
默认在 /var/lib/docker/containers/目录下找与全ID相同的目录。
查找一下：
$ docker inspect R4 | grep -i container
	"ResolvConfPath": "/data/docker_root/docker/containers/c93d39c35e29b0b3b1d297968e77b67bde191a675aa31cc14f99bc34e1439260/resolv.conf",
	"HostnamePath": "/data/docker_root/docker/containers/c93d39c35e29b0b3b1d297968e77b67bde191a675aa31cc14f99bc34e1439260/hostname",
	"HostsPath": "/data/docker_root/docker/containers/c93d39c35e29b0b3b1d297968e77b67bde191a675aa31cc14f99bc34e1439260/hosts",
名字太长，定义临时变量来简化：
$ tmpDir=/data/docker_root/docker/containers/c93d39c35e29b0b3b1d297968e77b67bde191a675aa31cc14f99bc34e1439260/

暂停容器
$ docker stop R4

$ sudo ls -lth $tmpDir
-rw-------. 1 root root 3.5K Apr 25 09:52 config.v2.json
-rw-------. 1 root root 1.6K Apr 25 09:52 hostconfig.json

4A)修改 hostconfig.json
$ sudo vim $tmpDir/hostconfig.json
#	格式如："{容器内部端口}/tcp":[{"HostIp":"","HostPort":"映射的宿主机端口"}]

原文："PortBindings":{"8787/tcp":[{"HostIp":"","HostPort":"8022"}]}
改为 "PortBindings":{"8787/tcp":[{"HostIp":"","HostPort":"8022"}],"8895/tcp":[{"HostIp":"","HostPort":"8895"}]}


4B) 修改config.v2.json在ExposedPorts中加上要暴露的端口
$ sudo vim $tmpDir/config.v2.json
#	格式如："{容器内部端口}/tcp":{}

原文："ExposedPorts":{"8787/tcp":{}}
改为："ExposedPorts":{"8787/tcp":{},"8895/tcp":{}}


(5)重启该容器
$ docker restart R4

$ docker ps
CONTAINER ID   IMAGE                     COMMAND                  CREATED        STATUS          PORTS                                                                   NAMES
c93d39c35e29   dawneve/seurat:4.1.0b     "/rocker_scripts/doc…"   5 hours ago    Up 12 seconds   0.0.0.0:8022->8787/tcp, :::8022->8787/tcp                               R4

无效！


(6) 查询IP
$ docker inspect R4 | grep IPAddress
	"IPAddress": "172.17.0.3",

(7) iptable转发端口
将容器的8000端口映射到docker主机的8001端口
  sudo iptables -t nat -A DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.3:8000

将容器的8895端口映射到docker主机的8895端口
$ sudo iptables -t nat -A DOCKER -p tcp --dport 8895 -j DNAT --to-destination 172.17.0.3:8895


(100) 修改容器的json文件：
暂停容器，
修改容器映射时只需要 修改 hostconfig.json 的 PortBindings, 
增加容器映射时还需要改 config.v2.json 的 ExposedPorts

重新运行容器。
$ docker restart R4
失败！还是要重新启动容器，或者提交镜像再启动。


或者这里应该重启docker服务？
$ sudo service docker restart
没试



ref: 
https://forums.docker.com/t/how-to-expose-port-on-running-container/3252/13
https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container/26622041#26622041







2.方法2 容器打包成镜像，重新运行该镜像时添加端口映射

$ docker ps
$ docker commit containerid foo/aaa

$ docker run -it --name web_demo -p 8000:80  foo/aaa:v1  /bin/bash  # 添加了端口映射

$ docker run -it --name web_demo -p 8000:80  foo/aaa:v1  bash






ref:
https://blog.csdn.net/guoqingru0311/article/details/134050245





========================================
|-- 镜像存放地点 Where are Docker Images Stored? Docker Container Paths Explained
----------------------------------------
Docker has been widely adopted and is used to run and scale applications in production. Additionally, it can be used to start applications quickly by executing a single Docker command.


1. docker 的设置 
$ docker info #ubuntu
...
 Storage Driver: overlay2
 Docker Root Dir: /var/lib/docker
...

# for CentOS
$ docker info | grep -i driver
 Storage Driver: overlay2
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
$ docker info | grep -i root
 Docker Root Dir: /var/lib/docker




2. 镜像文件和容器文件都存放在哪里？
The storage location of Docker images and containers

(1) 查询1：docker info 
Ubuntu, CentOS: /var/lib/docker/


(2) 查询2：
$ docker inspect openjdk:9.0.1-11-slim
...
"LowerDir": "/var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be/diff:/var/lib/docker/overlay2/113c46fa2fc7e81949801027acf7f40219a1c89a162f1f625caceadd7a52df4a/diff:/var/lib/docker/overlay2/61608abb333f641a522fffc6fff3ed0ab80dc5dfbe8fde7e5ea69f71ee898dbf/diff:/var/lib/docker/overlay2/0fa09106e20aeda8d68048cb925975e3e060f3aac8b22fc1e6cbd9fbe289d1a3/diff",
...
"UpperDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/diff",
...

查看这些文件
$ sudo ls -lah /var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be
total 32K
drwx-----x  4 root root 4.0K Sep 12 23:36 .
drwx-----x 59 root root  12K Sep 13 09:37 ..
-rw-------  1 root root    0 Sep 12 23:36 committed
drwxr-xr-x  2 root root 4.0K Sep 12 23:36 diff
-rw-r--r--  1 root root   26 Sep 12 23:36 link
-rw-r--r--  1 root root   86 Sep 12 23:36 lower
drwx------  2 root root 4.0K Sep 12 23:36 work


(3). Docker 根目录的结构
The internal structure of the Docker root folder

$ sudo ls -la /var/lib/docker
total 64
drwx--x--x 14 root root  4096 Sep 12 23:13 .
drwxr-xr-x 89 root root  4096 Sep 12 19:48 ..
drwx------  2 root root  4096 Jan 13  2020 builder
drwx--x--x  4 root root  4096 Sep  3 16:25 buildkit
drwx-----x  5 root root  4096 Sep 13 09:37 containers #容器文件
drwx------  3 root root  4096 Jan 13  2020 image
drwxr-x---  3 root root  4096 Jan 13  2020 network
drwx-----x 59 root root 12288 Sep 13 09:37 overlay2  #镜像文件
drwx------  4 root root  4096 Jan 13  2020 plugins
drwx------  2 root root  4096 Sep 12 23:13 runtimes
drwx------  2 root root  4096 Jan 13  2020 swarm
drwx------  2 root root  4096 Sep 12 23:36 tmp
drwx------  2 root root  4096 Jan 13  2020 trust
drwx-----x  3 root root  4096 Sep 12 23:13 volumes


(4) 容器及其ID
$ sudo ls -lth /var/lib/docker/containers
total 12K
drwx------ 4 root root 4.0K Sep 12 23:13 375c2cb65a97a2fc884ba97fa70afaec95764f3b6197ad2f9a28a7350d81d69d
drwx------ 4 root root 4.0K Sep 12 23:13 b919662117ccf799921f0e667a63645b4ba4eae404227ae52233e9aab7e681da
drwx------ 4 root root 4.0K Sep 12 23:13 e2957a0e8b196caffc17fdc12287730bf9a213465ee8680c921575d42d6d6c99

$ docker ps -a
CONTAINER ID   IMAGE                      COMMAND                  CREATED        STATUS                      PORTS                    NAMES
375c2cb65a97   dawneve/rstudio:monocle3   "/init"                  4 months ago   Exited (255) 3 months ago   0.0.0.0:5000->8787/tcp   strange_wu
e2957a0e8b19   dawneve/rstudio:Seurat     "/init"                  6 months ago   Exited (0) 4 months ago                              friendly_borg
b919662117cc   dawneve/mysql              "docker-entrypoint.s…"   6 months ago   Exited (255) 3 months ago   0.0.0.0:7070->3306/tcp   peaceful_shtern
都能对上号。


(5) 镜像及存放地点
$ sudo ls -lth /var/lib/docker/overlay2
这里面装了很多镜像的层。所以总数会超过镜像个数。

$ docker images
REPOSITORY                   TAG             IMAGE ID       CREATED        SIZE
dawneve/rstudio              monocle3        8893c1f83058   6 months ago   2.58GB
dawneve/rstudio              Seurat          0ccae6079dad   6 months ago   2.09GB
dawneve/rstudio              latest          9e22c8cd092b   6 months ago   1.95GB
satijalab/seurat             4.0.0           32b06bd197c7   7 months ago   3.64GB
openjdk                      9.0.1-11-slim   5149033ba93d   3 years ago    374MB
hub.c.163.com/library/node   slim            914ef9e2ccb0   4 years ago    227MB
dawneve/mysql                latest          9e64176cd8a2   4 years ago    407MB

$ sudo du -sh /var/lib/docker/
7.8G	/var/lib/docker/
以上镜像size加起来大于这个数字，说明有共用部分。


$ sudo ls -lth /var/lib/docker/image/overlay2/imagedb/content/sha256
total 56K
-rw------- 1 root root 3.9K Sep 12 23:36 5149033ba93d3d1b6fc97a9bfb7cd56ec4b442e430ac36723f588bdf897f8e4a
-rw------- 1 root root 6.0K Sep 12 23:22 914ef9e2ccb047ed9a243a38a84b0285ca14e83afc1a35077a79560c185ec7c8
-rw------- 1 root root 7.3K Mar  3  2021 9e22c8cd092b6289d0765e08b682e2517cb7cef579baa871eec2362c9e43960d
-rw------- 1 root root 7.6K Mar  2  2021 8893c1f83058683401060f258f9cb693ec83154ce5a677bf7e8086eb1e89348d
-rw------- 1 root root 7.4K Mar  1  2021 0ccae6079dadb8cad8b05efb11a07f9f7fe6b3fd5634c87f7c2008025bfb9f81
-rw------- 1 root root 9.8K Mar  1  2021 32b06bd197c7868cf7b24fe578b53dc8b83ea997af9e5a626707a51750e598b6
-rw------- 1 root root 6.6K Jan 13  2020 9e64176cd8a206f88336506fe52cd8f87423147dc197d0250175dddc39465e90
这只是sha256码，文件在哪里呢？


$ docker inspect openjdk:9.0.1-11-slim |tail  -n 24 | head -n 9
$ docker image inspect 5149 |tail  -n 24 | head -n 9
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be/diff:/var/lib/docker/overlay2/113c46fa2fc7e81949801027acf7f40219a1c89a162f1f625caceadd7a52df4a/diff:/var/lib/docker/overlay2/61608abb333f641a522fffc6fff3ed0ab80dc5dfbe8fde7e5ea69f71ee898dbf/diff:/var/lib/docker/overlay2/0fa09106e20aeda8d68048cb925975e3e060f3aac8b22fc1e6cbd9fbe289d1a3/diff",
                "MergedDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/merged",
                "UpperDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/diff",
                "WorkDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/work"
            },
            "Name": "overlay2"
        },
#
The LowerDir contains the read-only layers of an image. The read-write layer that represents changes are part of the UpperDir.
LowerDir: 镜像的仅可读部分。
UpperDir: 镜像可读可写部分。


$ sudo ls -lth /var/lib/docker/overlay2/ | grep d255fe73
drwx-----x 4 root root 4.0K Sep 12 23:36 d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be

$ sudo ls -lth /var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be
total 16K
-rw------- 1 root root    0 Sep 12 23:36 committed
drwxr-xr-x 2 root root 4.0K Sep 12 23:36 diff
-rw-r--r-- 1 root root   26 Sep 12 23:36 link
-rw-r--r-- 1 root root   86 Sep 12 23:36 lower
drwx------ 2 root root 4.0K Sep 12 23:36 work



(6) 挂载到虚拟机的目录
$ docker run --name nginx_container -it --rm -v /var/log dawneve/nginx bash
root@c4cd8406733e:/# ls /var/log
alternatives.log  apt  bootstrap.log  btmp  dpkg.log  faillog  lastlog	nginx  wtmp

另一个终端查看 Mounts - Destination 中的内容
$ docker inspect nginx_container
        "Mounts": [
            {
                "Type": "volume",
                "Name": "fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5",
                "Source": "/var/lib/docker/volumes/fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5/_data",
                "Destination": "/var/log",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
#

对比下文例子可知，-v只提供一个参数，则是docker内部的地址，外部地址是随机生成的sha256字符那个目录。
$ ls -lah /var/lib/docker/volumes/fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5/_data
total 168K
drwxr-xr-x 4 root root 4.0K Sep 13 14:21 .
drwx-----x 3 root root 4.0K Sep 13 14:21 ..
-rw-r--r-- 1 root root 1.7K Apr 25  2017 alternatives.log
drwxr-xr-x 2 root root 4.0K Sep 13 14:21 apt
-rw-r--r-- 1 root root  34K Apr 25  2017 bootstrap.log
-rw-rw---- 1 root utmp    0 Apr 25  2017 btmp
-rw-r--r-- 1 root root  74K Apr 26  2017 dpkg.log
-rw-r--r-- 1 root root 3.2K Apr 26  2017 faillog
-rw-rw-r-- 1 root utmp  30K Apr 26  2017 lastlog
drwxr-xr-x 2 root root 4.0K Sep 13 14:21 nginx
-rw-rw-r-- 1 root utmp    0 Apr 25  2017 wtmp





(7) 完整的目录映射方式
$ docker run --name nginx_container -it --rm -v /var/log:/home/wangjl/ dawneve/nginx bash 
root@f32ff5a624d8:/# ls /home/wangjl/
Xorg.0.log		alternatives.log.3.gz

另一个终端查看：
$ ls /var/log
alternatives.log        alternatives.log.7.gz 

$ docker inspect nginx_container
...
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/var/log",
                "Destination": "/home/wangjl",
                "Mode": "",
                "RW": true,
                "Propagation": "rprivate"
            }
...
source 是宿主机， dest 是 docker 内部。


(8) Clean up space used by Docker
It is recommended to use the Docker command to clean up unused containers. Container, networks, images, and the build cache can be cleaned up by executing:

$ sudo ls /var/lib/docker/overlay2 | wc #60

$ docker system prune -a
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Are you sure you want to continue? [y/N] N
杀伤力太大了，不敢用。



remove unused volumes by executing:
$ docker volume prune
WARNING! This will remove all local volumes not used by at least one container.
Are you sure you want to continue? [y/N] y
Deleted Volumes:
f0c2c51bc9aded986ca956fabb7a6fe15711e3e571cee4a0e44cef4d3a61b860
9118a1d173a6f4da12835bc16dd14385d31b0e1e04b2b98247518ecc5d195ed2

Total reclaimed space: 207MB




(9) 查询自己安装的包
$ apt show docker #这个不是我们期望的 docker 
$ apt show docker.io  #这个才是

不要用 snap 命令安装docker，否则使用中会出错。
$ snap info docker







###### 这是因为有两份吗？
$ sudo tree /var/lib/docker/ > docker_file_str.txt
$ cat docker_file_str.txt  | grep -n openjdk
45482:│   │   │   │   ├── java-11-openjdk
59085:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.list
59086:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.postrm
59397:│   │   │   │   ├── java-11-openjdk
72983:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.list
72984:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.postrm


$ cat docker_file_str.txt | head -n 45492 | tail -n 20
$ cat docker_file_str.txt | head -n 59407 | tail -n 20






ref: https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/










========================================
故障排除 troubleshooting
----------------------------------------



========================================
|-- mysql 从容器外连不上怎么办？
----------------------------------------
有人说改这个，没改，/etc/mysql/mysql.conf.d
(1)在mysqld下添加skip-name-resolve
(2)In my.cnf file, add:
connect_timeout = 10
table_open_cache = 900
Restart MySQL.

(3)It might be the firewall problem or maybe because the MySQL server is bound to the loop-back IP (127.0.0.1 / localhost) which effectively cuts you off from connecting from “outside”.



感觉问题不在容器及内部的服务，在宿主机的端口不可访问，证据如下： 



1. docker是正常运行的
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
740797493b8c        dawneve/mysql       "docker-entrypoint.s…"   8 weeks ago         Up 9 minutes        0.0.0.0:7070->3306/tcp   loving_engelbart



进入docker可以登录mysql，
$ docker exec -it 740 bash
root@740797493b8c:/# mysql -u root -p 
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3

也就是docker提供的mysql服务一直在，一直正常运行！





2. 但是在docker外部怎么都无法连接mysql

$ mysql -h 127.0.0.1 -P7070 -uroot -p
Enter password: 
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0


$ mysql -h192.168.2.120 -P 7070 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '192.168.2.120' (111)







3. 使用telnet看端口，直接连不上。
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
telnet: Unable to connect to remote host: Connection refused




4.nmap扫描的结果是 filtered，
$ sudo nmap -sS -p 7000-8000 192.168.2.120

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-05 22:20 CST
Nmap scan report for sustc-HG.lan (192.168.2.120)
Host is up (0.000015s latency).
Not shown: 998 closed ports
PORT     STATE    SERVICE
7000/tcp open     afs3-fileserver
7070/tcp filtered realserver
8000/tcp open     http-alt

什么意思？
(1)https://blog.csdn.net/lee244868149/article/details/39177669
filtered(被过滤的)
由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。

难道是防火墙？

(2)
https://blog.csdn.net/m0_37268841/article/details/80234365
Filtered（过滤的）：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。

那么，我修改端口总可以吧？




5. 监听端口
http://www.kbase101.com/question/16413.html

(1)
$ sudo tcpdump -A 'udp and port 7070' -w tcpdump.out
[sudo] password for wangjl: 
tcpdump: listening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C0 packets captured
0 packets received by filter
0 packets dropped by kernel

现在停止转储并检查是否有任何数据包在tcpdump.out中被捕获或者没有使用wireshark。


(2)
$ nc y.biomooc.com -u 7070
如果没有捕获数据包，这意味着某些中间设备（防火墙）阻止了通信。否则，如果捕获，请检查服务器给出的回复以回复请求。如果它是带有某些错误代码的任何类型的ICMP回复，则表示存在一些阻塞的本地防火墙。


那就是防火墙问题了？





6. 关掉防火墙
(1)
$ sudo iptables -F
清空iptables设置。


(2)
$ service ufw status
$ service ufw stop

$ netstat | grep 7070
tcp        0      1 sustc-HG.lan:54550      10.20.46.143:7070       SYN_SENT   
tcp        0      1 sustc-HG.lan:54548      10.20.46.143:7070       SYN_SENT


这个用的 centos: https://blog.csdn.net/Blog_inG/article/details/88963043


(3)
关闭ubuntu的防火墙 ufw disable 
开启防火墙 ufw enable
https://www.jb51.net/article/138876.htm

$ sudo ufw disable
这个有用了。可以连接mysql了。
不知道是不是因为这个？


Ubuntu 防火墙更多命令：
sudo ufw allow 80 允许外部访问80端口
sudo ufw delete allow 80 禁止外部访问80 端口
sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口





7.回测：
步骤4和5的结果还是一样，没变化。

步骤3 telnet端口，结果是：
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
J
5.7.B8  1g<.rDA43X#r:mysql_native_password

^CConnection closed by foreign host.






8.更多端口查看方法
(1)
$ netstat -an|grep 7070
tcp6       0      0 :::7070                 :::*                    LISTEN 


(2)
服务端查看所有开放端口：$ netstat -luntp

$ netstat -luntp | head
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:43917         0.0.0.0:*               LISTEN      9690/python


$ netstat -luntp | grep 7070
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp6       0      0 :::7070                 :::*                    LISTEN      -    



(3)
$ ss -tnl

(4)
$ curl -i http://y.biomooc.com:7070
$ wget http://y.biomooc.com:7070




9. 又不行了，感觉是间歇性的。切换到局域网内部。改端口试试？
$ sudo docker run -p 7071:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
a1e0c7438e6d        dawneve/mysql       "docker-entrypoint.s…"   3 seconds ago       Up 2 seconds        0.0.0.0:7071->3306/tcp   lucid_shaw

$ mysql -h192.168.2.120 -P7071 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '192.168.2.120' (111)

还是连不上。

1)看iptables被加了这么一行
wangjl@sustc-HG:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain DOCKER (0 references)
target     prot opt source               destination         
ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:mysql

2)能ping通:
$ ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.079 ms


3)但是就是连不上:
$ mysql -h 172.17.0.2 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '172.17.0.2' (111)

$ mysql -h 172.17.0.2 -P3306 -uroot -p
一样不行。


4)
$ sudo nmap -sS -p 3300-8000 172.17.0.2

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-27 10:03 CST
Nmap scan report for 172.17.0.2
Host is up (0.000064s latency).
All 4701 scanned ports on 172.17.0.2 are closed
MAC Address: 02:42:AC:11:00:02 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 82.19 seconds


$ sudo nmap -sS -p 0-3300 172.17.0.2

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-27 10:09 CST
Nmap scan report for 172.17.0.2
Host is up (0.000015s latency).
All 3301 scanned ports on 172.17.0.2 are closed
MAC Address: 02:42:AC:11:00:02 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 3.25 seconds
这就奇怪了，都ping通了，但是不知道是哪个端口？



5) 端口还是不通。
$ telnet 192.168.2.120 8000
Trying 192.168.2.120...
Connected to 192.168.2.120.
Escape character is '^]'.
^C^C^C^C^C
Connection closed by foreign host.

$ telnet 192.168.2.120 7071
Trying 192.168.2.120...
telnet: Unable to connect to remote host: Connection refused


6) 换随机端口呢？
$ sudo docker run -P -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
02ebf4e44db2        dawneve/mysql       "docker-entrypoint.s…"   3 seconds ago       Up 2 seconds        0.0.0.0:32768->3306/tcp   eager_snyder

$ telnet 192.168.2.120 32768
Trying 192.168.2.120...
telnet: Unable to connect to remote host: Connection refused

$ mysql -h 192.168.2.120 -P32768 -uroot -p
通过了！！

再启动7070端口的容器，也正常了。
麻蛋，问题还是没有解决。这个间歇性bug，又白白耽误我8个小时。



10. 升级docker试试
感觉docker内部mysql没问题，就是外部端口映射出的问题。
(1)
可能是主机端口耗尽了？怎么查？


(2)
1) 查看老版本
$ docker --version
Docker version 18.09.9, build 1752eb3

升级 docker，需要sudo权限
$ curl -fsSL https://get.docker.com/ | sh

升级失败，需要获取google服务器上的代码包。
W: Failed to fetch https://packages.cloud.google.com/apt/dists/cloud-sdk/InRelease  Could not connect to packages.cloud.google.com:443 (2404:6800:4008:801::200e), connection timed out Could not connect to packages.cloud.google.com:443 (172.217.160.110), connection timed out







========================================
|-- docker 报错，可能是升级失败导致的
----------------------------------------
$ docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?


然后老docker也不能用了，没办法，只好重装docker了。


2)docker的安装和升级
1.删除docker  
sudo apt-get purge docker.io
sudo rm -rf /etc/docker/
sudo apt-get autoremove

2. 安装docker
sudo apt-get update
sudo apt-get upgrade
curl -sSL https://get.docker.com/ | sh

https://blog.csdn.net/Blog_inG/article/details/88963043



3)docker国内镜像源
https://www.daocloud.io/mirror

curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io



4)Ubuntu 使用阿里云 apt仓库安装 docker
如果你已经添加过官网的源 请在/etc/apt/sources.list 最后那几行删掉（有一个是那刚才添加的国外deb源 不然你每次apt update 都会爆一个蛋疼的错Failed to fetch https://apt.dockerproject.org/repo/dists/ubun），然后执行下面的阿里云安装源

$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
## OK 

$ sudo add-apt-repository \
     "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \
     $(lsb_release -cs) \
     stable"
#


5) 可行。又回来了。相当于没有升级。
$ sudo apt-get install docker

$ docker version
Client:
 Version:           18.09.9
#

$ docker --version
Docker version 18.09.9, build 1752eb3



========================================
|-- docker images 存储空间在哪里？占了多大？
----------------------------------------
1. 位置
$ docker info | grep "Docker Root Dir"
WARNING: No swap limit support
 Docker Root Dir: /var/lib/docker

$ cd /var/lib/docker
$ sudo ls -lth


$ sudo ls -lth image/overlay2/imagedb/content/sha256
$ docker images #可看到image id，和上一条一样。

$ sudo ls -aShl overlay2/


2. 怎么查看实际磁盘占有大小？
$ du -s /var/lib/docker/overlay2的最后一行。
或者 $ du -sh /var/lib/docker/overlay2。

或者更human readable的，根据文件大小排序 $ du -sh * | sort -h



ref:https://www.cnblogs.com/allen2333/p/11645140.html





========================================
|-- docker pull 下载不下来怎么办？怎么加速？
----------------------------------------
1. 使用国内镜像
(1)vim /etc/docker/daemon.json文件中加入，这里我加入的是阿里云还有七牛云：
{
  "registry-mirrors": [
  "https://registry.cn-hangzhou.aliyuncs.com",
  "https://reg-mirror.qiniu.com/"
  ]
}

然后重启守护进程
$ systemctl daemon-reload




(2)阿里云-控制台-容器镜像服务：
镜像加速器 
加速器地址 https://cgwjlyc8.mirror.aliyuncs.com


配置镜像加速器
您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器

sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://cgwjlyc8.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker






2. 好用的镜像链接如下：
科大镜像：https://docker.mirrors.ustc.edu.cn/
网易：https://hub-mirror.c.163.com/
阿里云：https://<你的ID>.mirror.aliyuncs.com
七牛云加速器：https://reg-mirror.qiniu.com参考链接：



3. 登录后下载，成功率大增
$ docker login -u 用户名  -p 密码  
$ docker pull ubuntu





4. 下载一个 gcc 编译器的镜像
$ docker pull gcc
$ docker run --rm gcc gcc --version
gcc (GCC) 11.2.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


$ cat Hello.c
#include<stdio.h>
int main(){
  printf("hello, c!\n");
}


$ docker run --rm -v /home/wangjl/test/cwl_test:/home/wangjl/  gcc gcc /home/wangjl/Hello.c -o /home/wangjl/Hello.out
$ ./Hello.out 
hello, c!


(2) 也可以直接一步执行多个shell语句: bash -c "cmd1 && cmd2"
$ docker run --rm -it ubuntu:20.04 bash -c "cd /etc  && cat hostname"
c802bd5d2030

$ docker run --rm -v /home/wangjl/test/cwl_test:/app/ --workdir=/app  gcc \
bash -c "gcc Hello.c -o a.out && ./a.out"
## hello, c!

-rwxr-xr-x 1 root   root    16K Sep 17 21:51 a.out









========================================
|-- ubuntu 镜像不支持显示中文
----------------------------------------
1. 查看本地语言包，安装语言包
$ locale -a 
C
C.UTF-8
POSIX
zh_CN.utf8









========================================
|-- 强制重启docker后，之前的容器不能start
----------------------------------------
1. 下次重启docker前，要先stop正在运行的容器，否则容易莫名其妙的错误

$ docker stop 16b
16b
$ docker start 16b
Error response from daemon: failed to create task for container: task 16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e: already exists
Error: failed to start containers: 16b


系统细节
	$ uname -a
	Linux jinlab-svr3 3.10.0-1160.108.1.el7.x86_64 #1 SMP Thu Jan 25 16:17:31 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux


系统报错：
$ sudo tail -f /var/log/messages -n 500 | grep -i error
Sep 25 16:36:23 jinlab-svr3 dockerd: time="2024-09-25T16:36:23.652057341+08:00" level=info msg="stopping event stream following graceful shutdown" error="context canceled" module=libcontainerd namespace=plugins.moby
Sep 25 16:56:59 jinlab-svr3 dockerd: time="2024-09-25T16:56:59.814283085+08:00" level=error msg="stream copy error: reading from a closed fifo"
Sep 25 16:56:59 jinlab-svr3 dockerd: time="2024-09-25T16:56:59.988586144+08:00" level=error msg="Handler for POST /v1.45/containers/16b/start returned error: failed to create task for container: task 16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e: already exists" spanID=aeaa4f8436c1e5f1 traceID=a111d52db97d763b21bfa861c16beebc









2. 死马当活马医：网络办法尝试 [失败]

https://github.com/docker/for-linux/issues/809
https://ahmetozer.org/Error-response-from-daemon-OCI-runtime-create-failed-container-with-id-exists

(1) 停止docker 容器
$ docker stop R4
$ docker ps


查看情况：
	$ docker inspect 16b
	很多输出，但是无用。


查看日志：
	$ docker logs 16b
	[root@16b4479c19da /]# [root@16b4479c19da /]# 
	就这一行，没啥信息。




(2) 停止docker 服务
$ sudo service docker stop

$ sudo service docker stop
[sudo] password for wangjl:
Redirecting to /bin/systemctl stop docker.service
Warning: Stopping docker.service, but it can still be activated by:
  docker.socket

查看服务
$ service docker status
Redirecting to /bin/systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)
   Active: inactive (dead) since Wed 2024-09-25 16:36:23 CST; 22s ago
...


查看错误：
$ dockerd --debug
INFO[2024-09-25T16:37:15.967941877+08:00] Starting up
dockerd needs to be started with root privileges. To run dockerd in rootless mode as an unprivileged user, see https://docs.docker.com/go/rootless/
就这一行，没有有用信息。




查根目录位置
$ docker info | grep -i root
 Docker Root Dir: /data/docker_root/docker



$ docker ps -a
CONTAINER ID   IMAGE                     COMMAND                  CREATED        STATUS                        PORTS                                                                   NAMES
16b4479c19da   dawneve/scpolya-seq2:b5   "bash"                   5 months ago   Exited (128) 41 minutes ago   10080-10081/tcp, 0.0.0.0:8085->8085/tcp, :::8085->8085/tcp, 10085/tcp   scPolyA-seq2_b5



查找容器id
$ sudo find /data/docker_root/docker/ | grep -in 16b4479c19da
	665:/data/docker_root/docker/image/overlay2/layerdb/mounts/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e
	666:/data/docker_root/docker/image/overlay2/layerdb/mounts/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/init-id
	667:/data/docker_root/docker/image/overlay2/layerdb/mounts/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/parent
	668:/data/docker_root/docker/image/overlay2/layerdb/mounts/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/mount-id
	958348:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e
	958349:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/checkpoints
	958350:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/config.v2.json
	958351:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/hostname
	958352:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e-json.log
	958353:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/hosts
	958354:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/resolv.conf.hash
	958355:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/resolv.conf
	958356:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/hostconfig.json
	958357:/data/docker_root/docker/containers/16b4479c19daeac62f66a17efa326c12949e8a78f953017b7033757938b7be3e/mounts
#



删除运行状态信息：无法执行，找不到这个文件
	#For example my container name bindnat64 and docker id is 4871484679fsd498sg4hr9t989.
	$ rm -rf /var/run/docker/runtime-runc/moby/4871484679fsd498sg4hr9t989
	$ docker start bindnat64
	bindnat64











3. 最后的尝试：提交为镜像，重新开容器

$ docker commit 16b new_image_name
$ docker run new_image_name

可以了！





========================================
singularity 简介与安装: for HPC
----------------------------------------
1. 简介

(1).Singularity是劳伦斯伯克利国家实验室专门为大规模、跨节点HPC和DL工作负载而开发的容器化技术。具备轻量级、快速部署、方便迁移等诸多优势，且支持从Docker镜像格式转换为Singularity镜像格式。

适合不给 root 权限的环境。

官方文档 https://sylabs.io/docs/
	https://sylabs.io/guides/3.5/user-guide/
仓库 https://singularity-hub.org/
代码 https://github.com/hpcng/singularity
	https://singularity.hpcng.org/

PKU教程: http://hpc.pku.edu.cn/_book/guide/soft_env/Singularity.html




(2).优缺点
https://zhuanlan.zhihu.com/p/126682747

1) Singularity 的优势
Singularity拥有容器技术所包含的大多数优势，例如启动迅速、资源开销小、轻松的迁移和扩展等等。除此之外，相较于Docker这样的容器技术，它还有一些独特的优势：

更加轻松的环境打包迁徙：Singularity所依赖的东西都在镜像文件中，不需要再单独打包 / 导入，直接拷贝走镜像即可。没有复杂的缓存机制，并且该镜像已经过压缩，只需占用非常少的磁盘空间。

和现有系统无缝整合：系统用户权限、网络等均直接继承宿主机配置，并且无需进入某个镜像后再执行命令，可以直接在外部调用镜像内的指令，就像执行一个本地安装的指令一样。

无需运行 daemon 进程：Singularity提供的完全是一个运行时的环境，在不使用时不需要单独的进程，不占用任何资源。不由 daemon 进程代为执行指令，资源限制和权限问题也得以解决。


官网说的优点：https://sylabs.io/singularity/
- A secure, single-file based container format: 一个单文件的镜像格式。
- Support for data-intensive workloads: 架起了HPC与AI、DL/ML、预测分析的桥梁。
- Extreme mobility: 使用标准文件和对象复制工具来 转移、共享、分发Singularity 容器。每个Singularity 终端都可以运行该容器。
- Compatibility: 兼容几乎任何环境
- Simplicity: 如果可以使用 Linux，就可以使用 Singularity
- Security: 屏蔽容器内权限提升，使用不可修改的单文件镜像格式来做签名和验证。
	allowing untrusted users to run untrusted containers in a trusted way.
- User groups: 
	https://github.com/sylabs
	https://groups.google.com/g/singularity-ce
	https://join.slack.com/t/singularityce/shared_invite/zt-t28zjurl-UnsNlmoggF7DcpMrKSR7Fw



2) Singularity 的缺点
上面提到了很多优势，但 singularity 也并非绝对完美的。

缺少网络虚拟化的支持
目前未实现 PID Namespace
认知度较低
由于众所周知的原因在国内下载镜像比较困难








2. 安装 (挺不好安装的)
(0) 安装 try1 尝试失败
## 安装依赖
$ sudo apt-get install -y build-essential libseccomp-dev pkg-config squashfs-tools cryptsetup
## $ sudo yum install -y gcc libuuid-devel squashfs-tools openssl-devel

## Install Golang 安装go (我安装过了)
export VERSION=1.13 OS=linux ARCH=amd64   
wget https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz 
tar -C /usr/local -xzvf go$VERSION.$OS-$ARCH.tar.gz
rm -f go$VERSION.$OS-$ARCH.tar.gz 
echo 'export PATH=/usr/local/go/bin:$PATH' >> /etc/profile
source /etc/profile

## 安装Singularity，这里的安装版本为3.5.2
$ git clone https://github.com/singularityware/singularity.git
$ cd singularity
$ git checkout v3.8.0  #现在的稳定版，查官网 https://sylabs.io/docs/

## ./configure --prefix=/usr/local --sysconfdir=/etc
$ ./mconfig
$ cd builddir
$ make  ## 很慢 21:12 --> IO超时

GEN GO DEP /data/wangjl/soft/singularity/builddir/starter.d
go: github.com/AdamKorcz/go-fuzz-headers@v0.0.0-20210319161527-f761c2329661: Get https://proxy.golang.org/github.com/%21adam%21korcz/go-fuzz-headers/@v/v0.0.0-20210319161527-f761c2329661.mod: dial tcp 172.217.24.17:443: i/o timeout
安装失败！！ //todo

$ sudo make install
$ cd ../..
$ rm -rf singularity*
可以删除刚才下载的安装文件夹了。
singularity version




(1) try2: 使用虚拟机中的 ubuntu20.04 再次安装
$ wget https://github.com/sylabs/singularity/releases/download/v3.8.3/singularity-ce-3.8.3.tar.gz
-rw-rw-r--  1 wangjl wangjl 8.1M Sep  2 01:25 singularity-ce-3.8.3.tar.gz

$ tar zxvf singularity-ce-3.8.3.tar.gz 
$ cd singularity-ce-3.8.3/
$ vim README.md 
安装请看 INSTALL.md
$ vim INSTALL.md


1)安装开发工具和包
$ sudo apt-get update

$ sudo apt-get install -y build-essential \
  libseccomp-dev pkg-config squashfs-tools cryptsetup

报错:The following information may help to resolve the situation:

The following packages have unmet dependencies:
 build-essential : Depends: libc6-dev but it is not going to be installed or
                            libc-dev
                   Depends: g++ (>= 4:7.2) but it is not going to be installed
                   Depends: dpkg-dev (>= 1.17.11) but it is not going to be installed
 libseccomp-dev : Depends: libseccomp2 (= 2.5.1-1ubuntu1~18.04.1) but 2.5.1-1ubuntu1~20.04.1 is to be installed
E: Unable to correct problems, you have held broken packages.  ##这是个啥？

虚拟机恢复Ubuntu20.04到出厂设置，使用原版源安装一切正常。
莫名其妙... 可能是源在同步中？之前的源是tsinghua，现在是默认cn.ubuntu源。


2) 安装Go语言 install and configure golang: https://golang.org/doc/install
$ sudo apt install golang-go

$ which go
/usr/bin/go

$ go version
go version go1.13.8 linux/amd64

3) 回去安装
$ cd singularity-ce-3.8.3/
$ ./mconfig && \
  cd ./builddir && \
  make  ##特别耗时，30min?
$ sudo make install #也耗时很久

4) 检查版本号
$ singularity --version
singularity-ce version 3.8.3

表示安装成功。



(2) 查看帮助
$ singularity --version
singularity-ce version 3.8.3

$ singularity
$ singularity --help
Linux container platform optimized for High Performance Computing (HPC) and Enterprise Performance Computing (EPC)
Usage: singularity [global options...]
Description:
  Singularity containers provide an application virtualization layer enabling mobility of compute via both application and environment portability. 
	Singularity 容器提供了一个应用程序虚拟化层，通过应用程序和环境的可移植性来支持计算的可移植性。
  With Singularity one is capable of building a root file system that runs on any other Linux system where Singularity is installed.
	我们可以用Singularity建立一个根文件系统，然后在所有安装Singularity的linux下运行。

Available Commands:
  build       Build a Singularity image
  pull        Pull an image from a URI
  run         Run the user-defined default command within a container
  inspect     Show metadata for an image
  exec        Run a command within a container
  search      Search a Container Library for images
  sif         Manipulate Singularity Image Format (SIF) images
For additional help or support, please visit https://www.sylabs.io/docs/








========================================
|-- singularity 使用方法和镜像构建
----------------------------------------
3. 使用 
(1) 一个很小的镜像 ubuntu:20.04 | OK
https://blog.csdn.net/kongxx/article/details/97965609

$ docker pull ubuntu:20.04


1) 生成 sif 镜像
获取预编译镜像 （会在当前目录下下载 ubuntu_<tag>.sif 文件）
$ singularity pull docker://ubuntu:20.04  #虽然docker下过，还要下载

从 Docker Hub build 镜像
$ singularity -d build ubuntu.sif docker://ubuntu:20.04 #很多屏的输出，没看出是否下载

从本地缓存生成 镜像
$ singularity build ubuntu_20.04-v2.sif docker-daemon://ubuntu:20.04


从镜像tar文件开始
$ docker save ubuntu:20.04 -o ubuntu20.04.tar
-rw------- 1 wangjl wangjl  72M Sep 16 15:15 ubuntu20.04.tar

$ singularity build ubuntu_20.04-v3.sif docker-archive://ubuntu20.04.tar




结果4个文件 大小一样，md5互不一样。
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 10:55 ubuntu.sif
-rwxrwxr-x 1 wangjl wangjl  27M Sep 16 10:53 ubuntu_20.04.sif
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 15:10 ubuntu_20.04-v2.sif
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 15:16 ubuntu_20.04-v3.sif





2) 交互模式运行 singularity shell
  shell       Run a shell within a container

$ singularity shell ubuntu_20.04.sif
Singularity> pwd
/home/wangjl
Singularity> id
uid=1000(wangjl) gid=1000(wangjl) groups=1000(wangjl),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare),134(docker)

Singularity> vim ReadMe 
bash: vim: command not found
Singularity> ping baidu.com
bash: ping: command not found
Singularity> exit
exit

怎么看着就是宿主机呢？目录是，用户也是。
宿主的命令ping, vim, 内部没有。
难道只是虚拟的命令环境，但是文件系统还是宿主机的？如果这样，就特别适合做 java/C的编译了!



3) 执行一个命令并退出 singularity exec
  exec        Run a command within a container

$ singularity exec ubuntu.sif bash -c  "pwd && id" 
/usr/bin/bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
/home/wangjl
uid=1000(wangjl) gid=1000(wangjl) groups=1000(wangjl),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare),134(docker)
$


4)运行一个容器 singularity run，感觉和 shell 一样，只不过最后不用放命令了。
  run         Run the user-defined default command within a container

$ singularity run ubuntu.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> pwd
/home/wangjl
Singularity> groups
wangjl adm cdrom sudo dip plugdev lpadmin lxd sambashare docker
Singularity> exit
exit
$ 


在内部写一个文件 01.txt
$ singularity run ubuntu.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> echo "line1">01.txt
Singularity> exit
exit
$ cat 01.txt 
line1

$ ls -lth
total 184M
-rw-rw-r-- 1 wangjl wangjl    6 Sep 16 11:11 01.txt


5) 后台运行容器实例
  instance    Manage containers running as services

启动实例
$ singularity instance start ubuntu.sif test1
$ singularity instance start ubuntu.sif test2

查看实例：只有IP，没有端口列 (类似于docker ps)
$ singularity instance list
INSTANCE NAME    PID      IP    IMAGE
test1            62541          /home/wangjl/ubuntu.sif
test2            62581          /home/wangjl/ubuntu.sif

操作实例
可以通过 shell, exec, run 命令来连到容器中运行命令

使用 shell 命令连入容器
$ singularity shell instance://test1
Singularity> cat 01.txt 
line1
Singularity> exit
exit

使用 exec 执行命令
$ singularity exec instance://test2 cat 01.txt
line1

停止实例
$ singularity instance stop test1
$ singularity instance stop test2
关闭（并删除）容器，更像是 docker stop + docker rm，所以轻易不要stop，只用 exit 就行了。



6) 绑定目录 -B 
在 Singularity 中也可以在 shell, run, instance.start 等命令中通过 “-B” 选项来实现 Docker 中 “-v” 选项提供挂载卷的功能，比如：
$ singularity shell -B /apps:/apps ubuntu.sif

挂在多个用逗号隔开：  -B /home/tom:/home/tom,/home/tom/dataset:/home/dataset \


$ singularity shell --help
Run a shell within a container

  -B, --bind strings           a user-bind path specification.  
		spec has the format src[:dest[:opts]], where src and dest are outside and inside paths.  路径内外的映射？
		If dest is not given, it is set equal to src. 
		Mount options ('opts') may be specified as 'ro' (read-only) or 'rw' (read/write, which is the default). Multiple bind paths can be given by a comma separated list.

$ singularity shell -B /tmp:/apps ubuntu.sif
Singularity> ls -lth /apps #虚拟的目录
total 48K
drwx------ 2 wangjl wangjl 4.0K Sep 16 11:11 tracker-extract-files.1000
Singularity> exit
exit

$ ls -lth /tmp #宿主机的目录
total 48K
drwx------ 2 wangjl wangjl 4.0K Sep 16 11:11 tracker-extract-files.1000




7) --fakeroot 啥意思？在容器内有root权限
The --fakeroot option is available with the following singularity commands:
shell
exec
run
instance start
build

$ singularity exec --fakeroot docker://ubuntu:20.04 ls -lth








(2) 运行一个试试 mysql 镜像 | ok，不支持端口映射
https://uh.edu/rcdc/resources/software/Singularity.php

1) Get the docker image and convert it to singularity image,
$ singularity pull docker://dawneve/mysql  #不好，singularity 没法做端口映射
INFO:    Converting OCI blobs to SIF format
INFO:    Starting build...
Getting image source signatures
Copying blob d08a2c3112d4 done 
...
Writing manifest to image destination
Storing signatures
2021/09/16 10:13:20  info unpack layer: sha256:d08a2c3112d431c43e02458a285501d289333380438e760962619c8672bcbe0b
...
INFO:    Creating SIF file...

$ ls -lth
total 131M
-rwxrwxr-x 1 wangjl wangjl 131M Sep 16 10:17 mysql_latest.sif


2) To open an interactive shell inside the container,
$ singularity shell mysql_latest.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> mysql -V
mysql  Ver 14.14 Distrib 5.7.18, for Linux (x86_64) using  EditLine wrapper

Note: The project directory by default mounts to /mnt instead of /project
貌似不适合这种带端口映射的情况。

3) To directly execute a command inside your container environment,
## singularity exec shub://singularityhub/ubuntu cat /etc/os-release

$ pwd 
/home/wangjl/data/dbFile

$ mkdir -p ${PWD}/mysql/var/lib/mysql ${PWD}/mysql/run/mysqld
$ singularity instance start --bind ${HOME} \
    --bind ${PWD}/mysql/var/lib/mysql/:/var/lib/mysql \
    --bind ${PWD}/mysql/run/mysqld:/run/mysqld \
    mysql_latest.sif mysql
## INFO:    instance started successfully

$ singularity instance list
INSTANCE NAME    PID     IP    IMAGE
mysql            3115          /home/wangjl/data/dbFile/mysql_latest.sif


$ singularity run instance://mysql #报错
error: database is uninitialized and password option is not specified 
  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD
这个报错怎么解决？
docker的-e参数，这里是什么？是 --env 
$ singularity run --env MYSQL_ROOT_PASSWORD=123456  instance://mysql


4) 连接该数据库，并新建库和表
$ ifconfig #查宿主机的ip
192.168.2.242
不支持端口映射，那就是 3306 端口本身了。

$ mysql -h 192.168.2.242 -P 3306 -uroot -p
mysql> create database wang;
mysql> use wang;
Database changed

CREATE TABLE `think_weibo` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `uid` int(20) NOT NULL,
  `content` text,
  `add_time` varchar(30) DEFAULT NULL,
  `cid` int(10) DEFAULT NULL,
  `archive` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into think_weibo values(1,101,"ctx1", "20210901",1, 0),(2,202,"ctx2", "20210902",2, 1);

mysql> select * from think_weibo;
+----+-----+---------+----------+------+---------+
| id | uid | content | add_time | cid  | archive |
+----+-----+---------+----------+------+---------+
|  1 | 101 | ctx1    | 20210901 |    1 |       0 |
|  2 | 202 | ctx2    | 20210902 |    2 |       1 |
+----+-----+---------+----------+------+---------+
2 rows in set (0.00 sec)

mysql> exit
Bye


查看文件
$ ls -lth dbFile/mysql/var/lib/mysql/wang
total 112K
-rw-r----- 1 wangjl wangjl  96K Sep 16 16:32 think_weibo.ibd
-rw-r----- 1 wangjl wangjl 8.6K Sep 16 16:29 think_weibo.frm
-rw-r----- 1 wangjl wangjl   65 Sep 16 16:28 db.opt


5) 退出该容器
$ singularity instance stop mysql
INFO:    Stopping mysql instance of /home/wangjl/data/dbFile/mysql_latest.sif (PID=3115)










(3) 再试试 java 的镜像 | ok
#############
先安装一个 docker 
$ sudo apt install docker.io
$ docker --version
Docker version 20.10.7, build 20.10.7-0ubuntu1~20.04.1

$ sudo groupadd docker #添加docker用户组
$ sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中
Adding user wangjl to group docker

$ newgrp docker #更新用户组
$ groups 

$ sudo vim /etc/docker/daemon.json 
{
  "registry-mirrors": [
    "http://hub-mirror.c.163.com",
    "https://registry.cn-hangzhou.aliyuncs.com"
  ]
}

$ sudo systemctl daemon-reload #重启守护进程
$ sudo systemctl restart docker

$ docker login -u dawneve 
输入密码，登录。
$ docker pull openjdk:9.0.1-11-slim

$ docker images
REPOSITORY   TAG             IMAGE ID       CREATED       SIZE
openjdk      9.0.1-11-slim   5149033ba93d   3 years ago   374MB

$ pwd
/home/wangjl/test

$ cat Hello.java
public class Hello { 
	public static void main(String args[])  {    
		System.out.println("Hello world, from Java!");  
	}
}

$ docker run --rm -v /home/wangjl/test:/test/ openjdk:9.0.1-11-slim bash -c 'cd /test/ && javac Hello.java && java Hello'
Hello world, from Java!
#############


1) 从本地缓存的镜像构建 sif 文件
$ singularity build openjava9-v1.sif docker-daemon://openjdk:9.0.1-11-slim
注意：从原来的docker变成了docker-daemon；必须加tag标签；

报错：是不是也是空间不够？很可能是临时文件夹不够大
INFO:    Creating SIF file...
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0xa8 pc=0x5631607d5e9a]


防止撑爆 /tmp 临时文件夹:
$ TMPDIR=$PWD singularity build openjava9-v1.sif docker-daemon://openjdk:9.0.1-11-slim
INFO:    Build complete: openjava9-v1.sif


2) 从 tar 文件生成 sif 
$ docker save openjdk:9.0.1-11-slim -o jdk9.tar
$ singularity build openjdk9-v2.sif docker-archive://jdk9.tar

生成的文件大小一样，md5不同
-rwxr-xr-x 1 wangjl wangjl 174M Sep 16 15:40 openjava9-v1.sif
-rwxr-xr-x 1 wangjl wangjl 174M Sep 16 15:36 openjdk9-v2.sif

编译和运行
$ singularity run -B /home/wangjl/test:/app/  openjava9-v1.sif bash
Singularity> cd /app
Singularity> javac Hello.java
Singularity> java Hello 
Hello world, from Java!
Singularity> exit
exit

$ ls -lht #注意所有人和组的区别
total 12K
-rw-rw-r-- 1 wangjl wangjl 427 Sep 16 15:45 Hello.class #在 Singularity 中生成的
-rw-r--r-- 1 root   root   427 Sep 16 14:58 Hello.class2 #在docker中生成的，改名2


或者执行一行命令
$ singularity exec -B /home/wangjl/test:/app/ --workdir=/app openjava9-v1.sif bash -c "cd /app && ls -lth"
/usr/bin/bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
total 12K
-rw-rw-r-- 1 wangjl wangjl 427 Sep 16 15:45 Hello.class
-rw-r--r-- 1 root   root   427 Sep 16 14:58 Hello.class2
-rw-rw-r-- 1 wangjl wangjl 134 Sep 16 14:57 Hello.java













4. 生成 sif 镜像的方法

(1) build可以生成两种不同格式的容器，具体如下。
- 适用于生产环境使用的压缩只读Singularity Image File (SIF) 格式 (默认)
- 适用于交互式开发的根目录可写的沙盒 (–sandbox)



(2) Singularity可以方便地处理Docker镜像
https://singularity.hpcng.org/user-docs/master/build_a_container.html
https://blog.csdn.net/weixin_44843824/article/details/119715691


方式1：从docker uri开始
$ singularity pull docker://godlovedc/lolcow # 下载pre-built image，如果没有呢？和下一个一样
$ singularity build mylolcow_latest.sif docker://godlovedc/lolcow # 下载后再build成镜像


方式2：从本地缓存的docker image开始
假设本地有godlovedc/lolcow镜像
$ sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
godlovedc/lolcow    latest              577c1fe8e6d8        16 months ago

$ singularity build lolcow_from_docker_cache.sif docker-daemon://godlovedc/lolcow:latest
注意: 从原来的docker变成了docker-daemon；



方式3：从镜像tar文件开始
首先需要将docker镜像转成tar文件：
先查看当前的docker镜像
$ sudo docker images
REPOSITORY           TAG              IMAGE ID       CREATED        SIZE  
hello-world          latest           d1165f221234   5 months ago   13.3kB

使用如下命令将hello-world镜像转成tar文件，这里save后面的参数就是IMAGE ID，即上面输出的第三列
$ sudo docker save d1165f221234 -o hello_world.tar
这样当前目录下面就出现了hello_world.tar文件。

接着，将该tar文件转成singularity镜像，命令与输出如下：
$ singularity build hello_world.sif docker-archive://hello_world.tar
INFO:    Build complete: hello_world.sif

原本的docker://换成了docker-archive://，方式2里面是docker-daemon://；
这里用的是tar文件，singularity也可以处理tar.gz文件。




(3) 从定义文件构建

1) 定义文件
$ cat nginx.def
Bootstrap: docker
From: nginx
Includecmd: no

%startscript
   nginx

执行构建：
$ sudo singularity build nginx.sif nginx.def #必须使用root权限
-rwxr-xr-x 1 wangjl wangjl  50M Sep 16 16:54 nginx.sif


2)测试 
$ singularity instance start --writable-tmpfs nginx.sif web 
$ curl localhost
curl: (7) Failed to connect to localhost port 80: Connection refused
#网页不能访问，curl也不行，可能默认的80端口被封了？测试发现，加sudu就好了。

$ singularity instance list
INSTANCE NAME    PID     IP    IMAGE
web              3578          /home/wangjl/data/nginx.sif
$ singularity instance stop web


3) 修改配置文件，改端口，再次测试
查配置文件的位置
$ singularity shell nginx.sif 
Singularity> cat /etc/nginx/conf.d/default.conf | grep -i root
        root   /usr/share/nginx/html;
Singularity> exit
exit


自定义配置文件：
$ cat nginx.config 
server {
    listen       8008;
    listen  [::]:8008;
    server_name  localhost;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
		
        # list files
        autoindex on; 
        autoindex_exact_size on; 
        autoindex_localtime on; 
    }
}

不加sudo访问不了。可能是网络、端口是系统资源，必须特权用户才能调用。
$ sudo singularity instance start -B /home/wangjl/data/nginx.config:/etc/nginx/conf.d/default.conf --writable-tmpfs nginx.sif web 

$ sudo singularity instance list
INSTANCE NAME    PID     IP    IMAGE
web              4457          /data/wangjl/nginx.sif
$ sudo singularity instance stop web








5. 生信常用的镜像
(1) 从github 上找
https://singularityhub.github.io/singularity-hpc/

https://github.com/pscedu/singularity-bowtie2
https://github.com/pscedu/singularity-samtools
https://singularityhub.github.io/singularity-hpc/r/biocontainers-samtools/


(2) 命令行搜索
$ singularity search samtools
Found 15 container images for amd64 matching "samtools":

	library://alesr13/default/samtools_bwa_picard:v0.1
		Signed by: 6e23de6eac622dd1d96f304af7b50e57f44404e7

	library://btmiller/default/testimg-bowtie2-samtools:latest

	library://daanjg98/rnaseq/samtools:1.11

从搜索结果中选一个靠谱的，建立sif镜像
$ TMPDIR=$PWD singularity build samtools.sif library://daanjg98/rnaseq/samtools:1.11
INFO:    Build complete: samtools.sif
-rwxr-xr-x 1 wangjl wangjl 170M Sep 16 17:43 samtools.sif


查看版本号:
$ singularity exec samtools.sif samtools --version
samtools 1.11
Using htslib 1.11
Copyright (C) 2020 Genome Research Ltd.

据说还能这样执行：
$ ./samtools.sif samtools --version
samtools 1.11
Using htslib 1.11
Copyright (C) 2020 Genome Research Ltd.


拷贝过来一个 bam 文件 

不认识其他目录，只认识 $HOME 目录。
$ ls /data
lost+found  wangjl

$ singularity exec samtools.sif bash
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> cd /data
bash: cd: /data: No such file or directory
Singularity> ls /|grep data

Singularity> cd ~/test
Singularity> samtools view cgm-90.sort.bam | wc
  57814  994108 22848219
Singularity> exit
exit


容器启动时所在的工作目录
$ singularity exec samtools.sif pwd 
/home/wangjl

完整运行模式: 要使用完整路径:
$ singularity exec samtools.sif samtools view ~/test/cgm-90.sort.bam | wc -l #57814

一句话运行
$ ./samtools.sif samtools view ~/test/cgm-90.sort.bam | wc -l  #57814






6. 疑难杂症：
(1) 临时文件夹 /tmp 装不下怎么办？
$ TMPDIR=$PWD singularity build openjdk9-V2.sif docker-archive://jdk9.tar #能改变临时文件夹位置的命令









ref:
http://hpc.pku.edu.cn/_book/guide/soft_env/Singularity.html
经典常用命令[推荐] https://blog.csdn.net/kongxx/article/details/97965609
构建镜像 https://zhuanlan.zhihu.com/p/138806519
https://biocorecrg.github.io/ELIXIR_containers_nextflow/singularity.html

官方服务文档 https://singularity.hpcng.org/user-docs/master/running_services.html#nginx-hello-world-in-singularity





========================================
|-- 使用 docker 生成 singularity 镜像
----------------------------------------
使用场景：
对于不支持 docker 的机器，怎么获取 sif 镜像呢？
可以在另一台主机上生成，由于 singularity 安装很困难，如果仅安装 docker 怎么生成 sif 文件呢？


1. 搜了一下 
$ docker search singularity
NAME                                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
singularityware/docker2singularity             docker2singularity                              4                    [OK]
singularityware/singularity                    docker base images to provide release versio…   2                    [OK]
arcts/singularity-util                         A multi-purpose Docker based container that …   2                    [OK]
alfpark/singularity                            Singularity Images                              1                    [OK]

貌似第一个可以试试，看一下可用的tag有哪些
$ curl -L -s https://registry.hub.docker.com/v1/repositories/singularityware/docker2singularity/tags
==> chrome F12 console:
t2=[...] curl 输出的结果。
for(var i=0; i<t2.length; i++){console.log(t2[i].name)}
输出:
1.10
1.11
1.12
1.13
v2.3
v2.4
v2.5
v2.6
v2.6.0
v3.1
v3.2.1
v3.3.0
v3.4.0
latest

为了保证可重复性，我们就下载最新的版本号
$ docker pull singularityware/docker2singularity:v3.4.0

在下载一个 nginx，mysql，并尝试生成其sif文件
$ docker pull nginx 

$ docker images
REPOSITORY                           TAG       IMAGE ID       CREATED        SIZE
nginx                                latest    ad4c705f24d3   9 days ago     133MB
mysql                                latest    0716d6ebcc1a   2 weeks ago    514MB
dawneve/rstudio                      latest    9e22c8cd092b   7 months ago   1.95GB
singularityware/docker2singularity   v3.4.0    9506680afdf6   2 years ago    350MB




(1) docker导出为tar文件，看来不需要这一步了。
$ docker save nginx:latest -o nginx.tar
-rw-------    1 root     root      131.2M Sep 19 07:46 nginx.tar




(2) 尝试转换
找到官方教程: 说这个docker过期了，官方不让他们再放新镜像了。可能是竞争。
https://hub.docker.com/r/singularityware/docker2singularity

$ docker run \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /root/wangjl:/output \
--privileged -t --rm \
singularityware/docker2singularity \
nginx:latest

生成一个 simg 镜像文件，是一个老的格式。





(3) 最新的在哪里呢？转到一个新的网站了
https://quay.io/repository/singularity/docker2singularity
https://quay.io/repository/singularity/docker2singularity?tab=tags 最新的版本是 v3.8.3

$ docker pull docker pull quay.io/singularity/docker2singularity

$ docker tag quay.io/singularity/docker2singularity dawneve/docker2singularity
$ docker rmi quay.io/singularity/docker2singularity

试试这个最新版
$ docker run \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /root/wangjl:/output \
--privileged -t --rm \
dawneve/docker2singularity \
nginx:latest

产出的文件:
-rwxr-xr-x    1 root     root       49.3M Sep 19 08:07 nginx_latest-2021-09-09-5f214b8ed419.sif

$ mv nginx_latest-2021-09-09-5f214b8ed419.sif nginx.sif


如果是windows，这样写: -v D:\host\path\where\to\output\singularity\image:/output \




(4) 运行 sif 文件
$ docker pull quay.io/singularity/singularity:v3.8.3
$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 version
3.8.3

$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 instance list 
INSTANCE NAME    PID    IP    IMAGE


报错:
$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 run nginx.sif pwd











####################################
带远程桌面的镜像 Desktop as a Container
https://quay.io/repository/rarm_sa/daac
$ docker pull quay.io/rarm_sa/daac
$ docker tag quay.io/rarm_sa/daac daac

https://github.com/snowjet/DaaC
不知道怎么用。










========================================
容器编排： Kubernetes(k8s) 简介 与 CRI //todo
----------------------------------------
前置知识: Linux和Docker基本使用熟练掌握，一门后端语言 Java or Python.


1. 简介
(1)
Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。

Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。


(2) K8s 只能与 CRI 运行时通信。
K8s 是通过 docker-shim 作为桥接服务，将 CRI 转换为 Docker API，然后与 Dokcer 进行通信的。
CRI 运行时是啥？我们暂可以简单的将 Ta 理解为与 Docker 同等的存在（另外一个容器容器运行时）。
	CRI（Container Runtime Interface）是 K8s 定义的一组与容器运行时进行交互的接口，用于将 K8s 平台与特定的容器实现解耦。
在 K8s 早期的版本中，对于容器环境的支持是通过 hard code 方式直接调用 Docker API 的，后来为了支持更多的容器运行时和更精简的容器运行时，K8s 提出了CRI。

实际对容器的操作最终还是要交给 OCI，CRI 也只是个中转。

(3) 凝练
k8s是开源的Docker容器编排系统，
他处理计算集群的节点调度，积极应对工作负荷，
保证节点的状态符合用户声明的意图，
使用POD和标签的概念，聚合容器把应用组合，
成为易于管理和发现的逻辑单元。






2. 课程与教程

(1) 文字版

1) Kubernetes 是用于自动部署，扩展和管理容器化应用程序的开源系统。
https://kubernetes.io/zh/
它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。Kubernetes 源自Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践


2)
https://www.kubernetes.org.cn/k8s
https://www.kubernetes.org.cn/


基本概念:
	Node: pod运行在 Node 上；一个node 上可以有无穷多个pod，只要资源够用。
	pods: 最小的容器管理单元，一个pod通常有一个容器，必要的时候也可以多个；一个pod有一个IP。
	replicate controller: 保证容器的重复数，一旦有坏的及时补上；
	Secrets: 保存密码的
	ReplicaSet: 容器集合
	DaemonSets: 保证每个节点有一个 Pod 在运行；
	Ingresses: 一个入口进去后分成几个流向
	CronJobs：定时任务，适合定期备份、生成报告、做测试等；
	CRDs: 根据 CRD definition 和 custom controller 调用 K8S API. 
	
	Service: 每个pod有自己的IP，多个pod构成一个service，这个服务也有一个IP。即便pod挂掉了，service的IP还在。
		一个service可以包含多个pod，这些pod可以分布在几个node上。
		Service 是一个逻辑概念。Pod才是真实存在的。
		Service 是按照pod的标签识别的，比如 app=B 的pod都属于某个服务。
		启动过程：master node 上的 Deployment 一个服务A，需要在 worker nodes上扩容4个pod。
		滚动更新过程： 停掉一个pod, 启动一个pod with new IP address, 然后 updated app；然后更新下一个pod，直到4个pod都更新；
		在更新和扩容过程中，service的IP是保持不变的。

	集群 master: k8s 的核心服务，认证/授权等入口服务；
		Scheduler: 负责调度
		Kube-dns: 负责整个集群的dns服务。实现通过名字访问。
		ControllerManager: 负责pod的扩容、更新等；
		dashboard: 集群数据的展示、操作的GUI界面
		ETCD: 内部数据库；
		RestAPI：可以把pod的信息保存到ETCD数据库
	集群 node: 负责维护其pod的更新、volume、网络等。
		kube-proxy：负责服务发现，和负载均衡。
	整个过程: 
		用户执行 kubectl/userClient请求，master进行认证/授权，然后Scheduler经过计算分配资源，
		APIServer就请求 资源对应的node上的 Kubelet 运行 pod， 然后 APIServer 把pod信息保存到ETCD数据库；
		pod运行起来后， ControllerManager 就开始管理这些pod。谁挂了就创建一个新的。
		对于几个node上的属于同一个服务的pods，它们可以通过 kube-proxy 暴露一个端口，通过node的某个端口号直接访问。
		让每个pod都可以通过名字访问对方，这就是k8s提供的亮点功能。
		

k8s 设计理念
	API 设计原则
		声明式的，每个都是名字
		从应用出发设计接口
	控制机设计原则
		假如任何可能的错误，并作出处理
		任何模块都可以在出错后自动恢复
		任何模块都会优雅降级，低级模块不依赖高级模块
k8s 网络
	CNI 接口的网络都支持
	Flannel, Calico, Weave 都提供了
	Docker本身的网络只能访问本node上的容器，而不能跨主机访问，但是pod可以跨主机互相访问；



通过打分，确定新建pod的主机:
Kubernets scheduler - preselect
	调度时检查的点:
	NodiskConflict: 先检查是否挂载冲突
	CheckNodeMemoryPressure: 内存压力检查
	NodeSelector: 可以选择具有某个标签的节点
	FitResource: 要满足pod需要的 CPU、GPU、内存等要求；
	Affinity: 有些pod最好连在一起，有些最好不在一起；

Kubernets scheduler - optimize-select
	SelectorSpreadPriority: 尽量分散pod
	LeastRequestedPriority: 主机承载量-已经占用的 ??
	AffinityPriority

K8s Pod 通讯方式
	pod内部通讯: 由于同一个pod内的容器共享网络，通过 localhost:端口号 直接访问。
	Pod间通讯 - 同一个node上: 共享 docker0 网桥，可以通过 pod IP访问。
	Pod间通讯 - 不同node上: 把pod IP 和node IP 关联起来。

k8s 服务发现
	kube-proxy(ClusterIP): 虚拟IP，只能集群内部访问，只要service不删除，这个IP是固定的。
	kube-proxy(NodePort): 暴露到集群上，外部可以通过集群IP和端口号访问。
	Kube-DNS: 内部插件，负责集群内部的DNS解析，可以让k8s内部的pod通过名字互相访问。


第一个难点：构建一个k8s集群。
https://github.com/liuyi01/kubernetes-starter
https://blog.csdn.net/weixin_41701308/article/details/115723651




(2) 视频版
1) https://coding.imooc.com/class/198.html
聚焦Kubernetes和Docker，精讲服务编排
以循序渐进带入的方式，解决kubernetes“入门门槛高、学习曲线陡”的难题

## Docker官方支持Kubernetes， Kubernetes是容器编排最大赢家
Kubernetes 以其高效、简便、高水平的可移植性等优势占领了绝大部分市场，江湖一哥地位毋庸置疑
脱胎于谷歌的成熟的Borg，围绕Kubernetes的生态正不断完善
容器编排Kubernetes是最有未来的，要学就学它


https://www.cnblogs.com/cocowool/p/kubernetes-articles.html



《Kubernates权威指南(第5版)》
https://gitee.com/coderkkx/k-kubernetes-public







========================================
理解OCI（Open Container Initiative）及docker的OCI实现
----------------------------------------
1. 今天看到 htop 中有一个 root 运行的 run init 命令。
搜了一下，貌似与容器有关。


(2) runC是一个遵循OCI标准的用来运行容器的命令行工具(CLI Tool)，它也是一个Runtime的实现。尽管你可能对这个概念很陌生，但实际上，你的电脑上的docker底层可能正在使用它。至少在笔者的主机上是这样。


$ sudo docker info
...
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
...

(3) runC由Go语言实现。






2. OCI定义了容器运行时标准，runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。

runC是从Docker的libcontainer中迁移而来的，实现了容器启停、资源隔离等功能。Docker默认提供了docker-runc实现，事实上，通过containerd的封装，可以在Docker Daemon启动的时候指定runc的实现。

我们可以通过启动Docker Daemon时增加--add-runtime参数来选择其他的runC 实现。

containerd向上为Docker Daemon提供了gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。

Docker一开始就一家独大，并且并不是一种开放的态姿态在做，所以很早之前Google就投资了CoreOS来做竞争的容器--Rocket。那时是三家鼎立：Docker/Rocket/Warden，为了避免惨烈的竞争，大家终于统一意见，决定成立OCI做统一的容器运行时---RunC，OCI成立后加入了大约50家厂商。出于对Docker封闭化商业式发展的担心，OCI商讨出这种方案：以RunC为核心重新构建生态圈，并且通过插件来弱化容器在CaaS生态圈的重要性。



(2) 官网解释 Open Container Initiative
https://opencontainers.org/
该标准是为了
	- 创建容器格式 image-spec
	- 运行时格式 runtime-spec

The Open Container Initiative is an open governance structure for the express purpose of creating open industry standards around container formats and runtimes.

Established in June 2015 by Docker and other leaders in the container industry, the OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec). The Runtime Specification outlines how to run a “filesystem bundle” that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.




ref:
探索runC (上) https://segmentfault.com/a/1190000017543294
探索runC (下) https://blog.csdn.net/weixin_33744141/article/details/88705609







========================================
|-- docker 收费后的替代产品
----------------------------------------
“docker替代方案有：OpenVZ、Rancher、Nanobox、Podman、RKT、Singularity、Kubernetes、FreeBSD、Apache Mesos、Vagrant、LXC等等。”

Podman	
OpenVZ	https://openvz.org/







========================================
使用nsenter进入docker容器的命名空间
----------------------------------------
1. 背景和作用
docker exec 是进入容器内部。
nsenter 是一个可以用来进入到目标程序所在 namespace 中运行命令的工具，一般可以用于在容器外 debug 容器中运行的程序。

一个最典型的用途就是进入容器的网络命令空间。
容器一般比较简化，没有网络调试工具，比如说ip address，ping，telnet，ss，tcpdump等等命令，可以使用 nsenter 进入容器所在命名空间，使用宿主机的命令进行调试。

此外，nsenter也可以进入mnt, uts, ipc, pid, user命令空间，以及指定根目录和工作目录。


(2) 安装
util-linux 是一个开放源码的软件包，是一个对任何 Linux 系统的基本工具套件。含有一些标准 Unix 工具，如 login。
util-linux 软件包包含许多工具。其中比较重要的是加载、卸载、格式化、分区和管理硬盘驱动器，打开 tty 端口和得到内核消息。

$ sudo yum install -y util-linux


我忘了ubuntu是怎么安装的了，版本
$ nsenter --version
nsenter from util-linux 2.34





2. 使用

$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       latest    fb52e22af1b0   3 weeks ago   72.8MB

$ docker run --rm -it -d ubuntu bash
2e7529

$ docker run --rm -it -d ubuntu bash
cc1ff


(1) 查看帮助
$ nsenter --help
Usage:
 nsenter [options] [<program> [<argument>...]]
Run a program with namespaces of other processes.

Options:
 -a, --all              enter all namespaces
 -t, --target <pid>     target process to get namespaces from
 -m, --mount[=<file>]   enter mount namespace
 -u, --uts[=<file>]     enter UTS namespace (hostname etc)
 -i, --ipc[=<file>]     enter System V IPC namespace
 -n, --net[=<file>]     enter network namespace
 -p, --pid[=<file>]     enter pid namespace
 -C, --cgroup[=<file>]  enter cgroup namespace
 -U, --user[=<file>]    enter user namespace
 -S, --setuid <uid>     set uid in entered namespace
 -G, --setgid <gid>     set gid in entered namespace
     --preserve-credentials do not touch uids or gids
 -r, --root[=<dir>]     set the root directory
 -w, --wd[=<dir>]       set the working directory
 -F, --no-fork          do not fork before exec'ing <program>
 -Z, --follow-context   set SELinux context according to --target PID

 -h, --help             display this help
 -V, --version          display version


(2) 简单实例
在使用nsenter命令之前需要获取到docker容器的进程，然后再使用nsenter工具进去到docker容器中
每一个容器都有.State.Pid，所以这个命令除了容器的id需要我们根据docker ps -a去查找，其他的全部为固定的格式

$ docker inspect -f {{.State.Pid}} 容器名或者容器id 

比如: 
$ docker inspect -f {{.State.Pid}} 2e7529
24226

$ ps -aux | grep 24226
root       24226  0.0  0.1   4116  3360 pts/0    Ss+  20:39   0:00 bash

输入该命令便进入到容器中
$ nsenter --target 上面查到的进程id --mount --uts --ipc --net --pid 
解释nsenter指令中进程id之后的参数的含义： 
-mount参数是进去到mount namespace中  （文件系统）
-uts参数是进入到uts namespace中  （主机名与域名）
-ipc参数是进入到System V IPC namaspace中  （信号量、消息队列和共享内容）
-net参数是进入到network namespace中   （网络设备、网络栈、端口）
-pid参数是进入到pid namespace中    （进程编号）
-user参数是进入到user namespace中 （用户和用户组）

$ sudo nsenter --target 24226 --mount --uts --ipc --net --pid 
root@2e7529203bbb:/# ls /data
ls: cannot access '/data': No such file or directory
root@2e7529203bbb:/# exit
logout
$ ls /data
lost+found  wang

说明在容器内部无法访问 /data 目录。

进入进程的命名空间了，就可以愉快的抓包了。 how?




(3) docker隔离应用应用涉及到的六大名称空间
1)、pid 命名空间(进程ID)
不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。

2)、net 命名空间(网络)
有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。

3)、ipc 命名空间(进程间通信)
容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。

4)、mnt 命名空间(挂载文件系统)
类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。

5)、UTS 命名空间(主机名/域名)
UTS("UNIX Time-sharing System") 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。

6)、user 命名空间(用户)
每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。





(4) 查看docker的连接
由于使用DOCKER的时候，ESTABLISHED连接不会出现在netstat中，在运行中的docker容器中列出打开的套接字的方法 ,查找docker的进程号 ：

$ docker inspect -f'{{.State.Pid}}' <containerid>  
$ docker inspect -f'{{.State.Pid}}' 2e75 
24226

查看连接： 
$ sudo nsenter -t <pid> -n netstat | grep ESTABLISHED 
$ sudo nsenter -t 24226 -n netstat | grep ESTABLISHED 
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path



只进入网络命名空间，这样可以利用主机上的命令来测试
可以看到，在之前测试时，容器内是没有ip 这个命令的，现在只挂网络命名空间后，就可以通过主机上的ip命令执行了。而执行的结果是容器内的。

$ sudo nsenter -t 24226 -n ifconfig 
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 43  bytes 4702 (4.7 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

$ sudo nsenter -t 24226 -n ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
6: eth0@if7: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever


$ sudo nsenter -t 24226 -n ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
...





(5) Linux的每个进程都具有命名空间，可以在/proc/PID/ns目录中看到命名空间的文件描述符。

$ sudo ls -lth /proc/24226/ns
total 0
lrwxrwxrwx 1 root root 0 Sep 26 21:39 cgroup -> 'cgroup:[4026531835]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 pid_for_children -> 'pid:[4026532396]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 time -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 time_for_children -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 user -> 'user:[4026531837]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 mnt -> 'mnt:[4026532393]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 pid -> 'pid:[4026532396]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 uts -> 'uts:[4026532394]'
lrwxrwxrwx 1 root root 0 Sep 26 20:41 ipc -> 'ipc:[4026532395]'
lrwxrwxrwx 1 root root 0 Sep 26 20:39 net -> 'net:[4026532398]'




显示父pid
$ ps -ef | head
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Sep24 ?        00:00:06 /sbin/init splash
root           2       0  0 Sep24 ?        00:00:00 [kthreadd]









ref:
http://www.huilog.com/?p=1145#more-1145
https://www.junmajinlong.com/virtual/namespace/ns_overview/
https://tencentcloudcontainerteam.github.io/tke-handbook/tke-skill/using-nat-gateway-visit-internet.html




========================================
docker --privileged=true参数作用
----------------------------------------

Docker 应用容器 获取宿主机root权限（特殊权限）
$ docker run -d --name="centos7" --privileged=true centos:7


1. 大约在0.6版，privileged被引入docker。

使用该参数，container内的root拥有真正的root权限。
否则，container内的root只是外部的一个普通用户权限。

- privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。
- 甚至允许你在docker容器中启动docker容器。

$ docker help run 
...
--privileged=false     Give extended privileges to this container
...




2. 实例

Docker 应用容器 获取宿主机root权限（特殊权限）
$ docker pull ubuntu:20.04

(1)  常规启动
$ docker run -it --name="ubt_no" ubuntu:20.04
root@25ba9070a37e:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay         895G   15G  881G   2% /
tmpfs            64M     0   64M   0% /dev
tmpfs           126G     0  126G   0% /sys/fs/cgroup
shm              64M     0   64M   0% /dev/shm
/dev/sdc3       895G   15G  881G   2% /etc/hosts
tmpfs           126G     0  126G   0% /proc/acpi
tmpfs           126G     0  126G   0% /proc/scsi
tmpfs           126G     0  126G   0% /sys/firmware

root@25ba9070a37e:/# lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   7.3T  0 disk 
`-sda1   8:1    0   7.3T  0 part 
sdb      8:16   0   7.3T  0 disk 
`-sdb1   8:17   0   7.3T  0 part 
sdc      8:32   0  1024G  0 disk 
|-sdc1   8:33   0   200M  0 part 
|-sdc2   8:34   0   500M  0 part 
|-sdc3   8:35   0 895.3G  0 part /etc/hosts
`-sdc4   8:36   0   128G  0 part [SWAP]
sdd      8:48   0  17.2T  0 disk 
|-sdd1   8:49   0   500M  0 part 
`-sdd2   8:50   0  17.2T  0 part 
sdf      8:80   0   7.3T  0 disk 
`-sdf1   8:81   0   7.3T  0 part 
sr0     11:0    1  1024M  0 rom 

root@25ba9070a37e:/# mount /dev/sdb1 /mnt
mount: /mnt: permission denied.
挂载失败。



(2) 启动命令加 --privileged=true 参数
$ docker run -it --name="ubt_with" --privileged=true ubuntu:20.04 

root@8f6951e114aa:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay         895G   15G  881G   2% /
tmpfs            64M     0   64M   0% /dev
tmpfs           126G     0  126G   0% /sys/fs/cgroup
shm              64M     0   64M   0% /dev/shm
/dev/sdc3       895G   15G  881G   2% /etc/hosts

root@8f6951e114aa:/# lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   7.3T  0 disk 
`-sda1   8:1    0   7.3T  0 part 
sdb      8:16   0   7.3T  0 disk 
`-sdb1   8:17   0   7.3T  0 part 
sdc      8:32   0  1024G  0 disk 
|-sdc1   8:33   0   200M  0 part 
|-sdc2   8:34   0   500M  0 part 
|-sdc3   8:35   0 895.3G  0 part /etc/hosts
`-sdc4   8:36   0   128G  0 part [SWAP]
sdd      8:48   0  17.2T  0 disk 
|-sdd1   8:49   0   500M  0 part 
`-sdd2   8:50   0  17.2T  0 part 
sdf      8:80   0   7.3T  0 disk 
`-sdf1   8:81   0   7.3T  0 part 
sr0     11:0    1  1024M  0 rom


root@8f6951e114aa:/# mount /dev/sdb1 /mnt  #挂载成功
root@8f6951e114aa:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
overlay         895G   15G  881G   2% /
tmpfs            64M     0   64M   0% /dev
tmpfs           126G     0  126G   0% /sys/fs/cgroup
shm              64M     0   64M   0% /dev/shm
/dev/sdc3       895G   15G  881G   2% /etc/hosts
/dev/sdb1       7.3T  1.9T  5.0T  28% /mnt




ref: https://www.jb51.net/article/202094.htm




========================================
测试示例 labs.play-with-docker.com
----------------------------------------
1. 登录
https://labs.play-with-docker.com/
使用 docker账户
然后获得 4 小时使用时长。

https://labs.play-with-docker.com/p/cn9fee47vdo000aksoeg




2. 点击左侧 Add New instance
192.168.0.13

(1) 测试web端口
$ python3 -m http.server 8080
	点击顶部 打开端口：8080，
	能看到新网页 http://ip172-18-0-62-cn9fee47vdo000aksoeg-8080.direct.labs.play-with-docker.com/

用途：可以使用 wget 下载所需资源，然后docker内启用web服务，再下载到本地。




(2) 使用 xshell 登录 ssh
$ ssh ip172-18-0-62-cn9fee47vdo000aksoeg@direct.labs.play-with-docker.com

使用的软件：
$ docker --version
Docker version 24.0.7, build afdd53b

$ gcc --version
gcc (Alpine 12.2.1_git20220924-r10) 12.2.1 20220924
Copyright (C) 2022 Free Software Foundation, Inc
可见，这是一个基于 Alpine 的镜像。

$ git --version
git version 2.40.1

$ python3 -V
Python 3.11.6


查看配置
$ df -Th
Filesystem           Type            Size      Used Available Use% Mounted on
overlay              overlay        10.0G     88.0K     10.0G   0% /
tmpfs                tmpfs          64.0M         0     64.0M   0% /dev
tmpfs                tmpfs          15.7G         0     15.7G   0% /sys/fs/cgroup
/dev/sdb             xfs            64.0G     45.5G     18.4G  71% /etc/resolv.conf
/dev/sdb             xfs            64.0G     45.5G     18.4G  71% /etc/hostname
/dev/sdb             xfs            64.0G     45.5G     18.4G  71% /etc/hosts
shm                  tmpfs          64.0M         0     64.0M   0% /dev/shm
/dev/sdb             xfs            64.0G     45.5G     18.4G  71% /var/lib/docker


$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
fd0      2:0    1    4K  0 disk 
sda      8:0    0   30G  0 disk 
└─sda1   8:1    0   30G  0 part 
sdb      8:16   0   64G  0 disk /var/lib/docker
                                /etc/hosts
                                /etc/hostname
                                /etc/resolv.conf
sr0     11:0    1 1024M  0 rom 




(3) 查看某 docker 镜像的最新标签

$ curl -L -s https://registry.hub.docker.com/v2/repositories/satijalab/seurat/tags
{"count":23,"next":"https://registry.hub.docker.com/v2/repositories/satijalab/seurat/tags?page=2\u0026page_size=10","previous":null,"results":[{"creator":1444440,"id":64566966,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:37b9526f189d98f3369553fca903e319825417c6b14cc14f8f9b7316eff2bac5","os":"linux","os_features":"","os_version":null,"size":1453071913,"status":"active","last_pulled":"2024-02-19T00:40:53.329663Z","last_pushed":"2023-02-25T17:57:37.951027Z"}],"last_updated":"2023-02-25T17:57:37.951027Z","last_updater":6098287,"last_updater_username":"satijalab","name":"latest","repository":7514121,"full_size":1453071913,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-19T00:40:53.329663Z","tag_last_pushed":"2023-02-25T17:57:37.951027Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image","digest":"sha256:37b9526f189d98f3369553fca903e319825417c6b14cc14f8f9b7316eff2bac5"},{"creator":6098287,"id":542676161,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:fd8a2dfda142f4da85e4112f734f97b889e0bb314593e2709e0563d4fd95e87c","os":"linux","os_features":"","os_version":null,"size":1514186617,"status":"active","last_pulled":"2024-02-19T02:03:53.326731Z","last_pushed":"2023-11-04T19:17:15.645666Z"}],"last_updated":"2023-11-04T19:17:15.760216Z","last_updater":6098287,"last_updater_username":"satijalab","name":"5.0.0","repository":7514121,"full_size":1514186617,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-19T02:03:53.326731Z","tag_last_pushed":"2023-11-04T19:17:15.760216Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image","digest":"sha256:fd8a2dfda142f4da85e4112f734f97b889e0bb314593e2709e0563d4fd95e87c"},{"creator":6387786,"id":85494185,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:a69c815ce3325a7b0cbde047f51deb8606ccf12a27923d08c14bc80f9bb7fdf3","os":"linux","os_features":"","os_version":null,"size":1520497799,"status":"active","last_pulled":"2024-02-07T12:57:43.762094Z","last_pushed":"2023-02-25T18:05:24.476758Z"}],"last_updated":"2023-02-25T18:05:24.476758Z","last_updater":6098287,"last_updater_username":"satijalab","name":"develop","repository":7514121,"full_size":1520497799,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-07T12:57:43.762094Z","tag_last_pushed":"2023-02-25T18:05:24.476758Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image","digest":"sha256:a69c815ce3325a7b0cbde047f51deb8606ccf12a27923d08c14bc80f9bb7fdf3"},{"creator":6098287,"id":375059604,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:c627e515bfc556d8b74821427610e24469d0ad9e9a7f1a2787e6581c9cf61bc5","os":"linux","os_features":"","os_version":null,"size":1438888567,"status":"active","last_pulled":"2024-02-16T15:24:10.277998Z","last_pushed":"2023-01-31T21:12:05.072528Z"}],"last_updated":"2023-01-31T21:12:05.072528Z","last_updater":6098287,"last_updater_username":"satijalab","name":"4.3.0","repository":7514121,"full_size":1438888567,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-16T15:24:10.277998Z","tag_last_pushed":"2023-01-31T21:12:05.072528Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image","digest":"sha256:c627e515bfc556d8b74821427610e24469d0ad9e9a7f1a2787e6581c9cf61bc5"},{"creator":6387786,"id":187642308,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:2365e22e1117791e1c09756050ebdb8f4edf9f4509938d37344ba7ee2741fd57","os":"linux","os_features":"","os_version":null,"size":1498121485,"status":"active","last_pulled":"2024-02-15T07:55:08.251865Z","last_pushed":"2022-05-02T01:27:50.596133Z"}],"last_updated":"2022-05-02T01:27:50.596133Z","last_updater":6098287,"last_updater_username":"satijalab","name":"4.1.0","repository":7514121,"full_size":1498121485,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-15T07:55:08.251865Z","tag_last_pushed":"2022-05-02T01:27:50.596133Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"},{"creator":6387786,"id":186193436,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:477b8abc1e4e49d51de67d20070c37d8301a2fc605659e1c942e8a8e7170b3db","os":"linux","os_features":"","os_version":null,"size":1408647623,"status":"active","last_pulled":"2024-01-30T21:15:56.237204Z","last_pushed":"2022-01-11T00:19:27.015298Z"}],"last_updated":"2022-01-11T00:19:27.015298Z","last_updater":6387786,"last_updater_username":"andrewwbutler","name":"4.0.6","repository":7514121,"full_size":1408647623,"v2":true,"tag_status":"active","tag_last_pulled":"2024-01-30T21:15:56.237204Z","tag_last_pushed":"2022-01-11T00:19:27.015298Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"},{"creator":6387786,"id":173431722,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:3935ae9ca60e918a86c79d0af0de5f762750fd61b281e162ff9f551377b702a9","os":"linux","os_features":"","os_version":null,"size":1352410142,"status":"inactive","last_pulled":"2024-01-15T13:24:04.211755Z","last_pushed":"2021-10-21T23:19:05.825225Z"}],"last_updated":"2021-10-21T22:04:27.297206Z","last_updater":6387786,"last_updater_username":"andrewwbutler","name":"4.0.5","repository":7514121,"full_size":1352410142,"v2":true,"tag_status":"inactive","tag_last_pulled":"2024-01-15T13:24:04.211755Z","tag_last_pushed":"2021-10-21T22:04:27.297206Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"},{"creator":6387786,"id":172113896,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:f0311bb3716481201ae4e673245299a02a86c698c28eb6526497c8cabcafecec","os":"linux","os_features":"","os_version":null,"size":1352751915,"status":"inactive","last_pulled":"2024-01-18T14:31:41.62613Z","last_pushed":"2021-10-14T17:46:51.522843Z"}],"last_updated":"2021-10-14T17:46:51.522843Z","last_updater":6387786,"last_updater_username":"andrewwbutler","name":"4.0.4","repository":7514121,"full_size":1352751915,"v2":true,"tag_status":"inactive","tag_last_pulled":"2024-01-18T14:31:41.62613Z","tag_last_pushed":"2021-10-14T17:46:51.522843Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"},{"creator":6387786,"id":153616181,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:0a45b0d73365f5735bf14d53cb2e360edd9b7955b20fd37393bb755ad658ad5f","os":"linux","os_features":"","os_version":null,"size":1323699021,"status":"active","last_pulled":"2024-02-05T21:22:45.778329Z","last_pushed":"2021-06-10T22:53:11.604368Z"}],"last_updated":"2021-06-10T22:52:47.71611Z","last_updater":6387786,"last_updater_username":"andrewwbutler","name":"4.0.3","repository":7514121,"full_size":1323699021,"v2":true,"tag_status":"active","tag_last_pulled":"2024-02-05T21:22:45.778329Z","tag_last_pushed":"2021-06-10T22:52:47.71611Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"},{"creator":6387786,"id":150999231,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:bd93b0c46b78dd4c0cfdbb2f474e82dcb5885f0252a8334bbc2386c08d40ac4c","os":"linux","os_features":"","os_version":null,"size":1325419547,"status":"inactive","last_pulled":"2024-01-15T13:24:04.249872Z","last_pushed":"2021-05-25T15:20:14.920782Z"}],"last_updated":"2021-05-25T15:20:14.920782Z","last_updater":6387786,"last_updater_username":"andrewwbutler","name":"4.0.2","repository":7514121,"full_size":1325419547,"v2":true,"tag_status":"inactive","tag_last_pulled":"2024-01-15T13:24:04.249872Z","tag_last_pushed":"2021-05-25T15:20:14.920782Z","media_type":"application/vnd.docker.container.image.v1+json","content_type":"image"}]}

放到chrome的js控制台中，赋值给 wjl
	> wjl.results[1].name
	'5.0.0'

也就是最新版是 $ docker pull satijalab/seurat:5.0.0


js 数据格式：
	> for(var i in wjl.results[1]){console.log(i)}
	creator
	id
	images
	last_updated
	last_updater
	last_updater_username
	name
	repository
	full_size
	v2
	tag_status
	tag_last_pulled
	tag_last_pushed
	media_type
	content_type
	digest


js 中查看历史版本：
	> for(var i=0; i<wjl.results.length; i++){ 
		console.log(wjl.results[i].last_updated, wjl.results[i].name, )
	}
	2023-02-25T17:57:37.951027Z latest
	2023-11-04T19:17:15.760216Z 5.0.0
	2023-02-25T18:05:24.476758Z develop
	2023-01-31T21:12:05.072528Z 4.3.0
	2022-05-02T01:27:50.596133Z 4.1.0
	2022-01-11T00:19:27.015298Z 4.0.6
	2021-10-21T22:04:27.297206Z 4.0.5
	2021-10-14T17:46:51.522843Z 4.0.4
	2021-06-10T22:52:47.71611Z  4.0.3
	2021-05-25T15:20:14.920782Z 4.0.2









========================================
|-- docker 容器安装远程桌面 //todo
----------------------------------------
3. 尝试远程桌面安装

(1) 启动空容器
$ docker run --rm -d -it --name desk -p 9000:3389 ubuntu:22.04
$ docker exec -it desk bash

替换为国内源
# sed -i "s/archive.ubuntu/mirrors.aliyun/g;s/security.ubuntu/mirrors.aliyun/g" /etc/apt/sources.list #跳过
# apt update




(2) 安装默认 unity/GNOME 桌面
不喜欢 xfce4

root@d2ed573128e2:/# apt search unity
Sorting... Done
Full Text Search... Done
a11y-profile-manager-indicator/jammy 0.1.11-0ubuntu4 amd64
  Accessibility Profile Manager - Unity desktop indicator

biometric-driver-community-multidevice/jammy 0.9.70-1 amd64
  Biometric Authentication Driver (community multidevice)

cultivation/jammy 9+dfsg1-2build2 amd64
  game about the interactions within a gardening community


ubuntu-unity-desktop/jammy 0.4 amd64
  The Ubuntu Unity desktop system


安装：# apt install ubuntu-unity-desktop
	1)地区 Asia, 	Time zone: Shanghai;
	2)键盘类型：English(US)，再选;
	3)显示控制器，选择默认 lightgm（之前的Ubuntu机器是 gdm3），配置文件在 /etc/init.d


ubuntu-gnome-desktop/jammy 0.92 amd64
  The Ubuntu desktop system (transitional package)
尝试安装另一个
# apt install ubuntu-gnome-desktop






(3) 安装 xrdp 协议
# apt install xrdp
# service xrdp start
# systemctl enable xrdp 

查询：
# ps -aux | grep xrdp
root     29922  0.0  0.0   8980  2476 pts/1    S    16:09   0:00 /usr/sbin/xrdp-sesman
xrdp     29925  0.0  0.0   9272   720 pts/1    S    16:09   0:00 /usr/sbin/xrdp


查看使用的端口号
# apt install net-tools
# netstat -lnpt | grep xrdp
tcp6       0      0 127.0.0.1:3350          :::*                    LISTEN      29922/xrdp-sesman 


配置端口：
# apt install vim
# apt install less
# vim /etc/xrdp/xrdp.ini 
修改 port=3389为
port=3388

然后重启xrdp就可以了
# service xrdp restart


# startx
报错
Fatal server error:
[748470.930] (EE) no screens found(EE)

查日志：
# less /var/log/Xorg.0.log 

删除文件 /etc/X11/xorg.conf



ref:
https://zhuanlan.zhihu.com/p/669068384





========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------





