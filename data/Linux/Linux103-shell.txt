Linux103-shell


  
http://man.linuxde.net/xargs
https://www.tutorialspoint.com/unix/unix-what-is-shell.htm


GNU官方bash教程： http://www.gnu.org/software/bash/manual/bash.html





========================================
Linux下获取帮助
----------------------------------------
没有必要记住所有东西。linux有非常详细的文档和帮助工具。

help: 几乎所有的命令都可以通过 -h和--help获得使用方法、参数信息等。
man: 最为常用的linux帮助命令，获得详细描述。9中命令类型。如 man 1 ls
	man -k 关键字 可以用来查询包含该关键字的文档；
info 与man类似，但是提供的信息更为详细深入，以类似网页的形式显示。
	可以通过:/ 关键词 进行搜索；
终极方法：doc文档为详细信息，保存路径/usr/share/doc目录中，txt、html、pdf等格式。

用图形界面打开当前窗口：nautilus

或者google之~~





2. 其他教程

https://keysaim.github.io/post/linux/2017-11-17-linux-study-common-tools/






========================================
|-- 编写Shell过程中注意事项
----------------------------------------

开头加解释器：#!/bin/bash 
语法缩进，使用四个空格；
多加注释说明。 
命名建议规则：
	变量名大写、局部变量小写，函数名小写，名字体现出实际作用。 默认变量是全局的，在函数中变量local指定为局部变量，避免污染其他作用域。 
有两个命令能帮助我调试脚本：
	set -e 遇到执行非0时退出脚本，
	set-x 打印执行过程。 
写脚本一定先测试再到生产上。






ref:
https://zhuanlan.zhihu.com/p/161356277







========================================
命令行BASH的编辑和运行方式
----------------------------------------
1.安装ubuntu
2.图形化界面gnome简介：
（CentOS）打开文件用浏览器：打开文件，菜单 edit》preference》behavior，always open in browser window勾选即可。
尽量不要使用root权限。

可以设定桌面个数。

3-命令行BASH的基本操作
内核：kernel
外壳：shell=图形界面（GUI） + CLI（命令行界面 bash）

bash：
	--提示符：$(一般用户)     #(root)
	--firefox后面加&符号，也就是运行 firefox& 就是后台执行，不干扰当前命令行。
	-终止当前命令：ctrl +C

	--通过tab键自动补齐（但不补参数），按2次给出所有相关命令的提示。空白双击tab，提示是否显示2393个命令？
	--history 显示所有执行过的命令。上下键：最近执行过的命令。
	-- 很少用，脚本中用：
	 	!! 重复前一个命令；
		 !字符 重复前一个以“字符”开头的命令；
		!num 按照历史记录的序号执行命令；
		!?abc	重复之前包含abc的命令
		!-n重复n个命令之前的那个命令；
	--历史命令搜索命令：ctrl+R
	--按esc，再按 小数点，重复使用上一次的参数；

	--bash通配符：
		* 匹配任何字符；
		?	匹配任意一个字符；
		[0-9] 匹配一个数字；
		[abc]	匹配列表中任意字符
		[^abc]	匹配列表中字符以外字符

bash切换用户：
su - 切换到root用, 加-切换到新终端（推荐），不加 - 则使用原终端；
exit 退出当前登录
sudo	使用管理员身份运行命令；
id	显示当前用户信息；
passwd	修改当前用户密码；

bash作业管理：
后台运行：命令后加一个&则后台运行该指令；
暂停某个程序：ctrl+z 或者发送信号17；

管理后台作业命令：
	jobs 查看 
	bg 后台作业
 	fg 前台作业






4. 一个命令运行多个shell命令




有些情况(docker)只能提供一条shell命令

$ bash -c "cd / && ls -lth | head"
total 2.1G
drwxrwxrwt  60 root root 228K Jul 26 17:26 tmp
drwxr-xr-x  46 root root 1.6K Jul 26 10:05 run
drwxr-xr-x 169 root root  12K Jul 21 06:21 etc
drwxr-xr-x   4 root root 4.0K Jul 15 06:26 boot
drwxr-xr-x  23 root root 5.0K Jul  8 07:52 dev
drwx------  12 root root 4.0K Jun 25 10:40 root










========================================
|-- 非root权限安装tmux
----------------------------------------
1.源码的下载
wget https://github.com/tmux/tmux/releases/download/2.2/tmux-2.2.tar.gz
wget https://github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gz
wget http://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz


2.软件的解压


3.软件的安装(以我下载的版本为例)
#libevent
./configure --prefix=$HOME/.local --disable-shared
make
make install


#ncurses
./configure --prefix=$HOME/.local
make
make install


#tmux
./configure CFLAGS="-I$HOME/.local/include -I$HOME/.local/include/ncurses" LDFLAGS="-L$HOME/.local/lib -L$HOME/.local/include/ncurses -L$HOME/.local/include" CPPFLAGS="-I$HOME/.local/include -I$HOME/.local/include/ncurses" LDFLAGS="-static -L$HOME/.local/include -L$HOME/.local/include/ncurses -L$HOME/.local/lib" 
#我这边在tmux目录下配置需要去掉 CPPFLAGS 及其后的东西，并加上prefix
./configure --prefix=/home/chuchu/bin/tmux CFLAGS="-I$HOME/.local/include" LDFLAGS="-L$HOME/.local/lib"

make
cp tmux $HOME/bin




#环境变量设置(如果PATH中已经有该路径，即可省略如下步骤)
#将下面的语句添加到.bashrc中
export $PATH="$HOME/.local/bin:$PATH"
#重载环境
source .bashrc



========================================
|-- 把shell terminal 分为多窗口: tmux (Linux终端复用神器)
----------------------------------------
Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。
使用tmux最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。

特点是 可以后台托管进程。再也不用担心和服务器断网了。



几个名词
tmux使用C/S模型构建，主要包括以下单元模块：

server 服务器: 输入tmux命令时就开启了一个服务器;
|-- session	会话: 一个服务器可以包含多个会话;
  |--window	窗口: 一个会话可以包含多个窗口;
    |--panel	面板: 一个窗口可以包含多个面板 [强悍的分屏]


https://blog.csdn.net/nisxiya/article/details/43482681
注意点：进入tmux面板后，一定要先按ctrl+b，然后松开，再按其他的组合键才生效。



1.安装 
$ sudo apt-get install tmux

2. 新建tmux窗口 
$ tmux

建议起一个名字，否则容易混乱。比如新创建一个会话以"ccc"命名
$ tmux new -s ccc
-s 就是 session


3. 先按下Ctrl +b 然后松开，再按下如下其他键，完成分割窗口等功能：
(1) %竖直分割
(2) "水平分割
这样就分为4个窗口【4个可以同时看到的窗口】
(3)窗口间的切换o，或上下左右方向键；
(4)& 输入yes，退出tmux，关掉当前窗口
(5) d 从当前 session 回到正常shell，但session还在运行，可以登回去 tmux a -t Name。




ctrl+b后的基本操作：
pageup/pagedown 下翻屏（翻页）
?	列出所有快捷键；按q返回
d	脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话
$	重命名当前tmux窗口
s	选择并切换会话；在同时开启了多个会话时使用
  以菜单方式显示和选择会话。这个常用到，可以选择进入哪个tmux

D	选择要脱离的会话；在同时开启了多个会话时使用
:	进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话
[	复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出
]	进入粘贴模式，粘贴之前复制的内容，按q/Esc退出
~	列出提示信息缓存；其中包含了之前tmux返回的各种提示信息
t	显示当前的时间
  显示时钟。然后按enter键后就会恢复到shell终端状态
Ctrl+z	挂起当前会话


## 面板操作
Ctrl+方向键	以1个单元格为单位移动边缘以调整当前面板大小
Alt+方向键	以5个单元格为单位移动边缘以调整当前面板大小
空格键	可以在默认面板布局中切换，试试就知道了
q	显示面板编号
o	选择当前窗口中下一个面板
方向键	移动光标选择对应面板
x           Kill the current pane.

## window操作
c	new-window
p 	前一个窗口
n 	下一个窗口
s 	可以看到一行一个session，行内有window个数。window内才是我们看到的分屏。
	按左右键显示有几个 pane




4.退出当前tmux窗口到终端，其实后台还在运行，不影响下载等
$ tmux detach
或者直接ctrl+b,d返回shell。




5.在终端操作或进入tmux窗口
(1)查看还在运行中的tmux窗口 $ tmux ls

(2)重命名窗口
$ tmux rename -t 1 natapp
$ tmux rename -t win002 win003

(3)登录一个已知会话。即从终端环境进入会话。
再次进入某个tmux窗口 $ tmux a -t 1 

第一个参数a也可以写成attach。后面的aaa是会话名称。
# tmux a -t aaa 

(4)关闭会话（销毁会话）
# tmux ls
aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]
bbb: 1 windows (created Wed Aug 30 19:02:09 2017) [112x22]
# tmux kill-session -t bbb
# tmux ls




更多快捷键：
入门: https://www.imooc.com/video/19480
https://www.cnblogs.com/kevingrace/p/6496899.html
http://mingxinglai.com/cn/2012/09/tmux/




========================================
|-- tmux中最不可少的配置: 用鼠标切换窗口/调节分屏大小
----------------------------------------
1.功能：怎么可以用鼠标将窗口拖大拖小？

$ vim ~/.tmux.conf
setw -g mouse-resize-pane on
setw -g mouse-select-pane on
setw -g mouse-select-window on
setw -g mode-mouse on



我的版本号
$ tmux -V
tmux 2.6

tmux2.1之后版本：
先按Ctrl + B， 松开以后，输入冒号，输入
$ set-option -g mouse on  #我的2.6可用
$ set -g mouse on #我的2.6也可用
缺点是设置为on不能用鼠标复制文本了！要重新设置为 set -g mouse off 后，在鼠标选中、右击、复制。


这几行的作用分别是:
- 开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）
- 开启用鼠标点击pane来激活该pane
- 开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）
- 开启window/pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）

这几行配置加到 ~/.tmux.conf 中，然后在tmux里面按 C-b : 执行 source ~/.tmux.conf 即可生效 （也可以直接将这几行放在 C-b : 的输入行去执行，每次执行一行，不过 tmux重启后还得再来一遍）。


(2)附送一条tips: 最大化/还原pane
如果你用的是tmux >= 1.8，那么可以用 C-b z 来最大化一个pane，想恢复的时候再次按 C-b z 就是了

如果你用的是tmux < 1.8，那么有点复杂，自己看这里: “Maximizing” a pane in tmux(https://superuser.com/questions/238702/maximizing-a-pane-in-tmux/357799#357799)





2.背景补充
(1)什么是window?
就是用 C-b c 创建出来的窗口，每个window跟tmux所在的终端一样大，window里面可以容纳多个pane。

所有窗口的名称显示在底部状态栏上。 有了上面的配置，只要点击窗口名就可以切换到指定窗口了 （快捷键是 C-b n, C-b p, C-b 1 .. C-b 9）


(2)什么是pane?
就是窗口里面的分屏，可以用 C-b o 来切换到下一个pane，
或者用 C-b Up 切换到当前pane上方的pane, 用C-b Down切换到当前pane下方的pane.

还有一种切换方法是 C-b q，tmux会显示每个pane的序号，按这个序号就可以跳过去了（按慢了可不行，得在数字消失前按）。

开启了 mouse-select-pane 选项之后， 就可以用鼠标点击面板切换了


(3)用鼠标改变pane的大小
其实前面切换window或者pane，用鼠标并没有太大优势，也就只能略微减轻一点记忆负担。 

但用鼠标拖动改变pane的大小这条是比快捷键有优势的，因为用快捷键很难一次调节到位 ，比如是增加6行还是9行？ 缩小20列还是40列？而且 还可以斜向拖住交叉点来同时改变多个窗口的大小



https://www.cnblogs.com/bamanzi/p/tmux-mouse-tips.html
















========================================
Linux文件系统基本结构
----------------------------------------

1.Linux系统目录架构

-倒转的单根树状结构；
-文件系统的根为/
-文件系统严格区分大小写；
-路径使用"/"分割；


bin文件夹：常用的可执行文件，所有用户都可以执行；
boot文件夹：启动、引导，操作系统内核（版本号）；
dev文件夹：所有的硬件、设备都抽象为文件了；
etc文件夹：几乎所有的配置文件，.conf（configuration）文件；
home文件夹：与用户名同名的文件夹；
lib文件夹：库文件（对应win下的dll文件）；
media文件夹：U盘等的；
opt文件夹：经常空着，大型程序可以放到这里；
proc 实时文件夹
sbin只有超级用户才能执行；
sys 底层目录
temp 临时目录
usr 默认软件
var 经常变的信息： log等信息；



2. 当前工作目录
-显示shell或系统进程的当前工作目录：pwd  （Print Working Directory）



3. 文件名称
-文件与目录没有区别；文件的名称大小写敏感；最多255个字符；除了正斜线都是有效字符；
-touch命令可以创建一个空白文件或更新已有文件时间；
-以 ‘.’ 开头的文件是隐藏文件；





========================================
|-- Linux文件基本操作管理
----------------------------------------
ls命令
ls -a 显示所有文件，包括隐藏文件；
ls -l  详细信息；
ls -R 递归的显示所有子目录
ls Downloads/  显示Downloads文件下文件；

file  xx  查看文件xx的类型；


绝对路径和相对路径
绝对路径：以/开头，递归每级目录直到目标；恒定；
相对路径：以当前目录为起点，到达目标文件；变动；

cd 命令切换路径；
上一级 cd ..
当前目录 cd .
家目录 cd ~  或者cd 回车
到达上一个工作目录 cd -



复制文件和目录
cp xxfile
cp -r xxfileDir
cp xxA xxDir

移动文件
mv xxA xxDir

删除文件
rm xxFile
	-i 交互删除
	-r 递归删除
	-f 强制删除

创建文件夹 	mkdir
删除非空目录 rm -r ccDir













========================================
多命令协作：管道|及重定向 2>&1,  | tee log.txt
----------------------------------------
1. 开源文化的核心理念之一：不要重复发明轮子；
很多开源软件都是现有软件、代码、功能的重新组合，就好像通过零件装配机器一样，源代码的开放和共享让这成为了可能，同时也大大的提高了效率和生产力。
业界著名的开源网站是github，如果想用的流畅，你需要先学习如何使用git进行版本管理。

linux系统中，大多数命令都很简单，基本上一个命令完成一个功能。
复杂功能，可以通过简单功能的叠加来实现。
linux的命令行（CLI）为我们提供了管道和重定向机制，来完成多命令协作。让前一个的输出直接成为后一个的输入。




2.命令行shell的数据流有以下定义：
名称	说明	编号	默认
STDIN	标准输入	0	键盘
STDOUT	标准输出	1	终端
STDERR	标准错误	2	终端
命令行通过STDIN接收参数或数据，通过STDOUT输出结果或通过STDERR输出错误。




3. 通过管道和重定向我们可以控制CLI的数据流的。
重定向(使用cat .out.txt查看文件中的内容)
	关键字	实例		作用	
	>	$ ls > a.txt	#把ls的标准输出保存到a.txt文件中。其中>是1>的简写。
	>>	$ pwd >>a.txt	#把pwd 的标准输出追加到a.txt文件尾部
	2>	$ ls nowhere 2> out.txt	#把STDERR写入到out.txt文件，创建日志挺有用！
	2>&1 $ ls nowhere >out3.txt 2>&1 #把STDERR和STDOUT结合，同时保存正常结果和报错信息到out3.txt中。
	<	$ grep wang < /etc/passwd
#用文件/etc/passwd作为内容作为标准输入，不再使用键盘，使用grep命令查找带有wang关键字的信息。不常见。




4. 可以根据以上规则进行组合：
1>&2  正确返回值传递给2输出通道 &2表示2输出通道 
	如果此处错写成 1>2, 就表示把1输出重定向到文件2中. 
2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道. 
$ command < file1 >file2 #command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。


举个例子. 
$ ls a.txt b.txt >file.out 2>&1 #等价于$ ls a.txt b.txt 1>file.out 2>&1 
$ cat file.out 
ls: b.txt: No such file or directory 
a.txt 

现在, 正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端. 
补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.

$ ls nowhere 2>> out.txt	#表示追加错误输入到文件
$ w 2>> out4.txt 1>&2	#把w命令的标准输出合并到标准错误中。
$ ls 1>>std.out 2>>std.err #分别输出STDOUT和STDERR到文件std.out和std.err中。

$ grep wang < /etc/passwd
wangjl:x:1001:1002::/home/wangjl:/bin/bash
wangbl:x:1008:1009:,,,:/home/wangbl:/bin/bash





5. 后台运行
一般形式为：
$ nohup command & 
　　如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： 
$ nohup command > myout.file 2>&1 & 
　　在上面的例子中，输出被重定向到myout.file文件中。



6. 管道（｜）
多命令协作最常用的方式就是管道。
管道操作符是“|”，它可以将前面一个命令的标准输出 (stdout)传递给后面一个命令，作为后面命令的标准输入(stdin)。
注意它仅能传递标准输出，而不能传递错误输出(stderr)给后面的命令。 
当然如果想传递错误输出, 可以使用重定向指令实现 command1 2>&1 |command2

$ ls -l | grep txt
-rwxrwxr-x 1 wangjl wangjl     3173 Jun 10 19:33 a.txt
-rw-rw-r-- 1 wangjl wangjl     7575 Dec 27 01:25 data.txt
-rw-rw-r-- 1 wangjl wangjl      177 Jun 10 19:46 out2.txt
-rw-rw-r-- 1 wangjl wangjl       53 Jun 10 19:48 out3.txt
-rw-rw-r-- 1 wangjl wangjl      416 Jun 10 19:55 out4.txt
-rw-rw-r-- 1 wangjl wangjl      184 Jun 10 19:58 out.txt
-rw-rw-r-- 1 wangjl wangjl        0 Jun 10 20:16 txt.out


$ find / -user wangjl | grep mysql >mysql.out
在整个系统中(/)查找用户名为wangjl的文件，且包含mysql关键字，输出到mysql.out文件中。

$ find / -user wangjl 2> /dev/null | grep xampp
/home/wangjl/xampp.out
#输出到/dev/null设备的内容自动被丢弃。




7. Here Document
Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

它的基本的形式如下：
command << delimiter
    document
delimiter
它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

注意：
 - 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
 - 开始的delimiter前后的空格会被忽略掉。


# 实例
shell用重定向作为标准输入的用法是：cmd<<delimiter ,shell 会将分界符delimiter之后直到下一个同样的分界符之前的内容作为输入
(1) 实现ftp自动登录并运行ls指令的用法如下：其中zjk为用户名，zjk123为密码
ftp -i -n 192.168.21.46 <<EOF  
user zjk zjk123  
ls  
EOF


(2) 登录sftp并下载
#先定义下载地址
cd /home/wangjl/web/docs/mem/ 

USER=wangjl;
PASS_X=passwd

echo 'get host X'
lftp -u ${USER},${PASS_X} sftp://x.biomooc.com:22<<EOF
cd /home/wangjl/data/testCode
lcd /home/wangjl/web/docs/mem/
get mem_202004.pdf
bye
EOF

#重命名文件
mv mem_202004.pdf X_mem_202004.pdf





8. /dev/null 文件
如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：
$ command > /dev/null



9. 双向重定向tee命令
(1)tee是linux中的管道命令，用来双向重定向。
就是执行的命令 | tee log.txt 会同时在屏幕上显示程序运行的结果，并且同时将运行的结果写到log.txt文件中

直接覆盖日志文件   
$ ls -l | tee t.log

将输出内容附加到日志文件   
$ ls -l | tee -a t.log


如果不想输出到屏幕呢？可以重定向到 /dev/null 设备:
$ ls -lth /home | tee -a ls.log > /dev/null



(2)注意： command  | tee stdout.log
这里有一个需要注意的坑点，上面的命令只是把标准输出，也就是 STDOUT 写进文件，并没有处理错误输出，也就是 STDERR
如果需要处理错误输出，命令如下：
command > >(tee -a stdout.log) 2> >(tee -a stderr.log >&2)
如果你想把标准输出和错误输出都重定向到一个文件，那么命令如下：
command  2>&1 | tee -a log
from: https://stackoverflow.com/questions/692000/how-do-i-write-stderr-to-a-file-while-using-tee-with-a-pipe


vim一般在训练网络的时候需要保存log文件，同时需要在屏幕上网络的输出信息，在shell文件中常常会看到如下代码
执行的命令 2>&1 | tee log.txt

至于最上面的2>&1是数据流重定向，意思是将正确和错误的结果同时输出


$ ./aaa.sh 2>&1 | tee -a log  ##This simply redirects stderr to stdout, so tee echoes both to log and to screen.

Note: Since bash version 4 you may use |& as an abbreviation for 2>&1 |:
$ ./aaa.sh |& tee -a log

注意：python的logger模块就是输出到 stderr，如果想把屏幕输出同时都输出到文件，需要使用 cmd 2>&1 | tee logfile 的形式。


(3)问题： tee会改变多语言多脚本调用过程中，脚本在屏幕的输出顺序，怎么回事？
可能是tee带有buffer，怎么去掉buffer？






10. 管道和重定向小结
管道通常用来组合不同的命令，以实现一个复杂的功能。
重定向通常用来保存某命令的输出信息或错误信息，可以用来记录执行结果或保存错误信息到一个指定的文件。



refer:
苏勇linux视频：http://study.163.com/course/courseLearn.htm?courseId=232007#/learn/video?lessonId=340069&courseId=232007
http://study.163.com/course/introduction/221001.htm#/courseDetail
标准输入、输出、错误：http://www.360doc.com/content/15/0319/09/19443956_456354803.shtml






========================================
xargs 从std input 构建和执行命令(build and execute command lines from standard input)
----------------------------------------
由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以xargs命令就派上了用场。
xargs是构建单行命令的重要组件之一。

它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。 
xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。
xargs的默认命令是echo，空格是默认定界符(可以用单引号、双引号、反斜线保护)、换行分割。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。



1.命令格式 http://man.linuxde.net/xargs
$ somecommand |xargs -item  command
参数：
-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。
-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。
-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。
-t 表示先打印命令，然后再执行。
-p 当每次执行一个argument的时候询问一次用户。(相当于-t的交互版)
-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。

-a file 从文件中读入作为sdtin
-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。
-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。
-L num 从标准输入一次读取 num 行送给 command 命令。
-l 同 -L。
-x exit的意思，主要是配合-s使用。。
-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。






2. xargs是什么，与管道有什么不同？
通道符“|“:是将前一个命令的输出做为后一个命令的标准输入。注意：这里的标准输入指的是：通道符右侧命令的处理内容，也就是说左侧的标准输出不能作为右侧命令的参数，只能作为命令的处理对象。
简单讲：只有通道符时，右侧命令将左侧输出作为处理内容。加上xargs后，将左侧输出作为参数。具体看下面wc命令的执行，就明白了。

(1) 把管道符左侧作为参数而不是输入
echo '--help' | cat 
输出：--help
实际上就是echo命令的输出通过管道定向到cat的输入了


echo '--help' | xargs cat 
输出：很多内容，其实就是 cat --help 的输出。
--help 做成cat的一个命令参数来运行cat命令



(2)读取文件内容
假如你有一个文件包含了很多你希望下载的URL，你能够使用xargs下载所有链接：
cat url-list.txt | xargs wget -c

想读取文件内容
$ echo 'aa.txt' |cat #不行。相当于左侧是一个文本输入给右侧，文本内容就是'aa.txt'
aa.txt
$ echo 'aa.txt' | xargs cat #可以；相当于cat aa.txt；引号加不加都行。
this is line 1
line2
another line.3


(3)很多程序是不处理标准输入的，例如 kill , rm
echo '516' | kill #这种命里是不能执行的。
echo 'test' | rm -f #也无效

1)通过 kill `ps -ef | grep 'ddd'`    
#这种形式，这个时候实际上等同于拼接字符串得到的命令，其效果类似于  kill $pid

2) for procid in $(ps -aux | grep "some search" | awk '{print $2}'); do kill -9 $procid; done   
#其实与第一种原理一样，只不过需要多次kill的时候是循环处理的，每次处理一个

3) ps -ef | grep 'ddd' | xargs kill  #该命令会报错。
$ ps -ef | grep 'nginx'| awk '{print $2}'|xargs kill
#OK，使用了xargs命令，铺垫了这么久终于铺到了主题上。
xargs命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数


(4)批量查文件行数
$ cat fname.txt 
aa
bb
$ cat fname.txt |awk '{print $1".txt"}' #拼接成文件名
aa.txt
bb.txt
$ cat fname.txt |awk '{print $1".txt"}' |wc -l #结果是2个文件名
2
$ cat fname.txt |awk '{print $1".txt"}' |xargs wc -l #是2个文件的行数
 3 aa.txt
 4 bb.txt
 7 total

(5)查看/sbin下other组可写文件的大小
$ find /sbin -perm -o=w |xargs ls -lth #指定u/g/o，前面有-则表示匹配，没有则表示只匹配
lrwxrwxrwx 1 root root 14 Mar 30 00:40 /sbin/halt -> /bin/systemctl
lrwxrwxrwx 1 root root 20 Mar 30 00:40 /sbin/init -> /lib/systemd/systemd



(6)xargs和find命令
1)在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：
$ chmod 777 fname.txt
$ find . -perm -7 -print | xargs chmod o-w

2)查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件
$ find . -type f -print | xargs file
./fname.txt:    ASCII text

3)尝试用rm 删除太多的文件，你可能得到一个错误信息：/bin/rm Argument list too long. 用xargs 去避免这个问题
示例 find ~ -name '*.log' -print0 | xargs -i -0 rm -f {}

$ find ~ -name '.*' 2>/dev/null | xargs -n1 -i cp {} . #先把这些配置文件复制过来
$ find . -name '.*' -print|xargs -n1 -i rm -f {} #再全部删除掉

4)查找所有的jpg 文件，并且压缩它
# find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz

5)拷贝所有的图片文件到一个外部的硬盘驱动 
# ls *.jpg | xargs -n1 -i cp {} /external-hard-drive/directory








3. 有用的参数
(1)-d 指定分隔符。
默认情况下xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个之后当作命令行参数传递给其后面的命令，并运行之。

$ ls | xargs
facebook.txt out.txt passwd regFile xxx.bed

$ ls | xargs -d \. #把点号当做分隔符了。
facebook txt
out txt
passwd
regFile
xxx bed


$ echo '11@22@33'|xargs
11@22@33

$ echo '11@22@33'|xargs -d '@'
11 22 33




(2) -n 一行多少个
xargs 用作替换工具，读取输入数据重新格式化后输出。

$ ls | xargs -n2
facebook.txt out.txt
passwd regFile
xxx.bed



(3) -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：
参考格式： cat arg.txt | xargs -I {} ./sk.sh -p {} -l

1)使用echo命令
$ cat fname.txt 
aa
bb

$ cat fname.txt |xargs -I {} echo man {} --version
man aa --version
man bb --version


2)复制所有txt文件到 ./text 目录下：
$ ls *.jpg | xargs -n1 -I cp {} /data/images

$ ls *.txt|xargs -n1 
aa.txt
bb.txt
fname.txt

$ mkdir text
$ ls *.txt|xargs -n1 -I {} cp {} ./text #把txt文件复制到text文件夹中
$ ls text/
aa.txt  bb.txt  fname.txt


与具体的支持有关
$ find ./ -maxdepth 2 -name "*txt*" -print|xargs -t -I{} sed '1i\=====' {} #大写I需要指定{}
sed 1i\===== ./fname.txt 
=====
aa
bb
$ find ./ -maxdepth 2 -name "*txt*" -print|xargs -t -I[ sed '1i\=====' [ #也可以自己指定，比如[
sed 1i\===== ./fname.txt 
=====
aa
bb
$ find ./ -maxdepth 2 -name "*txt*" -print|xargs -t -i sed '1i\=====' {} #小写i默认指定为{}
sed 1i\===== ./fname.txt 
=====
aa
bb

Ubuntu和CentOS下: -i默认是{}为替代符，而-I则需要手动指定替代符。

$ ls -lth text
##total 0
$ ls *.txt | xargs -I % cp % ./text
$ ls -lth text
##-rw-rw-r-- 1 wangjl wangjl 36 May 11 10:46 aa.txt
注释：这里使用 % 作为指示符，第一个 % 可以理解为声明，第二个 % 可以理解为调用。你也可以用其他字符，比如 ls *.txt | xargs -I {} cp {} ./text



(4)-0 选项表示以 '\0' 为分隔符，一般与find结合使用
-0 Input items are terminated by a null  character  instead  of  by whitespace,  and the quotes and backslash are not special (every character is taken literally).

find . -name "*.txt" -print0
输出：./2.txt./3.txt./1.txt     => 加上 -print0 参数表示find输出的每条结果后面加上 '\0' 而不是换行


统计一个源代码目录中所有 txt 文件的行数：
$ find . -type f -name "*.txt" -print0|xargs -0 wc -l
 2 ./fname.txt
 3 ./aa.txt
 4 ./bb.txt
 9 total
$ find . -type f -name "*.txt" |xargs wc -l #或者完全不带0的
 2 ./fname.txt
 3 ./aa.txt
 4 ./bb.txt
 9 total

查找所有的 txt 文件，并且压缩它们：
$ find . -type f -name "*.txt"|xargs tar -czvf text.tar.gz
$ find . -type f -name "*.txt" -print|xargs tar -czvf text2.tar.gz
生成的文件大小一样，解压出来也一样，但是压缩后的md5sum结果不一样，奇怪//todo 




(5) -t打印出要执行的命令， -p(-t的交互版)询问是否执行该命令
使用-t选项之后xargs并不会马上执行其后面的命令，而是输出即将要执行的完整的命令(包括命令以及传递给命令的命令行参数)，然后再执行。
$ echo '11@22@33' | xargs -t -d '@'  echo 
echo 11 22 33
11 22 33

而-p也输出命令，但是会询问是否执行，输入 y 才继续执行，否则不执行。
$ echo '11@22@33' | xargs -p -d '@'  echo 
输出：
echo 11 22 33
 ?...y      ==>这里询问是否执行命令 echo 11 22 33 输入y并回车，则显示执行结果，否则不执行
 11 22 33   ==>执行结果


(6) -E 选项，有的系统的xargs版本可能是-e  eof-str
注意：-E只有在xargs不指定-d的时候有效，如果指定了-d则不起作用，而不管-d指定的是什么字符，空格也不行。

正常情况下有3个命令行参数 11、22、33 由于使用了-E '33' 表示在将命令行参数 33 之前的参数传递给执行的命令，33本身不传递。等价于 echo 11 22 这里-E实际上有搜索的作用，表示只取xargs读到的命令行参数前面的某些部分给命令执行。
$ echo '11 22 33' | xargs -E '33' echo 
输出：
11 22









========================================
shell脚本|概述与运行
----------------------------------------
1. 概述
shell提供了对UNIX系统的接口。收集输入，并根据输入执行程序。当一个程序执行完毕后，它会显示该程序的输出。
 
shell是一个环境，我们可以运行我们的命令，程序和shell脚本。shell有不同的风格，就像有不同风格的操作系统。每个的shell的风格，有它自己的一套识别的命令和功能。

shell它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；
作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。

(1)资源：
	http://www.yiibai.com/shell/
	http://www.runoob.com/linux/
	http://www.itshouce.com.cn/linux/linux-shell.html
	编写Shell脚本的最佳实践 http://kb.cnblogs.com/page/574767/
	菜鸟教程 http://www.runoob.com/linux/linux-shell.html

(2)分类
Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。
Linux 的 Shell 种类众多，常见的有：
	Bourne Shell（/usr/bin/sh或/bin/sh）
	Bourne Again Shell（/bin/bash）
	C Shell（/usr/bin/csh）
	K Shell（/usr/bin/ksh）
	Shell for Root（/sbin/sh）
	……
	
本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。

在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。
#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。



2. hello world 
(1)编写
第一个shell脚本
打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。
输入一些代码，第一行一般是这样：

#!/bin/bash
echo "Hello World !"

(2)运行 
运行方法1：添加可执行权限
$ chmod +x ./test.sh  #使脚本具有执行权限
$ ./test.sh  #执行脚本

注意，一定要写成 ./test.sh，而不是 test.sh

运行方式2：作为解释器参数
$/bin/sh test.sh
或简写 $sh test.sh

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。




========================================
|-- ``（反引号）和$()的区别及eval详解
----------------------------------------
1.在bash中，$( )与` `（反引号）都是用来作命令替换的。
｀｀和$() 内部通常是一个shell命令，在执行脚本之前，会先执行这个命令，相当于函数调用

(1)命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。

$ echo today is $(date "+%Y-%m-%d")
today is 2021-03-29


(2)在操作上，这两者都是达到相应的效果，但是建议使用$( )，理由如下：
- ``很容易与"搞混乱，尤其对初学者来说。
- 在多层次的复合替换中，`` 必须要额外的转义字符处理（反斜线），而$()比较直观。
最后，$( )的弊端是，并不是所有的类unix系统都支持这种方式，但反引号是肯定支持的。


(3)示例:
i) 使用反引号``（键盘顶部数字键最左边）: 通用，可能和""搞混
$ files=`ls *fastq`
$ echo $files
mef-COL01_R1.fastq mef-COL01_R2.fastq

ii) 使用 $() 符号: 有的unix不支持
$ echo $(ls *fastq)
mef-COL01_R1.fastq mef-COL01_R2.fastq







2. eval命令
eval可以读取一连串的参数，然后按照参数特性来执行。参数数目不限，彼此之间用分号隔开。

eval会对后面的命令进行两遍扫描
- 如果第一遍扫描后，命令是个普通命令，则执行此命令；
- 如果命令中含有变量的间接引用，则保证间接引用的语义。
也就是说，eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。
因此，eval命令适用于那些一次扫描无法实现其功能的变量。

eval 执行以下两个步骤：
第一步，执行变量替换，类似与C语言的宏替代；
第二步，执行替换后的命令串。

下面来看几个例子：
例1：执行含有带字符串的命令
$ cat num.txt
0
1
2

$ test1="cat num.txt"
$ echo $test1
cat num.txt

$ eval $test1
0
1
2

解说: 第一次扫描，把 $test1 替换为其内容 cat num.txt，第二次扫描，执行该命令。





例2: shell脚本中，参数个数是 $#, 最后一个参数是$$#，试一下加不加 eval 的输出
$ cat a.sh
echo "try1:" $#
echo "try2:" $$#
echo "try3:" "$$#"

echo "try4:" \$$#
echo "try5:" "\$$#"

eval echo "try6:" \$$#
eval echo "try7:" "\$$#"


$ bash a.sh first lastOne
try1: 2
try2: 31941#
try3: 31941#
try4: $2
try5: $2
try6: lastOne
try7: lastOne





注意：
1) eval 不能获得函数处理结果。
2) shell中eval 嵌套无意义，在其他语言中可以通过 eval(eval(“code”)) ，来执行动态生成的 code 的返回，而由于shell 中 eval 将后面的 eval 命令简单当作命令字符串执行，失去了嵌套作用，嵌套被命令替换取代。










========================================
shell脚本|变量、注释、字符串、数组
----------------------------------------

##变量：

1.定义时，shell变量不用加$符号，如
$ my_name="biomooc"
注意：变量名和等号之间不能有空格。
变量命名规则：
	- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
	- 中间不能有空格，可以使用下划线（_）。
	- 不能使用标点符号。
	- 不能使用bash里的关键字（可用help命令查看保留关键字）。

2.除了显式地直接赋值，还可以用语句给变量赋值，如：
$ my_name2=`ls /etc`
$ for file in `ls /etc` #注意不是单引号，是主键盘顶部数字行最左边的那个键。
或
$ for file in $(ls /etc)
以上语句将 /etc 下目录的文件名循环出来。
$ for file in $(ls /etc);do echo $file; done;



或者 这样也能获取文件test.txt中的值；
temp=`cat test.txt`
echo temp #变成一行输出了，换行符是空格?







3.使用变量
使用一个定义过的变量，只要在变量名前面加美元符号即可，如：
your_name="biomooc"
echo $your_name
echo ${your_name} #{}是为了定边界，加不加都行，不过如果歧义了必须加上。

#例1：
$ echo "$your_nameIsGood" #对于没有定义的变量，不报错，输出空。
$ echo "${your_name}IsGood"
biomoocIsGood

#例2：
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
输出：
I am good at AdaScript
I am good at CoffeScript
I am good at ActionScript
I am good at JavaScript


4.只读变量
已经定义的变量可以重新赋值。
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

#!/bin/bash
myUrl="http://www.google.com"
readonly myUrl
myUrl="http://www.biomooc.com"

运行脚本会报错：
./a.sh: line 4: myUrl: readonly variable




5.删除变量
使用 unset 命令可以删除变量。语法：
unset variable_name

变量被删除后不能再次使用。unset 命令不能删除只读变量。



6.变量类型
运行shell时，会同时存在三种变量：

1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行








## 注释
1.单行注释 #

2.多行注释
:<<EOF
注释内容...
注释内容...
注释内容...
EOF

也可以使用其他符号(!或者`等)、字母或字母组合代替EOF
:<<!
注释内容...
注释内容...
注释内容...
!













========================================
|-- Shell 字符串
----------------------------------------
字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。

1.单引号
原样输出，变量名被原样输出。

2.双引号
如果有变量，则解析变量的值。
双引号内可以有转义字符。

your_name='Cat'
str="Hello, I have a \"$your_name\"! \n"
echo $str

Hello, I have a "Cat"! \n



3.拼接字符串
your_name="biomooc"
# 使用双引号拼接
greeting="hello, "$your_name" !"  #greeting="hello, $your_name !" #效果相同
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !' #单引号内的变量不解析
echo $greeting_2  $greeting_3

输出结果为：
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !



4.获取字符串长度
string="abcd"
echo ${#string} #输出 4

计算字符长度也可是使用 length:
$ expr length "$string"
4



5.提取子字符串
以下实例从字符串第 0 个字符开始截取 4 个字符：
$ greeting='Hello, shell world'
$ echo ${greeting:0:4}
Hell
$ echo ${greeting:7:3}
she



6.查找子字符串
查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：

string="this is a fox"
echo `expr index "$string" io`  # 输出 3
注意： 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。


$ aa=`expr index "$string" s`
$ echo $aa
4





7. ${} 变量、截取、替换
获取变量值只是它的基本功能，{}内部还支持变量替换，变量截取，先看看基本语法

(1) 通过删除不需要的部分子串来截取

#是去掉左边（键盘上#在 $ 的左边）
%是去掉右边（键盘上% 在$ 的右边）
单一符号#，%是最小匹配；两个符号##，%%是最大匹配
这种语法，我自己给他取个名字，“砍头去尾” 语法，这个用法通常会搭配通配符 '*' 来使用。


Linux 的字符串截取，有八种方法。
四种符号：# ## % %%
#、## 表示从左边开始删除。一个 # 表示从左边删除到第一个指定的字符；两个 # 表示从左边删除到最后一个指定的字符。
%、%% 表示从右边开始删除。一个 % 表示从右边删除到第一个指定的字符；两个 % 表示从左边删除到最后一个指定的字符。

--> 删除包括了指定的字符本身。

var=http://www.aaa.com/123.htm
1)$ echo ${var#*/} #/www.aaa.com/123.htm
2)$ echo ${var##*/} #123.htm
3)$ echo ${var%/*} #http://www.aaa.com
4)$ echo ${var%%/*} #http:


## 通过字符坐标获取
第一个：后面代表字符开始的位置，第二个：后面代表要获取子串的长度

5)从左边第几个字符开始，及字符的个数
$ echo ${var:7:4} #www.

6)从左边第几个字符开始，默认到最后
$ echo ${var:7} #www.aaa.com/123.htm

7)从右边第几个字符开始，及字符的个数
$ echo ${var:0-7:3} #123

8)从右边第几个字符开始，一直到结束。
$ echo ${var:0-7} #123.htm




(2) 字符替换
$ path=/etc/sysconfig/network

$ echo ${path/et/ET}  //第一个出现的et替换成 ET
/ETc/sysconfig/network
$ echo ${path//et/ET}  //所有出现的et替换成ET
/ETc/sysconfig/nETwork









========================================
|-- Shell 数组
----------------------------------------
bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
类似与 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

1.定义数组
在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：
数组名=(值1 值2 ... 值n)

例如：
array_name=(value0 value1 value2 value3)

或者
array_name=(
value0
value1
value2
value3
)

还可以单独定义数组的各个分量：
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen

可以不使用连续的下标，而且下标的范围没有限制。



2.读取数组
读取数组元素值的一般格式是：
${数组名[下标]}

例如：
valuen=${array_name[n]}

使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}





3.获取数组的长度
获取数组长度的方法与获取字符串长度的方法相同，例如：

# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}

# 取得数组单个元素的长度
lengthn=${#array_name[n]}







4.数组综合练习：
(1) 从目录得到数组
$ arr2=(`ls ../`)  #定义数组
说明：使用$ arr2=(`ls -lth ../`)并不能获取行为元素的数组，因为是用空格分割数组的。

$ echo ${arr2[@]} #输出全部数组元素
cavas-lines.html exons2.bed exons2.txt exons.bed exons.txt gettyimages-1006034670-800x533.jpg hg19_ucsc_genes.gtf index2.html test tmp
$ echo ${arr2[0]} #第0个数组值
cavas-lines.html
$ echo ${arr2[1]} #第1个数组值
exons2.bed

$ echo ${#arr2[0]} #第一个数组值cavas-lines.html的长度
16
$ echo ${#arr2[@]} #数组长度
10




(2) 从字符串获取数组
$ a1="this is a book"
$ arr=($a1)
$ echo ${arr[1]} #is


如果使用其他分隔符呢？ https://blog.csdn.net/lfwer/article/details/84923165

$ a2="this,fox,jumps,over,that,box"
$ arr2=(${a2//,/ })  # 注意最后花括号前有一个空格
$ echo $arr2  # this
$ echo ${arr2[3]}  # over


## 遍历数组：方法1
$ for i in ${arr2[@]}
do 
	echo ${i}
done
输出:
this
fox
jumps
over
that
box


## 遍历数组：方法2
$ for (( i = 0 ; i < ${#arr2[@]} ; i++ ))
do
  echo -e $i "\t" ${arr2[$i]}
done
输出:
0 	 this
1 	 fox
2 	 jumps
3 	 over
4 	 that
5 	 box





忘了加空格就成了替换
$ arr3=(${a2//,/})
$ echo $arr3
thisfoxjumpsoverthatbox


切片
$ echo ${arr2[@]:0:2}  #从第0个开始，取2个
this fox
$ echo ${arr2[@]:2:3}  #从第2个开始，取3个
jumps over that

$ echo ${arr2[@]:3} #省略，则表示从第3个元素，取到最后
over that box



array 的模拟操作(模拟js 的数组)

1) push: 在末尾添加
$ array1=("${arr2[@]}" "Apple")
$ echo ${array1[@]}
this fox jumps over that box Apple

2) pop: 末尾弹出一个，返回 length-1 长度的数组
$ array2=(${arr2[@]:0:$((${#arr2[@]}-1))})
$ echo ${array2[@]}
this fox jumps over that

3) shift: 从第一个元素弹出一个，其余返回
$ array3=(${arr2[@]:1})
$ echo ${array3[@]}
fox jumps over that box

4) unshift: 从前面压入一个元素
$ array4=("XXX" "${arr2[@]}")
$ echo ${array4[@]}
XXX this fox jumps over that box




// 看不懂 shell 的函数
function del_array {
	local i
	for (( i = 0 ; i < ${#array[@]} ; i++ ))
	do
		if [ "$1" = "${array[$i]}” ] ;then
			break
		fi
	done
	del_array_index $i
}

function del_array_index {
	array=(${array[@]:0:$1} ${array[@]:$(($1 + 1))})
}



ref:
https://blog.csdn.net/huzhenwei/article/details/5385238





========================================
shell脚本|运算符: 算术/关系/布尔/字符串/文件测试
----------------------------------------
Shell 和其他编程语言一样，支持多种运算符，包括：
	算术运算符
	关系运算符
	布尔运算符
	字符串运算符
	文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：
#!/bin/bash
val=`expr 2 + 2`
echo "两数之和为 : $val" #4

两点注意：
 - 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
 - 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

1.算数运算符示例
$ a=10
$ b=20  #c=1;d=2 #或者一行多个语句，用分号分开

$ `expr $a + $b` #30: command not found
$ echo `expr $a - $b` #-10

$ echo `expr $a * $b` #需要加转义符expr: syntax error
$ echo `expr $a \* $b` #200

$ echo `expr $a / $b` #0 除法
$ echo `expr $b / $a` #2 除法
$ echo `expr $b % 3` #2 取余数


(2) 
$ cat c.sh
a=10
b=20

if [ $a == $b ]
then
        echo "eq"
fi

if [ $a != $b ]
then
        echo "neq"
fi


注意：条件表达式要放在方括号之间，并且([]和==两侧都)要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。

如果出现报错: [: too many arguments，则可能是2个原因：
- 字符串中间有空格，解决方法：加上双引号 if [ "$a1" == "$a2" ]; then echo ${id}:"eq"; fi;



(3) 判断是一个输入的数字是否能被10整除
$ cat b.sh
a=$1
echo $a
if [ `expr $a % 10` = 0 ]
then
        echo " /10=?...0"
fi

测试：
$ bash b.sh 11 #不能
11
$ bash b.sh 20 #能
20
 /10=?...0














2.关系运算符，只能用在if判断中，不能用到赋值中
echo [ $a -eq $b ] #会报错

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：
-ne 不相等  [ $a -ne $b ] 返回 true。
-gt >
-lt <
-ge >=
-le <=








3.布尔运算符
下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：
!  not  [ ! false ] 返回 true。
-o  or  [ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a  and [ $a -lt 20 -a $b -gt 100 ] 返回 false。







4.逻辑运算符
以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

运算符	说明	举例
&&	逻辑的 AND	[[ $a -lt 100 && $b -gt 100 ]] 返回 false
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]] 返回 true








5. 字符串运算符
下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

运算符	说明	举例
=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。
-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
-n	检测字符串长度是否为0，不为0返回 true。	[ -n "$a" ] 返回 true。
str	检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。









========================================
|-- shell判断文件,目录是否存在或者具有权限
----------------------------------------
1.文件测试运算符
文件测试运算符用于检测 Unix 文件的各种属性。
属性检测描述如下：

操作符	说明	举例
-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。



(1) -f 和-e的区别
-e 文件存在(和 -a一样)
-f 存在，且是一个常规文件(不是设备、目录等)


Conditional Logic on Files
-a file exists.
-b file exists and is a block special file.
-c file exists and is a character special file.
-d file exists and is a directory.
-e file exists (just the same as -a).
-f file exists and is a regular file.
-g file exists and has its setgid(2) bit set.
-G file exists and has the same group ID as this process.
-k file exists and has its sticky bit set.
-L file exists and is a symbolic link.
-n string length is not zero.
-o Named option is set on.
-O file exists and is owned by the user ID of this process.
-p file exists and is a first in, first out (FIFO) special file or named pipe.
-r file exists and is readable by the current process.
-s file exists and has a size greater than zero.
-S file exists and is a socket.
-t file descriptor number fildes is open and associated with a terminal device.
-u file exists and has its setuid(2) bit set.
-w file exists and is writable by the current process.
-x file exists and is executable by the current process.
-z string length is zero.

(2) 是用 -s 还是用 -f 这个区别是很大的！
-s 文件存在，且非空(大小超过0)
-f 文件存在，且是常规文件(不是设备、目录等)






2. 实例 
shell判断文件,目录是否存在或者具有权限

#!/bin/sh
myPath="/var/log/httpd/"
myFile="/var /log/httpd/access.log"

# 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限
if [ ! -x "$myPath"]; then
mkdir "$myPath"
fi

# 这里的-d 参数判断$myPath是否存在
if [ ! -d "$myPath"]; then
mkdir "$myPath"
fi

# 这里的-f参数判断$myFile是否存在
if [ ! -f "$myFile" ]; then
touch "$myFile"
fi

# 其他参数还有-n,-n是判断一个变量是否是否有值
if [ ! -n "$myVar" ]; then
echo "$myVar is empty"
exit 0
fi

# 两个变量判断是否相等
if [ "$var1" = "$var2" ]; then
echo '$var1 eq $var2'
else
echo '$var1 not eq $var2'
fi





ref: https://www.cnblogs.com/sunyubo/archive/2011/10/17/2282047.html











========================================
|-- $(())与expr 整数运算
----------------------------------------
$ echo $((3+2)) ##5
$ echo $((3*2)) ##6
$ echo $((3/2)) ##1

如果使用变量
$ i=2
$ echo $((i+3)) #5
$ echo $(($i+3)) #5




$ echo `expr 2+3`   //运算符前后需要空格
2+3

$ echo `expr 2 + 3`
5

$ echo `expr 2 * 3` //会提示语法错误，需要转义
expr: syntax error

$ echo `expr 2 \* 3`
6





========================================
shell脚本|输出与测试：echo、printf、test
----------------------------------------
1. echo $a

(1) echo -e 参数能输出转移符号，比如 tab ，换行等。
$ echo "this\tis"
this\tis

$ echo -e "this\tis"
this	is

$ echo -e "this\nis"
this
is


(2) 打印出带颜色的文字
$ echo -e "\e[1;32mOK\e[0m" # 绿色的 OK
OK

$ echo -e "\e[1;31mFAILED\e[0m"  # 红色的 FAILED
FAILED


例: 输出红色的警告
$ echo -e "\033[31m WARNING! \033[m各个字符的含义。？"
解释:
\033 是ASCII字表里的 {ESC}
[八进制数字m 表示不同的颜色，31-37, 41-47 你可以自己试一下效果
[m 恢复默认值






2. printf功能更加强大
printf 命令模仿 C 程序库（library）里的 printf() 程序。
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。

printf 命令的语法：
printf  format-string  [arguments...]
参数说明：
format-string: 为格式控制字符串
arguments: 为参数列表。


%d %s %c %f 格式替代符详解:
d: Decimal 十进制整数 -- 对应位置参数必须是十进制整数，否则报错！
s: String 字符串 -- 对应位置参数必须是字符串或者字符型，否则报错！
c: Char 字符 -- 对应位置参数必须是字符串或者字符型，否则报错！
f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！

如：其中最后一个参数是 "def"，%c 自动截取字符串的第一个字符作为结果输出。
$  printf "%d %s %c\n" 1 "abc" "def"
1 abc d





3.Shell test 命令
Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。







========================================
shell脚本|流程控制
----------------------------------------
1.选择
(1)if语句
if condition
then
    command1 
    command2
    ...
    commandN 
fi

写成一行（适用于终端命令提示符）：
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi


(2)if else 注意else语句不能是空语句。
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi


(3)if else-if else
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi


(4)if else语句经常与test命令结合使用，如下所示：

num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo '两个数字相等!'
else
    echo '两个数字不相等!'
fi


(5)Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：

case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac

case的语法和C family语言差别很大。 
它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。


例子：提示输入1到4，与每一种模式进行匹配：
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac









2.for循环
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done


(1)例如：
for i in `ls ../*count`
do 
	#语句块
	ls -lth $i 
	echo ${i} #用{}能避免变量名和后面的字符歧义 ${i}s, 而不是 $is
done

可以在中间加入功能：获取细胞id列表
cell_id=`ls ../*count | sed -e 's/..\/htseq_//' -e 's/.sam.count//'`
echo $cell_id|head


写成一行：for var in item1 item2 ... itemN; do command1; command2… done;
$ for i in `ls .`; do ls $i;wc $i; done;


(2)in可以是数字
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
输出
The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5


(3)还可以用C语言风格的for循环。不过，和C中的还是有差别的。
for((assignment;condition:next));do
    command_1;
    command_2;
    commond_..;
done;

通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：
#!/bin/bash
for((i=1;i<=5;i++));do
    echo "这是第 $i 次调用";
done;

与 C 中相似，赋值和下一步执行可以放到代码之前循环语句之中执行，这里要注意一点：如果要在循环体中进行 for 中的 next 操作，记得变量要加 $，不然程序会变成死循环。







3.while 循环语句
while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：

while condition
do
    command
done

#!/bin/bash
int=1
while(( $int<=5 ))
do
    echo "int="$int
    let "int++" #递增，参考bash let语句
done
输出：
int=1
int=2
int=3
int=4
int=5



(2) 读取文件第几行 第几列的值
list文件如下
platform            NO1         NO2
 -----------     ----------   --------
 AIX_64             1          20
 NT_X64             2          21
 LINUX_X64          3          22
 HPIA_64                       23

脚本 
cat list| awk 'NR>2' | while read platform  NO1  NO2
do
    echo $NO1"   "$NO2
done

解释：
#NR>2  表示从第三行读取
#while read platform  NO1  NO2   这三个参数必须有，
如果只有   while read NO1  NO2 ， 那么输出结果 NO1  是 platform的值， NO2  输出的是文件中NO1  和NO2 的值。








4.while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。

echo '按下 <CTRL-D> 退出'
echo -n '输入你最喜欢的网站名: '
while read FILM
do
    echo "是的！$FILM 是一个好网站"
done




5.无限循环
无限循环语法格式：

while :
do
    command
done


或者
while true
do
    command
done


或者
for (( ; ; ));do 
	command 
done


例子：每2秒输出当前日期时间
$ cat e.sh
for (( ; ; ));do
        echo `date`;
        sleep 2;
done





6.until 循环
until 循环执行一系列命令直至条件为 true 时停止。
until 循环与 while 循环在处理方式上刚好相反。
一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。

until 语法格式:

until condition
do
    command
done

condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。
以下实例我们使用 until 命令来输出 0 ~ 9 的数字：

#!/bin/bash
a=0
until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done




7.跳出循环
在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。

(1)break命令允许跳出所有循环（终止执行后面的所有循环）。
例子：输入大于5则跳出循环
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break
        ;;
    esac
done


(2)continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

对上面的例子进行修改：
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done

运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo "游戏结束" 永远不会被执行。
使用ctrl+c强制结束。






========================================
|-- shell 判断元素是否在数组中
----------------------------------------

1.
echo "${array[@]}" | grep -wq "$var" &&  echo "Yes" || echo "No"



2.
for i in ${array[@]}
do
   [ "$i" == "$var" ] && echo "yes"
done




ref:https://blog.csdn.net/u010022051/article/details/51919280



========================================
|-- shell 双重循环: 打印正方形、直角三角形、等腰三角形、菱形、九九乘法表
----------------------------------------
1. 基础 
(1) echo的使用方法：   
-n:不换行输出
-e:支持反斜线控制的字符转换


转义：
\a：发出警告声
\b：删除前一个字符
\c ：最后不加上换行符号
\f : 换行但光标仍旧停留在原来的位置
\n ：换行且光标移至行首
\r :光标移至行首，但不换行
\t：插入tab
\v 与 \f 相同
\ 插入 \ 字符 
\nnn 插入  nnn(八进制)所代表的ASCII字符



(2)seq的使用方法：
seq   10 #起始默认是1，间隔默认也是1
seq  1  10  #从1开始，到10结束，间隔为1，结果是：1 2 3.... 10

seq  2  100 #间隔默认是1
seq  1  3 10 # 从1到10，间隔为3，结果是：1 4 7 10





2. 开始双重循环

这些都要放到脚本中才能执行，直接执行则报错。

(1) 打印正方形
$ cat tx.sh
for ((i=1;i<=5;i++))
do 
	for ((j=1;j<=5;j++))
	do 
		echo -n "* "
	done
	echo 
done

$ bash tx.sh
* * * * * 
* * * * * 
* * * * * 
* * * * * 
* * * * * 


(2) 直角三角形
for ((i=1;i<=5;i++))
do 
	for ((j=1;j<=$i;j++))
	do 
		echo -n "* "
	done
	echo 
done

$ bash tx.sh 
* 
* * 
* * * 
* * * * 
* * * * * 


# 右上三角形
for ((i=1;i<=10;i++))
do 
	for ((j=0;j<=$i-1;j++))
	do 
	echo -n "  "
	done
	for ((j=10-$i;j>0;j--))
	do 
		echo -n "* "
	done
	echo
done

  * * * * * * * * * 
    * * * * * * * * 
      * * * * * * * 
        * * * * * * 
          * * * * * 
            * * * * 
              * * * 
                * * 
                  * 
#


# 右下三角
for ((i=1;i<=10;i++))
do 
	for ((j=10;j>=i;j--))
	do 
	echo -n "  "
	done
	
	for ((j=1;j<=i;j++))
	do 
		echo -n "* "
	done
	
	echo
done

#
                    * 
                  * * 
                * * * 
              * * * * 
            * * * * * 
          * * * * * * 
        * * * * * * * 
      * * * * * * * * 
    * * * * * * * * * 
  * * * * * * * * * *



(3) 等腰三角形
for ((i=1;i<10;i++))
do 
	for ((j=10;j>=i;j--))
	do 
	echo -n " "
	done
	
	for ((j=1;j<=2*i-1;j++))
	do 
		echo -n "*"
	done
	
	echo
done

          *
         ***
        *****
       *******
      *********
     ***********
    *************
   ***************
  *****************
 *******************

(4) 菱形

#############
#测试
$ read -p "请输入菱形长度" len
请输入菱形长度10
$ echo $len
10


#############
# 脚本
read -p "请输入菱形长度" len

for i in `seq 1 $len`
do 
	for ((j=$len-1;j>=$i;j--))
	do
		echo -n " "
	done 
	
	for ((m=1;m<=2*$i-1;m++))
	do
		echo -n "*"
	done
	
	echo
done;

for i in `seq 1 $len`
do 
	for ((j=1;j<=$i;j++))
	do
		echo -n " "
	done
	
	for ((n=2*$len-$i;n>=$i;n--))
	do 
		echo -n "*"
	done
	
	echo 
done;

$ bash tx3.sh 
请输入菱形长度5
    *
   ***
  *****
 *******
*********
 *********
  *******
   *****
    ***
     *
#



(5) 打印九九乘法表
$ cat tx4.sh 
for ((i=1;i<=9;i++))
do 
	for ((j=1;j<=i;j++))
	do 
		echo -ne "$j*$i=$((i*j)) \t";
	done;
	echo
done;


$ bash tx4.sh 
1*1=1 	
1*2=2 	2*2=4 	
1*3=3 	2*3=6 	3*3=9 	
1*4=4 	2*4=8 	3*4=12 	4*4=16 	
1*5=5 	2*5=10 	3*5=15 	4*5=20 	5*5=25 	
1*6=6 	2*6=12 	3*6=18 	4*6=24 	5*6=30 	6*6=36 	
1*7=7 	2*7=14 	3*7=21 	4*7=28 	5*7=35 	6*7=42 	7*7=49 	
1*8=8 	2*8=16 	3*8=24 	4*8=32 	5*8=40 	6*8=48 	7*8=56 	8*8=64 	
1*9=9 	2*9=18 	3*9=27 	4*9=36 	5*9=45 	6*9=54 	7*9=63 	8*9=72 	9*9=81





ref:
https://blog.csdn.net/weixin_50344760/article/details/109743454





========================================
Linux中变量的含义 $#,$@,$0,$1,$2,$*,$$,$?，@，$^、$
----------------------------------------
$0 这个程式的执行名字
$n 这个程式的第n个参数值，n=1..9
 $0 是脚本本身的名字
 $1 是传递给该shell脚本的第一个参数
 $2 是传递给该shell脚本的第二个参数
$* 这个程式的所有参数，与位置变量不同，此选项参数可超过9个。
$@ 是传给脚本的所有参数的列表，代表目标文件(target) 。跟$*类似，但是可以当作数组用
$# 这个程式的参数个数

$$ 这个程式的PID(脚本运行的当前进程ID号)

$! 执行上一个背景指令的PID(后台运行的最后一个进程的进程ID号)
$? 执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)
$- 显示shell使用的当前选项，与set命令功能相同

@这个符串通常用在“规则”行中，表示不显示命令本身，而只显示它的结果
$^代表所有的依赖文件(components)
$< 代表第一个依赖文件(components中最左边的那个)。


1. 区别：@ *
相同点：都是引用所有参数
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数（分别存储在1 2 3）则"*" 等价于 “1 2 3"（传递了一个参数）；而“@" 等价于 "1" "2"  "3"（传递了三个参数）

例1:
$ cat test.sh
echo "--\$* 演示 --"
for i in "$*"; do 
	echo $i;
done;
#
echo "--\$@ 演示 --"
for i in $@; do 
	echo $i;
done;

输出结果
$ bash test.sh 1 2 3
--$* 演示 --
1 2 3
--$@ 演示 --
1
2
3






========================================
shell脚本|函数与参数传递、默认参数
----------------------------------------

## linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。
1. shell中函数的定义格式如下：
[ function ] funname [()]
{
    action;
    [return int;]
}

说明：
1)可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
2)参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)

例子1： 
$ cat e.sh
my_fun(){
        echo "This is my first function"
}

my_fun

$ ./e.sh
This is my first function




2. 函数参数
在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

带参数的函数示例：

#!/bin/bash
funAdd(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
	return $(($1+$2))
}
funAdd 1 20
echo $? #函数返回值在调用该函数后通过 $? 来获得。

输出： 
第一个参数为 1 !
第二个参数为 20 !
21

注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。


另外，还有几个特殊字符用来处理参数：
参数处理	说明
$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。








3. Shell 传递参数
在执行 Shell 脚本时，可以向脚本传递参数。
(1).脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

$ vim b.sh
$ cat b.sh
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

$ chmod +x b.sh
$ ./b.sh 1 2 3 4
Shell 传递参数实例！
执行的文件名：./b.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3


(2).其他特殊字符
$# 传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数。
	如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
	如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
#










4. 默认参数，linux变量默认值设置 := :? :+ :-

# linux shell
username="";
echo "${username:+$LOGNAME}"

1)修改原变量(username)值
:=    变量username未定义或者空值,则被替换
= 未定义则被替换

2)不修改变量值,
只在${}中替换变量值
:-  username未定义或者空值,则${}输出被替换,变量值不变
-  username未定义,则${}输出被替换,变量值不变

3)脚本会从出错行退出，而且会显示出错误行行号
:?   username未定义或者空值  并且脚本退出执行
? username未定义则替换 并且脚本退出执行

4)不修改变量值
只有当变量已被定义而不是未定义的时候，“${}”表达式才执行替换
:+ 如果变量被定义而且非空,则替换${} 输出值
+  如果变量已被定义,则替换${} 输出值


: 则对空字符串''也起作用，否则只对null起作用。
分清哪些改变变量值，哪些不改变：只有带=的改变变量值。




详解 + 实例：

(1)if 繁琐方式
if [ ! $1 ]; then
    $1='default'
fi

## 等价方式就是（最常用的默认值设置方法）
name=$1;
name=${name:=default} ##
echo $name

$ bash test.sh 001
001
$ bash test.sh
default



(2)- 变量为null，则取默认值。不改变变量值。 ${vari-defaultValue}
例1:
$ cat test2.sh
echo '--默认参数举例--'
unset name;
echo "1: name="${name}
echo "2: name="${name-Ubuntu}
echo $name;

echo '---when not null---'
name=''
echo "3: name="${name}
echo "4: name="${name-Ubuntu}
echo $name;

echo '---test from shell---'
pass=$1
echo "5: pass="${pass-123456}

输出结果 
$ bash test2.sh 123abc
--默认参数举例--
1: name=
2: name=Ubuntu

---when not null---
3: name=
4: name=

---test from shell---
5: pass=123abc



(3)= 变量为null时, 同时改变变量值
$ unset name
$ echo ${name=ubuntu}
ubuntu
$ echo $name
ubuntu

$ name=""
$ echo ${name=ubuntu}

$ echo $name


(4):- 变量为null 或 空字符串，取默认值，不改变变量值 ${vari:-defaultValue}

## for null
$ unset name
$ echo ${name:-linux}
linux
$ echo $name


## for ''
$ name=''
$ echo ${name:-linux}
linux
$ echo $name





(5) :? 变量为null 或 空字符串时报错并退出
name='admin'
echo ${name:?linux}
echo $name;

unset name;
echo ${name:?linux}
## -bash: name: linux

name=''
echo ${name:?linux}
## -bash: name: linux



(6):+ 变量不为空时使用默认值，不改变变量值。
与 :- 相反
name='admin'
echo ${name:+linux} ## linux
echo $name; ## admin


refer:
https://www.linuxidc.com/Linux/2018-11/155618.htm
https://blog.csdn.net/qq_35515661/article/details/93313731




========================================
shell脚本|shell文件包含
----------------------------------------
和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。
Shell 文件包含的语法格式如下：

. filename   # 注意点号(.)和文件名中间有一空格
或
source filename


例子： 
1.新建3个文件：
$ cat a1.sh
url="hello, shell file 1"

$ cat a2.sh
name="from biomooc.com"

$ cat b.sh
# include file 1
. ./a1.sh

# include file 2
source ./a2.sh

echo "File 1: $url, File 2: $name"

2.为b.sh添加执行权限，并执行该文件
$ chmod +x b.sh
$ ./b.sh
File 1: hello, shell file 1, File 2: from biomooc.com






========================================
crontab定时任务
----------------------------------------
crontab - maintain crontab files for individual users (Vixie Cron)

cron是一个[守护程序]用于在指定的时间内执行行程类的任务，每一个用户都有一个 crontab 文件，来允许他们指定需要执行的内容和时间，此外，系统也有一个 crontab ，用来允许像交替日志和更新本地数据这样有规则的任务。


成功的task
0 0,12 * * * date >> /home/wangjl/web/log.txt #0点和12点写入一次时间戳






1.使用 crontab -e命令
这个命令比较简单直接输入就可以
$ crontab -e
然后选一个编辑器，比如2，回车。


(1)crontab的语法规则格式：
代表意义	分钟	小时	日期	月份	周	命令
数字范围	0~59	0~23	1~31	1~12	0~7	需要执行的命令
周的数字为 0 或 7 时，都代表“星期天”的意思。


(2)另外，还有一些辅助的字符，大概有下面这些：
特殊字符	代表意义
*(星号)	代表任何时刻都接受的意思。举例来说，0 12 * * * command 日、月、周都是*，就代表着不论何月、何日的礼拜几的12：00都执行后续命令的意思。
,(逗号)	代表分隔时段的意思。举例来说，如果要执行的工作是3：00与6：00时，就会是：0 3,6 * * * command时间还是有五列，不过第二列是 3,6 ，代表3与6都适用
-(减号)	代表一段时间范围内，举例来说，8点到12点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二列变成8-12.代表 8,9,10,11,12 都适用的意思
/n(斜线)	那个n代表数字，即是每隔n单位间隔的意思，例如每五分钟进行一次，则：*/5 * * * * command用*与/5来搭配，也可以写成0-59/5，意思相同





2.输入你想执行的内容了.
(1)比如:
*/2 * * * * date >> /home/wangjl/time.log #每过两分钟就向time.log文件中写入当然的系统时间.
* * * * * date>>/home/wangjl/web/test/date.txt #每分钟写入文件。

# For example, you can run a backup of all your user accounts at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/

格式：
# For more information see the manual pages of crontab(5) and cron(8)
# m h  dom mon dow   command
#minute hour day-of-month month-of-year day-of-week commands
合法值为：00-59 00-23 01-31 01-12 0-6 (0 is sunday)
除了数字还有几个特殊的符号："*"、"/"和"-"、","
	*代表所有的取值范围内的数字
	"/"代表每的意思,"/5"表示每5个单位，例如每3分钟运行一次命令： */3 * * * * /home/wangjl/XXXX.sh
	"-"代表从某个数字到某个数字
	","分开几个离散的数字

参数说明(看例子,就明白了)
	m 分钟 0-59
	h 小时 0-23
	dow 天1-31
	mon 月 1-12
	dow  星期 1-6  0表示星期天
	command 就是要执行的命令

(2)关键是要记住/var/spool/cron这个目录。
除了root用户之外的用户可以执行crontab配置计划任务。
所有用户定义的crontab存储在目录/var/spool/cron下，任务会以创建者的身份被执行。
要以特定用户创建一个crontab，先以该用户登录，执行命令crontab -e，系统会启动在VISUAL或者EDITOR中指定的的编辑软件编辑crontab。文件内容与/etc/crontab格式相同。

最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。

$ sudo cat /var/spool/cron/crontabs/wangjl
看到的内容和 $ crontab -e 看到的内容一样。



删除crontab文件
$crontab -r

千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。



(3)如果一个cron任务需要定期而不是按小时,天,周,月来执行,则需要添加/etc/cron.d目录。这个目录下的所有文件和文件/etc/crontab语法相同
//todo


(4)查看/etc/crontab文件：
###########################
$ cat /etc/crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user  command
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
###########################
解释：
SHELL变量的值指定系统使用的SHELL环境(该样例为bash shell)，
PATH变量定义了执行命令的路径。
文件/etc/crontab中每行任务的描述格式如下:

  minute hour day month dayofweek command
  minute - 从0到59的整数
  hour - 从0到23的整数
  day - 从1到31的整数 (必须是指定月份的有效日期)
  month - 从1到12的整数 (或如Jan或Feb简写的月份)
  dayofweek - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)
  command - 需要执行的命令(可用as ls /proc >> /tmp/proc或 执行自定义脚本的命令)
  root表示以root用户身份来运行
  run-parts表示后面跟着的是一个文件夹，要执行的是该文件夹下的所有脚本
  
  对于以上各语句，星号(*)表示所有可用的值。例如*在指代month时表示每月执行(需要符合其他限制条件)该命令。
  整数间的连字号(-)表示整数列，例如1-4意思是整数1,2,3,4
  指定数值由逗号分开。如：3,4,6,8表示这四个指定整数。
  符号“/”指定步进设置。“/”表示步进值。如0-59/2定义每两分钟执行一次。步进值也可用星号表示。如*/3用来运行每三个月份运行指定任务。
  以“#”开头的为注释行,不会被执行。

开始不知道/etc/crontab文件中的run-parts是什么意思，直接把命令按照/etc/crontab的格式加上总是无法运行，后来才知道run-parts是指后面跟着的是文件夹。


(5)其他注意事项
cron服务会每分钟检查一次/etc/crontab、/etc/cron.d/、/var/spool/cron文件下的变更。如果发现变化，就会下载到存储器中。因此，即使crontab文件改变了，程序也不需要重新启动。
新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

推荐自定义的任务使用crontab -e命令添加，退出后用/etc/init.d/crond restart命令重启crond进程，官方文件说不用重启进程，但我遇到不重启无法运行任务的情况。

更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:
$service cron restart

ubuntu下启动、停止与重启cron:
	$sudo /etc/init.d/cron start
	$sudo /etc/init.d/cron stop
	$sudo /etc/init.d/cron restart



3.更多例子
1)在 凌晨00:01运行
1 0 * * * /home/wangjl/XXXX.sh

2)每个工作日23:59都进行备份作业。
59 11 * * 1,2,3,4,5 /home/wangjl/XXXX.sh

或者如下写法：
59 11 * * 1-5 /home/wangjl/XXXX.sh

3)每分钟运行一次命令
*/1 * * * * /home/wangjl/XXXX.sh

4)每个月的1号 14:10 运行
10 14 1 * * /home/wangjl/XXXX.sh

每小时的第3和第15分钟执行
3,15 * * * * myCommand

在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand

每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand

实例5：每周一上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 myCommand

每月1、10、22日的4 : 45重启smb
45 4 1,10,22 * * /etc/init.d/smb restart

实例10：每星期六的晚上11 : 00 pm重启smb 
命令：
0 23 * * 6 /etc/init.d/smb restart


假设需要每天的 23:01 分创建目录，配置 crontab 如下即可：
1 23 * * * mkdir -p /path-to-your-dir/`date +%F`
宕机重启后需要单独另外执行脚本检查是否有缺失


实例： 比如搞一个日记本：每天四次时间戳，每周备份一次，中间随便cat>>添加内容。
* 0,6,12,18 * * * date >> /home/wangjl/web/log.txt #每6个小时写入一次时间戳
59 23 * * 0 cp /home/wangjl/web/log.txt /home/wangjl/web/log.`date +%F`.txt #每周日晚上11:59备份日记。备注日期。



实例15：每小时执行/etc/cron.hourly目录内的脚本
命令：
01 * * * * root run-parts /etc/cron.hourly
说明：
run-parts这个参数后跟文件夹；如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了

注意： 
1）脚本中涉及文件路径时写全局路径；
2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：

cat start_cbp.sh
#!/bin/sh
source /etc/profile
export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
/usr/local/jboss-4.0.5/bin/run.sh -c mev &




refer:
https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#
https://blog.csdn.net/u013033143/article/details/82882842
https://blog.csdn.net/xinyflove/article/details/83178876







========================================
shell 综合练习
----------------------------------------
1. 输入一个基因序列文件，输出原始序列和其反向互补序列

(1)脚本 test.sh， 接收一个参数，就是 含有序列的文本文件

temp=`cat $1`
i=0
newT=""

while (( $i<${#temp} ));do
  cnt=${temp:i:1}
  #echo $i, $cnt
  if [ $cnt == "G" ];then
        newT="${newT}C"
  elif [ $cnt == "C" ];then
        newT="${newT}G"
  elif [ $cnt == "A" ];then
        newT="${newT}T"
  elif [ $cnt == "T" ];then
        newT="${newT}A"
  fi
  ((i++))
done;

echo $temp
echo "Complementary sequence:"
echo $newT



使用方法:

$ bash test.sh gene.txt
ATGCATGCAAAAA
Complementary sequence:
TACGTACGTTTTT

bug: 文件不能有空行。
如果想避免遇到空行报错，只需要把if中的左右两边都加上双引号。
或者前后加上字符串
if [ x$cnt == x"G" ];then

todo: 这里只做了互补，反向还要使用 rev 函数。

(2) 一行脚本也能实现反向互补
$ cat gene2.fa
AATTC
TTGG
ATGC
AAAAAA

$ cat gene2.fa | xargs | sed 's/[^ATGC]//g' | tr "ATGC" "TACG" | rev
TTTTTTGCATCCAAGAATT

逻辑顺序:
先变成一行；去掉换行符和空格等；互补；反向；





2. 







========================================
数学计算 bc 
----------------------------------------
1. 十进制转为二进制
$ echo 'obase=2;5' | bc
101

$ echo 'obase=2;127' | bc
1111111

$ echo 'obase=2;3844' | bc
111100000100







========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


