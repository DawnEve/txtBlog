Linux网络
linux简介4|网络与iptables  



TP-link 路由器设置、网络工具等。
IP Gate DNS等。




========================================
网络原理
----------------------------------------

网络编制：主流是IP编址；
IPv4地址为32位长，IPv6地址为128位长，
IPv4包括：网络部分和主机部分：

$ ifconfig #查看当前IP等信息

子网掩码：IP和子网掩码成对出现才能知道那些部分为网络部分。
子网掩码为1的部分对应IP中的网络部分。余下的是

同一个网络主机之间通信：ARP协议。

不同网络之间通信：网关/路由器或具有路由器功能的主机。

路由：不同网络之间传输数据的功能叫做路由功能，一般有多个接口，连接到不同的网络中，并且通过路由表进行数据转发。

域名：IP地址难记，所有我们一般使用域名进行管理。

域名分为三个部分，用.分开：
	类型：www org
	域名：域名称
	主机名：该域中的某台主机。

DNS：每个域名代表一个IP，而DNS服务器就是用来在IP与域名之间进行转换的。





========================================
|-- OSI七层模型详解 (物理层、数据链路层、网络层、传输层.....应用层协议与硬件)
----------------------------------------
https://blog.csdn.net/yaopeng_2005/article/details/7064869


1.
互联网的本质就是一系列的网络协议，这个协议就叫OSI协议（一系列协议），按照功能不同，分工不同，人为的分层七层。实际上这个七层是不存在的。没有这七层的概念，只是人为的划分而已。区分出来的目的只是让你明白哪一层是干什么用的。

每一层都运行不同的协议。协议是干什么的，协议就是标准。
实际上还有人把它划成五层、四层。
七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
五层划分为：应用层、传输层、网络层、数据链路层、物理层。
四层划分为：应用层、传输层、网络层、网络接口层。





OSI 7层模型的小结
由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。
在7层模型中，每一层都提供一个特殊的网络功能。

从网络功能的角度观察：

- 下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；
- 第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；
- 而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。

简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。









========================================
|-- TCP/IP四层参考模型，传输层协议（TCP/UDP），https/http/socket认知
----------------------------------------
1.在网络通信中，网络组件的寻址对信息的路由选择和传输来说是相当关键的。相同网络中的两台机器间的消息传输有各自的技术协定。LAN 是通过提供6字节的唯一标识符（“MAC”地址）在机器间发送消息的。SNA 网络中的每台机器都有一个逻辑单元及与其相应的网络地址。DECNET、AppleTalk 和 Novell IPX 均有一个用来分配编号到各个本地网和工作站的配置。

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
在传输层中有TCP协议与UDP协议。
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。
HTTP是应用层协议，TCP是传输层协议！ 数据包在网络传输过程中，HTTP被封装在TCP包内！！

　　┌───────────────┐┌─┬─┬──┬─┬──┬─┬──┬─┬──┬─┬──┐
　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│
　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│
　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│
　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│
　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│
　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│
　　└───────────────┘└─┴─┴──┴─┴──┴─┴──┴─┴──┴─┴──┘
　　┌─────────────┐┌────────────────┬───────────────────┐
　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│
　　└─────────────┘└────────────────┴───────────────────┘
　　┌─────────────┐┌─────────┬───────┬─────────────────┐
　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│
　　│第二层，网间层　││　　　　　└───────┘　　　　　　　　　　│
　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │
　　└─────────────┘└───────────────────────────────────┘
　　┌─────────────┐┌────────────────┬───────────────────┐
　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│
　　└──────────────┘└───────────────┴───────────────────┘


2.
		TCP		UDP
是否连接		面向连接	面向非连接
传输可靠性	可靠	不可靠
应用场合		传输大量的数据，对可靠性要求较高的场合	传送少量数据、对可靠性要求不高的场景
速度		慢	快





3. socket协议
https://qinqianshan.com/web/web_basic/socks-https-http/







========================================
|-- 交换机、路由器、集线器
----------------------------------------
https://qinqianshan.com/web/web_basic/switches-and-routers/

集线器是物理层设备,采用广播的形式来传输信息。

交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。

路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。



首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。

而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。 这样在机器很多或数据量很大时，两者将会有比较明显的。

而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 






========================================
怎么设置信道来提高【无线路由】的速度？
----------------------------------------
1.现有无线基本上都是2.4G的，有1-13个信道。
2.每个路由发出的无线信号都有主信道和带宽。可以通过手机安装wifi analyzer这款app来查看。
3.信道不重叠时互不干扰，这时无线通信质量最好。只有1,6,11这三个信道能互相不干扰。
4.信道完全重叠的无线信号会自动协商，当一个wifi发送信号时，其他路由自动等待。
	这能完成基本通信，但肯定会降低速度。
5.信道有重叠的信号会互相争抢，干扰比同信道竞争更强，因为没有机制保证大家安静的等待一个wifi去通信。
6.蜂窝网络会自动减少每个路由器的功率，保证1,6,11三个通道基本覆盖整个体育场。


========================================
|-- 无线路由的ngb是什么意思？
----------------------------------------
//



========================================
|-- 路由功能？静态路由表有什么用？
----------------------------------------

路由器的作用是帮你把数据包发送到某个地址，比如有个数据包要发给115.239.210.27，路由器其实不认识这个地址，那么它就会发给wan口，wan口通向电信服务器那边，而服务器知道这是百度的地址，这样就联通了。这个例子中115.239.210.27这个ip是服务器认识的，但是如果服务器不认识这个地址的话，那么数据包就不能发到目的地址。比如两个路由器串联，A路由到B路由的lan口是互不认识的，当然电信服务器也不可能认识这种内网地址，因此这种情况下路由器就不能帮你转发到目的地址了。所以就有了静态路由这个东西，比如有这样的静态路由192.168.2.0 255.255.255.0 192.168.1.2，意思让路由器一发现有发到192.168.2.0 255.255.255.0这个地方去的数据，就啥也不管直接发到192.168.1.2即可。192.168.1.2这个地址不能路由器自己的地址，但是一定要是某个跟自己连接着的路由器那个口的ip。举个例子来说明一下：

A路由wan口192.168.0.1 255.255.255.0，lan口192.168.1.1 255.255.255.0
B路由wan口192.168.1.2 255.255.255.0，lan口192.168.2.1 255.255.255.0

A的lan口出来的线接B的wan口，这种情况下，接Awan口的电脑是ping不到B路由lan口下的电脑的。
路由器的基本作用是连接两个网络，可以让连接的2个网段互相连通，所以A路由wan下的电脑可以ping通A路由lan口下的电脑。然而A路由却不知道192.168.2.0这个网络，所以无法ping通B路由lan口下的电脑，所以要在
A路由下做192.168.2.0 255.255.255.0 192.168.1.2的静态路由
B路由下做192.168.0.0 255.255.255.0 192.168.1.1的静态路由。

以上只适用于高端路由器，普通家用路由器是不一样的，后者就算不做静态路由B下的电脑还是可以ping通A下的电脑，反过来就不行，因为普通家用路由器是做了动态路由的


注意事项：
配置静态路由，一定要两个路由都有配置到跳转，要不的话，只配置了一个路由，那么造成的情况就是数据包无法发送出来或数据包发送出去了，找不到返回的地址！切记


目的网络IP：访问的目标主机或IP网段。
　　子网掩码：填入子网掩码，一般为255.255.255.0。
　　网关：下一跳路由器入口的IP地址。
注意：
　　1、网关必须是与本路由器LAN口IP属于同一个网段。
　　2、如果目的IP地址是一台主机IP地址，则子网掩码必须为255.255.255.255。
　　3、如果目的IP地址为IP网段，则须与子网掩码匹配。例如，如果目的IP为10.0.0.0，子网掩码为255.0.0.0。
#




========================================
|-- 路由覆盖面积不够怎么办？
----------------------------------------

配置方法：
http://jingyan.baidu.com/article/c146541357a7fa0bfcfc4cb6.html
无线设置-基本设置-开启WDS。


注意事项
	2台路由器必须都支持WDS中继（桥接）功能。
	只需要主路由器1支持WPA加密中继连接就可以，路由器2可以不支持，但是必须支持WPA的无线加密协议。
	有些54M的老路由器不支持WPA方式的中继连接，但本身支持WPA加密，可以做附路由。

	DHCP不能2个都开启，必须是连接外网的那台路由器开启（手动配置IP除外）
	主路由器的Internet连接方式无需干涉，不需要额外配置，保持原有方式就可以。
	民用路由器无线信号稳定性差，如果断网、连接不上，必须先重启路由器2，再重启路由器1，然后用电脑重新连接即可。 先重启路由器1有时会导致中继失败。



原理：
其实很简单，无需购置额外的高功率路由器，只需加装一台无线中继器或无线拓展器，就能轻易增加无线网络的覆盖面积了，这样不仅可以收获较好的信号覆盖，而且也不用再担心大功率路由器会引发辐射的问题了。无线中继器通过无线连接到路由器或接入点（AP）上，加速信号，重新发送，来拓展信号的覆盖范围。

注意要点：
首先，无线中继器必须部署在信号源（无线路由器）和客户端设备（手机、平板）的接收范围内。
其次，如果信号源的WiFi是加密的话，无线中继器也需要相关的加密密钥。
还有，设备的兼容性问题可能降低无线信号源的信号质量。





========================================
|-- ip段/数字,如192.168.0.1/24是什么意思?
----------------------------------------
ip地址一共是32位，/24就表示他的网络号是24位，也就是说共有2^（32-24）-2个主机（因为主机为全0和全1的保留不用，所以需要减2），共254个ip，其他的按此类推~~

/24表示掩码的位数，A类IP地址的默认子网掩码为255.0.0.0（由于255相当于二进制的8位1，所以也缩写成“/8”，表示网络号占了8位）;B类的为255.255.0.0（/16）;C类的为255.255.255.0(/24)。/30就是255.255.255.252。32就是255.255.255.255.

子网掩码的前缀表示法！  
11111111 11111111 1111111 00000000  24个1组成    
转成成十进制等于 255.255.255.0    

11111111 11111111 1111111 11111100  30个1组成    
转成成十进制等于 255.255.255.252 



ip地址后面跟/24表示掩码位是24位，子网掩码是255.255.255.0的IP地址，其主机位最多有254个。
子网掩码通常有以下2种格式的表示方法：
1． 通过与IP地址格式相同的点分十进制表示
如：255.0.0.0 或255.255.255.128

2． 在IP地址后加上"/"符号以及1-32的数字，其中1-32的数字表示子网掩码中网络标识位的长度
如：192.168.1.1/24 的子网掩码也可以表示为255.255.255.0
子网掩码一般为255.255.255.0

http://blog.csdn.net/aerchi/article/details/39396423



========================================
|-- 默认DNS推荐
----------------------------------------
dns： 123.125.81.6

电信：首选地址：101.226.4.6，备用地址：218.30.118.6     联通：首选地址：123.125.81.6，备用地址：140.207.198.6
移动：首选地址：101.226.4.6，备用地址：218.30.118.6     铁通：首选地址：101.226.4.6，备用地址：218.30.118.6 
		
测试所在运营商网络 http://www.ip.cn/




========================================
|-- 二级路由器设置实例
----------------------------------------

更便宜的无线扩容方案，是从现有无线路由lan口接出一根网线，连到新路由的wan口，设置不同的域（如顶层用192.168.1.*，第二层使用192.168.2.*）即可容纳二倍的无线设备上网。同理，使用三个无线路由即可容纳三倍的无线设备上网。
同一个嵌套的子网内不要有重复的域名！


顶级Wan口：
	MAC地址：	D8-15-0D-7B-B2-DD	 
	IP地址：	202.196.120.202	静态IP
	子网掩码：	255.255.255.0	 
	网关：	202.196.120.193	 
	DNS服务器：	202.196.64.1 , 114.114.114.114

顶级Lan口：以太网适配器 本地连接:
   连接特定的 DNS 后缀 . . . . . . . : a.com
   本地链接 IPv6 地址. . . . . . . . : fe80::2046:449a:e5fb:8fce%11
   IPv4 地址 . . . . . . . . . . . . : 192.168.1.100
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . : 192.168.1.1	
#


二级Wan口：
	基本设置
	WAN口连接类型自动获得IP地址 
	IP地址192.168.1.200
	子网掩码255.255.255.0
	网关192.168.1.1
	DNS服务器202.196.64.1 , 114.114.114.114

二级LAN口设置
	MAC地址BC-46-99-23-96-EC
	LAN口IP设置自动（推荐） 
	IP地址192.168.0.1
	子网掩码255.255.255.0 






========================================
网络基础配置命令
----------------------------------------
lspci 列出所有网卡信息 eth0 eth1 ...；
lsusb	列出所有usb设备；

ifconfig -a查看所有接口
ifconfig eth0 查看特定接口

ifup、ifdown 来启用禁用某网卡
ifup eth0
ifdown eth0

setup命令配制网络：类图形界面，其实是文本的界面。
配制完成，用ifup启用网卡，并使用ifconfig命令查看信息。



网络相关配置文件
网卡配制文件
/etc/sysconfig/network-scripts/ifcfg-eth0

DNS配置文件
/etc/resolv.conf

主机名配置文件
/etc/sysconfig/network

静态主机名配置文件
/etc/hosts



网络相关配置文件Ubuntu1604
du@Bioinf1:/etc/network$ ls -lth
总用量 32K
-rw-r--r-- 1 root root  510 10月 17 11:49 interfaces

du@Bioinf1:/etc/network$ cat interfaces


========================================
|-- 网络测试命令
----------------------------------------
测试网络连通性
ping 192.168.1.1
ping baidu.com

测试DNS解析
host baidu.com
dig baidu.com

显示路由表
ip route

追踪到达目标地址的网络路径
traceroute baidu.com

使用mtr进行网络质量测试（结合traceroute和ping）
mtr baidu.com

修改主机名 hostname NGS
这是临时修改，重启就没了，永久修改需要:
主机名配置文件
/etc/sysconfig/network


========================================
|-- 网站性能测试工具 Apache Benchmark(ab)  
----------------------------------------
http://blog.163.com/songchao01230@126/blog/static/11618487220129261351247/

Apache Benchmark简称为ab，是apache自带的用于HTTP Server测试的工具。它可以接受单一的URL，然后重复地按照指定的多个独立线程的方式加载，并使用不同的命令行参数控制访问的次数、最大的并发访问数等。另外一项不错的功能是可以输出比较详细的报告。

#执行100次请求，并发是10.
>ab -n 100 -c 10 http://blog.dawneve.com/

>ab -k -n 1000 -c 100 http://localhost/

-k 
 启用KeepAlive功能，即在一个HTTP会话中执行多个请求。默认不启用KeepAlive功能。 
-n requests 
 在测试会话中所执行的请求个数。默认仅执行一个请求，此时其结果不具有意义。 
-c concurrency 
 一次产生的请求个数。默认是一次一个。 
#


========================================
|-- 故障排查指导思想
----------------------------------------
网络故障排查遵循 从底层到高层、从自身到外部 的流程进行；
1 先查看网络配置信息是否正确：
	-IP地址
	-子网掩码
	-网关
	-DNS
2.查看到达网关是否连通
ping 网关IP地址

3.查看DNS解析是否正常：(防止对方挂掉，多试几个)
host baidu.com
host 163.com
host douban.com


========================================
|-- VMware12中安装的虚拟机Ubuntu12桥接联网不能用怎么办？
----------------------------------------
一般恢复默认设置即可解决：VM菜单“编辑”下的“虚拟网络编辑器”，右下角有一个 “恢复默认设置”，经过几分钟，重启虚拟主机中的系统即可联网。


========================================
|-- 使用 curl 发起http请求
----------------------------------------
安装 apt-get install curl 

1. 发起http请求
$ curl http://baidu.com
<html>
<meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
</html>

抓取页面内容到一个文件中
curl -o baidu.html  http://www.baidu.com/

用 -O（大写的），后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西
curl -O http://www.mydomain.com/linux/index.html


2. 断点续传，-C(大写的)
curl -C -O http://www.sina.com.cn





3. 当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理
curl -x 192.168.2.203:8089 -o home.html https://www.sina.com.cn/

https://www.iteye.com/blog/pgwcumt-1706624
(1)有些网站要求我们使用固定的浏览器进行访问，使用curl同样可以模拟，只需要把浏览器信息加入http request中即可，使用option:-A，
curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 192.168.2.203:8089 -o page.html -D cookie0001.txt http://baidu.com
这样，服务器端接到访问的要求，会认为你是一个运行在Windows 2000上的IE6.0
而"Mozilla/4.73 [en] (X11; U; Linux 2.2; 15 i686"则可以服务端Linux上的Netscape 4.73。


(2)有些网站做了防盗链的处理，就是检查http访问的referer，如果和设定不匹配则不允许访问。curl提供了设定referer的option： -e
curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 192.168.2.203:8089 -e "www.baidu.com" -o page.html -D cookie0001.txt http://baidu.com
这样就是告诉服务器，你是从百度点击某个链接过来的


https://www.cnblogs.com/panxuejun/p/10574038.html
# 指定http代理IP和端口
curl -x 113.185.19.192:80 http://aiezu.com/test.php
curl --proxy 113.185.19.192:80 http://aiezu.com/test.php
 
#指定为http代理
curl -x http_proxy://113.185.19.192:80 http://aiezu.com/test.php
 
#指定为https代理
curl -x HTTPS_PROXY://113.185.19.192:80 http://aiezu.com/test.php
 
#指定代理用户名和密码，basic认证方式
curl -x aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php
curl -x 113.185.19.192:80 -U aiezu:123456 http://aiezu.com/test.php
curl -x 113.185.19.192:80 --proxy-user aiezu:123456 http://aiezu.com/test.php
 
#指定代理用户名和密码，ntlm认证方式
curl -x 113.185.19.192:80 -U aiezu:123456 --proxy-ntlm http://aiezu.com/test.php
 
#指定代理协议、用户名和密码，basic认证方式
curl -x http_proxy://aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php






4. 快速用法（配合sed/awk/grep）
$curl http://mydomain.net

下载保存
$curl http://mydomain.net > index.html
$curl -o index.html http://mydomain.net
$curl -O http://mydomain.net/target.tar.gz

GET
$curl http://www.yahoo.com/login.cgi?user=nickname&password=12345

POST
$curl -d "user=nickname&password=12345" http://www.yahoo.com/login.cgi

POST 文件
$curl -F upload= $localfile  -F $btn_name=$btn_value http://mydomain.net/~zzh/up_file.cgi

通过代理 -x
$curl -x 123.45.67.89:1080 -o page.html http://mydomain.net

保存cookie -D
$curl -x 123.45.67.89:1080 -o page1.html -D cookie0001.txt http://mydomain.net

使用cookie -b
$curl -x 123.45.67.89:1080 -o page1.html -D cookie0002.txt -b cookie0001.txt http://mydomain.net

模仿浏览器 -A
$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -o page.html -D cookie0001.txt http://mydomain.net

伪造referer -e
$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -e"mail.yahoo.com" -o page.html -D cookie0001.txt http://mydomain.net






5. 高级下载功能
循环下载
$curl -O http://mydomain.net/~zzh/screen[1-10].JPG

循环（匹配）下载
$curl -O http://mydomain.net/~{zzh,nick}/[001-201].JPG  # >like zzh/001.JPG

循环（引用）下载
$curl -o #2_#1.jpg http://mydomain.net/~{zzh,nick}/[001-201].JPG # like >001_zzh.jpg

断点续传
$curl -c -O http://mydomain.net/~zzh/screen1.JPG

分块下载
$curl -r  0 -10240  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 10241 -20480  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 20481 -40960  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 40961 - -o  "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3
...
$cat zhao.part* > zhao.mp3







6. curl语法及选项
curl（7.29.0）所支持的选项（options）参数如下
在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP
    --anyauth       选择 "any" 认证方法 (H)
-a, --append        添加要上传的文件 (F/SFTP)
    --basic         使用HTTP基础认证（Basic Authentication）(H)
    --cacert FILE   CA 证书，用于每次请求认证 (SSL)
    --capath DIR    CA 证书目录 (SSL)
-E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL)
    --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL)
    --ciphers LIST  SSL 秘钥 (SSL)
    --compressed    请求压缩 (使用 deflate 或 gzip)
-K, --config FILE   指定配置文件
    --connect-timeout SECONDS  连接超时设置
-C, --continue-at OFFSET  断点续转
-b, --cookie STRING/FILE  Cookies字符串或读取Cookies的文件位置 (H)
-c, --cookie-jar FILE  操作结束后，要写入 Cookies 的文件位置 (H)
    --create-dirs   创建必要的本地目录层次结构
    --crlf          在上传时将 LF 转写为 CRLF
    --crlfile FILE  从指定的文件获得PEM格式CRL列表
-d, --data DATA     HTTP POST 数据 (H)
    --data-ascii DATA  ASCII 编码 HTTP POST 数据 (H)
    --data-binary DATA  binary 编码 HTTP POST 数据 (H)
    --data-urlencode DATA  url 编码 HTTP POST 数据 (H)
    --delegation STRING GSS-API 委托权限
    --digest        使用数字身份验证 (H)
    --disable-eprt  禁止使用 EPRT 或 LPRT (F)
    --disable-epsv  禁止使用 EPSV (F)
-D, --dump-header FILE  将头信息写入指定的文件
    --egd-file FILE  为随机数据设置EGD socket路径(SSL)
    --engine ENGINGE  加密引擎 (SSL). "--engine list" 指定列表
-f, --fail          连接失败时不显示HTTP错误信息 (H)
-F, --form CONTENT  模拟 HTTP 表单数据提交（multipart POST） (H)
    --form-string STRING  模拟 HTTP 表单数据提交 (H)
    --ftp-account DATA  帐户数据提交 (F)
    --ftp-alternative-to-user COMMAND  指定替换 "USER [name]" 的字符串 (F)
    --ftp-create-dirs  如果不存在则创建远程目录 (F)
    --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F)
    --ftp-pasv      使用 PASV/EPSV 替换 PORT (F)
-P, --ftp-port ADR  使用指定 PORT 及地址替换 PASV (F)
    --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F)
    --ftp-pret      在 PASV 之前发送 PRET (drftpd) (F)
    --ftp-ssl-ccc   在认证之后发送 CCC (F)
    --ftp-ssl-ccc-mode ACTIVE/PASSIVE  设置 CCC 模式 (F)
    --ftp-ssl-control ftp 登录时需要 SSL/TLS (F)
-G, --get           使用 HTTP GET 方法发送 -d 数据  (H)
-g, --globoff       禁用的 URL 队列 及范围使用 {} 和 []
-H, --header LINE   要发送到服务端的自定义请求头 (H)
-I, --head          仅显示响应文档头
-h, --help          显示帮助
-0, --http1.0       使用 HTTP 1.0 (H)
    --ignore-content-length  忽略 HTTP Content-Length 头
-i, --include       在输出中包含协议头 (H/F)
-k, --insecure      允许连接到 SSL 站点，而不使用证书 (H)
    --interface INTERFACE  指定网络接口／地址
-4, --ipv4          将域名解析为 IPv4 地址
-6, --ipv6          将域名解析为 IPv6 地址
-j, --junk-session-cookies 读取文件中但忽略会话cookie (H)
    --keepalive-time SECONDS  keepalive 包间隔
    --key KEY       私钥文件名 (SSL/SSH)
    --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL)
    --krb LEVEL     启用指定安全级别的 Kerberos (F)
    --libcurl FILE  命令的libcurl等价代码
    --limit-rate RATE  限制传输速度
-l, --list-only    只列出FTP目录的名称 (F)
    --local-port RANGE  强制使用的本地端口号
-L, --location      跟踪重定向 (H)
    --location-trusted 类似 --location 并发送验证信息到其它主机 (H)
-M, --manual        显示全手动
    --mail-from FROM  从这个地址发送邮件
    --mail-rcpt TO  发送邮件到这个接收人(s)
    --mail-auth AUTH  原始电子邮件的起始地址
    --max-filesize BYTES  下载的最大文件大小 (H/F)
    --max-redirs NUM  最大重定向数 (H)
-m, --max-time SECONDS  允许的最多传输时间
    --metalink      处理指定的URL上的XML文件
    --negotiate     使用 HTTP Negotiate 认证 (H)
-n, --netrc         必须从 .netrc 文件读取用户名和密码
    --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数
    --netrc-file FILE  设置要使用的 netrc 文件名
-N, --no-buffer     禁用输出流的缓存
    --no-keepalive  禁用 connection 的 keepalive
    --no-sessionid  禁止重复使用 SSL session-ID (SSL)
    --noproxy       不使用代理的主机列表
    --ntlm          使用 HTTP NTLM 认证 (H)
-o, --output FILE   将输出写入文件，而非 stdout
    --pass PASS     传递给私钥的短语 (SSL/SSH)
    --post301       在 301 重定向后不要切换为 GET 请求 (H)
    --post302       在 302 重定向后不要切换为 GET 请求 (H)
    --post303       在 303 重定向后不要切换为 GET 请求 (H)
-#, --progress-bar  以进度条显示传输进度
    --proto PROTOCOLS  启用/禁用 指定的协议
    --proto-redir PROTOCOLS  在重定向上 启用/禁用 指定的协议
-x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理
    --proxy-anyauth 在代理上使用 "any" 认证方法 (H)
    --proxy-basic   在代理上使用 Basic 认证  (H)
    --proxy-digest  在代理上使用 Digest 认证 (H)
    --proxy-negotiate 在代理上使用 Negotiate 认证 (H)
    --proxy-ntlm    在代理上使用 NTLM 认证 (H)
-U, --proxy-user USER[:PASSWORD]  代理用户名及密码
     --proxy1.0 HOST[:PORT]  在指定的端口上使用 HTTP/1.0 代理
-p, --proxytunnel   使用HTTP代理 (用于 CONNECT)
    --pubkey KEY    公钥文件名 (SSH)
-Q, --quote CMD     在传输开始前向服务器发送命令 (F/SFTP)
    --random-file FILE  读取随机数据的文件 (SSL)
-r, --range RANGE   仅检索范围内的字节
    --raw           使用原始HTTP传输，而不使用编码 (H)
-e, --referer       Referer URL (H)
-J, --remote-header-name 从远程文件读取头信息 (H)
-O, --remote-name   将输出写入远程文件
    --remote-name-all 使用所有URL的远程文件名
-R, --remote-time   将远程文件的时间设置在本地输出上
-X, --request COMMAND  使用指定的请求命令
    --resolve HOST:PORT:ADDRESS  将 HOST:PORT 强制解析到 ADDRESS
    --retry NUM   出现问题时的重试次数
    --retry-delay SECONDS 重试时的延时时长
    --retry-max-time SECONDS  仅在指定时间段内重试
-S, --show-error    显示错误. 在选项 -s 中，当 curl 出现错误时将显示
-s, --silent        Silent模式。不输出任务内容
    --socks4 HOST[:PORT]  在指定的 host + port 上使用 SOCKS4 代理
    --socks4a HOST[:PORT]  在指定的 host + port 上使用 SOCKSa 代理
    --socks5 HOST[:PORT]  在指定的 host + port 上使用 SOCKS5 代理
    --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码
    --socks5-gssapi-service NAME  为gssapi使用SOCKS5代理服务名称
    --socks5-gssapi-nec  与NEC Socks5服务器兼容
-Y, --speed-limit RATE  在指定限速时间之后停止传输
-y, --speed-time SECONDS  指定时间之后触发限速. 默认 30
    --ssl           尝试 SSL/TLS (FTP, IMAP, POP3, SMTP)
    --ssl-reqd      需要 SSL/TLS (FTP, IMAP, POP3, SMTP)
-2, --sslv2         使用 SSLv2 (SSL)
-3, --sslv3         使用 SSLv3 (SSL)
    --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL)
    --stderr FILE   重定向 stderr 的文件位置. - means stdout
    --tcp-nodelay   使用 TCP_NODELAY 选项
-t, --telnet-option OPT=VAL  设置 telnet 选项
     --tftp-blksize VALUE  设备 TFTP BLKSIZE 选项 (必须 >512)
-z, --time-cond TIME  基于时间条件的传输
-1, --tlsv1         使用 => TLSv1 (SSL)
    --tlsv1.0       使用 TLSv1.0 (SSL)
    --tlsv1.1       使用 TLSv1.1 (SSL)
    --tlsv1.2       使用 TLSv1.2 (SSL)
    --trace FILE    将 debug 信息写入指定的文件
    --trace-ascii FILE  类似 --trace 但使用16进度输出
    --trace-time    向 trace/verbose 输出添加时间戳
    --tr-encoding   请求压缩传输编码 (H)
-T, --upload-file FILE  将文件传输（上传）到指定位置
    --url URL       指定所使用的 URL
-B, --use-ascii     使用 ASCII/text 传输
-u, --user USER[:PASSWORD]  指定服务器认证用户名、密码
    --tlsuser USER  TLS 用户名
    --tlspassword STRING TLS 密码
    --tlsauthtype STRING  TLS 认证类型 (默认 SRP)
    --unix-socket FILE    通过这个 UNIX socket 域连接
-A, --user-agent STRING  要发送到服务器的 User-Agent (H)
-v, --verbose       显示详细操作信息
-V, --version       显示版本号并退出
-w, --write-out FORMAT  完成后输出什么
    --xattr        将元数据存储在扩展文件属性中
-q                 .curlrc 如果作为第一个参数无效






https://www.jianshu.com/p/07c4dddae43a



========================================
|-- 如何查看实时网速？
----------------------------------------
1. 推荐工具：nload
ubuntu的安装可以使用apt进行，apt-get install nload 

其他系统安装过程如下
wget http://www.roland-riegel.de/nload/nload-0.7.2.tar.gz
tar zxvf nload-0.7.2.tar.gz
cd nload-0.7.2
./configure;make;make install

安装完成后，直接用nload （也可后面跟上网卡号查看指定网卡号）
-u参数可以指定显示的网速的单位，如nload -u M是以MB为单位，nload -u K是以KB为单位

使用

如何使用 nload 显示当前网络使用量呢？

基本语法是：
nload
nload device
nload [options] device1 device2

键入下列命令：
$ nload
$ nload eth0
$ nload em0 em2

会得到输出：

操控 nload 应用程序

nload 命令一旦执行就会开始监控网络设备，你可以使用下列快捷键操控 nload 应用程序。

你可以按键盘上的 ← → 或者 Enter/Tab 键在设备间切换。
按 F2 显示选项窗口。
按 F5 将当前设置保存到用户配置文件。
按 F6 从配置文件重新加载设置。
按 q 或者 Ctrl+C 退出 nload。
设置显示刷新间隔

默认每 100 毫秒刷新一次显示数值，下面的例子将时间间隔设置成 500 毫秒：

$ nload -t {interval_number_in_millisec}
$ nload -t 500
输出：



2.
# sar -n DEV 1 100 

1代表一秒统计并显示一次 
100代表统计一百次 
使用ntop等工具，就更方便简单了，不过这个更灵活

P.S.  sar在sysstat包

http://www.cnblogs.com/eshizhan/archive/2012/04/11/2441644.html



3.
查看流量 watch -n 1 "/sbin/ifconfig eth0 | grep bytes"
http://blog.csdn.net/blade2001/article/details/7070591





========================================
|-- 如何监控主机的资源(CPU、内存、网络)使用情况 //todo
----------------------------------------
1.监视CPU，可以使用top的空闲idle百分比看，越小表示主机越忙。
$ top -d 10 |grep Cpu  #-d指定多久记录一次
%Cpu(s):  2.1 us,  0.6 sy,  0.0 ni, 96.8 id,  0.4 wa,  0.0 hi,  0.0 si,  0.0 st




2.可视化，定期调用R刷新image。




========================================
|-- 使用linux检查端口是否畅通 telnet 10.20.66.37 8090
----------------------------------------
在linux下，我们就直接可以用telnet命令来测试端口是否畅通。具体用法：telnet 指定的IP或者 域名 端口号.

比如：telnet 10.20.66.37 8090



1. 不能访问的端口。因为根本没设置过这些端口。
## 0.不能访问的端口
$ telnet y.biomooc.com 7071
Trying 10.20.46.143...
telnet: connect to address 10.20.46.143: Connection refused

$ telnet y.biomooc.com 443
Trying 10.20.46.143...
telnet: connect to address 10.20.46.143: Connection refused




2.可以正常访问的端口，都有具体的服务。
## 1. mysql端口
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
Connection closed by foreign host.


## 2. flask的web端口
$ telnet y.biomooc.com 8000
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

Connection closed by foreign host.


## 3. nginx端口
$ telnet y.biomooc.com 80
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
## ctrl+C
^CConnection closed by foreign host.


## 5. jupyter 端口
$ telnet y.biomooc.com 7000
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

HTTP/1.1 400 Bad Request

Connection closed by foreign host.



## 6. Rstudio端口
$ telnet y.biomooc.com 8787
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

HTTP/1.1 400 Bad Request
Date: Thu, 05 Dec 2019 02:27:30 GMT
Connection: close
Server: RStudio

Connection closed by foreign host.


3.
综上，只要出现 Escape character is '^]'. 这一行，就表示这个端口可以正常访问。





========================================
用iptables搭建一套强大的安全防护盾
----------------------------------------
http://blog.chinaunix.net/uid-26495963-id-3279216.html

1.什么是iptables
常见于linux系统下的应用层防火墙工具。

常用人员：
	系统管理人员、网络工程人员、安全人员等。


2.场景：模拟用iptables控制并发的http访问

目标机器：IP2	json233
客户端机器：IP1	json232

场景描述：
IP1(通过ab命令) -> IP2(http服务)

需要虚拟机配合测试。
未完待续。


参考资料
http://www.imooc.com/learn/389

详情参考本博客： Linux/网络与iptables


========================================
|-- iptables安全防护盾
----------------------------------------
1.
定义：iptables是常见的应用于linux下的应用层防火墙工具。
常用人员：系统管理人员、网络工程人员、安全人员等等。
视频：http://www.imooc.com/learn/389
	http://www.imooc.com/search/?words=iptables

2.场景：模拟用iptables控制并发的http访问。
ab命令通过100(win7)机器访问117(CentOS6.5)http服务.

(1)启动http服务
[wangjl@NGSL ~]$ sudo /etc/init.d/httpd status
httpd (pid  3756) is running...
##关掉防火墙
$ sudo service iptables stop
##写入http文件
# cd /var/www/html/
# cat >test.txt
test
访问]http://192.168.1.117/test.txt
可以看到文字：test

(2)win7客户端开始并发访问
使用apache的ab工具做压力测试。
I:\xampp\apache\bin>ab
ab: wrong number of arguments
Usage: ab [options] [http://]hostname[:port]/path

#-n总请求数，-c每次并发的数量。
I:\xampp\apache\bin>ab -n 100000 -c 40 http://192.168.1.117/test.txt

(3)赶快查看服务端的压力和连接数
$ netstat -an|grep 80|grep 192.168.1.100|grep EST -c
31
$ w
 12:35:08 up  4:37,  4 users,  load average: 6.39, 2.70, 1.18

而静息状态下，这两个参数分别是：
$ netstat -an|grep 80|grep 192.168.1.100|grep EST -c
0
$ w
 12:42:18 up  4:44,  4 users,  load average: 0.05, 0.68, 0.76


(4)在服务端控制并发
如果想控制一下这些高并发，可以使用iptables工具在服务端设置
# iptables -I INPUT -p tcp --dport 80 -s 192.168.1.100 -m connlimit --connlimit-above 10 -j REJECT

客户端再次并发访问：
>ab -n 100000 -c 40 http://192.168.1.117/test.txt
直接报错，而-c修改为5的时候就正常了。







3.学习iptables的意义
1）如何用iptables搭建一套实际使用的防火墙；
2）如何用iptables进行防攻击；
3）如何利用iptables进行数据包转发；
4）明白iptables的强大及实际使用的意义。


4.Netfilter
Netfilter是linux操作系统核心层内部的一个数据包处理模块；
什么是Hook point？数据包在Netfilter中的挂载点共5个(防火墙“四表五链”中的五链)：
	PRE_ROUTING/ INPUT/ OUTPUT/ FORWARD/ POST_ROUTING

用户层的iptables命令是调用内核层的Netfilter，通过挂载点Hook point操作数据包的。

这5个钩子函数，用来抓取数据包，并把数据包的信息拿来匹配各个链位置在对应表中的规则，匹配之后，进行对应的accept、drop等。





5.iptables规则组成 
(1)组成部分：四张表 + 五条链 +规则
四张表table(保存规则)：filter表、nat表、 mangle表、raw表
五条链chain(钩子位置)：进路由之前PREROUTING/ 进系统INPUT/ 转发FORWARD/ 出系统OUTPUT/  出路由(发送到网卡之前)POSTROUTING


(用户层) 应用层 |  iptables命令
___________________________________
(内核层)
传输层：TCP UDP  | Filter表  NAT表  Mangle表
网络层   | NetFilter
网络接口层 | 


1)表就是存储的规则；数据包到了该链处，会去对应表中查询设置的规则，然后决定是否放行、丢弃、转发还是修改等等操作。

如果要访问某台主机上面的http服务，必须先经过那台主机的内核允许，才可以进行访问
防火墙其实也是在内核上面开启的一个服务。防火墙里面有表格，写一些规则，允许哪个主机访问什么服务，这个表格由iptables进行控制
有两种规则：iptables 与 firewalld 
第一张表：filter表：放的是经过内核的ip,可使用的链：  input output forward 
第二张表：nat表：放的不是经过内核的服务，可使用的链： input output postrouting prerouting 
第三张表：备用表格mangle：可使用的链： input output forward postrouting prerouting


表名称/	功能/	内核模块
filter/	负责过滤功能，防火墙/	iptables_filter
nat(Network Address Translation)/	网络地址转换/	iptables_net
mangle/	拆解报文，修改，重新封装/	iptables_mangle
	mangle表：修改数据包，改变包头中的内容（TTL, TOS, MARK）
raw表：关闭nat表上启用的链接追踪机制


最常用的表是： filter表（访问控制）和nat（转发）表。
Filter表：用来处理是否放行
NAT表：实现数据包转发，修改源地址 端口 目标地址 端口，实现地址转换


2)
PREROUTING是不经过内核路由之前的信息
INPUT和OUTPUT均包括经过内核和不经过内核的信息
FORWARD是经过内核的路由转发信息
POSTROUTING是不经过内核路由之后的信息






(2)iptable规则的组成

数据包访问控制： ACCEPT、DROP、REJECT
数据包改写：SNAT、DNAT
信息记录：LOG

DROP没有返回消息，而REJECT给客户端有返回消息。
SNAT是对发起端地址改写，DNAT对目标地址改写。


iptables命令常用方法: 
iptables [-p table] 链管理 chain
-t table : filter,nat,mangle,raw (默认为 filter)

链管理：
-F : 清空规则链
-N：创建新的自定义规则链
-X : drop 删除用户自定义的规则链
-P : Policy 为指定链设置默认策略；iptables -t filter -P FORWARD DROP
	-P设置默认iptables规则。
-E：重命令自定义链


规则管理：
-A在末尾添加规则。
-I在开头插入规则。
-D删除规则
-R：替代指定链上的规则

查看：
-L：列表，列出指定链上的指定的规则
-n -v –line-numbers -x 等参数
-L和-n一般连用。


匹配条件 - 基本匹配：
-s 原地址IP。-s 发起源有哪些
-d 目的IP。-d 目标地址
-p 协议{tcp|udp|icmp}。-p 连接类型
-i 数据报文的流入接口
-o 数据报文的流出接口

匹配条件 - 扩展匹配：-m match_name
-m 在原有基础上做个补充，tcp, state, multiport
--dport PORT:目标端口，可以是单个端口
--dports 端口段
--sport PORT:源端口
-p udp|tcp|icmp
–icmp-type
0 : echo-reply
8 : echo-request

目标：
-j TARGET：jump至指定的TARGET
- ACCEPT 接受
- DROP 丢弃
- REJECT 拒绝访问
- RETURN 返回调用链






2)防火墙常用的行为动作
动作	说明
ACCEPT	允许数据包通过
DROP	直接丢弃数据包，不给任何回应，此时客户端会不停地去向服务器发送数据包，发送超时才会有反应
REJECT	拒绝数据包通过，必要时会给数据发送端一个响应信息，如果客户端的请求被拒绝，就会收到拒绝的信息
SNAT	源地址转换，解决内网用户用同一个公网地址上网的问题
MASQUERADE	是SNAT的一种特殊形式，适用于动态的，临时会变的ip上
DNAT	目的地址转换



refer:
https://blog.csdn.net/u011456940/article/details/52634184



========================================
|-- iptables配制-场景1 (查看端口、开闭端口)
----------------------------------------
规则1：对所有的地址开放本机的tcp（80、22、10-21）端口的访问；
规则2：允许对所有的地址开放本机的基于ICMP协议的数据包的访问。
规则3：其他未被允许的端口则禁止访问。

服务端查看所有开放端口：
$ netstat -luntp
$ iptables --version
iptables v1.4.7


#-L列出之前设置过的iptables规则
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination




$ sudo iptables -nL #-n是数字化显示主机ip和端口号

$ iptables -F # -F更新为新的规则，如果没有新规则，相当于逐条删除已有规则。
 -F, --flush [chain]   Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the  rules  one  by one.

（1）设置新的规则
# iptables -I INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口
# iptables -I INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口: ssh。一定要允许，否则服务器失控。
# iptables -I INPUT -p tcp --dport 10:21 -j ACCEPT
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere            tcp dpts:10:ftp
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:http

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination









设置规则2：
# iptables -I INPUT -p icmp -j ACCEPT

设置规则3的拒绝：
# iptables -A INPUT -j REJECT
## -A表示是追加到末尾。

$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-port-unreachable

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

$ netstat -lntp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:631               0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:42712               0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:25                0.0.0.0:*                   LISTEN      -
tcp        0      0 :::111                      :::*                        LISTEN      -
tcp        0      0 :::80                       :::*                        LISTEN      -
tcp        0      0 :::22                       :::*                        LISTEN      -
tcp        0      0 ::1:631                     :::*                        LISTEN      -
tcp        0      0 ::1:25                      :::*                        LISTEN      -
tcp        0      0 :::44731                    :::*                        LISTEN      -


使用一个Ubuntu机器上的端口扫描工具：
$ sudo apt install nmap
$ sudo nmap -sS -p 0-1000 192.168.1.117
Starting Nmap 7.01 ( https://nmap.org ) at 2017-09-07 15:28 CST
Nmap scan report for bogon (192.168.1.117)
Host is up (0.00030s latency).
Not shown: 987 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed unknown
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
80/tcp open   http
MAC Address: 08:00:27:59:54:C6 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 23.94 seconds








（2）在服务器上删除一条80端口的访问规则：
 # iptables -D INPUT -p tcp --dport 80 -j ACCEPT

在Ubuntu上扫描该服务器端口，发现80端口已经不能外部访问了。
~$ sudo nmap -sS -p 0-1000 192.168.1.117
Starting Nmap 7.01 ( https://nmap.org ) at 2017-09-07 15:32 CST
Nmap scan report for bogon (192.168.1.117)
Host is up (0.00035s latency).
Not shown: 988 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed unknown
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
MAC Address: 08:00:27:59:54:C6 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 23.06 seconds








（3）如果服务器上明确禁止访问80端口呢？
$ sudo iptables -I INPUT -p tcp --dport 80 -j REJECT
查看现有规则：
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80 reject-with icmp-port-unreachable
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-port-unreachable

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination


在其他机器上扫描的结果：
$ sudo nmap -sS -p 0-1000 192.168.1.117
Starting Nmap 7.01 ( https://nmap.org ) at 2017-09-07 17:21 CST
Nmap scan report for bogon (192.168.1.117)
Host is up (0.00049s latency).
Not shown: 988 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed unknown
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
MAC Address: 08:00:27:59:54:C6 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 21.87 seconds

和上一个一样，80端口看不到状态，也就是不能访问。




（4）以上设置iptables对本机访问有什么不良影响？

在服务器上看，80端口对本地是开放的
$ netstat -lntp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:631               0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:42712               0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:25                0.0.0.0:*                   LISTEN      -
tcp        0      0 :::111                      :::*                        LISTEN      -
tcp        0      0 :::80                       :::*                        LISTEN      -
tcp        0      0 :::22                       :::*                        LISTEN      -
tcp        0      0 ::1:631                     :::*                        LISTEN      -
tcp        0      0 ::1:25                      :::*                        LISTEN      -
tcp        0      0 :::44731                    :::*                        LISTEN      -


问题1：本机不能访问本机
$ ssh wangjl@127.0.0.1
一直连接中...
也就是外网可以访问，但是本机不能访问本机的22端口（回环地址）。

解决方法：如要对回环网卡lo做允许。
# iptables -I INPUT -i lo -j ACCEPT #允许所有数据包通过lo网卡。

[!] -i, --in-interface name
              Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains).  When the "!" argument is used before the interface name, the sense is inverted.  If the interface name ends in a "+", then any interface which begins with this name will match.  If this option is omitted, any interface name will match.


再用ssh登陆自己就可以了。
$ ssh wangjl@127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
RSA key fingerprint is 8d:96:7a:f8:9f:0b:3e:e1:e5:49:dc:70:dd:89:8c:57.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '127.0.0.1' (RSA) to the list of known hosts.
wangjl@127.0.0.1's password:
Last login: Fri Aug 19 12:23:24 2016 from 192.168.1.100



问题2：本机不能访问其他主机
$ wget http://www.imooc.com/
--2016-08-19 14:05:39--  http://www.imooc.com/
Resolving www.imooc.com...
一直连接不上。

对已经建立的监听，设置允许
# iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

match = -m matchname [per-match-options]
state: This module, when combined with connection tracking, allows access to the connection tracking state for this packet.
      [!] --state state
       Where  state  is  a comma separated list of the connection states to match.  Possible states are INVALID meaning that the packet could not be identified for some reason which includes running out of memory and ICMP errors which don’t correspond to any known connection,  ESTABLISHED  meaning that the packet is associated with a connection which has seen packets in both directions, NEW meaning that the packet has started a new connection, or otherwise associated with a connection which has not  seen  packets  in both  directions,  and  RELATED meaning that the packet is starting a new connection, but is associated with an existing connection, such as an FTP data transfer, or an ICMP error.




再访问外网就正常了。
$ wget http://www.imooc.com/
--2016-08-19 14:14:42--  http://www.imooc.com/
Resolving www.imooc.com... 117.121.101.40, 117.121.101.41, 115.182.41.180
Connecting to www.imooc.com|117.121.101.40|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: “index.html”

    [  <=>                            ] 220,830      534K/s   in 0.4s

2016-08-19 14:14:43 (534 KB/s) - “index.html” saved [220830]

$ curl -I http://imooc.com
返回消息头。


（5）只允许IP为具体值的主机访问httpd服务
删除这条拒绝所有人访问的规则
$ sudo iptables -D INPUT -p tcp --dport 80 -j REJECT

允许-s源机器IP访问
$ sudo iptables -I INPUT -p tcp -s 192.168.1.110 --dport 80 -j ACCEPT

在110上访问目标主机
$ curl -I http://192.168.1.117/
HTTP/1.1 403 Forbidden
Date: Fri, 19 Aug 2016 06:40:02 GMT
Server: Apache/2.2.15 (CentOS)
Accept-Ranges: bytes
Content-Length: 4961
Connection: close
Content-Type: text/html; charset=UTF-8

换个115的主机:
$ curl http://192.168.1.117
curl: (7) Failed to connect to 192.168.1.117 port 80: Connection refused

说明只允许110访问设置成功了。





iptables配制-场景2
ftp主动模式和被动模式下的设置。http://www.imooc.com/video/7609




========================================
|-- Ubuntu中iptables常用设置
----------------------------------------
1. 关闭防火墙
$ sudo ufw disable
Firewall stopped and disabled on system startup


多用几次，就完全清除了规则
$ iptables -F  # -F更新为新的规则，如果没有新规则，相当于逐条删除已有规则。
-F, --flush [chain]   Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the  rules  one  by one.


$ iptables -nL #查看规则







========================================
|-- CentOS6中iptables常用设置
----------------------------------------

1.在Linux中设置防火墙，以CentOS为例，打开iptables的配置文件：
$ sudo vim /etc/sysconfig/iptables
# Firewall configuration written by system-config-firewall
# Manual customization of this file is not recommended.
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT



修改vi /etc/sysconfig/iptables命令添加使防火墙开放80端口
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  

2.关闭/开启/重启防火墙
 $ sudo /etc/init.d/iptables start 
iptables: Applying firewall rules:                         [  OK  ]
 $ sudo /etc/init.d/iptables stop
 $ sudo /etc/init.d/iptables restart 


3.永久性关闭防火墙
    chkconfig --level 35 iptables off     
    /etc/init.d/iptables stop  
    iptables -P INPUT DROP  


4.打开主动模式21端口
    iptables -A INPUT -p tcp --dport 21 -j ACCEPT  
     
5.打开被动模式49152~65534之间的端口
    iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT  
    iptables -A INPUT -i lo -j ACCEPT  
    iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT  

$ ~$ iptables -h
查找参数意义。


注意：
一定要给自己留好后路,留VNC一个管理端口和ssh的管理端口。
需要注意的是，你必须根据自己服务器的情况来修改这个文件。
全部修改完之后重启iptables: service iptables restart
你可以验证一下是否规则都已经生效：iptables -L或者iptables -nL



========================================
|-- CentOS7中iptables常用设置
----------------------------------------
https://blog.csdn.net/qzc70919700/article/details/79784566

#查看规则
sudo iptables -L -n --line-numbers |less


#插入规则，插入第一条
# sudo iptables -I INPUT -p tcp --dport 10007 -j ACCEPT


删除规则
# sudo iptables -D INPUT -p tcp --dport 10007 -j ACCEPT
// 把第一条规则删除
# sudo iptables -D INPUT 1 




========================================
centOS7 中的防火墙
----------------------------------------
Linux中存在iptables和firewalld两种防火墙
iptables：更接近数据的原始操作，精度更高
firewalld：更易操作




1.查看防火墙状态 systemctl status firewalld

开启防火墙 systemctl start firewalld  
关闭防火墙 systemctl stop firewalld
开启防火墙 service firewalld start 
若遇到无法开启
先用：systemctl unmask firewalld.service 
然后：systemctl start firewalld.service


关闭防火墙
如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估
systemctl stop firewalld.service


systemctl disable firewalld.service #禁止firewall开机启动

firewall-cmd --state ##查看默认防火墙状态（关闭后显示notrunning，开启后显示running）



2.查看对外开放的端口状态
查询已开放的端口 netstat -anp
查看监听的端口 netstat -lnpt

查询指定端口是否已开 firewall-cmd --query-port=10007/tcp
提示 yes，表示开启；no表示未开启。

firewall-cmd --list-ports ##查看已经开放的端口
firewall-cmd --zone=public --list-ports ##查看防火墙所有开放的端口





3.开启端口
firewall-cmd --zone=public --add-port=10007/tcp --permanent   # 开放端口
firewall-cmd --zone=public --remove-port=10007/tcp --permanent  #关闭端口
firewall-cmd --reload   # 配置立即生效
命令含义：
–zone #作用域
–add-port=80/tcp #添加端口，格式为：端口/通讯协议
–permanent #永久生效，没有此参数重启后失效


firewall-cmd --get-active-zones #运行完成之后，可以看到zone名称
## public
##  interfaces: em1



4.杀掉占用端口的进程

检查端口被哪个进程占用 sudo netstat -lnpt |grep 10007
tcp        0      0 10.20.57.27:10007       0.0.0.0:*               LISTEN      115213/python

查看进程的详细信息 ps 115213
115213 pts/22   S+     0:01 /home/hou/anaconda3/bin/python /home/hou/anaconda3/bin/jupyter-notebook --no-browser --port 10007 --ip=10.20.57.27

中止进程
kill -9 115213




5.查看端口是否开启
win下 > telnet  192.168.xx.xx 6379
linux下 $ sudo nmap -sS -p 0-1000 192.168.xx.xx


6.firewalld的域，类似于win的组概念
trusted 信任： 可接受所有网络连接
home 家庭：用于家庭网络，仅接受ssh/mdns/ipp-client/samba-client/dhcpv6-client服务连接
internal 内部：用于内部网络，仅接受ssh/mdns/ipp-client/samba-client/dhcpv6-client服务连接
work 工作：用于工作区，仅接受ssh/ipp-client或dhcpv6-client服务连接
public 公共：在公共区域呢使用，仅接受ssh/dhcpv6-client服务连接，为firewalld的默认区域
external 外部：出去的ipv4网络连接通过此区域伪装和转发，仅接受ssh服务连接
dmz 非军事区：仅接受ssh服务连接
block 限制：拒绝所有网络连接
drop 丢弃：任何接收的网络数据包都被丢弃，没有任何回复




refer:
https://blog.csdn.net/qq_28426351/article/details/52249710
https://blog.csdn.net/weixin_44224288/article/details/88136383





========================================
通信安全与gpg加密
----------------------------------------

1.对称加密和解密
这里，先简单介绍使用gpg进行对称加密和解密，后面重点介绍公钥加密和数字验证。 
*对称加密myfile： 
$ gpg -c myfile 
这样，会提示你输入两次密码，然后生成myfile的加密文件myfile.gpg,注意不能对目录加密,可以用-o选项指定输出文件名称。 


解密对称加密的文件： 
$ gpg -o mydecrypt -d myfile.gpg 
这样，会提示你输入解密密码，输入之后，将会解密相应的文件，通过-o指定生成的解密文件，-d指定被解密过的文件。 





2.非对称加密（也叫公钥加密）

(1)生成钥匙对： 
$ gpg --gen-key 
## gpg (GnuPG) 2.2.4; Copyright (C) 2017 Free Software Foundation, Inc.
输入姓名和邮箱，设置密码后产生key。 

gpg: /home/wangjl/.gnupg/trustdb.gpg: trustdb created
gpg: key 600247CD2973A676 marked as ultimately trusted
gpg: directory '/home/wangjl/.gnupg/openpgp-revocs.d' created
gpg: revocation certificate stored as '/home/wangjl/.gnupg/openpgp-revocs.d/F5369AFE4166801E40B2B9B8600247CD2973A676.rev'
public and secret key created and signed.

pub   rsa3072 2019-06-13 [SC] [expires: 2021-06-12]
      F5369AFE4166801E40B2B9B8600247CD2973A676
uid                      XXX <jXXXl@XX.com>
sub   rsa3072 2019-06-13 [E] [expires: 2021-06-12]


这里，首先要一个钥匙对才能公钥加密，这里根据系统情况不同，可能内容为英文。需要用户交互输入的地方，都通过"<====输入"这个标记指出来了。若对输入信息有所改动 ,可把 ~/.gnupg 目录下除 options 以外的文件删除 ,再运行 gpg --gen-key 命令 ,或者使用 gpg 的 edit 选项 .  钥匙对放在 ~/.gnupg 目录下 . 






(2)查看已有的钥匙： 
$ gpg --list-keys 

/home/wangjl/.gnupg/pubring.kbx
---- ---- ---
pub   rsa3072 2019-06-13 [SC] [expires: 2021-06-12]
      F5369AFE4166801E40B2B9B8600247CD2973A676
uid           [ultimate] XXX <jXXXl@XX.com>
sub   rsa3072 2019-06-13 [E] [expires: 2021-06-12]

这里， 
pub(公匙)
sub(私匙)







(3)使用gpg密钥进行加密和解密文件
1)查看要加密的文件
$ cat note.txt 
We'll meet on the 1st day next month at Water Gate.
Tom
2019.6.13


2)加密文件
$ gpg -ea -r XXX note.txt 

这里的XXX就是前面设置的你的名字。我们可以使用"gpg --list-keys"来查看我们可以选择用来加密的公钥。
选项"-e"实际就是"--encrypt"表示加密数据
"-a"表示创建ASCII的输出(可以不用这个选项,这样生成的文件就不是ASCII的内容了，并且文件后缀是*.gpg)
"-r"指定加密的用户id名称。 

3) 查看加密之后的文件： 
$ ls -l
total 4632
-rw-rw-r-- 1 wangjl wangjl      66 Jun 13 19:40 note.txt
-rw-rw-r-- 1 wangjl wangjl     785 Jun 13 19:43 note.txt.asc #文件增大了十倍。

$ cat note.txt.asc 
-----BEGIN PGP MESSAGE-----

hQGMA/s5kKzjTDH9AQwAnG6sIAxucafO8lNJkyUtZaEK4ROyMPMU3T71/6gZ1saf
T0a/zztIgPdmuTO01dtSXcuXcjygrdRN3Bt8Mdjg5zH2sfnZqBV/nT3AlvFDzgjV
NrnJ/uOJA6GlnA6F9zIzrvLg7R9B1EYurr/1TrDSKwQJH3ulcxBKCFRGV3Nscqna
LAmZpltC+3ToV7mIgq7RLb6W7vx3pU7iSLFCfNDQaTWyHkIT+XlNcw+xXOF3wphq
d4/awzFOwMX5b+HIakZmjihZUt5LnqXzXxinkA1eeOTmQFJZxlo4zIuQwJoLYkCa
4Q5Xx3t522aEmshQ/sNLyhhMYQscq7/AozL2nBjf8uferbTgY9oYquTDH7u8LOhl
eD30uSHpFFGIZK1Za5PgXsFDtaijklFTaKpCCsT4Ju9SUPFd3M5nNN2McRFG85vO
p/tFGExqzi3iCa/0R754ZHd7eCLQTE6XM+ZK/9PF4GcTIdpc7elRK4eaA4l9mXYL
evplhYMB4MwYCPgCFS0C0oQBBEpB73HfTzSRRL0KF2RUmYjJZ5GJ+IsP/yi3UltQ
7fF1KTqITckduLC2mjfXDXOCMA0+JXoeH9qTt+AjBXh3FkMxZ9/4loKrN+Q1c2yb
Cd2GIbF1ie5fwA1xhTrbI/T8VM8FXfEwYLm95eiyaHpF/oUglBwG6Yl2bLfEG8iH
necgtdQ=
=mPcF
-----END PGP MESSAGE-----


4)公钥解密过程 
$ gpg -o note_2.txt --decrypt note.txt.asc
 -o 指定解密文件名

	x Please enter the passphrase to unlock the OpenPGP secret key:  x
	x "XXX <jXXXl@XXX.com>"  x
	x 3072-bit RSA key, ID FB3990ACE34C31FD,  x #私钥号
	x created 2019-06-13 (main key ID 600247CD2973A676). #主钥号
输入刚才设置的密码，才能解开这个用户的私钥。
gpg: encrypted with 3072-bit RSA key, ID FB3990ACE34C31FD, created 2019-06-13
      "XXX <jXXXl@XXX.com>"

如果不在同一台机器上解密，则需要把本地私钥导出，放到待解密的机器上。
如果想要别人和你使用这个加密的方法通信，需要把你的公钥导出，发给别人，然后他们把这个公钥导入，在使用前面加密的方法用这个公钥加密数据并且发送给你，你再用你自己的私钥解密，得到解密后的原始数据,这也是公钥加密通信使用的常用方法。
后面会详细讲述如何导出本地的公钥和私钥，以及如何在其它机器上面导入之前导出的密钥。 


5)查看解密后的文件
内容是真的一模一样：
$ md5sum note*txt
63adefb2e879374c6ceff5d1d6359a03  note_2.txt
63adefb2e879374c6ceff5d1d6359a03  note.txt


6)导出（备份）公钥： gpg -o keyfilename --export KeyID
$ gpg -o mypubkey --export F5369AFE4166801E40B2B9B8600247CD2973A676 
-o指定生成的导出文件名称，
--export指定想要导出的密钥ID, 如果没有KeyID则是备份所有的公钥.
如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息


导出的公钥，可以发布，其它人只要导入你发布的公钥，就能用这个公钥加密数据并且发送给你，
你再用你自己的私钥解密，得到解密后的原始数据。
这也是公钥加密通信使用的常用方法。 


7)以文本方式导出公钥
$ gpg -o mypubkey2 -a --export F5369AFE4166801E40B2B9B8600247CD2973A676 



8)导出（备份）私钥
$ gpg -o mysubkey --export-secret-keys 600247CD2973A676 
如果没KeyID则是备份所有的私钥，
-o表示输出到文件mysubkey中，
如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息。 

输入密码就可以导出了。
$ ls -l
-rw------- 1 wangjl wangjl 3.7K Jun 13 20:08 mysubkey


9)导入私钥: 
$ gpg --import mysubkey 
gpg: key 600247CD2973A676: "XXX <jXXXl@XXX.com>" not changed
gpg: key 600247CD2973A676: secret key imported
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
gpg:  secret keys unchanged: 1


如果导入公钥命令是一样的，不过指定的文件应该是"mypubkey"了。
这个命令是另外一台机器上运行的，导入私钥之后那个机器就可以使用这个私钥解密数据了。
一般来说我们都是发布公钥让人导入，而不是导入私钥匙。 









(4)签名与验证
签名作用是验证明文、加密文件、密钥是来自正确的发送者的，没经过其它人的修改。签名使用的也是密钥对，与加密操作相同。只是在结果上，点不同。它只是在文件最后添上加密的验证信息（签名）。一旦文件有所改变，签名验证就会出错。

1)查看文件
$ cat note_2.txt
We'll meet on the 1st day next month at Water Gate.
Tom
2019.6.13


2)生成签名
$ gpg -o note_2.txt.sig -s note_2.txt
输入密码，解开私钥，加密获得文件，含有乱码头尾。.sig包含了原文件和签名。
-rw-rw-r-- 1 wangjl wangjl  544 Jun 13 20:17 note_2.txt.sig


产生文本格式的签名 
$ gpg -o note_2.txt.sig2 --clearsign note_2.txt 
该文件上边是原文本信息，下面是ascii码。


3)验证签名
$ gpg --verify note_2.txt.sig2
gpg: Signature made Thu 13 Jun 2019 08:21:20 PM CST
gpg:                using RSA key F5369AFE4166801E40B2B9B8600247CD2973A676
gpg: Good signature from "XXX <jXXXl@XXX.com>" [ultimate] #结论是 完好的签名。

这里，在验证之前，必须导入文件作者的公钥，对于分离式签名最后还要加上原文件参数(后面会讲到)。 


4)将签名文件恢复 
$ gpg -o note_3.txt --decrypt note_2.txt.sig
note_3.txt和原文件完全一样。









(5)签名并加密
$ gpg -o note_decrypt.sig -ser XXX note.txt 
## -rw-rw-r-- 1 wangjl wangjl  991 Jun 13 20:28 note_decrypt.sig

这里，无法直接通过"gpg --verify mydecrypt.sig"对文件mydecrypt.sig进行验证。而是在解密恢复文件的时候直接验证了


2)恢复加密的签名文件

$ gpg -o note_4.txt --decrypt note_decrypt.sig 
输出 Good signature。内容和原文件一样。








(6)分离式签名
$ gpg -o mydecrypt.sig -ab note.txt 
# -rw-rw-r-- 1 wangjl wangjl  659 Jun 13 20:33 mydecrypt.sig
mydecrypt.sig仅包含签名，分离式签名的意思是原文件和签名是分开的。
b选项表示分离式签名detach-sign. 

2)对分离的签名进行验证
$ gpg --verify mydecrypt.sig note.txt 
# Good signature
因为是分离的，所以要指定签名文件和原始文件。






(7)编辑公钥，不知道有啥用？

$ gpg --edit-key someone
someone是别人的用户id,输入之后，出现命令提示符号，进入交互模式。 
>fpr <===输入这个表示查看someone的指纹，核对信息真实性，这样之后签署。 
>sign <===输入这个签署公钥，这样以后再使用它加密的时候不会产生警告了。 
>check <===输入这个，检查someone已有的钥匙的签名。 
>quit <===输入这个，退出交互，可能会提示你保存之前的设置。







参考： 
refer: https://blog.csdn.net/xueye3000/article/details/51691720
http://blog.chinaitlab.com/html/57/340757-64526.html 
http://blog.sina.com.cn/s/blog_44abafb201008zjo.html 
http://wiki.ubuntu.org.cn/GPG/PGP 


白话GPG加密的应用场景、加密通信的理论过程 https://www.jianshu.com/p/671ebeddcf60





========================================
科学上网
----------------------------------------
1.傻瓜代理，一键搞定的；
2.基于hosts文件的；
3.基于VPN的。

推荐1:Lantern蓝灯（据说最近不太能用了） 
推荐2:hosts文件 hosts hosts@github https://github.com/racaljk/hosts



hosts文件的：http://laod.cn/hosts/2016-google-hosts.html
	如果是用linux系统的同学，请修改 /etc/hosts 这个文件。
	修改hosts后生效的方法：$ sudo rcnscd restart


（一般这些网站都是SSL加密链接）如谷歌学术：https://scholar.google.com/
https://www.google.com/ncr 方式访问，禁止国别跳转



科学上网工具大推荐[10151224更新Android]
https://www.bennythink.com/scientific-internet-tools-recommended.html



Lantern：官方译名蓝灯，基于P2P原理的工具。我更喜欢称之为拉登，本拉登的那个拉登。
安装即可使用。
监听端口为8787。
GitHub项目地址：https://github.com/getlantern/lantern
主页：https://getlantern.org/



VPNGate：日本筑波大学开发的分布式VPN，想要封只能靠DPI（深度包检测）了。选择服务器的技巧：运行时间比较短的日韩服务器。
监听端口为：VPN没有监听端口？又不是本地代理
主页：http://www.vpngate.net/cn/
PS，有个很好玩的现象，为啥韩国和中国的流量排名超靠前呢？这说明我们中国网民都在使用韩国人民开的VPN啊。
http://www.ll00.cn/network/vpngate.php









BreakWall:首页
https://wiki.yoitsu.moe/wiki/BreakWall:%E9%A6%96%E9%A1%B5

	chrome hosts:
	Shadow socks
	
	tor加网桥上socks4过墙再想其他的
#


========================================
|-- 纸飞机上谷歌查论文: 搭建ShadowSocks 服务
----------------------------------------

纸飞机看谷歌: 搭建ShadowSocks 服务。
官网 https://github.com/shadowsocks/shadowsocks/tree/master



1. VPS安装ShadowSocks
wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2>&amp;1 | tee shadowsocks-all.log

## 选择脚本（Python、R、Go、libev），任选一个：
## 输入密码和端口，笔者直接回车用默认
## 安装成功后，命令行出现：
Congratulations, Shadowsocks-Go server install completed!
Your Server IP        :  45.32.73.59
Your Server Port      :  8989
Your Password         :  teddysun.com
Your Encryption Method:  aes-256-cfb

Welcome to visit: https://teddysun.com/486.html
Enjoy it!
（如果安装失败，请尝试其他脚本）

不用启动，已经启动过了。
	sudo ssserver -p 7878 -k password -m rc4-md5 -d start
	sudo ssserver -p 20180 -k v123456 -m rc4-md5 -d start
#


低配版: https://www.daozhao.com/3202.html
git clone https://github.com/madeye/shadowsocks-libev.git


(2)如何暂停和重启？
$ ps -aux | grep sha
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root     34303  0.0  3.2  58060 13704 ?        Ss   07:53   0:00 /usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks-python/config.json -d start


Shadowsocks-Python 版：(推荐这个，可以查状态)
/etc/init.d/shadowsocks-python start | stop | restart | status


ssserver -d start/stop/restart  # daemon mode

ssserver -c /etc/shadowsocks.json -d start



(3)修改端口等
先暂停，修改后再启动
vim  /etc/shadowsocks.json



(4)设置开机启动
#vi /etc/rc.local    （加入以下一行命令）
ssserver -c /etc/shadowsocks.json -d start






2. Shadowsocks客户端
Shadowsocks官网 windows客户端下载：https://github.com/shadowsocks/shadowsocks-windows/releases

打开，输入服务器ip、端口、密码：

Shadowsocks windows客户端
把刚才安装Shadowsocks脚本成功后，输出的信息填上去：




3.一旦被墙了,该如何解决呢

怕vps被墙，现在都不敢登录ssh了，怎么破？

我改了端口号，证书登录。linode用了两年多，从未被墙
估计强是判断流量的，单纯ssh操作应该不会有问题，如果做端口转发，流量大了就不好说了


方法1 被动的处理: 被墙后,需要停止VPS , 几天或几周后 可能会自动解禁


墙有两百种阻断方式，一种是TCP阻断，一种是ICMP阻断。Ping命令走的是ICMP协议，而SHH连接的时候是TCP协议。你出现能ping通，ssh却连不上的这种情况时，就是ICMP包被放行了，而TCP包却被拦截了，这就是TCP阻断，也是目前封禁比较常用的方法，让你端口用不了问。另外也有专门针对某一个指定端口的封禁。这时候ping也是没问题的，但是无法连接指定端口。


遇到GFW谁也没办法: https://blog.csdn.net/chenggong2dm/article/details/6706370



(1)停掉ss
ssserver -d stop

/etc/init.d/shadowsocks-python stop
/etc/init.d/shadowsocks-python status

怎么关掉开机启动？
https://blog.csdn.net/qq_14989227/article/details/79227283


service ipstable stop





(3) 不用bash了，用mosh
远程和本地都安装mosh。
sudo apt-get install mosh


ref: 
http://www.itucd.com/archives/1287
https://www.hinwen1.com/31972.html
https://zhuanlan.zhihu.com/p/113906130 如何使用客户端。




========================================
|-- 修改ssh端口号
----------------------------------------
1. Linux中SSH默认端口为22，为了安全考虑，我们有必要对22端口进行修改，现修改端口为60000；

修改方法如下：
在/etc/ssh/sshd_config中找到Port 22，将其修改为60000,或使用/usr/sbin/sshd -p 60000指定端口。

如果用户想让22和60000端口同时开放，只需在/etc/ssh/sshd_config增加一行内容如下：
$ sudo vim /etc/ssh/sshd_config
Port 22
Port 60000
保存并退出

重启ssh服务:
$ sudo service ssh restart
或者 /etc/init.d/ssh restart

ssh user@ip -P 60000 




2.
增加 UseDNS no配置，可以提速。
ref:
解决SSH登录国外VPS连接特别慢的问题
https://www.zhujimi.net/ssh-close-usedns.html






========================================
内网穿透软件natapp
----------------------------------------
需要购买服务（2019年是9元/月）：https://natapp.cn/article/nohup
下文的 authtoken=xxxx 用我的 authtoken=e53b1f66a57d57f9 代替。


1.下载
wget http://download.natapp.cn/assets/downloads/clients/2_3_9/natapp_linux_386_2_3_9.zip

2.解压出natapp文件
unzip natapp_linux_386_2_3_9.zip

3.为natapp文件加可执行权限
chmod +x natapp

4.运行该软件
./natapp -authtoken=xxxx

5.然后把Forwarding行、Linux用户名和密码发给我
Forwarding tcp://server.natappfree.cc:42589 -> 127.0.0.1:22 

6.远程登录方式
ssh username@server.natappfree.cc -p 42589
password




如上直接运行的缺点是,如果关掉窗口,就是关掉了natapp程序,所以会掉线.
建议改为后台运行。


4b. 最好是在tmux中运行。
$ tmux
$ ./natapp -authtoken=xxxx



4c. 后台运行（不推荐）
nohup ./natapp -authtoken=xxxx -log=stdout &
注意一定要加上 -log=stdout

另开一个窗口检查一下
ps -ef|grep natapp
如果要关掉进程，可以用上述命令查看进程号(第二列是pid)，然后kill掉
kill -9 2777

nohup 默认会在当前目录 创建 nohup.out 文件,会记录natapp运行日志,为避免日志过大,可以将日志等级降低 如
nohup ./natapp -authtoken=xxx -log=stdout -loglevel=ERROR &

注意，这样看不到端口号，必须购买natapp的端口号。




========================================
可用的局域网 wifi和密码
----------------------------------------
{
	jinlab:20172017,
	sc_F2: 姓名全拼,
}





========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

