nginx(win + linux)

文档：http://nginx.org/en/docs/

nginx的优势是处理静态请求，cpu内存使用率低，
apache适合处理动态请求，
所以现在一般前端用nginx作为反向代理抗住压力，apache作为后端处理动态请求。


一键安装包：https://github.com/lj2007331/oneinstack
win下nginx很多功能用不成，强烈推荐在linux下运行nginx。


agentzh 的 Nginx 教程（版本 2016.07.21）
https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html


正向代理、反向代理、负载均衡原理
https://blog.csdn.net/qq_36125138/article/details/84144932



========================================
nginx是什么？
----------------------------------------
一. 介绍
1.
Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。

Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。

Nginx相较于Apache\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。在Linux操作系统下，nginx使用epoll事件模型,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue.


Nginx 是一个很强大的高性能Web和反向代理服务器，它具有很多非常优越的特性：在高连接并发的情况下，Nginx是Apache服务器不错的替代品，感谢Nginx为我们选择了 epoll and kqueue作为开发模型。


[官网下载站](http://www.nginx.org/),  
[官网商业站](https://www.nginx.com/),  
[官网docs](http://nginx.org/en/docs/), 

[中文手册](http://www.nginx.cn/doc/index.html), 
[nginx how to](http://www.nginx.cn/nginx-how-to)

[官方英文新手指南](http://nginx.org/en/docs/beginners_guide.html)





2. Nginx能做什么 
https://mp.weixin.qq.com/s/Viv9T1kSTePNI6O2xDzyRg
相信很多人都听过nginx，这个小巧的东西慢慢地在吞食apache和IIS的份额。那究竟它有什么作用呢？可能很多人未必了解。

——反向代理
——负载均衡
——HTTP服务器（动静分离）
——正向代理
以上就是我了解到的Nginx在不依赖第三方模块能处理的事情


说到反向代理，可能很多人都听说，但具体什么是反向代理，很多人估计就不清楚了。摘一段百度百科上的描述：
http://cxshun.iteye.com/blog/1535188

反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。






二、名词解释

> 代理服务器
一般是指局域网内部的机器通过代理服务器发送请求到互联网上的服务器，代理服务器一般作用在客户端。



> 反向代理(资源服务器在防火墙内)

客户端（用户A）向反向代理的命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。而客户端A始终认为它访问的事原始服务器B而不是服务器Z。由于防火墙作用，只允许服务器Z进出，防火墙和反向代理共同作用保护了原始资源服务器B。

用户A <--> 反向代理服务器z <--> { 防火墙 -- 只允许z服务器进出 <--> 原始资源服务器B } 


用途：将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡或为后端较慢的服务器提供缓冲服务。



> 正向代理(用户在防火墙内)

正向代理是一个位于客户端A和原始服务器（服务器B）之间的服务器（代理服务器Z），为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标（服务器B），然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

{用于A--|                   }
{用户B--|--路由器-- 防火墙内} --互联网 -- 服务器B
{用户C--|     |             }
{         代理服务器Z       }

用途：在防火墙内的局域网客户端提供访问Internet的途径。还可以使用缓冲特性减少网络使用率。


从安全性来讲：
- 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。
- 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。




三、Nginx VS Apache
相同点：
1、都是HTTP服务器软件
2、功能上都采用模块化结构设计
3、都支持通用的语言接口，如PHP、Perl、Python等
4、支持正向、反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输
 

不同点：
1、Apache处理速度很慢，占用很多内存资源
2、功能上，Apache所有模块支持动静态编译，Nginx模块都是静态编译的
3、对Fcgi的支持：Apache支持的很不好，Nginx支持非常好
4、处理连接方式：Nginx支持epoll, Apache不支持
5、空间使用上：Nginx安装包仅几百K




四、Nginx优势
Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:

1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高
2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度
3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡
4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源
5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DDOS这样的攻击对Nginx来说基本上是没有任何作用的
6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行

Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。


Nginx具有很高的稳定性；支持热部署；代码质量非常高，代码很规范，手法成熟，模块扩展也很容易；采用了一些os提供的最新特性如对sendfile(Linux2.2+),accept-filter（FreeBSD4.1+）,TCP_DEFER_ACCEPT(Linux 2.4+)的支持，从而大大提高了性能。







https://blog.csdn.net/liutengteng130/article/details/46700939




========================================
win7 64bits系统安装nginx
----------------------------------------

参考：
http://www.cnblogs.com/cnscoo/archive/2012/09/03/2668577.html


如果是使用ISAPI的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。
如何查看当前运行的PHP的版本？一个很简单的办法就是phpinfo();
Thread Safety disabled是NTS，enabled是TS
Configure Command看到VC98字样的是VC6，Compiler标明 MSVC9 (Visual C++ 2008) 的是VC9
在WIN7下：IIS7+NTS+FastCGI+vc9 是最佳搭档或者apache+fastcgi+nts+vc6。
在WINXP下：Apache+TS+Apache module +vc6最合适的搭档。

1.下载nginx1.10.3 http://nginx.org/en/download.html
  下载php:http://windows.php.net/download#php-5.6
2.解压php-5.6.30-Win32-VC11-x64.zip到c:/web/php下，将其中的php.ini-production改成php.ini。
3.解压nginx-1.10.3.zip到C:/web/nginx下，编辑C:\web\nginx\conf\nginx.conf文件中的server{}部分:
	location / {
		root   html;
		index  index.html index.htm index.php; #添加PHP首页
	}

　　#取消以下注释并修改:
	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	location ~ \.php$ {
		root           html;
		fastcgi_pass   127.0.0.1:9000;
		fastcgi_index  index.php;

　　　　# html表示网站目录，须和root中的保持一致
		fastcgi_param  SCRIPT_FILENAME  html$fastcgi_script_name;
		include        fastcgi_params;
	}
	
按如上的配置，如果访问127.0.0.1:9000/a.php，则实际上根据root指令和fast_cgi.conf配置，nginx会通过fast_pass指令访问/usr/share/nginx/html/a.php这个文件。
        记得用root指令，指定站点的文档根路径。	
	
	
4.在C:\web\nginx中添加php-cgi.cmd文件并写入内容:
"C:\web\php\php-cgi.exe" -b 127.0.0.1:9000 -c "C:\web\php\php.ini"

5.在C:\web\nginx\html文件夹中添加phpinfo文件index.php并写入内容:
 <?php
     phpinfo();
 ?>
6.运行C:\web\nginx\php-cgi.cmd和c:\web\nginx\nginx.exe（nginx -c conf\nginx.conf），默认使用80端口，日志见文件夹nginx\logs
然后打开：http://localhost/index.php，有没有看到熟悉的phpinfo页面！

6.1.错误：
启动php的时候报错：在启动php时，无法启动此程序,因为计算机中丢失MSVCR110.dll的解决方法。
http://blog.csdn.net/lzq123_1/article/details/46400597
（1）进入 http://www.microsoft.com/zh-CN/download/details.aspx?id=30679 ，选择中文，我的是64位系统，选择vcredist_x64.exe,文件很小，下载很慢。。。
（2）同意协议，程序正在安装的，这里安装进度的提示，慢慢等待吧，很快的
当安装完成之后就会有这个界面的提示，提示我们已经设置成功。
以上就是无法启动此程序,因为计算机中丢失MSVCR110.dll的解决方法，

7.nginx基本命令:
　　start nginx：启动nginx
　　nginx -s stop：停止nginx
　　nginx -s quit：退出nginx






========================================
|-- windows下nginx安装、配置与使用
----------------------------------------
目前国内各大门户网站已经部署了Nginx，如新浪、网易、腾讯等；国内几个重要的视频分享网站也部署了Nginx，如六房间、酷6等。新近发现Nginx 技术在国内日趋火热，越来越多的网站开始部署Nginx。

    相比apeach、iis，nginx以轻量级、高性能、稳定、配置简单、资源占用少等优势广受欢迎。

1)下载地址：http://nginx.org

2)启动：解压至c:\web\nginx，运行nginx.exe(即nginx -c conf\nginx.conf)，默认使用80端口，日志见文件夹C:\nginx\logs

3)使用　http://localhost

4)关闭 nginx -s stop 或taskkill /F /IM nginx.exe > nul 
5)常用配置
 　　C:\web\nginx\conf\nginx.conf,使用自己定义的conf文件如my.conf，命令为nginx -c conf\my.conf

　　常用配置如下： 
　　Nginx.conf代码 
　　http {
　　 server {
	　　 #1.侦听80端口 
	　　 listen 80; 
	　　 location / {
		　　 # 2. 默认主页目录在nginx安装目录的html子目录。 
		　　 root html; 
		　　 index index.html index.htm; 
		　　 # 3. 没有索引页时，罗列文件和子目录 
		　　 autoindex on; 
		　　 autoindex_exact_size on; 
		　　 autoindex_localtime on; 
	　　 }
	　　 # 4.指定虚拟目录 
	　　 location /tshirt { 
		　　 alias D:\programs\Apache2\htdocs\tshirt; 
		　　 index index.html index.htm; 
	　　 }
　　 }
    # 5.虚拟主机drupal.dawneve.com 配置 
	#http://www.osyunwei.com/archives/3727.html
    server {
        listen       80;
        server_name drupal.dawneve.com;
		index index.php index.html index.htm;
        # access_log drupal.dawneve.com/logs/access.log; 
        root html\drup.dawneve.com\htdocs; 
        location / {
            index index.html; 
        }
    } 
　　
　　小提示： 
　　运行nginx -V可以查看该Win64平台编译版支持哪些模块。我这里的结果为： 
	nginx version: nginx/1.10.3
	built by cl 16.00.40219.01 for 80x86
	built with OpenSSL 1.0.2k  26 Jan 2017
	TLS SNI support enabled
	configure arguments: 
	--with-cc=cl 
	--builddir=objs.msvc8 
	--with-debug 
	--prefix= 
	--conf-path=conf/nginx.conf 
	--pid-path=logs/nginx.pid 
	--http-log-path=logs/access.log 
	--error-log-path=logs/error.log 
	--sbin-path=nginx.exe 
	--http-client-body-temp-path=temp/client_body_temp 
	--http-proxy-temp-path=temp/proxy_temp 
	--http-fastcgi-temp-path=temp/fastcgi_temp 
	--http-scgi-temp-path=temp/scgi_temp 
	--http-uwsgi-temp-path=temp/uwsgi_temp 
	--with-cc-opt=-DFD_SETSIZE=1024 
	--with-pcre=objs.msvc8/lib/pcre-8.40 
	--with-zlib=objs.msvc8/lib/zlib-1.2.11 
	--with-select_module
	--with-http_realip_module 
	--with-http_addition_module 
	--with-http_sub_module 
	--with-http_dav_module 
	--with-http_stub_status_module 
	--with-http_flv_module 
	--with-http_mp4_module 
	--with-http_gunzip_module 
	--with-http_gzip_static_module 
	--with-http_auth_request_module 
	--with-http_random_index_module 
	--with-http_secure_link_module 
	--with-http_slice_module 
	--with-mail 
	--with-stream 
	--with-openssl=objs.msvc8/lib/openssl-1.0.2k 
	--with-openssl-opt=no-asm 
	--with-http_ssl_module 
	--with-mail_ssl_module 
	--with-stream_ssl_module 
	--with-ipv6
　　
　　显然，最经常用的memcache, rewrite模块都没在其中，因此该win32编译版本仅能供基本开发测试使用，对于产品平台，应该重新编译自己想要的win32版本，或者在linux下使用更方便。

6）查看nginx进程

　　tasklist /fi "imagename eq nginx.exe"，如下显示：
映像名称                       PID 会话名              会话#       内存使用
========== =============== ======== ================ =========== ============
nginx.exe                     8944 Console                    1      5,128 K
nginx.exe                     6712 Console                    1      5,556 K

7）nginx常用命令

nginx -s stop 强制关闭 
nginx -s quit 安全关闭 
nginx -s reload 改变配置文件的时候，重启nginx工作进程，来时配置文件生效 
nginx -s reopen 打开日志文件

8）其它
　　可以通过配置文件开启多个nginx工作进程，但同时只有其中一个nginx工作进程在工作，其他的阻塞等待。
　　一个nginx工作进程最多同时可以处理1024个连接。
　　nginx中需要共享内存的cache或者模块无法在windows下正常使用。
　　不过，nginx官方正在改进，将来nginx会以服务的方式运行，使用 I/O completion ports代替select方法，使多个工作进程能并发工作。
　　要使用nginx配合php-cgi使用，需要修改环境变量，否则，php-cgi运行一定次数就推出，需要重启，设置PHP_FCGI_MAX_REQUESTS这个变量为0即可。

　　以上在win7上通过。 

 8）nginx以windows服务形式启动
　　1.下载微软两个工具：instsrv.exe srvay.exe
　　2.执行命令:instsrv Nginxc:/nginx/srvany.exe
　　3.配置Nginx的运行参数
　　可以直接将配置导入到注册表Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/NGINX/Parameters]
"Application"="C://web//nginx//nginx.exe"
"AppParameters"=""
"AppDirectory"="C://web//nginx//"

　　注意：windows下的Nginx缺少很多内置module，用Nginx -V 命令查看。
#





========================================
nginx在ubuntu下的安装和配置
----------------------------------------
1. 查看版本号
$ nginx -V
nginx version: nginx/1.14.0 (Ubuntu)
built with OpenSSL 1.1.1  11 Sep 2018
TLS SNI support enabled


$ sudo vim /etc/nginx/sites-available/default
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# 查看这些文档，知道如何配置nginx
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##





2. 对于新系统 ubuntu 20.04
(1) 默认没有 nginx
$ nginx -version
Command 'nginx' not found, but can be installed with:
sudo apt install nginx-core    # version 1.18.0-0ubuntu1.2, or
sudo apt install nginx-extras  # version 1.18.0-0ubuntu1.2
sudo apt install nginx-full    # version 1.18.0-0ubuntu1.2
sudo apt install nginx-light   # version 1.18.0-0ubuntu1.2


从头安装最新版 1.20.1
1)先安装gcc编译器
$ sudo apt-get install build-essential
$ sudo apt-get install libtool


2)下载并解压
$ wget http://nginx.org/download/nginx-1.20.1.tar.gz #只有1.1M
$ tar zxvf nginx-1.20.1.tar.gz
$ cd nginx-1.20.1/

编译与安装
$  ./configure
./configure: error: the HTTP rewrite module requires the PCRE library.


3) 安装依赖
http://www.nginx.cn/install 中提到“一般我们都需要先装 PCRE, zlib，前者为了重写rewrite，后者为了gzip压缩。”

$ apt search PCRE #不知道选哪个

太难解决了，放弃源码安装了。


(2) 使用系统版本
$ sudo apt install nginx-core

$ nginx -v
nginx version: nginx/1.18.0 (Ubuntu)

$ sudo service nginx status #active (running)

$ ls /var/www/html/ #文件
$ ls -lth /etc/nginx/conf.d/ #配置文件
$ vim /etc/nginx/sites-available/default #默认配置文件









========================================
|-- nginx在linux下的集成安装包
----------------------------------------
https://github.com/lj2007331/oneinstack

恭喜您，OneinStack 安装成功！

OneinStack Linux+Nginx/Tengine+MySQL/MariaDB/Percona+PHP
+Pureftpd+phpMyAdmin+redis+memcached+jemalloc脚本中用到的软件包大多最新稳定版本,修复了一些安全性问题。

查看本地环境:  探针 phpinfo Opcache phpMyAdmin(为了更安全，建议重命名 phpMyAdmin 目录！)
创建 WEB 虚拟主机执行脚本:  ./vhost.sh
创建 FTP 虚拟账号执行脚本:  ./pureftpd_vhost.sh
Github 项目地址:  https://github.com/lj2007331/oneinstack
OneinStack 官网:  https://oneinstack.com
QQ 群:  558540514(付费千人群) 535783209(新)

mysql用户名和密码：
GRANT ALL PRIVILEGES ON *.* TO '用户名'@'%' IDENTIFIED BY '我的密码';
FLUSH PRIVILEGES;

（1）OneinStack如何配置MySQL远程连接？
https://oneinstack.com/question/oneinstack-how-to-configure-mysql-remote-connection/
# iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT
# service iptables save #保存iptables规则

（2）没有ssl怎么办？没法做ab测试。
安装ssl（某些vps默认没装ssl)。使用root账号：
wget https://www.openssl.org/source/openssl-1.1.0e.tar.gz
tar -zxvf openssl-1.1.0e.tar.gz
cd openssl-0.9.8r
./Configure
./config
make  #等待很久
make install

检测版本号
# openssl version
还是报错 openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory

发现有这个文件啊
[root@iZm5ej0xncw7iyb3abhlkqZ lib]# find / -name "*libssl.so.1.1*"
/usr/local/lib64/libssl.so.1.1
/root/openssl-1.1.0e/libssl.so.1.1

安装正确：
[root@iZm5ej0xncw7iyb3abhlkqZ bin]# rpm -qa | grep openssl
openssl-1.0.1e-48.el6_8.4.x86_64
openssl-devel-1.0.1e-48.el6_8.4.x86_64


做一个软链接 
# ln -s /usr/local/lib64/libssl.so.1.1 /lib/libssl.so.1.1  不行

# cd /usr/lib64
# ln -s  libssl.so.1.0.1e libssl.so.1.1 不行
# ln -s  /usr/local/lib64/libssl.so.1.1 libssl.so.1.1 

(没搞定。。。)




========================================
|-- docker 版 nginx: 适合浏览器查看服务器上的图片
----------------------------------------

1. 普通 nginx 
http://biomooc.dawneve.cc/linux/docker-guide.html

$ docker --version
Docker version 20.10.7, build 20.10.7-0ubuntu1~20.04.1


(1) 下载镜像
$ docker pull nginx:1.21.3

$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
nginx        1.21.3    ad4c705f24d3   2 weeks ago   133MB

(2) 写配置文件
$ cat nginx.config 
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
		
        # list files
        autoindex on; 
        autoindex_exact_size on; 
        autoindex_localtime on; 
    }
}


(3) 启动容器：文件映射、端口映射

$ docker run --rm -d -p 93:80 \
--mount type=bind,source=/home/wang/,target=/usr/share/nginx/html/ \
--mount type=bind,source=/home/wang/nginx.config,target=/etc/nginx/conf.d/default.conf \
nginx:1.21.3

$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                               NAMES
dddb162006ad   nginx:1.21.3   "/docker-entrypoint.…"   6 seconds ago   Up 4 seconds   0.0.0.0:93->80/tcp, :::93->80/tcp   eager_lehmann


(4) 浏览器查看
$ cat > index.html 
hello 
ctrl+C 

浏览器打开 http://192.168.2.156:93/ 可见到这句话。
删掉这个文件，能看到该目录下文件列表。


(5) 关掉该服务
$ docker stop dddb










========================================
|-- 使用nginx反向代理 内网rstudio server 的配置文件
----------------------------------------
$ nginx -v
nginx version: nginx/1.18.0 (Ubuntu)

(1) 参照
$ cat /etc/nginx/sites-available/default
把其中的 listen 改为其他端口，比如 8001

(2) 新建配置文件

$ sudo vim /etc/nginx/conf.d/rstudio.conf
server {
        listen 80 default_server;
        listen [::]:80 default_server;
		
	location / {
		proxy_pass http://y.biomooc.com:8787;
		proxy_redirect http://y.biomooc.com:8787/ $scheme://$host/;
		proxy_http_version 1.1;
		proxy_set_header Host $http_host;
		proxy_set_header Upgrade $http_upgrade;
		proxy_set_header Connection "upgrade";
		proxy_read_timeout 20d;
		# Use preferably
		proxy_set_header X-RStudio-Request $scheme://$host:$server_port$request_uri;
		# OR existing X-Forwarded headers
		proxy_set_header X-Forwarded-Host $host;
		proxy_set_header X-Forwarded-Proto $scheme;
		# OR alternatively the Forwarded header (just an example)
		proxy_set_header Forwarded "host=$host:$server_port;proto=$scheme;";
	}
	proxy_buffering off;
}

重启ningx
$ sudo service nginx restart
$ sudo service nginx status


(3) 测试
然后打开浏览器 http://192.168.2.156/
另一台主机的rstudio的8787端口，已经转到这台的80端口。




ref: https://www.ivistang.com/articles/506/




========================================
nginx + apache配置网址
----------------------------------------
1.网站的文件放在：/data/wwwlogs/blog2.biomooc.com（IP：139.129.233.213）
2.用用apache监听88端口，负责解析php。
3.用nginx监听80端口，并代理到本地的88端口。


1.配置apache
/usr/local/apache/conf/httpd.conf 文件末尾要包含一句 
Include conf/vhost/*.conf

/usr/local/apache/conf/vhost/blog2.biomooc.com.conf 
<VirtualHost *:88>
  ServerAdmin admin@example.com
  DocumentRoot "/data/wwwroot/blog2.biomooc.com"
  ServerName blog2.biomooc.com


  ErrorLog "/data/wwwlogs/blog2.biomooc.com_error_apache.log"
  CustomLog "/data/wwwlogs/blog2.biomooc.com_apache.log" common
<Directory "/data/wwwroot/blog2.biomooc.com">
  SetOutputFilter DEFLATE
  Options FollowSymLinks ExecCGI
  Require all granted
  AllowOverride All
  Order allow,deny
  Allow from all
  DirectoryIndex index.html index.php
</Directory>
</VirtualHost>


2.配置nginx
/usr/local/nginx/conf/nginx.conf中http{}内的最后加上
  include vhost/*.conf;


/usr/local/nginx/conf/vhost/blog2.biomooc.com.conf
server {
  listen 80;
  server_name blog2.biomooc.com;
  access_log /data/wwwlogs/blog2.biomooc.com.log combined;
  index index.html index.htm index.php;
  root /data/wwwroot/blog2.biomooc.com;


  location / {
    try_files $uri @apache;
  }
  location @apache {
    proxy_pass http://127.0.0.1:88;
    include proxy.conf;
  }
  location ~ .*\.(php|php5|cgi|pl)?$ {
    proxy_pass http://127.0.0.1:88;
    include proxy.conf;
  }
  location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ {
    expires 30d;
    access_log off;
  }
  location ~ .*\.(js|css)?$ {
    expires 7d;
    access_log off;
  }
  location ~ /\.ht {
    deny all;
  }
}









========================================
如何在Ubuntu1604/1804 下配置nginx服务器子目录
----------------------------------------

nginx是一个很好用的服务器软件，是apache的有力竞争者。

问题：
本文简介在ubuntu1604上，设置nginx显示静态资源（图片、文本、压缩包等），用局域网内的其他电脑可以直接查看这些资源。
具体说，就是通过web查看circos生成的图片，免去下载查看的麻烦。


方法：
1.安装niginx
自动下载并安装nginx
$ sudo apt-get install nginx
$ service nginx status
	active(running)
#

安装之后的文件结构大致为：
所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下
程序文件在/usr/sbin/nginx
日志放在了/var/log/nginx中
并已经在/etc/init.d/下创建了启动脚本nginx
默认的虚拟主机的目录设置在了/var/www/nginx-default
启动nginx : sudo /etc/init.d/nginx start




2.通过ifconfig查看主机ip地址。
$ ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:0e:cc:c3  
          inet addr:192.168.1.97

同局域网内的电脑可以通过浏览器访问该主机：http://192.168.1.97

Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.
Thank you for using nginx.


该文件的位置为：/var/www/html/index.nginx-debian.html

/etc/nginx/nginx.conf  主配置文件。
包含/etc/nginx/conf.d/*.conf 文件。

(2) 所以也可以直接修改 /etc/nginx/conf.d/ 下的文件:

$ sudo vim demo1.conf
server {
	listen 6060;
	server_name localhost;
	client_max_body_size 1024M;
	
	location / {
		proxy_pass http://localhost:8080;
		proxy_set_header Host $host:$server_port;
	}
}

server{
  listen 5000;
  server_name 192.168.2.120;
  location / {
    root /home/wangjl/data/mp4Player/;
    index index.html;
  }
}

然后 
$ sudo service nginx restart
重启即可访问新端口: 
192.168.2.120:5000 显示的静态文件就是 /home/wangjl/data/mp4Player/index.html
192.168.2.120:6060 显示的是端口转发 192.168.2.120:8080 的内容。







3. 设置nginx静态文件目录为/home/wangjl/sth/目录，列举该文件夹下的文件。

编辑配置文件 nginx.conf
【wrong】$ sudo vim /etc/nginx/conf.d/default.conf  这个文件不太对。
$ sudo vim /etc/nginx/sites-available/default

(1)设置如下内容：
server{
	location / {
		root /home/wangjl/sth/;
		autoindex on;     #开启目录浏览功能；   
	}
}


或者
	location / {
			# First attempt to serve request as file, then
	#       root /var/www/html;
			root /home/wangjl/Pictures;
			autoindex on;
			# as directory, then fall back to displaying a 404.
			try_files $uri $uri/ =404;
	}

	location /img/ {
			alias   /home/wangjl/sth/;
			autoindex       on;
	}

根目录是~/Pictures目录。
通过http://192.168.1.97/img/ 可以看到图片列表。
注意：缺少最后的/不行！




参考：https://segmentfault.com/q/1010000005687627
location /c/ {
	alias /a/
}
如果访问站点http://location/c访问的就是/a/目录下的站点信息。





（2）更多设置不成功：
http://www.cnblogs.com/Kaivenblog/p/5948587.html
location /img/ {
    root /home/wangjl/sth/;
    autoindex on;  #开启目录浏览功能；   
    autoindex_exact_size off; #关闭详细文件大小统计，让文件大小显示MB，GB单位，默认为b；   
    autoindex_localtime on; #开启以服务器本地时区显示文件修改日期！   
}


(3)设置之后要重启nginx，才能使设置生效。
$ sudo service nginx restart
















排错：
1. 如果关不掉nginx怎么办？
(1)常规service nginx stop
(2)查找nginx进程
$ ps -aux|grep nginx
然后 kill -9 xxxx 杀掉进程。


refer:
nginx的配置：http://www.cnblogs.com/t-road/p/6738888.html
agetouch blog:http://agetouch.blog.163.com/blog/static/228535090201791881025259/




========================================
|-- 反向代理，应该是Nginx做的最多的一件事了 (proxy_pass、upstream实现)
----------------------------------------

反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。

反向代理的代码
$ sudo vim /etc/nginx/conf.d/demo1.conf
server {
        listen 6001;
        server_name 192.168.2.203;
        client_max_body_size 1024M;

        location / {
                proxy_pass http://192.168.2.203:8080; # 如果这里填写localhost不行，就尝试本机IP地址
                proxy_set_header Host $host:$server_port;
        }
}


保存配置文件后重启Nginx，
$ sudo service nginx restart
或者 
$ sudo nginx -s reload

这样当我们访问 http://192.168.2.203:6001/ 的时候，就相当于访问localhost:8080了
Hello World!, port=8080




========================================
|-- 端口转发，与py简易服务器
----------------------------------------

1.在nginx配置文件中添加几行
$ sudo vim /etc/nginx/sites-available/default

#Demo1负载均衡池
upstream py3_pool{
    server 192.168.2.120:8000;
}

#Demo1端口转发
server {
    listen       8080;
    server_name  y.biomooc.com;
#    access_log logs/y.biomooc.com.log;
#    error_log logs/y.biomooc.com.error;

    #将所有请求转发给demo_pool池的应用处理
    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://py3_pool;
    }
}


python的Flask的web端口是8000，可以通过
http://y.biomooc.com:8000/x?name=test 访问，F12能看到Response中Server: Werkzeug/0.14.1 Python/3.6.3

现在使用nginx把端口8080的请求转发给8000，则访问 http://y.biomooc.com:8080/x?name=test 时，实际上后台响应的还是pyhton，但是F12能看到的Response中Server: nginx/1.14.0 (Ubuntu)

重复以上过程，即可完成不同URL转发到不同内部端口。
比如访问 book.biomooc.com 的8080，则自动转向内部的80端口等。






2. 附录：py开启简易服务器脚本
$ cat hello.py
from flask import Flask, escape, request

app = Flask(__name__)
@app.route('/')
def hello_world():
    return "hello world. http://y.biomooc.com:8000/x?name=test "

@app.route('/x')
def hello():
    name = request.args.get("name", "World")
    return f'Hello, {escape(name)}!'


if __name__=='__main__':
    app.run(host="192.168.2.120",port=8000)

# 启服务器
$ python hello.py
 * Serving Flask app "hello" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://192.168.2.120:8000/ (Press CTRL+C to quit)
#



========================================
|-- 负载均衡(3种原生 + 2种插件方案)
----------------------------------------
https://www.cnblogs.com/zhaoyingjie/p/7248678.html
端口转发
指的是由软件统一监听某个域名上的某个端口（一般是80端口），当访问服务器的域名和端口符合要求时，就按照配置转发给指定的 Tomcat 服务器处理。我们常用的 Nginx 也有端口转发功能。


负载均衡
负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。



1、RR（默认）
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。

简单配置
$ sudo vim /etc/nginx/conf.d/demoRR.conf
upstream test01{ #负载均衡的核心代码
	server 192.168.2.120:8080; #wordpress
	server 192.168.2.120:7000; #jupyter
	server 192.168.2.120:80; #web
	server 192.168.2.120:8081; #wrong
	server baidu.com:80; #访问不到，why?
}

server{
	listen 81;
	server_name 192.168.2.203; #这是用户访问的
	client_max_body_size 1024M;
	
	location / {
		proxy_pass http://test01;
		proxy_set_header Host $host:$server_port;
	}
}

这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。

$ sudo nginx -s reload
$ curl http://192.168.2.203:81





2、权重
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。

其余和上文一样，只是upstream 服务器后面多加了一个权重weight=7：
$ sudo vim /etc/nginx/conf.d/demoWeight.conf
upstream test02{ #负载均衡的核心代码
	server 192.168.2.203:8080 weight=7;
	server 192.168.2.203:7000 weight=2;
	server 192.168.2.203:80 weight=1;
}
server{
	listen 83;
	server_name 192.168.2.203;
	client_max_body_size 1024M;

	location / {
		proxy_pass http://test02;
		proxy_set_header Host $host:$server_port;
	}
}

$ sudo nginx -s reload
访问 http://192.168.2.203:83

那么10次一般只会有1次会访问到80，2次机会访问7000，而有7次会访问到8080。





3、ip_hash
上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。

upstream test03{
	ip_hash;
	server 192.168.2.203:8080;
	server 192.168.2.203:7000;
}


4、fair（第三方）
按后端服务器的响应时间来分配请求，响应时间短的优先分配。
upstream test04{
	fair;
	server 192.168.2.203:8080;
	server 192.168.2.203:7000;
}

5、url_hash（第三方）
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法
upstream test05{
	hash $request_url;
	server 192.168.2.203:8080;
	server 192.168.2.203:7000;
}


以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍




========================================
|-- HTTP服务器
----------------------------------------

Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器

$ sudo vim /etc/nginx/conf.d/demoHttp.conf
server{
	listen 84;
	server_name 192.168.2.203;
	client_max_body_size 1024M;

	location / {
		root /home/george/web/; 
		index index.html;
		
		#proxy_pass http://test02;
		#proxy_set_header Host $host:$server_port;
	}
}

$ sudo nginx -s reload
访问 http://192.168.2.203:84 就会默认访问到/home/george/web/目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。




========================================
|-- 动静分离
----------------------------------------
动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路

$ sudo vim /etc/nginx/conf.d/demoStaticDynamic.conf
upstream test85{
	#server 192.168.2.203:8080;
	server 192.168.2.120:8000; #python
}

server {
	listen 85;
	server_name 192.168.2.203;
	
	location / {
		root /home/george/wwwroot/; 
		index index.html;
	}
	
	#所有静态请求都有nginx处理，存放目录为html
	location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js|pdf)$ {
		root /home/george/wwwroot/; 
	}
	
	#所有动态请求都转发给tomcat / python 处理
	location ~\.(py|jsp|do)$ {
		proxy_pass http://test85;
	}
	
	error_page 500 502 503 504 /50x.html;
	location =/50x.html{
		root /home/george/wwwroot/;
	}
}

重启服务器
$ sudo nginx -s reload

访问 http://192.168.2.203:85/a1.png
显示的图片位于 /home/george/wwwroot/a1.png

访问 http://192.168.2.203:85/index.py
则显示的是 python flask的响应。

http://192.168.2.203:85/index.py?k=R&id=0_1
也能被python正常响应。说明nginx只区分?之前的部分，之后的部分原封不动传给了python。


这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat/python只负责处理jsp和请求。 
例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活。









========================================
|-- 反向代理用做内网域名转发
----------------------------------------
编辑反向代理服务器配置文件：vim /usr/local/nginx/conf/reverse-proxy.conf

https://www.cnblogs.com/freespider/p/6269399.html

只有一个域名，想做好几个系统，比如OA, ftp等，只好配置成内网转发了。
代理服务器接收不同的子域名，转发(proxy_pass)给不同的内网主机处理。


$ sudo vim /etc/nginx/conf.d/demoForURL.conf
server {          
    listen 80;
    server_name oa.test.com;
    location / {
        proxy_redirect off;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://10.0.1.2:8082; #这里填写内网B服务器, 以及对应的端口就可以转发过去了
    }
    access_log /data/wwwlogs/oa.test.com.log; #访问日志
}


如果想做负载均衡可以这么配置
upstream oa_server {
    server 10.0.1.2:8082;
    server 10.0.1.3:8082;
}
 
server {          
    listen 80;
    server_name oa.test.com;
    location / {
        proxy_redirect off;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://oa_server; #这里oa_server和upstream模块oa_server是一样的
    }
    access_log /data/wwwlogs/oa.test.com.log;
}

$ sudo nginx -s reload 






========================================
|-- 正向代理 (其实就是翻墙的原理了)
----------------------------------------
正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。


1.
server端：
应用在nginx的server段，不要server_name,需要添加一个 resolver 

$ sudo vim /etc/nginx/conf.d/demoForword.conf
server {
	# 配置DNS解析IP地址，比如 Google Public DNS，以及超时时间（5秒）
	resolver 114.114.114.114 8.8.8.8;
	resolver_timeout 5s;
	
	# 监听端口
	listen 8089;
	
	access_log /home/george/web/logs/proxy.access.log;
	error_log /home/george/web/logs/proxy.error.log;
	
	location / {
		# 配置正向代理参数
        proxy_pass $scheme://$host$request_uri;
		#proxy_pass http://$host$request_uri;
		
		# 解决如果URL中带"."后Nginx 503错误
        proxy_set_header Host $http_host;
		
		
        proxy_buffers 256 4k; # 配置缓存大小
        proxy_max_temp_file_size 0; # 关闭磁盘缓存读写减少I/O
        proxy_connect_timeout 30; # 代理连接超时时间

        # 配置代理服务器HTTP状态缓存时间
        #proxy_cache_valid 200 302 10m;
        #proxy_cache_valid 301 1h;
        #proxy_cache_valid any 1m;
	}
}

重启服务器
$ sudo nginx -s reload

resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。


(2)开服务器
$ cat a7000.py 
from flask import Flask,request
app = Flask(__name__)

@app.route("/")
def hello():
	ip = request.remote_addr;
	return "Hello python3, port=7000, from "+ip+"\n";

if __name__ == '__main__':
	app.debug = True;
	app.run(host="192.168.2.203",port=7000)
#
$ python3 a7000.py








2. 客户端做测试
$ curl 192.168.2.203:8089 
$ curl -x 192.168.2.203:8089  http://192.168.2.203:7000/index.py
curl --proxy 192.168.2.203:8089 http://192.168.2.203:8000/index.py


本机$ curl 192.168.2.203:7000
Hello python3, port=7000, from 192.168.2.203

换另一台PC， 
浏览器 http://192.168.2.203:7000/
Hello python3, port=7000, from 192.168.2.153
$ curl http://192.168.2.203:7000/
# 100    45  100    45    0     0     45      0  0:00:01 --:--:--  0:00:01  2812Hello python3, port=7000, from 192.168.2.153

使用代理 
$ curl -x 192.168.2.203:8089 http://192.168.2.203:7000/
失败，没有返回IP地址，返回了nginx欢迎页面。

不过访问百度则正常返回百度
$ curl -x 192.168.2.203:8089 http://www.baidu.com




(1)使用代理访问百度，并记录cookie(-D)
$ curl -x 192.168.2.203:8089 -D cookie0001.txt http://baidu.com
<html>
<meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
</html>
查看访问记录
george@ubt16:~/web/logs$ tail proxy.access.log
192.168.2.203 - - [22/Aug/2019:13:59:56 +0800] "GET http://baidu.com/ HTTP/1.1" 200 81 "-" "curl/7.47.0"


(2)使用代理-A(也总是失败)访问百度，模拟用户访问
$ curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36" -x 192.168.2.203:8089 -D cookie0003.txt http://baidu.com


竟然通过了！
$ curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 192.168.2.203:8089 -D cookieA01.txt http://baidu.com
这样，服务器端接到访问的要求，会认为你是一个运行在Windows 2000上的IE6.0
而"Mozilla/4.73 [en] (X11; U; Linux 2.2; 15 i686"则可以服务端Linux上的Netscape 4.73。


(3)访问https总是失败
$ curl -x HTTPS_PROXY://192.168.2.203:8089 -D cookie0003.txt https://www.baidu.com
curl: (56) Received HTTP code 400 from proxy after CONNECT
看日志
192.168.2.203 - - [22/Aug/2019:14:17:57 +0800] "CONNECT www.baidu.com:443 HTTP/1.1" 400 182 "-" "-"



client端：
一次代理，直接在shell执行：
#export http_proxy=http://192.168.2.203:86

永久使用：
#vim .bashrc
export http_proxy=http://192.168.2.203:86
#source .bashrc




========================================
|-- 如何在centOS6.8下配置nginx服务器子目录?
----------------------------------------
附录：—— 【centOS6 开nginx服务器】
https://www.cnblogs.com/heacool/p/6406664.html
查centOS的版本号：
$ lsb_release -a
版本号是6.8 。

# rpm -qa gcc
gcc-4.4.7-17.el6.x86_64
# rpm -qa pcre
pcre-7.8-7.el6.x86_64
# rpm -qa zlib
zlib-1.2.3-29.el6.x86_64
# rpm -qa openssl
openssl-1.0.1e-48.el6_8.3.x86_64

centos6.8系统下已安装有所需要的以上软件，下一步直接安装nginx。


1.下载
# cd /usr/local/src
# wget http://nginx.org/download/nginx-1.10.3.tar.gz

2.解压 
# tar -zxvf nginx-1.10.3.tar.gz

3.安装 
# ./configure --prefix=/usr/local/nginx
# make
# make install


4.查看安装位置
# whereis nginx
$ whereis nginx
nginx: /usr/local/nginx


5.启动nginx
nginx可执行文件存放路径： /usr/local/nginx/sbin/nginx
可进入/usr/local/nginx/sbin路径，输入 ./nginx 启动。

也可以通过ps -A命令查看nginx进程状态，确认nginx已启动:
#ps -A | grep nginx
或者
$ ps -aux | grep nginx 



6.自定义nginx子目录。
用途：便于直接查看circos等图形工具的输出结果。

/usr/local/nginx/conf/nginx.conf中第一行改为
user  root;#原来是nobody。这个很关键。修改文件夹权限为777等其他方法都不行。

location /{}下面平行添加：
        location /wangjl/ {
                #root /home/wangjl/web_pub/;
                alias   /home/wangjl/web_pub/;
                autoindex       on;
        }

重启nginx 
$ ./nginx -s reload

访问ip就可以看到新目录的内容了。
http://10.113.81.67/wangjl/
















========================================
nginx on CentOS7
----------------------------------------
1. 安装与测试
(1) 安装
$ sudo yum install dnf

$ dnf --version
4.0.9
  Installed: dnf-0:4.0.9.2-2.el7_9.noarch at Thu 19 May 2022 08:23:11 AM EST
  Built    : CentOS BuildSystem <http://bugs.centos.org> at Wed 07 Apr 2021 03:52:38 PM EST

  Installed: rpm-0:4.11.3-48.el7_9.x86_64 at Thu 12 May 2022 08:41:28 AM EST
  Built    : CentOS BuildSystem <http://bugs.centos.org> at Wed 24 Nov 2021 04:33:39 PM EST


$ sudo dnf install nginx
$ nginx -v
nginx version: nginx/1.20.1


(2) 开启
$ service nginx status
Redirecting to /bin/systemctl status nginx.service
● nginx.service - The nginx HTTP and reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)
   Active: inactive (dead)

启动服务
$ sudo systemctl start nginx
or 
$ sudo systemctl status nginx

查看状态
$ service nginx status # Active: active (running)


设置开机启动
$ sudo systemctl enable nginx
开机不启动
$ sudo systemctl disable nginx


关闭服务
$ sudo systemctl stop nginx
重启服务
$ sudo systemctl restart nginx
$ sudo systemctl reload nginx



(3) 查端口 
$ sudo netstat -anp | grep nginx
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      2972/nginx: master  
tcp6       0      0 :::80                   :::*                    LISTEN      2972/nginx: master  
unix  3      [ ]         STREAM     CONNECTED     406410   2972/nginx: master   
unix  3      [ ]         STREAM     CONNECTED     406411   2972/nginx: master


(4) 打开 80 端口
$ sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口


(5) 看ip
$ ifconfig
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.2.105  netmask 255.255.255.0  broadcast 192.168.2.255

(6) 查看浏览器 192.168.2.105 
Welcome to CentOS
The Community ENTerprise Operating System
...





2. 配置
Nginx core files and directories
Here are some main Nginx files and directories:

/etc/nginx: Nginx configuration files can be found in this directory.
/etc/nginx/nginx.conf 配置文件: This is the Nginx global configuration file
/etc/nginx/conf.d 目录: Nginx server block configuration files can be found in this directory
/usr/share/nginx/html 网页目录: web content served by the Nginx server can be found in this directory

$ ls -lth /usr/share/nginx/html
total 12K
lrwxrwxrwx. 1 root root   20 May 19 04:24 en-US -> ../../doc/HTML/en-US
drwxr-xr-x. 2 root root   27 May 19 04:24 icons
lrwxrwxrwx. 1 root root   18 May 19 04:24 img -> ../../doc/HTML/img
lrwxrwxrwx. 1 root root   25 May 19 04:24 index.html -> ../../doc/HTML/index.html
lrwxrwxrwx. 1 root root   14 May 19 04:24 poweredby.png -> nginx-logo.png
-rw-r--r--. 1 root root 3.6K Oct 18  2021 404.html
-rw-r--r--. 1 root root 3.7K Oct 18  2021 50x.html
-rw-r--r--. 1 root root  368 Oct 18  2021 nginx-logo.png


(1) 自定义网页首页

删除默认主页的链接
$ sudo rm /usr/share/nginx/html/index.html

自定义主页
$ sudo vim /usr/share/nginx/html/index.html
hello, 123!

访问页面 http://192.168.2.105/ 显示字符 hello, 123!








3. CentOS7 下 nginx 设置子目录
$ cd /home/wangjl/html/data
$ ls -lth
total 5.2M
-rw-rw-r--. 1 wangjl wangjl   16 Oct 12 08:54 a.txt
-rw-rw-r--. 1 wangjl wangjl 5.2M May  8  2021 thd.mp3

配置文件
$ sudo vim /etc/nginx/nginx.conf

在端口为 80 的server 中添加
	location /bio/ {
			root /home/wangjl/;
			#root /usr/share/nginx/html/;
			autoindex on;
	}
重启服务 $ sudo service nginx restart
测试: 
$ mkdir ~/bio/
$ vim ~/bio/a.txt 不行

试试开启路径上的权限
$ chmod o+rx /home/wangjl/





4. CentOS7 下 nginx 设置后缀名的静态文件位置

在端口为 80 的server 中添加
    location ~ \.(png|jpg|txt|mp3|pdf)$ {
        root         /usr/share/nginx/html/;
        add_header Access-Control-Allow-Origin '*';
		autoindex on;
    }
重启服务 $ sudo service nginx restart
测试: 
http://192.168.2.105/data/thd.mp3

也就是url中的 path 路径是相对于 root 目录的。

        location / {
            root         /usr/share/nginx/html;

            slice              1m;
            proxy_cache_key    $host$uri$is_args$args$slice_range;
            proxy_set_header   Range $slice_range;
            proxy_http_version 1.1;

            add_header Access-Control-Allow-Origin '*';
        }


        location /bio/ {
            alias /home/wangjl/;
            #root /usr/share/nginx/html/;
            autoindex on;
        }


        location ~ \.(png|jpg|txt|mp3|pdf)$ {
           root         /usr/share/nginx/html/;
           add_header Access-Control-Allow-Origin '*';
           autoindex on;
        }

=>关闭 SELinux
(1) 关闭
$ getenforce
Enforcing

$ sudo setenforce 0

$ getenforce
Permissive

(2) 恢复回去: 打开
$ sudo setenforce 1
$ getenforce 
Enforcing






========================================
|-- [CentOS7.9] localtion后面其实是一个正则表达式， 对应着URL路由
----------------------------------------
http://www.nginx.cn/115.html
conf是一个嵌套格式。server中的location相当于路由，一旦匹配就停止并返回，所以要把具体的放上面，模糊的放下面。

1. location匹配命令

~      #波浪线表示执行一个正则匹配，区分大小写
~*    #表示执行一个正则匹配，不区分大小写
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录
=      #进行普通字符精确匹配
@     #"@" 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files



2. location 优先级官方文档

(1)Directives with the = prefix that match the query exactly. If found, searching stops.
(2)All remaining directives with conventional strings, longest match first. If this match used the ^~ prefix, searching stops.
(3)Regular expressions, in order of definition in the configuration file.
(4)If #3 yielded a match, that result is used. Else the match from #2 is used.

(1)=前缀的指令严格匹配这个查询。如果找到，停止搜索。
(2)所有剩下的常规字符串，最长的匹配。如果这个匹配使用 ^~ 前缀，搜索停止。
(3)正则表达式，在配置文件中定义的顺序。
(4)如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。



3. 实例

实例: 
server {
    listen       80;
    listen  [::]:80;
    server_name  location.test.com;

    access_log  /var/log/nginx/location.host.access.log  main;

    #***注意多个location通常按精确的放前面，模糊大范围的放后面，nginx先找= ****
    location = /login.html {#精确匹配 /login
		root /usr/share/nginx/html/test-equal;#请求/login.html相当于寻找资源/usr/share/nginx/html/test-equal/login.html
    }
    location ^~ /prefix/ {#区分大小写且以/prefix/开头
		root /usr/share/nginx/html/test-prefix;
		#root代表根目录，请求/prefix/prefix.html相当于寻找资源/usr/share/nginx/html/test-prefix/prefix/prefix.html 
    }
    location ~ .(png|jpg)$ {#不区分大小写且以.png或.jpg结尾
		root /usr/share/nginx/html/test-suffix;
		#请求/suffix/a.png相当于寻找资源/usr/share/nginx/html/test-suffix/suffix/a.png
    }
    location ^~ /jd/ {# 区分大小写且以/jd/开头
		proxy_pass https://www.jd.com/;
		#proxy_pass  此处的url以/结尾，则nginx会取掉location部分再转发，
		# 例如，请求/jd/电器?name=1 则会转发到https://www.jd.com/电器?name=1
    }
    location ^~ /s {# /会匹配到所有的
		proxy_pass https://www.baidu.com;
		#proxy_pass  此处的url没有以/结尾，则匹配到的地址全部拼接到代理后的地址，
		# 例如，请求/s?name=1 则会转发到https://www.baidu.com/s?name=1
    }
    location  / {# 会返回index.html
		root /usr/share/nginx/html;
		index index.html;	
    }
}




location  = / {
  # 只匹配"/".
  [ configuration A ] 
}

location  / {
  # 匹配任何请求，因为所有请求都是以"/"开始
  # 但是更长字符匹配或者正则表达式匹配会优先匹配
  [ configuration B ] 
}

location ^~ /images/ {
  # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location
  [ configuration C ] 
}

location ~* .(gif|jpg|jpeg)$ {
  # 匹配以 gif, jpg, or jpeg结尾的请求. 
  # 但是所有 /images/ 目录的请求将由 [Configuration C]处理.   
  [ configuration D ] 
}

请求URI例子:
/ -> 符合configuration A
/documents/document.html -> 符合configuration B
/images/1.gif -> 符合configuration C
/documents/1.jpg ->符合 configuration D

@location 例子
error_page 404 = @fetch;

location @fetch(
	proxy_pass http://fetch;
)


注意： 
/和{之间要有空格；










4. 测试 on CentOS7.9 新虚拟机
$ sudo yum install nginx
$ sudo yum install tree
$ nginx -version
nginx version: nginx/1.20.1


$ cat index.html
<h1>hi!</h1>


(1) 新开一个端口 8002 
$ sudo vim /etc/nginx/conf.d/test.conf
server {
    listen 8002;
    listen [::]:8002;

    location / {
		root /home/wangjl;
		index index.html index.htm; 
		autoindex on;
   }
}

重启 nginx 服务
$ sudo service nginx restart

报错: $ sudo journalctl -xe
Oct 12 08:48:26 ct79 nginx[2340]: nginx: [emerg] bind() to 0.0.0.0:8002 failed (13: Permission denied)
日志：/var/log/nginx/error.log



1) 有人说是没有文件夹访问权限
$ sudo chmod o+r /home/wangjl
$ sudo chmod o+x /home/wangjl

$ sudo service nginx restart
还是报错


2) 排错重点1 临时关闭selinux
setenforce 0    ##设置SELinux 成为permissive模式
setenforce 1    ##设置SELinux 成为enforcing模式

关闭 SELinux
$ getenforce 
Enforcing
$ sudo setenforce 0  #我执行这行后就可以启动 nginx 了
$ getenforce 
Permissive

[我没做] 永久关闭selinux,
修改 /etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器。


[我没做] 用下面的方法打开某个端口:
$ sudo semanage port -l | grep http_port_t
http_port_t                    tcp      8001, 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988

[我没做] 或者加入到 SELinux 许可中: https://codeleading.com/article/95801363634/
$ sudo semanage port -a -t http_port_t  -p tcp 8002



3) 查端口，已经在监听
$ sudo service nginx restart
Redirecting to /bin/systemctl restart nginx.service

$ netstat -anp | grep 8002
tcp        0      0 0.0.0.0:8002            0.0.0.0:*               LISTEN      - 

4) 开放端口
$ sudo iptables -I INPUT -p tcp --dport 8002 -j ACCEPT
$ sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT

5) 打开浏览器访问，可以访问了
http://192.168.2.105:8002/
hi!

http://192.168.2.105/
默认的 80 端口也可以访问了。







(2) 修改配置文件: 设置图片匹配 ~* 
~*    #表示执行一个正则匹配，不区分大小写

1) 准备几个图文
/home/wangjl/ 
|-index.html
|-1.png
|-image/index.html
|-image/2.png


$ cd 
$ Rscript -e "png('1.png', width=300, height=400); plot(1:5); dev.off()"
$ mkdir image
$ Rscript -e "png('image/2.png', width=300, height=400); plot(1:5, col='red'); dev.off()"

$ cat index.html
<h1>hi!</h1>

<img src="1.png"> <br>
<img src="image/1.png"> <br>
<img src="2.png"> <br>
<img src="image/2.png">

$ cp index.html image/

浏览器查看：
http://192.168.2.105:8002/	只有第1个和第4个图可见：资源是相对于 /index.html 的地址。
http://192.168.2.105:8002/image/ 只有第三个图可见：资源是相对于 /image/index.html 的地址。


2) 改为 图片到固定文件夹查找
$ sudo vim /etc/nginx/conf.d/test.conf
server {
    listen 8002;
    listen [::]:8002;
	
	location ~* .(gif|jpg|jpeg|png)$ {
		# 匹配以 gif, jpg/jpeg or png结尾的请求. 
		root /home/wangjl/image;
	}
	
    location / {
		root /home/wangjl;
		index index.html index.htm; 
		autoindex on;
   }
}

$ sudo service nginx restart

浏览器查看 
http://192.168.2.105:8002/ 只有第三个图可见：图的根目录是 ~/image/ 内。
http://192.168.2.105:8002/image/  图都不可见







(3) 修改配置文件: 文件夹匹配 ^~ 
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录

$ sudo vim /etc/nginx/conf.d/test.conf
server {
    listen 8002;
    listen [::]:8002;
	
	location ^~ /images/ {#区分大小写且以/images/开头
		root /home/wangjl/book/;
    }
	
	location ~* .(gif|jpg|jpeg|png)$ {
		# 匹配以 gif, jpg/jpeg or png结尾的请求. 
		root /home/wangjl/image;
	}
	
    location / {
		root /home/wangjl;
		index index.html index.htm; 
		autoindex on;
   }
}

$ cd ~
$ mkdir -p book/images
$ Rscript -e "png('book/images/3.png', width=300, height=200); barplot(1:5, col='blue'); dev.off()"

$ cat index2.html
<img src="/images/3.png">
<img src="2.png">

$ sudo service nginx restart

http://192.168.2.105:8002/index2.html 这2个图都可见。
	第一个图匹配到规则 ^~ /images/ 后，在文件夹 /home/wangjl/book/ 中查找 /images/3.png，完整路径是 /home/wangjl/book/images/3.png
	第二个图则匹配到 ~* .(gif|jpg|jpeg|png)$，在 /home/wangjl/image 中找 2.png，完整路径是 /home/wangjl/image/2.png







(4) 设置端口转发，访问80转发到8002上

方法1
$ sudo vim /etc/nginx/conf.d/test2.conf
upstream test_pool{
    server 0.0.0.0:8002;
}
server {
	listen 80;
	listen [::]:80;
	location / {
		proxy_pass http://test_pool;
		proxy_set_header Host $host:$server_port;
	}
}



修改掉默认配置文件的端口号
$ sudo vim /etc/nginx/nginx.conf


$ sudo service nginx restart

http://192.168.2.105/  能看到第3张图
http://192.168.2.105/index2.html 两张图都能看到




方法2:
$ sudo vim /etc/nginx/conf.d/test2.conf
server {
    listen 80;
    listen [::]:80;

    location / {
        proxy_pass http://localhost:8002;
        #proxy_redirect http://localhost:8002/ $scheme://$host/;
        #proxy_http_version 1.1;
        #proxy_set_header Upgrade $http_upgrade;
        #proxy_set_header Connection $connection_upgrade;
        #proxy_read_timeout 20d;
        #proxy_buffering off;
   }
}

$ sudo service nginx restart

http://192.168.2.105/index2.html 两张图都能看到




========================================
|-- nginx 中 root 和 alias 的区别
----------------------------------------
1. 实例
(1) 区别
root响应的路径：配置的路径+完整访问路径(完整的location配置路径+静态文件)
alias响应的路径：配置路径+静态文件(去除location中配置的路径)

location /c/ {
	alias /a/;
}
如果访问站点http://location/c访问的就是/a/目录下的站点信息。


location /c/ {
	root /a/;
}
如果访问站点http://location/c访问的就是/a/c/目录下的站点信息。


(2) 实际使用时
server {
    location / {
        root /data/www;
    }

    location /images/ {
        alias /data;
    }
}

注意
使用alias时目录名后面一定要加“/”
一般情况下，在location /中配置root，在location /other中配置alias




2. url 分解：js 版
http://blog.dawneve.cc/index.php?k=Linux&id=2_4#15
F12 console:> location
hash: "#15"
host: "blog.dawneve.cc"
hostname: "blog.dawneve.cc"
href: "http://blog.dawneve.cc/index.php?k=Linux&id=2_4#15"
origin: "http://blog.dawneve.cc"
pathname: "/index.php"
port: ""
protocol: "http:"



========================================
|-- location 写法 详解
----------------------------------------
要检查：
- 端口是否打开
- 是否有 rx 权限，路径上的目录都要检查
- 是否关闭 SELinux



1. 准备文件
(1) web 目录
$ cd
$ ln -s /usr/share/nginx/html
$ sudo mkdir html/data
$ sudo chown $USER html/data

$ cd html/data/
下载图片，音乐，文本文件。
$ tree
.
├── a.txt
├── disc.jpg
├── thd.mp3
└── web
    ├── index2.html
    └── logs.txt

(2) web 目录2
$ cd
$ sudo mkdir html/images/
$ sudo chown $USER html/images
$ cd html/images
$ ls -lht
total 332K
-rw-rw-r--. 1 wangjl wangjl 8.3K May 13  2021 small.png
-rw-rw-r--. 1 wangjl wangjl 317K May 13  2021 001.png








2. 测试
SELinux 默认打开
$ getenforce 
Enforcing

使用端口 18002 
$ sudo iptables -I INPUT -p tcp --dport 18002 -j ACCEPT

(1) 配置文件
根据主配置文件，在其子文件夹建立新配置文件 test.conf
$ sudo vim /etc/nginx/nginx.conf
http {
	...
	include /etc/nginx/conf.d/*.conf;
	...
}

新建配置环境: 
$ sudo vim /etc/nginx/conf.d/test.conf
server {
	listen 18002;
	listen [::]:18002;
	
	location / {
		root /usr/share/nginx/html/data/;
		index index.html index.htm;
		autoindex on;
	}
}

重启服务:
$ sudo service nginx restart
启动失败，查看日志: 
$ journalctl -xe
	SELinux is preventing /usr/sbin/nginx from name_bind access on the tcp_socket port 18002.
	If you want to allow /usr/sbin/nginx to bind to network port 18002
	Then you need to modify the port type.
	Do
	# semanage port -a -t PORT_TYPE -p tcp 18002
	   where PORT_TYPE is one of the following: http_cache_port_t, http_port_t, jboss_management_port_t, jboss_messaging_port_t, ntop_port_t, puppet_port_t.

关闭 SELinux 
$ sudo setenforce 0
$ getenforce 
Permissive

重启服务:
$ sudo service nginx restart

浏览器测试: http://192.168.2.105:18002/
../
web/      12-Oct-2022 14:36        -
a.txt     12-Oct-2022 14:33       14
disc.jpg  19-Dec-2022 03:16   236337
thd.mp3   08-May-2021 09:00  5384466



(2) = 精确匹配 
精确匹配放前面，模糊的放到后面

	location = /login.html { #精确匹配 /login
		root /usr/share/nginx/html/test-equal; #请求/login.html相当于寻找资源/usr/share/nginx/html/test-equal/login.html
    }
$ cd ~/html/
$ sudo mkdir test-equal
$ sudo chown $USER test-equal
$ vim test-equal/login.html
this is login page

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/login.html



(3) ^~ /pre/ 匹配开头且区分大小写
	location ^~ /prefix/ { #区分大小写且以/prefix/开头
		root /usr/share/nginx/html/data/;
		#root代表根目录，请求 /prefix/index2.html相当于寻找资源 /usr/share/nginx/html/data/prefix/index2.html 
    }
为了方便，在已经设置权限的 ~/html/data/ 中新建目录和文件:
$ cd ~/html/
$ mkdir data/prefix
$ vim data/prefix/index2.html
index2.html under prefix/

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/prefix/index2.html

http://192.168.2.105:18002/prefix/indeX2.html 404


(3B) 转发到其他网站，url使用/结尾
	location ^~ /jd/ { # 区分大小写且以/jd/开头
		proxy_pass https://list.jd.com/;
		#proxy_pass  此处的url以/结尾，则nginx会去掉location部分再转发，
		# 例如，请求/jd/电器?name=1 则会转发到https://list.jd.com/电器?name=1
    }

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/jd/list.html?cat=737,1276,739


(3C) 转发到其他网站，url没有使用/结尾
	location ^~ /s { # 区分大小写，匹配到所有的 /s 开头
		proxy_pass https://www.baidu.com;
		# proxy_pass  此处的url没有以/结尾，则匹配到的地址全部拼接到代理后的地址，
		# 例如，请求/s?wd=1 则会转发到 https://www.baidu.com/s?wd=1
    }

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/s?wd=高山下的花环


(3D) 正则匹配，不区分大小写
	location ~* ^/test {
		return 402;
	}

$ curl -I http://192.168.2.105:18002/test  #402



(4) ~ xx$ 匹配后缀名，不区分大小写
	location ~ .(png|jpg)$ { #不区分大小写且以.png或.jpg结尾
		root /usr/share/nginx/html/images;
		# 请求 /001.png 相当于寻找资源 /usr/share/nginx/html/images/001.png
    }

$ cd ~/html/
$ mkdir images/Rplot
$ Rscript -e "png('images/Rplot/002.png', width=300, height=400); plot(2:2); dev.off()"

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/001.png
	http://192.168.2.105:18002/Rplot/002.png

最好把图片放到根目录，使用url: xx.com/images/xx.png 访问。


(5) /xx/ 按目录匹配
    location /web/ {# 会返回index.html
		root /usr/share/nginx/html/data/;
		# 请求 /web/index2.html 相当于寻找资源 /usr/share/nginx/html/data/web/index2.html
    }

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/web/index2.html


(5) / 兜底的匹配
	location / {
			root /usr/share/nginx/html/;
			index index.html index.htm;
			autoindex on;
	}

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/data/web/index2.html





(6) 定向到 home 文件夹
	location /wangjl/ {
			#root /home/wangjl/web_pub/;
			alias   /home/wangjl/;
			autoindex       on;
	}

重启服务: $ sudo service nginx restart
浏览器: http://192.168.2.105:18002/wangjl/
不能访问，排查发现other没有对home文件夹的读权限。
添加权限：$ chmod o+rx /home/wangjl/
可以访问了。






(10) 优先级问题 (更多见下一节)

http://192.168.2.105:18002/images/001.png 404
http://192.168.2.105:18002/001.png 可以

	location ^~ /a/ { #匹配字母a开头的
			return 666;
	}

	location /a/b/ { #普通匹配
			return 777;
	}

	location ~ /a/b/ { #正则匹配
			return 888;
	}

重启服务: $ sudo service nginx restart

$ curl -I http://192.168.2.105:18002/a/  #666
$ curl -I http://192.168.2.105:18002/abc/ #404 Not Found
$ curl -I http://192.168.2.105:18002/a/c  #666 

$ curl -I http://192.168.2.105:18002/a/b  #666 
$ curl -I http://192.168.2.105:18002/a/b/ #888        #说明普通匹配被跳过了? //todo
$ curl -I http://192.168.2.105:18002/a/b/c #888





= 开头表示精确匹配
^~ 开头  表示uri以某个常规字符串开头，理解为匹配url路径即可(非正则)

~  开头表示区分大小写的正则匹配
~*  开头 表示不区分大小写的正则匹配

!~  和!~*  分别为区分大小写不匹配及不区分大小写不匹配的正则

/  通用匹配，任何请求都会匹配到


=      #进行普通字符精确匹配
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录
~      #波浪线表示执行一个正则匹配，区分大小写
~*    #表示执行一个正则匹配，不区分大小写
@     #"@" 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files



优先级：

等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他location的匹配项

^~和普通匹配。使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会匹配表达式最长的那个。


没有 "location =" 或者 "location ^~" 的匹配, 查询正则匹配。


如果上一步得到的最长的location为^~类型，则表示阻断正则表达式，不再匹配正则表达式

如果上一步得到的最长的location不是^~类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程





========================================
|-- nginx 中几种 location 表达式的优先级问题
----------------------------------------
我们这里 只关注 location 上面的这五种写法, 不关注 location @name 


1. locaiton有五种类型的匹配规则
分别为完全匹配(=)、前缀普通匹配(^~)、正则表达式匹配(~或者~*)、普通匹配(/xx/，or /)

(1) location = /api     // 精确匹配
(2) location ^~ /api    // 前缀匹配2，如果找到停止搜索

(3) location ~* /api    // 忽略大小写正则匹配
(4) location ~ /api     // 正则匹配

(5) location /api       // 普通前缀匹配1


我们输入的网址叫做请求URI，nginx用请求URI与location中配置的URI做匹配。

location 中URI 优先级大概是 (1)精确匹配 > (2)前缀匹配2 > [(3)忽略大小写正则匹配，(4)(区分大小写)正则匹配] > (5)普通前缀匹配1 


location的编写形式
- 一般地，越精确的条件越放前面。以便减少匹配次数。
- 尽管location 的优先级与配置文件的编写顺序没什么关系，但是最好还是按照优先级顺序编写配置文件，方便理解，排查问题。



规则
- 等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项
- 前缀普通匹配(^~)优先级次之。不支持正则表达式。使用前缀匹配，如果有多个location匹配的话，则使用表达式最长的那个
- 正则表达式类型（~ 或 ~*）的优先级次之。一旦匹配成功，则不再查找其他匹配项
- 常规字符串匹配，如果有多个location匹配的话，则使用表达式最长的那个


说明
- 先判断精准命中，如果命中，立即返回结果并结束解析过程
- 若未结束，判断前缀普通匹配，如果有多个命中，使用表达式“最长”的命中结果，结束解析过程
- 若未结束，继续判断正则表达式的匹配，按正则表达式顺序为准，由上至下一旦匹配成功1个，立即返回结果，并结束解析过程
- 若未结束，继续普通匹配，普通匹配和前缀普通匹配相似，顺序无所谓，按照location表达式的长短来确定命中结果

Location，用来快速进行资源定位，定义不同方式来处理或解决url请求，一般有：/ , = /, ~, ~* ,^~

优先级是：(location = /)>(localtion ^~)>(location ~| ~* ）>(location /)
其中，~ 与 ~*，谁在上面先匹配谁.

准匹配优先级是最高的，它不论是在配置文件内容上面还是下面，服务器首先去找精准匹配的内容。

除了精准匹配，还有~ ，~* ，^~
	~是对大小写敏感，匹配时严格大小写
	~* 是对大小写不敏感，匹配时不分大小写。
	^~用来匹配以uri开头，匹配成功以后，会停止搜索后面的正则表达式匹配。

以上优先最高的是精准匹配 location = /，其次是：^，然后是 ~和~*，这两种看准在配置文件内容上面，就先匹配谁，优先级最低的是 /。

~ 和 ~*优先级其实是一样的，如果两个同时满足条件，配置文件中哪个location靠前，哪个生效。


以上规则在使用nginx时会被广泛使用，比如多台服务器做网站动静分离时：

location ~ .*\.(html|htm|js|css|txt|gif|png|jpg|jpeg|doc)$ {
	root html;
}






2. 优先级的验证
我们这里 核心关注的就是 这个顺序如何验证? 借助 curl -I 和 location 中的 return 状态码进行快速测试。

CentOS7.9 关闭 SELinux:
$ getenforce 
Permissive

版本号: Server: nginx/1.20.1

打开端口 8003
$ sudo iptables -I INPUT -p tcp --dport 8003 -j ACCEPT



(0) 配置文件
新建配置环境: 
$ sudo vim /etc/nginx/conf.d/testOrder.conf
server {
	listen 8003;
	listen [::]:8003;
	
	location / {
		root /usr/share/nginx/html/data/;
		return 100;
	}
}

重启服务: $ sudo service nginx restart
$ curl -I http://192.168.2.105:8003
HTTP/1.1 100



(1) = 精确匹配优先级最高

location = / {
	# 精确匹配 / ，主机名后面不能带任何字符串
	#[ configuration A ]
	return 101;
}

location / {
	# 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
	# 但是正则和最长字符串会优先匹配
	#[ configuration B ]
	return 100;
}

location = /location.html {
	#root /data/;
	#index index.html;
	return 102;
}

重启服务后测试:
$ curl -I http://192.168.2.105:8003
HTTP/1.1 101 

$ curl -I http://192.168.2.105:8003/location.html #102
= / 优先级高于/，所以即便 / 在前面也不影响 = / 的优先执行。




(2) 正则匹配 优先于 普通匹配
放到上文的 / 后面。
location /documents/ {
	# 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索
	# 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
	#[ configuration C ]
	return 200;
}

location ~ /documents/ {
	# 有正则表达式匹配到，则立刻返回。否则使用上面的 普通匹配
	#[ configuration CB ]
	return 201;
}

location ~ /documents/Abc {
	# 这个永远不会匹配到，因为第一个匹配的正则已经返回
	#[ configuration CC ]
	return 202;
}

location ~ /documents/Abc/Def {
	# 这个永远不会匹配到，因为第一个匹配的正则已经返回
	return 203;
}

location ~ /documents/AbcDefg {
	# 这个永远不会匹配到，因为第一个匹配的正则已经返回
	return 204;
}

测试:
$ curl -I http://192.168.2.105:8003/documents
HTTP/1.1 100  #少了个末尾斜线，只匹配了 /

$ curl -I http://192.168.2.105:8003/documents/
HTTP/1.1 201 Created

$ curl -I http://192.168.2.105:8003/documents/ab
HTTP/1.1 201 Created  #使用匹配最长的规则

$ curl -I http://192.168.2.105:8003/documents/abc
HTTP/1.1 201 Created  #大小写敏感
$ curl -I http://192.168.2.105:8003/documents/Abc
HTTP/1.1 201 Created  #有正则匹配上，后面的就失效了


$ curl -I http://192.168.2.105:8003/documents/Abc/
$ curl -I http://192.168.2.105:8003/documents/Abcdef
$ curl -I http://192.168.2.105:8003/documents/Abc/Def
$ curl -I http://192.168.2.105:8003/documents/Abc/Def/
$ curl -I http://192.168.2.105:8003/documents/AbcDef/
$ curl -I http://192.168.2.105:8003/documents/AbcDef
HTTP/1.1 201 Created

小结：正则匹配中，要把具体匹配放到前面，模糊的放到后面。
由于前面的 普通匹配，在后面总是能匹配到，所以普通匹配被忽略。



(2B) 把具体的放前面
前面还有之前的 1xx 的规则。

location /documents/ {
	# 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索
	# 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
	#[ configuration C ]
	return 200;
}

location ~ /documents/AbcDefg {
	return 204;
}

location ~ /documents/Abc/Def {
	return 203;
}

location ~ /documents/Abc {
	#[ configuration CC ]
	return 202;
}

location ~ /documents/ {
	#[ configuration CB ]
	return 201;
}

测试:
$ curl -I http://192.168.2.105:8003/documents   #100
$ curl -I http://192.168.2.105:8003/documents/  #201
$ curl -I http://192.168.2.105:8003/documents/ab #201
$ curl -I http://192.168.2.105:8003/documents/abc #201 区分大小写
$ curl -I http://192.168.2.105:8003/documents/Abc #202 区分大小写: 大写可以

$ curl -I http://192.168.2.105:8003/documents/Abc/           #202
$ curl -I http://192.168.2.105:8003/documents/Abc/index.html #202
$ curl -I http://192.168.2.105:8003/documents/Abcdef         #202
$ curl -I http://192.168.2.105:8003/documents/AbcDef         #202

$ curl -I http://192.168.2.105:8003/documents/AbcDefg  #204
$ curl -I http://192.168.2.105:8003/documents/AbcDefgh #204

$ curl -I http://192.168.2.105:8003/documents/Abc/Def  #203
$ curl -I http://192.168.2.105:8003/documents/Abc/Def/ #203






(3) 图片怎么设置？
这些规则放到 1xx 和 2xx 底下。

location ^~ /images/ {
	# 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。
	#[ configuration D ]
	return 301;
}

location ~* \.(gif|png|jpg|jpeg)$ {
	# 匹配所有以 gif,jpg或jpeg 结尾的请求（不区分大小写）
	# 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则
	#[ configuration E ]
	return 302;
}

location /images/ {
	# 字符匹配到 /images/，继续往下，会发现 ^~ 存在
	#[ configuration F ]
	return 303;
}

location /images/abc {
	# 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在
	# F与G的放置顺序是没有关系的
	#[ configuration G ]
	return 304;
}

location ~ /images/abc/ {
	# 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用
	#[ configuration H ]
	return 305;
}

优先级: ^~ 优先级是最高，接着是 ~/images/ > /images/


==> try1: 把 301 规则 images 改为 images2，否则启动失败: duplicate location "/images/"  行数是 conf F。
$ curl -I http://192.168.2.105:8003/images/a.png #302
$ curl -I http://192.168.2.105:8003/images/abc/a.png #302
$ curl -I http://192.168.2.105:8003/images/abc/1.jpg #302
$ curl -I http://192.168.2.105:8003/images/logo/a.PNG #302 不区分后缀大小写 ~*

$ curl -I http://192.168.2.105:8003/images/abc #304

$ curl -I http://192.168.2.105:8003/images/abc/       #305 
$ curl -I http://192.168.2.105:8003/images/abc/a.txt  #305 

$ curl -I http://192.168.2.105:8003/images2/abc/1.jpg  #301




https://blog.csdn.net/u011039332/article/details/125467695






========================================
|-- @ 用于 nginx内部跳转
----------------------------------------

location /index/ {
  error_page 404 @index_error;
}

location @index_error {
  root /home/wangjl/html/data/web/;
  autoindex on;
}

#以 /index/ 开头的请求，如果链接的状态为 404。则会匹配到 @index_error 这条规则上。
访问 http://192.168.2.105:8003/index/index.html
实际文件是: /home/wangjl/html/data/web/index/index.html





========================================
|-- 使用 nginx server: 做一个简陋的 markdown 网页管理工具
----------------------------------------
只需要提供md可视化即可，no or simple UI。
不提供编辑器，直接ftp上传 + vim编辑。
不基于后台语言，最好前端js一把搞定。
提供图片文件夹。
最好支持文件夹。


$ sudo vim /usr/share/nginx/html/index.html
<meta charset="utf-8"/>
<title>MarkdownReader.js</title>

<!--
<script src="/StackNote/static/js/lib/marked-2.0.3.js"></script>
<link rel="stylesheet" type="text/css" href="/StackNote/static/css/MarkDown.css" media="all">
v0.1 only js markdown reader;
-->
<script src="https://note.biomooc.com/static/js/lib/marked-2.0.3.js"></script>
<link rel="stylesheet" type="text/css" href="https://note.biomooc.com/static/css/MarkDown.css" media="all">
<style>
body{margin:0; padding:0;}
.wrapper{
	width:800px;
	margin:0 auto;
}
.header{ padding:5px; color: #aaa; font-size:small; border-bottom:1px dashed #aaa; }
.footer{margin-top:80px; border-top:1px solid black; padding:10px; color: #999;}

.markdown a{
    color: #0969da;
    text-decoration: none;
}

.markdown a:hover{ text-decoration: underline; }
.markdown p{ display: block; }
</style>


<div class="header wrapper">
	filename: <span id="filename"></span>
</div>

<div class="markdown">
	<div id="content" class="wrapper"></div>
</div>

<div class="footer wrapper">
	Supported by <a target="_blank" href="https://github.com/markedjs/marked">markedJS</a> | 
	Fork me on <a target="_blank" href="https://github.com/miostudio/MarkdownReader">Github</a> | 
</div>







<script>
// Tools
//get parameters from URL
function getUrlParam(name) {
	var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); //构造一个含有目标参数的正则表达式对象
	var r = window.location.search.substr(1).match(reg);  //匹配目标参数
	if (r != null) return unescape(r[2]); return null; //返回参数值
}

//ajax get file contents;
function ajax(fileName, obj){
	var xmlhttp=new XMLHttpRequest(); //1.获取对象
	//2.绑定回调函数
	xmlhttp.onreadystatechange=function(){
		if (xmlhttp.readyState==4 && xmlhttp.status==200){
			//wjl=marked.parse(xmlhttp.responseText);
			obj.innerHTML= marked(xmlhttp.responseText);
		}
	}
	//3.设定访问的url
	xmlhttp.open("GET", fileName, true);
	//4.发送请求
	xmlhttp.send();
}



// Action after window OK;
window.onload=function(){
	// get parameter from URL;
	var filename=getUrlParam("file");
	filename = filename || "help.md";
	// update toast
	document.getElementById("filename").innerHTML=filename;
	//render md to html
	ajax(filename, document.getElementById('content'))
}
//document.getElementById('content').innerHTML = marked.parse('# Marked in the browser\n\nRendered by **marked**.');
</script>



第二个文件，就是一个普通的 md 文件
$ vim help.md 
# Contents

Rendered by **markedJS**.

You can write a file in markdown, and render it with this app locally.

Below is a simple guide for how to write .md or .markdown file.



新建文件夹，可以放文件或图片等。
$ sudo mkdir /usr/share/nginx/html/images
$ sudo chmod -R 777 /usr/share/nginx/html/
$ sudo chgrp -R user /usr/share/nginx/html/

接着权限正常了:
$ ls -lth /usr/share/nginx/html/
total 20K
drwxrwxrwx. 2 root user   25 May 19 21:01 images






















========================================
debug: 重启服务常用命令，及报错
----------------------------------------
service nginx restart
service httpd restart

service memcached restart
service redis-server restart


========================================
|-- 重启失败 nginx: [error] open() "/run/nginx.pid" failed (2: No such file or directory)
----------------------------------------
症状： 重启报错。

1.先杀进程

$ killall nginx





2.
$ sudo nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful


??看到这个我明白了，更改配置时把.pem和.key的路径改了，配置文件读取时所在的路径是nginx下而不是conf.d下，也就是说，cert这个文件夹要放在nginx下和conf.d平级。
再执行nginx -t
??成功了。再执行systemctl restart nginx，就没事了。

$ which nginx
/usr/sbin/nginx

$ sudo nginx -c /etc/nginx/nginx.conf
nginx: [emerg] bind() to 0.0.0.0:9000 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:9000 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:9000 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:9000 failed (98: Address already in use)
nginx: [emerg] bind() to 0.0.0.0:9000 failed (98: Address already in use)
nginx: [emerg] still could not bind()
说明端口被占用了。

grep找到含有9000的文件，改后缀名。
$ sudo mv demoForURL.conf demoForURL.conf-backup


再次启动nginx
$ sudo nginx -s reload
nginx: [error] invalid PID number "" in "/run/nginx.pid"

这次换了报错。删掉这个文件。


最后把 /etc/nginx/conf.d/ 下的.conf 全改后缀名，然后再启动就好了。
$ sudo nginx -c /etc/nginx/nginx.conf
$ sudo service nginx restart


$ sudo service nginx status







3. 有资料这么说：
nginx -s reload is only used to tell a running nginx process to reload its config. After a stop, you don't have a running nginx process to send a signal to. Just run nginx (possibly with a -c /path/to/config/file)

于是我用了这方法，也就是nginx -c /path/to/config/file
https://www.cnblogs.com/fengfengyang/p/9189085.html



========================================
|-- OSError: [Errno 98] Address already in use
----------------------------------------
这个报错，被认为是端口被占用了。
File "test.py", line 10, in <module>
    app.run(host="192.168.2.120",port=7000)
原因：没有停下项目的情况下，关闭IDE．或者是之前的项目没有停掉，又一次运行了本项目．

解决办法：前者很简单，杀死进程．后者更简单把正在run的项目停掉．


1. 查找7000端口是哪个pid?
$ lsof -i:7000
COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
python3 10507 george    3u  IPv4  85695      0t0  TCP ubt16.lan:afs3-fileserver (LISTEN)
python3 10509 george    3u  IPv4  85695      0t0  TCP ubt16.lan:afs3-fileserver (LISTEN)
python3 10509 george    4u  IPv4  85695      0t0  TCP ubt16.lan:afs3-fileserver (LISTEN)



2.查找本pid是哪个程序?
ps -aux　 #　用ps -A查看所有进程
$ ps -aux | grep 10507
## george   10507  0.0  1.2  85720 26232 pts/20   S+   22:14   0:00 python3 a1.py

看来是我的py脚本。可以放心杀掉了。


3.杀死进程： 
kill -9 PID # PID是进程号,查看进程时会显示，比如 10507
$ kill -9 10507




4. 也可能碰到了不该使用的端口号。改一个吧，没办法。
比如0-1024的是系统保留端口，不让用；
22 ssh
80 web

6000 X11默认端口?
8787 Rstudio默认端口




#########
附录:
$ cat a1.py 
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
        return "Hello World!, port=7000"

if __name__ == '__main__':
        app.debug = True;
        app.run(host="192.168.2.203",port=7000)
#




========================================
|-- 打开 SELinux 情况下 访问 /home/ 目录 (牵涉 SELinux 就不会设置了 //todo)
----------------------------------------

(2) 家目录
$ cd ~/bio
创建文本文件。

$ tree
.
├── book1.txt
├── book2.txt
└── shelf
    └── book2.txt





2. 测试环境
$ nginx -version
nginx version: nginx/1.20.1


$ sudo vim /etc/nginx/nginx.conf
http {
	...
	include /etc/nginx/conf.d/*.conf;
	...
}



/usr/share/nginx/html

新建配置环境: 
$ sudo vim /etc/nginx/conf.d/test.conf
server {
	listen 18002;
	listen [::]:18002;
	server_name  _;
	
	location / {
		#root /home/wangjl/bio/;
		root /usr/share/nginx/html/data/;
		index index.html index.htm;
		autoindex on;
	}
}


$ sudo service nginx restart
报错：SELinux is preventing /usr/sbin/nginx from name_bind access on the tcp_socket port 8002
从日志看，显然是被SELinux给拦截了。
增加一个http端口：
$ sudo semanage port -a -t http_port_t -p tcp 18002 
$ sudo semanage port -d -t http_port_t -p tcp 18002 #删除该端口

开端口:
$ sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT
$ sudo iptables -I INPUT -p tcp --dport 18002 -j ACCEPT







(2) 为什么不能访问自己的位置呢？ 比如 /home/wangjl/
$ ps -efZ | grep nginx
system_u:system_r:httpd_t:s0    root      5576     1  0 09:36 ?        00:00:00 nginx: master process /usr/sbin/nginx
第一列显示的就是 SELinux 的权限，代表：用户:角色:类型:级别，这些描述 selinux 的安全上下文（详知请百度），先注意第三个字段为 httpd_t 类型


查看nginx 静态文件目录（centOS下是 /usr/share/nginx/html，或者你自定义前端dist的目录）的 selinux 信息
$ ls -Z /usr/share/nginx/html/data
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 a.txt
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 disc.jpg
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 thd.mp3

$ ls -Z /home/wangjl/
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:user_home_t:s0 bio

因为 nginx 进程只能访问 httpd_sys_content_t 类型的文件，而 httpd 可以读 httpd_sys_content_t 类型的文件。




(3) 于是，需要将该目录及子文件目录的 SELinux 信息修改为 httpd_sys_content_t
## semanage fcontext -a -t httpd_sys_content_t '/yourpath/dist(/.*)?'
$ sudo semanage fcontext -a -t httpd_sys_content_t '/home/wangjl/bio(/.*)?'

并刷新文件上下文信息即可（不刷新未更新，可自行查看 selinux 信息验证）
## restorecon -R /yourpath/dist
$ sudo restorecon -R /home/wangjl/bio

CentOS系统自带的 chcon 工具只能修改文件、目录等的文件类型和策略，无法对端口、消息接口和网络接口等进行管理，semanage 能有效胜任 SELinux 的相关配置工作

$ ls -lthZ /home/wangjl/bio
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book2.txt
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 shelf
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book1.txt

$ sudo service nginx restart

总结：centOS7的selinux安全机制默认限制文件上下文访问，需要放行。



## chcon -R -t httpd_sys_rw_content_t /root/www/
$ sudo chcon -R -t httpd_sys_content_t /home/wangjl/bio/

$ ls -Z /home/wangjl/bio/
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book1.txt
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book2.txt
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 shelf



可访问的标识:
$ ls -Z /usr/share/nginx/html/ | head -n 2
-rw-r--r--. root   root system_u:object_r:httpd_sys_content_t:s0 404.html
-rw-r--r--. root   root system_u:object_r:httpd_sys_content_t:s0 50x.html




(4) try again
查看:
$ sudo semanage fcontext -l | grep "/www"
/var/www(/.*)?                                     all files          system_u:object_r:httpd_sys_content_t:s0 
/var/www(/.*)?/logs(/.*)?                          all files          system_u:object_r:httpd_log_t:s0 
/var/www/[^/]*/cgi-bin(/.*)?                       all files          system_u:object_r:httpd_sys_script_exec_t:s0 
...

设置:
$ sudo semanage fcontext -a -t httpd_sys_content_t "/home/wangjl/bio(/.*)?"


$ ls -Z /home/wangjl/bio/
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book1.txt
-rw-rw-r--. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 book2.txt
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 shelf

查看 semanage 的上下文安全策略 
$ sudo semanage fcontext -l | grep "/bio"
...
/home/wangjl/bio/*                                 all files          system_u:object_r:httpd_sys_content_t:s0 
/home/wangjl/bio(/.*)?                             all files          system_u:object_r:httpd_sys_content_t:s0


查看被修改目录的安全策略
$ ls -Zd /home/wangjl/bio/
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 /home/wangjl/bio/ #之前执行过，所以修改了

更新才能生效
$ sudo restorecon -Rv /home/wangjl/bio/
drwxrwxr-x. wangjl wangjl unconfined_u:object_r:httpd_sys_content_t:s0 /home/wangjl/bio/




(5) 参照修改
$ ls -Z /etc/nginx/nginx.conf
-rw-r--r--. root root system_u:object_r:httpd_config_t:s0 /etc/nginx/nginx.conf

$ ls -Z /etc/nginx/conf.d/test.conf
-rw-r--r--. root root unconfined_u:object_r:httpd_config_t:s0 /etc/nginx/conf.d/test.conf

$ sudo chcon --reference=/etc/nginx/nginx.conf /etc/nginx/conf.d/test.conf

$ ls -Z /etc/nginx/conf.d/test.conf
-rw-r--r--. root root system_u:object_r:httpd_config_t:s0 /etc/nginx/conf.d/test.conf


恢复默认上下文
$ sudo restorecon -R -v /var/www/ #可能用的比较多，用于


$ sudo vim /etc/selinux/config 
SELinux=disabled

$ sudo reboot

还是不行！！




========================================
怎么在EC2上安装 nginx?
----------------------------------------
问题: EC2上安装了ubuntu1804, apt安装的nginx，可以使用curl获得nginx欢迎语句: curl 127.0.0.1
但是使用ip在浏览器获取不到。


可能的错误源：
> 您使用内部EC2 IP,而不使用公共IP.
> 您没有设置任何安全策略,并且正在访问EC2防火墙.
> iptables配置不正确,请禁用它,直到它不起作用为止.
> Nginx没有在正确的端口上侦听.使用默认配置.

1. 来确保打开了端口80
sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT
不起作用。

2. 在云服务器的安全组的【入站】里添加了HTTP协议，端口为80。添加之后，再次启动容器就可以通过浏览器访问了。
不要覆盖22端口，免得ssh登录不上。

http://52.15.209.96/ 能免费用到2021.5






####### shadowsocks
# https://www.textarea.com/ExpectoPatronum/shiyong-shadowsocks-kexue-shangwang-265/
$ pip -V
pip 20.1.1 from /home/ubuntu/.local/lib/python3.6/site-packages/pip (python 3.6)

$ pip install shadowsocks







========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------
