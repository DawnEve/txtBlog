csapp



视频: https://www.bilibili.com/video/BV1iW411d7hd/






========================================
怎么阅读 CSAPP(3e)?
----------------------------------------
1. 写作业

* 只需要几分钟。几乎不需要编程
** 20min; 测试代码、考试题
*** 1~2h。测试大量代码
**** 一个实验作业，需要大概 10 个小时


所有源码: https://csapp.cs.cmu.edu/
第二版: http://csapp.cs.cmu.edu/2e/home.html
最新的第三版pdf 目录: http://csapp.cs.cmu.edu/3e/pieces/preface3e.pdf
	第三版中文 775 页





2. 视角

Students should be introduced to computer systems from the perspective of a programmer, rather from the more traditional perspective of a system implementer. What does this mean?
Students should get a view of the complete system, comprising the hardware, operating system, compiler, and network.
Students learn best by developing and evaluating real programs that run on real machines.


第三版采用 x86-64 指令集，涉及 Interl Core i7 的虚拟地址结构、SSD 磁盘、IPv6等新技术内容。

第三版更加强调并发，增加了较大篇幅讨论信号处理与主程序间并发时的正确性保障。

基于 x86 的linux操作系统，采用C语言编程。这个组合经受住了时间的考验。


本书会探究编译器、计算机体系结构、操作系统、嵌入式系统、网络互联和网络安全等高级话题。


ISC: 
	(10周课程)硬件、操作系统、编译系统对应用程序的性能和正确性的影响。
	系统级I/O、网络编程、并发编程
	(其他书中找) 守护进程(daemon)、终端控制、Unix IPC(进程间通信)
		异步信号安全、协议无关的网络编程。



(2) CSAPP 是一本程序员修炼内功的指引书，为什么说是指引书呢？

CSAPP 是计算机原理 + 操作系统 + Linux 系统 + 汇编的一个大杂烩，它不是深入理解汇编、深入理解操作系统、深入理解计算机原理，所以它不会在某个知识点给你涉及很深，比如：
	* 虽然讲了虚拟内存，但是并没有说各种页面置换算法，这部分内容得我们去看操作系统相关的书；
	* 虽然讲了 Cache，但是并没有说缓存一致性协议，这部分内容得我们去看计算机组成相关的书；
	* 虽然说了链接，但是讲的内容比较表面，要想深入这块内容还是得看看《程序员的自我修养》这本书；
	* 虽然说了 Linux 系统的 I/0 和网络编程，但是只是说了几个简单案例，要想深入理解这些内容还得看《APUE》和《UNP》这两本；
	* 没有提及操作系统中的文件系统、调度算法等。


(3) 怎么看？
如果你是在校生，有了一定 C 语言基础后，非常建议你就开始看这本书，有精力也可以做做 CSAPP 的 lab。越早开始看，你的收益就越大，因为当计算机体系搭建起来后，你后面再深入每一个课程的时候，你会发现学起来会比较轻松些。

对于已经工作了，但是计算机系统没有一个清晰认识的读者，也可以从这本书开始一点一点学起来，这本书是很厚，但是并不一定要把书完完看完，每个章节的知识点还是比较独立的，有关硬件的章节我们可以选择跳过。







3. 共12个章节
	1 系统漫游
	2 数据表示
	3 机器语言
	4 处理器体系结构
	5 代码优化
	6 存储器层次结构
	7 链接
	8 异常控制流
	9 虚拟内存
	10 系统级I/O 
	11 网络编程 
	12 并发编程





4. 本书的实验

(1) 数据实验
仅适用位运算，是按简单的逻辑运算和算术运算。

(2) 二进制炸弹实验
提供一个目标文件。
运行时提示: 用户输入6个不同的字符串，如果任何一个不准确，炸弹会“爆炸”，打印出一条错误信息。
练习适用调试器，找到这6个字符。


(3) 缓冲区溢出实验
缓冲区溢出攻击的代码的危险性。

(4) 体系结构实验
- 修改处理器的HCL描述
- 增加新的指令
- 修改分支预测策略
- 增加、删除胖录路径和寄存器端口

(5) 性能试验
优化应用程序的核心函数(比如卷积积分或矩阵转置)的性能。
高速缓存的特性。


(6) cache 实验。
编写通用高速缓存模拟器，并优化小型矩阵转置的核心函数，
类似性能实验。
以最小化对模拟的高速缓存的不命中次数。
使用 Valgrind 为矩阵转置核心函数生成真实的地址访问记录。

(7) shell 实验
实现带有作业控制的 Unix shell 程序，包括 Ctrl+C和 ctrl+Z按键，fg、bg和jobs命令。
第一次接触并发，了解 Unix 的进程控制、信号和信号处理。


(8) malloc 实验。
实现自己的 malloc、free 和 realloc(可选)版本。
清晰的理解数据的布局和组织，并评估时间和空间效率的各种权衡和折中。

(9) 代理实验。
实现一个位于浏览器和万维网其他部分之间的并行web代理。
理解web客户端和服务器主题，练习概念：字节顺序、文件I/O、进程控制、信号、信号处理、内存映射、套接字和并发。





========================================
1 系统漫游
----------------------------------------

1. 信息就是位+上下文

8 bit 位 == 1byte 字节。
每个字节都有一个整数值，对应于某些字符。
每个字节对应 ascii 中的一个char字符。

由 ascii 字符构成的文件称为 文本文件，其他称为 二进制文件。

不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。


(1) C语言
起源于贝尔实验室。
ANSI C: K&R 书，全书 261 页。

C语言是系统级编程的首选，也非常适用于应用级程序的编写。
C语言的指针是很多程序员困惑和程序错误的原因。
C语言缺乏对非常有用的抽象的显式支持，例如 类、对象和异常。
C++和Java解决了这些问题。



2. 程序被翻译为不同的格式

(1) gcc 编译的过程分为 4个阶段

$ cat hello.c 
#include<stdio.h>
int main(){
	printf("hello, world!\n");
	return 0;
}

$ gcc -o hello hello.c 


编译系统（compilation system）
	预处理器(cpp): 处理#开头的命令，结果得到.i文件； 
	编译器(ccl): 包含汇编语言程序，把C指令翻译成汇编 .s文件。汇编为不同高级语言的不同编译器提供了通用的输出语言。
	汇编器(as): 把.s汇编语言翻译为机器语言指令 .o文件，二进制文件。
	链接器(ld): 把 printf.o 和 hello.o 合并为可执行文件(.out), 可被加载到内存中，由系统执行。





3. 了解编译系统如何工作的有什么用？

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞





4. 处理器读并解释存储在内存中的指令

$ ./hello 
hello, world!
$ 

如果该命令行的第一个单词不是一个内置的 shell 命令，那么shell将会假设这是一个可执行文件的名字，它将加载并运行这个文件。

(1) 系统的硬件组成
总线: 按字长(word) 传输内容，64位是8字节
I/O设备
主存
处理器：程序计数器(PC)、算术/逻辑单元(ALU)、寄存器文件(register file)
	CPU在指令的要求下可能会执行的操作:
		加载：从主存复制一个字节或一个字到寄存器，覆盖寄存器原来的内容
		存储: 寄存器赋值一个字节或一个字到主存，覆盖掉原来的内容
		操作: 把2个寄存器的内容复制到ALU，ALU对2个字做算术运算，并将结果放到一个寄存器中，覆盖掉原来的内容
		跳转: 从指令本身中抽取一个字，复制到程序计数器(PC)中，覆盖掉PC中原来的值


(2) 运行 hello world 程序






5. 高速缓存至关重要


6. 存储设备形成层次结构


7. OS 管理硬件

(1) 操作系统位于 硬件 和 应用程序之间

应用程序
OS 操作系统
硬件: 处理器、主存、I/O设备

(2) OS的基本功能

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而通常大不相同的低级硬件设备。

(3) OS 通过几个抽象概念来实现这2个功能
文件: 是对 IO设备的抽象表示
虚拟内存: 是对主存和磁盘IO设备的抽象表示
进程则是对处理器、主存和IO设备的抽象表示。



(4) Unix 的很多思想来自于 Multics 系统，只不过在一个更小、更简单的程序包中实现
	层次文件系统
	作为用户级进程的shell概念

后来厂商太多，互不兼容， IEEE 开始努力标准化 Unix 的开发，命名为 Posix 标准。
	Unix 系统调用的C语言接口
	shell程序和工具
	线程及网络编程
现在已经基本没有差异了。




(5) 几个概念
1) 进程 

假象：系统只运行 hello 程序，它独占的使用硬件。
	这个假象是通过进程的概念来实现的。

进程是 操作系统对一个正在运行的程序的一种抽象。
	一个系统可以同时运行多个进程，而每个进程都好像在独占地使用硬件。

并发运行，一个进程的指令和另一个进程的指令是交错执行的。

无论是单核还是多核系统，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器的进程间切换来实现的。
	操作系统实现这种交错执行的机制称为 上下文切换。



内核 kernel: OS 代码常驻内存的部分。
	内核不是一个独立的进程。
	它是系统管理全部进程所用代码和数据结构的集合。

应用程序需要OS的某些操作时，比如读写文件，他就会执行一条特殊的系统调用(system call)指令，将控制权传递给内核。
然后内核执行被请求的操作并返回应用程序。

实现进程这个抽象概念需要低级硬件和OS之间的紧密合作。
	第八章将揭示这项工作的原理，及应用程序如何创建和控制他们的进程。


2) 线程

现代OS中，一个进程实际上可以有多个称为 线程 的执行单元组成，
	每个线程都运行在 进程的上下文中，并共享同样的代码和全局数据。


由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为
	1 多线程之间比多进程之间更容易共享数据。
	2 线程一般比进程更高效。
	当多处理器可用的时候，多线程也是一种使得程序可以运行的更快的方法。第12章，并发概念，及如何写线程化的程序。


3) 虚拟内存
虚拟内存是一个抽象概念，他为每个进程提供了一个假象，即每个进程都在独占的使用主存。

每个进程看到的内存都是一致的，称为 虚拟地址空间。

不1-13 进程的虚拟地址空间
	图中地址是从下往上增大的
	[用户代码不可见内存] 地址空间的最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样的。
	最底部区域存放用户进程定义的代码和数据。
	
从低地址开始，看虚拟地址空间
	- 程序代码和数据: 代码和数据区是直接按照可执行文件的内容初始化的。第7章研究链接和加载，会有地址空间的内容。
	- 堆: 代码和数据区后紧随着是 运行时堆。当调用 malloc 和 free 这些C标准库函数时，堆可以在运行时动态的扩展和收缩。第9章管理虚拟内存，研究堆。
	- 共享库: 大约地址空间的中间部分，放C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。第7章介绍动态链接时，学习共享库如何工作。
	- 栈: 位于用户虚拟地址空间顶部的是 用户栈，编译器用它来实现函数调用。每调用一个函数，栈就会增长；从一个函数返回，栈就会收缩。第3章学习编译器是如何使用栈的。
	- 内核虚拟内存: 地址空间顶部的区域是为内核保留的。不允许应用程序读写该区域的内容或者直接调用内核代码定义的函数。


虚拟内存的运作需要硬件和OS的机密复杂的交互，包括对处理器生成的每个地址的硬件翻译。
	基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第9章解释虚拟内存，及对现代OS的重要性。



4) 文件 

文件就是字节序列，仅此而已。
每个IO设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。



(6) linux系统

起点是 Minix。
通过与 GNU 项目的力量结合，Linux 项目发展成一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设置。
Linux从手持设备到大型计算机，都得到了应用。








8. 系统之间利用网络通信

网络可以视为一个IO设备。

当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是本地磁盘驱动器。

系统也可以读取其他机器发送来的数据，并复制到自己的主存。


网络应用：电子邮件、即时通信、万维网、FTP和telnet等。





9. 重要主题

(1) Amdahl 定律

要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

一个有趣的特殊情况：60%的系统能够优化到不花时间的程度，整个系统的净加速比仍然只有 1/0.4=2.5X.



(2) 表示相对性能
比例 Told/Tnew, Told表示原始系统所需时间，Tnew为修改后的系统所需时间。
如果有所改进，比值大于1。用后缀X表示比例，比如 2.2X，读作 2.2倍。

更传统的是用百分比法，这种方法适用于变化小的情况，但其定义是模糊的。
	应该等于 100*(Told - Tnew)/ Tnew，还是 100*(Told - Tnew)/Told 还是其他值？
	他对较大的变化也没有太大意义。
	与简单的说性能提升 2.2X 相比，“性能提升了120%”更难理解。





(3) 并发和并行

计算机的2个动力：做的更多、做的更快。

当CPU同时做更多事情时，这两个因素都会改进。

并发(concurrency)是一个通用的概念，指一个同时具有多个活动的系统。
并行(parallelism)指的是用并发来使一个系统运行的更快。

并行可以在计算机的多个抽象层次上运用。

1) 线程级并发
通过在不同进程间快速切换来实现的，这种并发是 模拟 出来的。

随着 多核 + 超线程(hyperthreading) 的出现， => 多处理器系统变得普遍了。

图1-17 4核CPU，每个核都有自己的 L1 和L2 高速缓存。
	其中L1高速缓存分为2个部分: 一个保存最近取到的指令，一个存放数据。
	这些核共享更高层次的高速缓存(L3)，以及到主存的接口。


超线程，也叫 同时多线程(simultaneous multi-threading)，是一项允许一个CPU执行多个控制流的技术。
	Interl Core i7 处理器可以让每个核执行2个线程，所以4核的系统实际上可以并行执行8个线程。


多好处理器从2个方面提高系统新能：
	1. 减少了执行多个任务时模拟并发的需求。
	2. 可以并行让应用程序运行的更快
	第12章 并发。



2) 指令级并行
在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为 指令级并发。

一个时钟周期执行一条指令。超过1条指令，则称为超标量(super scalar)处理器。


3) 单指令、多数据并行: SIMD并行
多是为了提高处理影像、声音和视频数据应用的执行速度。





(4) 计算机系统中抽象的重要性

抽象 的使用是计算机科学中最为重要的概念之一。
	例如，为一组函数规定一个简单的应用程序接口API就是一个很好的编程习惯，程序员无需了解它的内部细节便可以工作。
	不同的编程语言提供了不同形式和等级的抽象支持，例如 Java类的声明和C语言的函数原型。


已经介绍的几个抽象：
	文件，是IO设备的抽象
	虚拟内存，是主存+IO设备的抽象
	指令集架构，提供了对实际处理器硬件的抽象。
		使用这个抽象，机器代码程序表现的就好像运行在一个一次只执行一条指令的处理器上。
		底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。
		只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。
	虚拟机，是IO设备+主存+处理器+操作系统的抽象。

计算机系统中一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。


学习OS时，我们介绍了三个抽象：
	文件是对IO设备的抽象
	虚拟内存是对程序存储器的抽象
	进程是对正在运行的程序的抽象。
	新增：虚拟机，提供对整个计算机的抽象，包括操作系统、处理器、程序。
		虚拟机的思想是IBM在20世纪60年代提出来的，但最近才显示出其管理计算机方式上的优势。
		因为一些计算机必须能够运行为不同操作系统或同一OS的不同版本设计的程序。






========================================
第一部分 程序结构和执行
----------------------------------------
计算机由处理器和存储器子系统组成。





========================================
2 信息的表示和处理
----------------------------------------
1.
无符号(unsigned)编码基于传统的二进制表示法，大于或等于0的数字。
补码(two's-complement)编码是表示有符号整数的最常见的方式：正或负。
浮点数(floating-point) 编码是表示实数的科学计数法的以2为基数的版本。

当结果太大不能表示时，某些运算就会溢出（overflow）

$ cat a1.c 
#include<stdio.h>
int main(){
	int a=200*300*400*500;
	printf("a=%d\n", a);
}

$ gcc a1.c 
a1.c: In function ‘main’:
a1.c:3:19: warning: integer overflow in expression of type ‘int’ results in ‘-884901888’
...

$ ./a.out 
a=-884901888



浮点数过小也不行。
整数的表示虽然有范围，但是是精确表示。
浮点数的表示范围更大，但是只是近似表示。

$ cat a2.c 
#include<stdio.h>
int main(){
	double a1=(3.14+1e20)-1e20;
	double a2=3.14+(1e20-1e20);
	printf("a1=%f\n", a1);
	printf("a2=%f\n", a2);
}

$ gcc a2.c
$ ./a.out 
a1=0.000000
a2=3.140000



这是因为 double 的最值
$ cat a3.c 
#include<stdio.h>
#include <float.h>
int main(){
	//DBL_MAX：double型的最大值
	//DBL_MIN：double型的最小值
	double m1=DBL_MAX;
	double m2=DBL_MIN;
	printf("size(double) = %ld\n", sizeof(double));
	printf("max=%le, addr:%p\n", m1, &m1);
	printf("min=%le, addr:%p\n", m2, &m2);
}

$ gcc a3.c
$ ./a.out 
size(double) = 8
max=1.797693e+308, addr:0x7ffc05877878
min=2.225074e-308, addr:0x7ffc05877880


$ cat a3.cpp 
#include<iostream>
#include <cfloat>
using namespace std;
int main(){
	double m1=DBL_MAX;
	double m2=DBL_MIN;
	cout << "size(double) = " << sizeof(double) << endl;
	cout << "max=" << m1 << ", addr:" << &m1 << endl;;
	cout << "min=" << m2 << ", addr:" << &m2 << endl;
}

$ g++ a3.cpp 
$ ./a.out 
size(double) = 8
max=1.79769e+308, addr:0x7ffdad776f28
min=2.22507e-308, addr:0x7ffdad776f30



(1). 信息存储
二进制与16进制的转换：4个二进制位 对应 一个16进制位

当值x是2的非负整数n次幂时，即x=2^n，则x写成二进制就是 1后面跟着n个0。
	16进制0 代表4个二进制0
	当n=i+4j, 0<=i<=3 的形式时，x写成16进制数就是 1(i=0), 2(i=1), 4(i=2) 或者 8(i=3)，后面跟着j个16进制的0.
		比如 2048=2^11，我们有 n=11=3+4*2，从而得到其16进制表示为 0x800



(2). 字长

对于一个字长为w的机器，其虚拟地址的范围为 0 ~ 2^w -1，程序最多访问 2^w 个字节，也即是支持的最大内存大小。

32位的系统，最多支持4k兆字节(4GB)。
64位的系统，最多支持 2^64/1024**3 = 17179869184 GB = 17179869184/1024**3 EB=16 EB = 1.84e19 bit
16

> 2**32/1024**3
4

> 2**64/1024**3
17179869184

> 2**64/1e19
1.8446744073709551


$ gcc -m32 prog.c #可以在32位机器运行，也能在 64 位机器运行
$ gcc -m64 prog.c #只能在 64 位机器运行




(3). 寻址

对象的地址为所使用字节中最小的地址。

最低有效字节在前面(地址低位)的，称为 小端法(little endian), 常用的 intel PC 就是。
	最常用的OS: Android 和 iOS 却只能运行于小端模式。
	小端逻辑合理：数字的低位放在内存的低位，数字的高位放在内存的高位。
最高有效字节在前面(地址高位)的，称为 大端法(big endian)
	IBM和Oracle的大多数机器使用大端模式。
	大端符合书写习惯，从地址低位到高位，依次是数字的高位到低位，和书写顺序一致。


一个机器不用关心这个问题。
多个变量之间也不用关心。
大小端是一个变量内的排列方式。

但是
i) 不同类型机器通过网络传输二进制数据时，字里的字节成了反序。
	避免方法：网络应用的编写必须遵守已建立的关于字节顺序的规则，发送前转为网络标准，接收后转为内部表示。
ii) 阅读整数数据的字节序列时，字节顺序也很重要。
	检查机器级程序时，看16进制。
ii) 编写规避正常的类型系统的程序时。
强制类型转换(cast) 或 联合(union) 允许一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。
	这对高级编程来说非常有用，甚至是必需的。



2) 测试程序
#include<stdio.h>

// csapp P32 字节表示的示例
typedef unsigned char *byte_ptr;
// 使用 typedef 给数据命名，能极大的提高代码的可读性。因为深度嵌套的类型声明很难读懂。


void show_bytes(byte_ptr start, size_t len){
    size_t i;
    for(i=0; i<len; i++){
        printf(" %.2x", start[i]); //todo??
    }
    printf("\n");
}

//显示int的二进制：从地址低位到高位
void show_int(int x){
    show_bytes( (byte_ptr) &x, sizeof(int) );
}

//显示float的二进制：
void show_float(float x){
    show_bytes( (byte_ptr) &x, sizeof(float) );
}

void show_pointer(void *x){
    show_bytes( (byte_ptr) &x, sizeof(void *) );
}

//测试 
void test_show_bytes(int val){
    int ival = val;
    float fval=(float)val;
    int *pval=&ival;
    show_int(val); //39 30 00 00
    show_float(fval);
    show_pointer(pval);
}

int main(){
    int y=12345;
    printf("y=%d, 0x%X\n", y, y); //y=12345, 0x3039
    test_show_bytes(y);

    return 0;
}
/*
y=12345, 0x3039
 39 30 00 00
 00 e4 40 46
 98 a6 4a 7e ff 7f 00 00
数字的最低位 39 最先打印出来，说明该机器是小端法。
指针与众不同，是8位的。
*/

Tips: $ man asciii # 显示一张 ASCII 字符码的表



(4) 表示字符串 

$ cat 18_str_as_char.cpp
#include<stdio.h>
#include<string.h>
void show_bytes(unsigned char * start, size_t len){
    size_t i;
    for(i=0; i<len; i++){
        printf(" %.2x", start[i]); //todo??
    }
    printf("\n");
}

void test1(){
	char p[] ={'1', '2', '3', '4', '5', '\0'};
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, sizeof(p) ); //获取数组的长度 = 字符串长度+1
}

void test2(){
	const char *p ="12345";
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, strlen(p)+1 );//实际占用长度 = 字符串长度 + 1
}

void test3(){
	const char *p ="abcdef";
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, strlen(p)+1 );
}

int main(){
    test1();
	test2();
	test3();
	
	return 0;
}

输出:
12345
 31 32 33 34 35 00
12345
 31 32 33 34 35 00
abcdef
 61 62 63 64 65 66 00

注意：使用 ASCII 码作为字符码的任何系统都能得到相同的结果，与字节顺序和字节大小无关。
因此，文本数据比二进制数据具有更强的平台独立性。



(5) 表示代码

不同机器类型使用不同且不兼容的指令和编码方式。

二进制代码是不兼容的。


(6) 布尔代数简介

~ 表示 NOT
& 表示 AND
| 表示 OR
^ 表示 Exclusive-or 相同为0，不同为1


位向量掩码，有选择的屏蔽一些信号，其中某一位上为1时，表示信号i是有效的；而0表示屏蔽该信号。
	这个掩码表示的就是设置为 有效信号 的集合。



(7) C语言的位运算
怎么打印 1 byte 的二进制？
怎么打印 1 int = 4byte 的二进制？

#include<stdio.h>

//打印1byte = 8bits的二进制表示
void show_byte(const unsigned char * ptr, int enter) {
    unsigned char j=*ptr;
    for(int i=7; i>=0; i--){
        printf("%s", (*ptr & (1<<i))==0? "0":"1" );
    }
    printf(" ");
    if(enter) printf("\n");
}

// 打印int的二进制，是4个字节
void show_int(int *ptr, int enter){
    //假设是小端，先打印最后一个字节
    for(int i=3; i>=0; i--){
        /* 方法1 可以
        unsigned char *p=(unsigned char*) ptr + i;
        show_byte((unsigned char *)p, 0);
        */
        //方法2 也可以: 优先级是 强制转换 > 加号
        show_byte( (unsigned char *)ptr+i, 0);
    }
    if(enter) printf("\n");
}

int main(){
    // a char
    char s='A';
    show_byte( &s, 0);
    printf(" %c %d\n", s, s);
    
    // an int
    int a=-2;  //0x41;
    show_byte( (char *)&a, 0);
    printf(" %d\n", a);
    show_int(&a, 0);
    printf(" %d\n", a);
}

$ gcc 17_print_binary.c 
$ ./a.out 
01000001  A 65
11111110  -2
11111111 11111111 11111111 11111110  -2



位运算的一个常见用法就是实现掩码运算
	掩码是一个位模式，表示从一个数中选出的位的集合。
	比如，掩码 0xFF(最低的8位为1)表示一个字的低位字节。
	位级运算 x & 0xFF 生成一个由x的最低有效字节组成的值，而其他字节被置为0.
		比如，对于 x=0x89ABCDEF，则 x&0xFF=0x000000EF。
	表达式 ~0 将生成一个全是1的掩码，不管机器的字大小是多少。而直接写成 0xFFFFFFFF(32位机器)则不具有可移植性。



(8) C 语言中的逻辑运算

C语言的逻辑运算符 ||, &&, ! 分别对应命题逻辑中的 OR, AND, NOT运算。
逻辑运算和位运算不能搞混，他们功能不同。

逻辑运算认为：
	非0的数都是TRUE，只有0表示FALSE
	逻辑运算符的&&和||如果第一个参数就能确定结果，那么就跳过第二个参数的计算过程。
		因此，表达式 a&&5/a 将不会造成被零除
		表达式 p&&*p++也不会导致间接引用空指针


(9) C 语言的移位运算

移位运算从左到右可结合， x<<j<<k 等价于 (x<<j)<<k

左移，相当于*2，会舍弃最高位。

而右移，则分为两种形式：逻辑右移和算术右移。
	逻辑右移在左侧高位补零；
	算术右移在左端补k个最高有效位的值，对符号整数数据运算非常有用。

加法 优先级 高于 移位运算。
	1<<2+3<<4，等价于 1<<(2+3)<<4






2. 整数表示


(1) 无符号数的编码

(2) 补码编码
最高位1 表示负，
最高位0 表示非负：包括0和正数。

为了防止有 1000 和 0000 这两个 -0和+0(浪费了一个编码)，规定了补码。

正数的补码就是原码；
负数的补码，就是原码取反，再加1。

假设4bit，
能表示的最小数字是 1000 就是除最高位是1，其余全是0，十进制就是 -2^3=-8
能表示的最大数字是 0111 就是除最高位是0，其余全是1，十进制就是 2^3 - 1=7

补码取值范围不是对称的：负数的取值范围比整数的范围大1。 abs(Tmin) = Tmax + 1


(3) 强制类型转换保持位值不变，只是改变了解释这些位的方式。

#include<stdio.h>

int main(){
    short a=-12345;
    unsigned short *b=(unsigned short *)&a;
    printf("sizeof short:%ld, u s:%ld\n", sizeof(a), sizeof(*b));
    printf("s=%d(%p), us=%u(%p)\n", a,&a, *b,b);
}

/*
s=-12345, us=53191
*/

(4) C语言中的有符号数与无符号数

大多数系统遵循的原则是底层的位保持不变。

limits.h 中规定是怎么写的呢？

#include<stdio.h>
#include <limits.h>
/*
#define INT_MAX 2147483647
#define INT_MMIN (-INT_MAX - 1)
*/

int main(){
    int x1=INT_MAX, x2=INT_MIN;
    printf("int max: %d, min: %d\n", x1, x2);
    
    x1+=1; x2-=1;
    printf("int max: %d, min: %d\n", x1, x2);
}

// int max: 2147483647, min: -2147483648
// int max: -2147483648, min: 2147483647

这是一个循环，最大的数+1就变成最小的数了；最小的数-1就变成最大的数了。



(5) 截断数字

int x=53191;
short sx=(short) x;
int y=sx;


可运行程序:
$ cat a6_trunc_int.c 
#include<stdio.h>
#include "a0_lib.c"

int main(){
    int x=53191;
    short sx=(short) x;
    int y=sx;

    // length
    printf("sizeof int:%ld, short:%ld\n", sizeof(x), sizeof(sx));
    // value
    printf("int %d, short: %d\n", x, sx);

    // 查看二进制表示: 发现short是丢弃了int的高位2个字节
    show_bytes(&x, sizeof(x), 0); printf(" int(%ld) %d\n", sizeof(int), x);
    show_bytes(&sx, sizeof(sx), 0); printf(" short(%ld) %d\n", sizeof(short), sx);

    return 0;
}

$ gcc a6_trunc_int.c 
$ ./a.out 
sizeof int:4, short:2
int 53191, short: -12345
00000000 00000000 11001111 11000111  int(4) 53191
11001111 11000111  short(2) -12345



(6) 有符号数与无符号数的建议

无符号数字转为有符号数字时容易出错误。
	1U - 2U >0 // 结果是一个正数!!
	1U < 2U //这样写才对

尽量使用有符号数。
	Java 就只有 有符号数字。







3. 整数运算

问题：为什么 2个正数相加会得到负数？而比较表达式 x<y 和 x-y<0 会产生不同的结果？
原因：计算机运算的有限性造成的。
溢出导致正数变负数：最大的正数+1得到最大的负数。
两个无符号数字相减，如果结果是负的，则会自动变正的：无符号0-1=最大正数。


(1) 无符号加法
对于一个4位的字长，求和的结果可能需要5位来保存。

Lisp 就支持无线精度，当然受限于总内存量。

(2) 补码加法

对于任意正数x，计算表达式 -x 和 ~x+1 得到的结果完全相同。





4. 浮点数

(1) IEEE 标准 756: 浮点标准

(4) 舍入

向偶数舍入：将数字向上或向下舍入，使得结果的最低有效数字是偶数。
	将 1.5 和 2.5 都舍入为2。

向0舍入：
向下舍入：
向上舍入：

(5) 浮点运算

(6) C 语言中的浮点数

强制转换时，有可能舍入 和/或 溢出。




5. 小结

在位级别上理解 IEEE 754 编码浮点数。
	浮点数只有有限的范围和精度，且不遵守普遍的算术属性，比如 结合性。








6. 本章共98个习题
作业: P88->P97
参考答案: P97->P108

(1) 确定你能访问的不同机器的大小端
指针法、共用体法。
写函数 int is_little_endian(); 小端返回1，大端返回0。
无论机器的字长是多少：32位 or 64 位。



(2) 




Chapter2 logs: 日志使用pdf页码 rP(相对页码)，内容使用真实页码P
2022.10.17 rP61 ->rP73
2022.10.18 rP78
2022.10.21 rP85, rP96
2022.10.22 rP112
2022.10.28 rP119 浮点数没看懂。->rP145





========================================
3 机器语言: 程序的机器级表示
----------------------------------------
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。

gcc 以汇编代码 的形式产生输出，汇编是机器代码的文本表示，给出程序的每一条指令。
然后gcc调用汇编器和链接器，根据汇编代码生成可执行的机器代码。
本章我们近距离地观察机器代码，以及人类可读的表示--汇编代码。

即使编译器做了大部分工作，能够阅读和理解汇编仍是一项重要的技能。

通过编译器选项，产生汇编文件，阅读这个文件，能理解编译器的优化能力，并分析代码中隐含的低效率。

如使用线程包写并发程序时，了解不同线程如何共享数据或保持私有数据的，以及准确知道如何在哪里访问共享数据，都很重要。这些数据在机器代码级是可见的。


快速浏览C语言、汇编代码以及机器代码之间的关系。
从数据的表示和处理以及控制的实现开始。介绍x86-64的细节。由Interl和AMD共同完成。
	程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。
	机器级表示数组、结构和联合数据结构。
	内存访问越界问题
	系统容易遭受缓冲区溢出攻击的问题。
	用GDB调试器检查机器级程序运行时行为的技巧。
	浮点数据和操作的代码的机器程序表示。


1. 历史观点


2. 程序编码

$ cat p1.c 
int Max(int x, int y){
	if(x>y) return x;
	return y;
}

$ cat p2.c 
#include<stdio.h>
extern int Max(int, int);
int main(){
	int a1=1, a2=2;
	int x=Max(a1, a2);
	printf("Max(%d, %d)=%d\n", a1, a2, x);
}

$ gcc -Og -o a.out p1.c p2.c

$ gcc -std=c11 -Og -o a.out p1.c p2.c
$ ./a.out
Max(1, 2)=2


其中 -Og 是让编译器产生符合原始C代码整体结构的机器代码的优先等级。
使用较高等级优化产生的代码会严重变形，以至于产生的机器代码和源代码之间的关系非常难以理解。
学习，使用 -Og;
为了高性能，可增加优化级，比如 -O1 或 -O2。






(1) 机器级代码

两种重要的抽象很重要:
	1. CPU的指令集架构(Instruction Set Architeture, ISA)
	2. 机器级程序使用的内存地址是虚拟地址。

汇编与二进制机器代码相比，可读性更好。
能够理解汇编代码和原始C代码的联系，是理解计算机如何执行程序的关键一步。

x86-64 的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的：
	* 程序计数器(通常称为PC，在x86-64中使用 %rip 表示): 给出将要执行的下一条指令在内存中的地址。
	* 整数寄存器文件：包含16个命名的位置，分别存储64位的值。可以保存地址(C语言的指针)或整数数据。有些记录重要的程序状态、临时变量(过程的参数、局部变量、函数返回值)
	* 条件码寄存器：最近执行的算术或逻辑指令的状态信息。实现控制或者数据流中的条件变化，比如用来实现 if 和 while 语句。
	* 一组向量寄存器可以存放一个或多个整数或浮点数值。


虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。
	C语言有数组和结构等，机器代码用一组连续的字节来表示。
	对标量，机器代码也不区分是否有符号。
	不区分各种类型的指针，甚至不区分指针和整数。

操作系统负责将虚拟地址空间，翻译成实际处理器内存中的物理地址。
机器代码依赖于硬件，且gcc也在不断修正生成的机器代码，所以可能和课本显示的有差异，仔细思考。


1) 使用-S产生汇编代码.s

$ cat p3.c
long mult2(long, long);

void multstore(long x, long y, long *dest){
	long t = mult2(x, y);
	*dest = t;
}

##gcc -Og -S mstore.c #生成汇编代码
$ gcc -Og -S -o mstore.s p3.c

$ cat mstore.s #汇编语言包括这几行：
...
multstore:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
...

每个缩进的行（不以.开头的行）都对应一条机器指令：
	pushq 指令表示将寄存器%rbx的内容压入程序栈中。
	这段代码已经去除了所有关于局部变量名或数据类型的信息。






2) 使用-c编译成目标文件.o

$ gcc -std=c11 -Og -c p3.c
$ ls -lt
-rw-rw-r-- 1 wangjl wangjl  1544 Oct 28 16:19 p3.o

$ cat p3.o
乱码，二进制不能直接查看。

怎么看字节的16进制表示？使用 gdb:

$ gdb p3.o
(gdb) x/18xb multstore
0x0 <multstore>:	0xf3	0x0f	0x1e	0xfa	0x53	0x48	0x89	0xd3
0x8 <multstore+8>:	0xe8	0x00	0x00	0x00	0x00	0x48	0x89	0x03
0x10 <multstore+16>:	0x5b	0xc3
(gdb) q

其中 multstore 就是上面汇编中的函数名。
显示的14字节的序列，这就是上面那一段汇编指令对应的目标代码。
机器执行的程序只是一个字节序列，它是一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

解释 gdb 命令，x表示显示，从函数 multistore 所处地址开始的 18 个十六进制格式表示(夜间写作x)的字节(简写为b)。
GDB分析机器级程序，见 3.10.2






3) 要查看机器代码文件的内容，有一类称为 反汇编(disassembler)的程序非常有用。
根据机器代码产生类似于汇编代码的格式。 linux下的 objdump -d xx.o 可以执行该任务。

$ man objdump
NAME
       objdump - display information from object files
...


$ objdump -d p3.o

p3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   f3 0f 1e fa             endbr64 
   4:   53                      push   %rbx
   5:   48 89 d3                mov    %rdx,%rbx
   8:   e8 00 00 00 00          callq  d <multstore+0xd>
   d:   48 89 03                mov    %rax,(%rbx)
  10:   5b                      pop    %rbx
  11:   c3                      retq 
注解:
Offset:  Bytes                  Equivalent assembly language
每组1-5个字节，每组对应一条指令，右边是等价的汇编语言。

一些关于机器代码和它的反汇编表示的特性值值的注意：
* x86-64 的指令长度从1-15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，不常用或操作数较多的指令需要的字节数较多。
* 设计指令格式的方法是：从某个给定位置开始，可以将字节唯一的解码成机器指令。
	例如，只有指令 pushq %rbx 是以字节值53开头的
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问源代码或汇编代码。
* 反汇编器使用的指令命名规则与GCC生成的汇编代码有细微差别。
	我们的例子中，反汇编省略了q，比如 pushq->push; 有的增加了q，比如 call->callq; 这些后缀是大小指示符，在大多数情况下可以省略。





4) 生成时间可执行的代码
需要对一组目标代码文件运行链接器，且这一组目标代码文件中必须含有一个 main 函数。
$ cat main.c 
#include<stdio.h>
void multstore(long, long, long*);

int main(){
	long d;
	multstore(2, 3, &d);
	printf("2 * 3 --> %ld\n", d);
	return 0;
}

long mult2(long a, long b){
	long s=a*b;
	return s;
}

生成可执行文件:
$ gcc -std=c11 -Og -o a.out main.c p3.c
$ ./a.out 
2 * 3 --> 6

执行反汇编:
$ objdump -d a.out
...
00000000000011d5 <multstore>:
    11d5:       f3 0f 1e fa             endbr64 
    11d9:       53                      push   %rbx
    11da:       48 89 d3                mov    %rdx,%rbx
    11dd:       e8 e7 ff ff ff          callq  11c9 <mult2>
    11e2:       48 89 03                mov    %rax,(%rbx)
    11e5:       5b                      pop    %rbx
    11e6:       c3                      retq   
    11e7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
    11ee:       00 00 
...

这段与 p3.c 反汇编产生的代码几乎完全一样。主要区别是左边列出的地址不同：
	* 链接器将这段代码的地址移到了一段不同的地址范围中。
	* 第二个不同，链接器填上了 allq 指令调用函数 mult2 需要使用的地址。
		链接器的任务之一，为函数调用找到匹配的函数的可执行代码的位置。
	* 第三个区别是，多了两行代码。这两行在返回语句 retq 后面，对程序没有影响。
		插入这两行是为了使函数代码变为16字节，有利于存储器系统性能，更好的放下一个代码块。







(3) 关于格式的注解

以.开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。


===> gcc和objdump 使用的是 ATT格式的汇编，怎么输出Intel格式的汇编呢？
$ gcc -Og -S -masm=intel p3.c
$ less p3.s
...
multstore:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	mov	rbx, rdx
	call	mult2@PLT
	mov	QWORD PTR [rbx], rax
	pop	rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
...


可见，Intel格式与ATT格式有所不同：
* Intel格式省略了指示大小的后缀。使用指令 push 和 mov，而不是 pushq 和 movq
* Intel代码省略了寄存器名字前面的%符号，用的是 rbx，而不是 %rbx。
* Intel代码用不同的方式来描述内存中的位置，使用 'QWORD PTR [rbx]' 而不是 '(%rbx)'
* 在带有多个操作数的指令情况下，列出来的操作数的顺序相反。当两种格式之间进行转换的时候，这一点非常令人困惑。

虽然本书不使用 Intel 格式，但是来自 Intel 和 Microsoft 的文档中会遇到它。







===> 把C程序和汇编代码结合起来
P118






3. 数据格式

gcc生产的汇编代码指令都有一个字符的后缀，表明操作数的大小。
比如，数据传送指令有4个变种:
	movb 传送字节
	movw 传送字 
	movl 传送双字
	movq 传送四字

汇编使用l来表示4字节整数和8字节双精度浮点数。
但汇编的浮点数使用完全不同的指令和寄存器，所以不会产生歧义。







4. 访问信息 

一个 x86-64 的中央处理器(CPU)包含一组16个存储64位值的 通用目的寄存器。
这些寄存器用来保存整数数据和指针。

图3-2(P119) 展示了16个寄存器，名字都是 %r 开头，后面跟着不同命名规则的名字，历史演化造成的。
	最初的 8086 有8个 【16 位】的寄存器，%ax 到 %bp，每个寄存器都有特殊的用途，名字反应其用途；
	扩展到IA32架构时，寄存器也扩展成 【32 位】，标号从 %eax 到 %ebp
	扩展到x86-64后，原来的8个寄存器扩展到【64位】，标号从 %rax 到  %rbp。
		还新增 8个寄存器，新命名规则 %r8 到 %r15
		记录最新的前8个寄存器名字和作用，现在都是 64 位:
			%rax 返回值
			%rbx 被调用者保存
			%rcx 第四个参数
			%rdx 第三个参数
			%rsi 第二个参数
			%rdi 第一个参数
			%rbp 被调用者保存 
			%rsp 栈指针

指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。
字节级操作可以访问最低的字节，
16位操作可以访问最低的2个字节
32位操作可以访问最低的4个字节
64位操作可以访问最低的8个字节= 8*8=64，整个寄存器。


后面的会展示很多指令，复制和生成 1字节、2字节、4字节、8字节值。
	但这些指令以寄存器为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会这么样，对此有两条规则：
		* 生成1字节或2字节数字的指令会保持剩下的字节不变
		* 生成4字节数字的指令会把最高位4个字节置为0。
		后面这条规则，是从IA32到x86-64的扩展的一部分而采用的。

常见的程序中，寄存器扮演不同的角色。
	* 最特别的是 栈指针 %rsp，用来知名运行时栈的结束位置。有些程序会明确的读写该寄存器。
	* 另外15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。
	更重要的是，有一组规范，控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值，以及存储局部和临时数据。


(1) 操作数指示符

大多数指令有一个或多个 操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
操作数有3类:
	1.立即数 immediate: 常数值，$后跟一个C表示整数，如 $-577 或 $0x1F
	2.寄存器 register: 表示某个寄存器的内容，16个寄存器的低位1/2/4/8字节中的一个作为操作数
		用符号 ra表示任意寄存器a，用引用 R[ra]来表示它的值，这是把寄存器集合看成一个数组R，用寄存器标识符作为索引。
	3.内存引用，根据计算出来的地址（称为有效地址）访问某个内存位置。
		将内存看成一个很大的字节数组，用符号 Mb[addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。
		为了简单，通常省去下标b。
		多种不同的 寻址模式，允许不同形式的内存引用。
		语法 Imm(rb, ri, s) 表示的是最常用的形式。有4个部分:
			立即数偏移 Imm
			一个基址寄存器 rb
			一个变址寄存器 ri
			一个比例因子s，这里s必须是1/2/4/8。
		* 基址和变址寄存器都必须是64位寄存器。
		* 有效地址被计算为 Imm + R[rb] + R[ri]*s
		* 引用数组元素时，会用到这种通用形式。
		* 其他形式都是这种通用形式的特殊情况，只是省略了某些部分。
		* 我们将看到：当引用数组和结构元素时，比较复杂的寻址模式是很有用的。
	
图 3-3 操作数格式。操作数可以表示立即数(常数)值、寄存器值或是来自内存的值。比例因子s必须是1/2/4/8 

$ cat p4_2.c
#include<stdio.h>
int main(){
	int arr[5]={0,1,2,3,4};
	printf("%d\n", arr[3]);
}

$ gcc -Og p4_2.c 
$ ./a.out 
3

$ objdump -d a.out >dustbin/a1.s
保存结果，通过 diff 比较差异。






(2) 数据传送指令 

最频繁的指令就是将数据从一个位置复制到另一位置的指令。

指令类，每一类中的指令执行相同的操作，只不过操作数大小不同。

1) 最简单的 mov 类：从源位置复制到目的位置，不做任何变化。
  有四个指令组成 movb, movw, movl, movq。区别是操作数大小不同，分别是1/2/4/8字节。

指令     /效果     /描述
MOV S,D  / S-->D   传送

souce 源操作数指定一个立即数，存储在寄存器中或者内存中。
dest 目的操作数是一个位置，要么是一个寄存器，要么是一个内存地址。
s和d不能是同一个内存位置。

把一个值从内存位置1复制到内存位置2需要2条指令:
	1 把源值加载到寄存器中
	2 把该寄存器值写入内存地址2
	这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分大小必须和指令最后一个字符('b', 'w', 'l', 'q')指定的大小匹配。

mov 指令通常只更新目的操作数指定的那些寄存器字节或内存位置。
唯一的例外是 movl指令向寄存器写入时，会把寄存器的高位4字节设置为0。
	这个例外是x86-64采用的惯例：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。

下面是mov指令，给出了源和目的类型的5种可能的组合。第一个是源 操作数，第二个是目的操作数。
1 movl %0x4050,%eax     immediate-> Register,  4bytes
2 movw %bp,%sp         Register->Register, 2bytes
3 movb (%rdi,%rcx),%al   Memory->Register,1byte
4 movb %-17,(%rsp)      Immediate->Memory, 1byte 
5 movq %rax,-12(%rbp)   Register->Memory, 8bytes


MOVZ 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。
	指令最后2个字符都是大小指示符：第一个是源的大小，第二个是目的的大小。
	这两个类中每个都有三条指令，包括了所有的源大小为1个和2个字节，目的大小为2个和4个的情况，当然只考虑目的大于源的情况。
	MOVZ S,R   零扩展S-->R 用零扩展填充高位
	movzbw
	

==> 理解数据传送如何改变目的寄存器








(3) 数据传送示例

C语言代码:
long exchange(long *xp, long y){
    long x=*xp;
    *xp=y;
    return x;
}

$ gcc -Og p4_2.c
$ ./a.out
$ objdump -d a.out >dustbin/a1.s
汇编:
0000000000001191 <exchange>:
    1191:	f3 0f 1e fa          	endbr64 
    1195:	48 8b 07             	mov    (%rdi),%rax   //把第一个参数移动到返回值寄存器
    1198:	48 89 37             	mov    %rsi,(%rdi)   //把第二个参数移动到第一个参数上
    119b:	c3                   	retq                 //返回

分析过程：
进入函数时，xp 和 y 分别存储在寄存器 %rdi和%rsi中。
然后指令2从内存中读出x，把它存放到寄存器%rax中，实现了 x=%xp;
	稍后，用寄存器 %rax 从这个函数返回一个值，因此返回值就是x。
接着指令将y写入就餐器%rdi中xp指向的内存位置，直接实现了 *xp=y。
这个例子展示了mov指令如何
	读取内存到寄存器
	从寄存器写入内存。


这段汇编代码有两点需要注意: 
	1.C语言的所谓指针，其实就是地址。
	间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
	2.像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。



==> 给C语言初学者: 指针的一些示例




(4) 压入和弹出栈数据

栈：先进先出。
x86-64中，栈向下增长，栈顶地址是栈中元素地址中最低的。

push 操作把数据压入栈。
	指令 pushq S 
	效果 R[%rsp]<-R[%rsp]-8; M[R[%rsp]]<-S;
	描述 将四字压入栈。
	
pop 操作删除数据。
	指令 popq D
	效果 D<-M[R[%rsp]]; R[%rsp]<-R[%rsp]+8
	描述 将四字弹出栈
		弹出的永远是最近被压入且仍然在栈中的值。


将四字压入栈，首先将指针减8，然后将值写到新的栈顶地址。
	因此，指令 pushq %rbp 的行为等价于下面两条指令:
	subq $8,%rsp
	movq %rbp,(%rsp)
	区别是: 一条指令1个字节，等价的2条指令共需要8个字节。


弹出一个4字的操作包括从栈顶位置读出数据，然后栈指针加8.
	因此 popq %rax 等价于下面2条指令
	movq (%rsp),%rax
	addq $8,%rsp

	而 movq 8(%rsp),%rdx 会将第二个四字从栈中复制到寄存器 %rdx。










5. 算术与逻辑操作 (P129)

这些操作分成4组:
	加载有效地址 leaq
	一元操作 INC, DEC, NEG, NOT
	二元操作 ADD, SUB, IMUL, XOR, OR, AND 
	移位
		SAL k,D  D<-D<<k 左移动
		SHL k,D  左移(等同于SAL)
		SAR k,D  算术右移
		SHR k,D  逻辑右移


(1) 加载有效地址 (load effective address)

leaq 7(%rdx,%rdx,4),%rax   #将%rax的值设置为 7+(x+4*x)=5*x +7

C 代码 
long scale(long x, long y, long z){
	long t=x+4*y+12*z;
	return t;
}

汇编 
$ gcc -Og p5_leaq.c
$ objdump -d a.out 
...
0000000000001149 <scale>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       48 8d 04 b7             lea    (%rdi,%rsi,4),%rax   #x+4*y
    1151:       48 8d 14 52             lea    (%rdx,%rdx,2),%rdx   #z+2*z=3*z
    1155:       48 8d 04 90             lea    (%rax,%rdx,4),%rax   #(x+4*y) + (3*z)*4 = x+4*y+12*z
    1159:       c3                      retq  
...

leaq 指令能执行加法和有限形式的乘法。





























========================================
################## /// *** ==> logs && cur: rP 166/775 (21.4%)
----------------------------------------
使用程序库: 
	Yi /data/wangjl/project/linux_C
	https://github.com/miostudio/linux_C

Chapter2 logs:
2022.10.28 rP145 -> rP153 -> rP155
2022.11.1 rP157 这一段太晦涩难懂了，讲汇编，需要清醒时看。
2022.11.3 rP162 mov 汇编与指针
2022.11.13 rP166 leaq 指令









========================================
4 处理器体系结构
----------------------------------------




========================================
// todo chapter
----------------------------------------
	5 代码优化
	6 存储器层次结构


编译原理:
	直接看编译后的代码: https://godbolt.org/




========================================
第二部分 在系统上运行程序
----------------------------------------





========================================
7 链接
----------------------------------------

	8 异常控制流
	9 虚拟内存


========================================
第三部分 程序间的交互和通信
----------------------------------------


========================================
10 系统级I/O 
----------------------------------------

========================================
11 网络编程 
----------------------------------------


========================================
12 并发编程
----------------------------------------








========================================
另一本神书: 《计算机系统设计原理》 Principles of Computer System Design //todo
----------------------------------------
https://book.douban.com/subject/3707841/
https://book.douban.com/subject/4087478/

https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/
http://web.mit.edu/6.033/www/


《计算机系统设计原理(影印版)》由计算机系统设计的权威专家、美国麻省理工学院Saltzer和Kaashoek教授编写。
《计算机系统设计原理(影印版)》是第一本阐述计算机系统设计中的基本原理和抽象的教材，是麻省理工开放式课程计划(MIT Open Courseware)中“计算机系统工程”课程的主教材。

计算机系统的基本原理横跨于操作系统、网络、数据库、分布式系统、程序设计语言、软件工程以及计算机体系结构等方面。通过详细分析每个基本原理的案例，《计算机系统设计原理(影印版)》演示了如何应用这些原理和抽象来解决实际的计算机系统设计问题。

《计算机系统设计原理(影印版)》的重点是计算机系统的设计，因此，《计算机系统设计原理(影印版)》阐述了那些在实践中已证明是成功的抽象概念，如命令、远程过程调用、客户/服务器组织结构、文件系统、事务处理、修复复制、读/写一致性，以及认证与保密消息等概念。这些抽象概念使得计算机系统设计者可以用功能日益强大的模块来构建计算机系统，保护计算机系统避免从意外的编程错误到恶意入侵在内的各种故障。《计算机系统设计原理(影印版)》描述了如何实现这些抽象概念，演示了如何把它们应用于不同的系统，为读者日后的设计工作打下基础。



This text identifies, examines, and illustrates fundamental concepts in computer system design that are common across operating systems, networks, database systems, distributed systems, programming languages, software engineering, security, fault tolerance, and architecture. Through carefully analyzed case studies from each of these disciplines, it demonstrates how to apply these concepts to tackle practical system design problems.

To support the focus on design, the text identifies and explains abstractions that have proven successful in practice such as, 
remote procedure call, 
client/service organization, 
file systems, 
data integrity, 
consistency, 
and authenticated messages. 

Most computer systems are built using a handful of such abstractions. The text describes how these abstractions are implemented, demonstrates how they are used in different systems, and prepares the reader to apply them in future designs.



Features:

Concepts of computer system design guided by fundamental principles.

Cross-cutting approach that identifies abstractions common to networking, operating systems, transaction systems, distributed systems, architecture, and software engineering.

Case studies that make the abstractions real: naming (DNS and the URL); file systems (the UNIX file system); clients and services (NFS); virtualization (virtual machines); scheduling (disk arms); security (TLS).

Numerous pseudocode fragments that provide concrete examples of abstract concepts.

Extensive support. The authors and MIT OpenCourseWare provide on-line, free of charge, open educational resources, including additional chapters, course syllabi, board layouts and slides, lecture videos, and an archive of lecture schedules, class assignments, and design projects.










========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------


