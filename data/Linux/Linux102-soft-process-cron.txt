Linux102-soft-process
软件、进程管理
	RPM软件包管理
定时任务设置与查看





《Linux就该这么学》
https://www.linuxprobe.com/basic-learning-07.html





========================================
Ubuntu 安装程序
----------------------------------------



========================================
|-- github 的主机(ubuntu) 软件安装方法(2023.4.26)
----------------------------------------
1. https://dawneve-crispy-engine-p6p7vjx4v43r94q.github.dev/
GitHub codespace.


(1) 硬盘
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ df -lh
Filesystem      Size  Used Avail Use% Mounted on
overlay          31G   15G   15G  52% /
tmpfs            64M     0   64M   0% /dev
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
shm              64M     0   64M   0% /dev/shm
/dev/sda1        29G   21G  8.0G  73% /usr/sbin/docker-init
/dev/sdb1        32G  224K   30G   1% /tmp
/dev/loop0       31G   15G   15G  52% /workspaces


$ lsblk
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
loop0     7:0    0   32G  0 loop /home/vscode/.minikube
loop1     7:1    0  500M  0 loop 
sda       8:0    0   30G  0 disk 
├─sda1    8:1    0 29.9G  0 part /workspaces/.codespaces/shared
├─sda14   8:14   0    4M  0 part 
└─sda15   8:15   0  106M  0 part 
sdb       8:16   0   32G  0 disk 
└─sdb1    8:17   0   32G  0 part /tmp
sr0      11:0    1  628K  0 rom 

$ htop
4核，8G内存。





(2) 路径
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ echo $PATH
/usr/local/rvm/gems/ruby-3.1.4/bin:
/usr/local/rvm/gems/ruby-3.1.4@global/bin:
/usr/local/rvm/rubies/ruby-3.1.4/bin:

/vscode/bin/linux-x64/704ed70d4fd1c6bd6342c436f1ede30d1cff4710/bin/remote-cli:
/home/codespace/.local/bin:
/home/codespace/.dotnet:
/home/codespace/nvm/current/bin:
/home/codespace/.php/current/bin:
/home/codespace/.python/current/bin:
/home/codespace/java/current/bin:
/home/codespace/.ruby/current/bin:
/home/codespace/.local/bin:

/usr/local/oryx:

/usr/local/go/bin:
/go/bin:

/usr/local/sdkman/bin:
/usr/local/sdkman/candidates/java/current/bin:
/usr/local/sdkman/candidates/gradle/current/bin:
/usr/local/sdkman/candidates/maven/current/bin:
/usr/local/sdkman/candidates/ant/current/bin:

/usr/local/rvm/gems/default/bin:
/usr/local/rvm/gems/default@global/bin:
/usr/local/rvm/rubies/default/bin:
/usr/local/share/rbenv/bin:

/opt/conda/bin:
/usr/local/php/current/bin:
/usr/local/python/current/bin:
/usr/local/py-utils/bin:
/usr/local/nvs:
/usr/local/share/nvm/versions/node/v19.9.0/bin:
/usr/local/hugo/bin:
/usr/local/dotnet/current:
/usr/local/sbin:
/usr/local/bin:
/usr/sbin:
/usr/bin:
/sbin:
/bin:
/usr/local/rvm/bin









2. 常用软件环境

/usr/local/
	python/
	php/
	go/

/usr/bin/gcc/


/home/codespace/  --> 还是 /usr/local/sdkman/
	java/


$ ls -lth /home/codespace/
total 0
lrwxrwxrwx 1 codespace codespace 33 Apr 25 20:06 java -> /usr/local/sdkman/candidates/java
lrwxrwxrwx 1 codespace codespace 20 Apr 25 20:06 nvm -> /usr/local/share/nvm




(1) gcc
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which gcc
/usr/bin/gcc

@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

(2) java
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which java
/home/codespace/java/current/bin/java

@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ java -version
openjdk version "17.0.7" 2023-04-18 LTS
OpenJDK Runtime Environment Microsoft-7626293 (build 17.0.7+7-LTS)
OpenJDK 64-Bit Server VM Microsoft-7626293 (build 17.0.7+7-LTS, mixed mode, sharing)


(3) py and pip
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which python
/home/codespace/.python/current/bin/python
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which python3
/home/codespace/.python/current/bin/python3

@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ python3 -V
Python 3.10.4


@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which pip
/home/codespace/.python/current/bin/pip
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ which pip3
/home/codespace/.python/current/bin/pip3

@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ pip -V
pip 23.1.1 from /usr/local/python/3.10.4/lib/python3.10/site-packages/pip (python 3.10)
@DawnEve ➜ /workspaces/codespaces-jupyter (main) $ pip3 -V
pip 23.1.1 from /usr/local/python/3.10.4/lib/python3.10/site-packages/pip (python 3.10)













========================================
|-- 多版本环境管理工具 sdkman
----------------------------------------
https://blog.csdn.net/xiligey1/article/details/123136985

1. 什么是sdkman
一个管理多个sdk版本的工具，支持Java、Scala、Flink、Spark、Hadoop、Maven、Sbt等

2. 怎么安装
sdkman可用于Mac, Linux, WSL, Cygwin, Solaris 和FreeBSD











========================================
|-- 报错： Ubuntu中Could not get lock /var/lib/dpkg/lock解决方案
----------------------------------------

1. 在Ubuntu中，有时候运用sudo  apt-get install curl 安装软件时，会出现一下的情况
E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)
E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?

2. 问题原因：主要是因为apt还在运行。

3. 解决方案：杀死所有的apt进程。
(1) 查找所有apt相关的进程，并用命令杀死。
$ ps afx|grep apt
15518 ?        RN     0:05          |   |   \_ /usr/bin/python3 /usr/lib/update-notifier/apt-check
15533 pts/25   S+     0:00  |   \_ grep --color=auto apt
13518 ?        Ss     0:00 /bin/sh /usr/lib/apt/apt.systemd.daily install
13522 ?        S      0:00  \_ /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held install
13612 ?        SNl    0:07 /usr/bin/python3 /usr/sbin/aptd

$ sudo kill -9 15518
$ sudo kill -9 13522
$ sudo kill -9 13522
$ sudo kill -9 13612



(2) 删除锁定文件

锁定的文件会阻止 Linux 系统中某些文件或者数据的访问，这个概念也存在于 Windows 或者其他的操作系统中。
一旦你运行了 apt-get 或者 apt 命令，锁定文件将会创建于 /var/lib/apt/lists/、/var/lib/dpkg/、/var/cache/apt/archives/ 中。
这有助于运行中的 apt-get 或者 apt 进程能够避免被其它需要使用相同文件的用户或者系统进程所打断。当该进程执行完毕后，锁定文件将会删除。
所以：
　　1：移除对应目录下的锁文件：
　　2：强制重新配置软件包：
　　3：更新软件包源文件：
$ sudo rm /var/lib/dpkg/lock
$ sudo dpkg --configure -a
$ sudo apt update


(3) 问题解决，执行apt install curl 命令成功。



https://www.cnblogs.com/yun6853992/p/9343816.html




========================================
|-- ubuntu 查看是否apt已经安装过某个包
----------------------------------------
查看是否已经安装
$ apt-cache policy vim
vim:
  Installed: 2:8.0.1453-1ubuntu1.13
  Candidate: 2:8.0.1453-1ubuntu1.13
  Version table:
 *** 2:8.0.1453-1ubuntu1.13 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/main amd64 Packages
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/main amd64 Packages
        100 /var/lib/dpkg/status
     2:8.0.1453-1ubuntu1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/main amd64 Packages






========================================
RPM软件包管理(CentOS)
----------------------------------------
RPM(Redhat Package manager)是针对CentOS系统的软件包格式。
此外，还有yum和源代码格式管理软件。
Ubuntu下是apt-get。CentOS下是yum。

	绝大多数开源软件都是直接以源代码形式发布的。源代码一般会被打包成tar.gz的归档压缩文件。程序源代码需要编译成为二进制形式之后才能运行使用。

Linux软件安装
对于绝大部分软件安装,使用如下步骤即可: 
	1) tar -zxvf ab.tar.gz 或者 tar -jxvf ab.tar.bz2 #解压
	2)cd ab #进入文件夹

	3)./configure [—prefix=] #配置安装环境 
	4)make #编译 
	5)make install #安装
	
?对于一些小部分软件安装,需要使用其他方法安装,如:需要使用cmake安 装、直接使用make安装等等
?安装软件前,最好先阅读README && INSTALL两个文件
?遇到不会安装的：可以求助社区或者作者

	源代码基本编译流程：
	1.	./configure	检查编译环境、相关库文件以及配置参数并生成makefile
	2.	make	对源代码进行编译，生成可执行文件。
	3.	make install	将生成的可执行文件安装到当前计算机中。

	源代码形式的软件使用起来较为麻烦，但是兼容性及可控制性较好。（看着只有三步，但是大多数第一步就进行不下去了！需要大量的经验，主要是依赖关系一般很复杂。即便顺利，一个10M的软件需要编译十几分钟。太漫长了，于是亟待简化Linux下软件安装这个问题！）
	开源软件一般会大量使用其他开源软件的功能，所以开源软件会有大量的依赖关系（使用某软件需要先安装其他软件）。

	使用RPM软件包管理软件
	源代码形式的缺点：操作复杂、编译时间较长、极容易出现错误！
	源代码形式的优点：使用所有系统、可定制。
	为了方便使用，Erik Troan 和 Marc Ewing开发了RPM(redhat Package Manager)。RPM通过将源代码基于特定平台系统编译为可执行文件，并保存依赖关系，来简化开源软件的安装管理。

	RPM设计目标如下：
	- 使用简单
	- 使用单一软件包格式发布文件（rpm文件）
	- 可升级
	- 追踪软件依赖关系
	- 基本信息查询
	- 软件验证功能
	- 支持多平台
	


rpm包有一个约定的命名规范：
	softName-1.2.0-30.el6.i686.rpm
		softName：软件名。
		1.2.0-30：版本号。
		el6：针对red hat enterprize release 6编译的。
		i686：针对32位系统。 x86_64是针对64位的。
	特别注意平台和bits。	
		
rpm基础命令：
	安装命令：rpm -i software.rpm 
	卸载软件：rpm -e software 
	升级形式安装：rpm -U software-new.rpm 
	rpm支持通过http、ftp协议安装软件
	rpm -ivh http://www.xxx.net/software.rpm 
可以加入以下参数：
	-v 显示相关信息
	-h 显示进度条
	

RPM会保存软件相关的很多信息，所以支持很多查询功能。
	rpm -qa 列出所有安装的rp软件 
	rpm -qi desktop-effect	软件信息，安装日期、版本号等
	rpm -ql	desktop-effect 列出属于某软件的文件
	rpm -qf /usr/share/doc/desktop-effects-0.8.4 查询某个文件属于哪个软件包
	
	查询安装之前的rpm信息加参数p即可：
	rpm -qip ncbi-blast-2.4.0+-2.x86_64.rpm		安装之前rpm包的信息
	rpm -qlp ncbi-blast-2.4.0+-2.x86_64.rpm 	查询安装之后可能添加的文件。

	
RPM验证：
防止传播过程中的恶意修改，为了安全现代系统都加入了对软件完整性的校验。
验证一般使用非对称加密算法，所以需要一个秘钥。

导入秘钥：
rpm --import RPM-GPG-KEY-CentOS-6 

验证rpm文件：
rpm -K software.rpm 
例子：$ rpm -K ncbi-blast-2.4.0+-2.x86_64.rpm 
ncbi-blast-2.4.0+-2.x86_64.rpm: sha1 md5 OK

验证已安装的软件是否被修改过：
rpm -V software 


========================================
|-- Yum(Yellowdog Updater, Modified)解决依赖关系: CentOS 设置 本地安装源
----------------------------------------
rpm软件包形式管理软件虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件需要首先安装一个或多个（有时多达上百个）其他软件，手工解决时很复杂。使用YUM可以解决这个问题。

Yum(Yellowdog Updater, Modified)是一个rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系问题。其特点如下：
	- 自动解决依赖关系
	- 可以对rpm进行分组，并基于组进行安装操作
	- 引入仓库概念，支持多个仓库
	- 配置简单






###
仓库概念
yum引入了仓库（repo）的概念，仓库用来存放所有现有的rpm软件包，当使用yum安装一个rpm软件的时候，如果存在依赖关系，会自动在仓库中查找依赖软件并安装。

仓库可以是本地的，也可以通过http、ftp或nfs形式使用集中地、统一的网络仓库。






###
yum仓库的配置
yum使用仓库保存管理rpm软件包，仓库的配置文件保存在/etc/yum.repos.d/目录下，格式如下：

[zzuRepo]
name=This is zzu rpm soft repo
mirrorlist=http://mirrors.zzu.edu.cn/centos/
#baseurl=http://mirror.centos.org/centos/
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
这里有完整版本：http://mirrors.zzu.edu.cn/wiki/centos/download/CentOS6-Base-zzu.repo

[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
	- 仓库可以使用file、http、ftp、nfs方式。
	- yum配置文件必须以.repo结尾，名字随便起。
	- 一个配置文件内可以保存多个仓库的配置信息。
	- /etc/yum.repos.d/目录下可以存在多个配置文件。
	


###
更换repo的方法：
参考
# http://blog.chinaunix.net/uid-23683795-id-3477603.html
# http://jingyan.baidu.com/article/e8cdb32b634c8637052bad04.html
# http://mirrors.zzu.edu.cn/wiki/centos.html
切换root用户，首先备份/etc/yum.repos.d/CentOS-Base.repo 
# cd /etc/yum.repos.d/
# mv CentOS-Base.repo CentOS-Base.repo.backup

下载对应版本repo文件, 放入/etc/yum.repos.d/,并改名为CentOS-Base.repo(操作前请做好相应备份)
# wget http://mirrors.zzu.edu.cn/wiki/centos/download/CentOS6-Base-zzu.repo
# mv CentOS6-Base-zzu.repo CentOS-Base.repo

运行以下命令生成缓存
# yum clean all # 清除YUM缓存： /var/cache/yum目录。
# yum makecache

$ yum repolist #查看源






###
yum基本命令
	yum install software-name	安装指定如软件
	yum remove software-name	卸载指定如软件
	yum update software-name	升级指定如软件

比如：安装一个vnc的客户端：
yum install tigervnc
可以通过 vncviewer 命令启动该vnc客户端。

查看一下刚安装软件的信息：
rpm -qi tigervnc

删除该软件：
yum remove tigervnc


yum查询：如果没有记住名字全称
	yum search keyword	搜索
	yum list (all|installed|recent|updates) 列出全部、安装的、最近的、软件更新
	yum info packageName 显示指定软件的信息(和rpm -qi tigervnc 一样，)

	yum whatprovides filename	查询哪个rpm软件包包含目标文件filename

[wangjl@centOS6 ~]$ yum search vnc

[wangjl@centOS6 ~]$  yum whatprovides /etc/ethers 

$ yum list installed //列出所有已安装的软件包 
$ yum list  #所有可安装的软件包 





###
创建yum仓库

可以通过以下方式手工创建yum仓库：
	1.将所有rpm文件拷贝到一个文件夹中；
		# mkdir /linux-yum
		# cp -rv /media/CentOS_6.7_Final/Packages/* /linux-yum/ 
		# ls| wc #统计文件个数
		
	2.通过rpm命令手工安装createrepo软件；
		# rpm -ivh createrepo #发现在CentOS_6.7_Final的光盘中已经没有这个包了。
		# yum install createrepo #通过远端安装

	3.运行命令createrepo -v /rpm-directory
		# createrepo -v /linux-yum/ #会自动创建索引文件/repodata/
		# cd ./repodata/ 
		# ls #可以查看产生的索引文件
		
	在/etc/yum.repos.d/目录下新建.repo文件
	# cd /etc/yum.repos.d/ 
	# vim CentOS-Disk.repo 
	写入如下文本
[Local]
name=local
baseurl=file:///linux-yum/ 
enabled=1
gpgcheck=0
	通常还需要运行一下清除缓存：
	# yum clean all #每次运行安装或者查询命令会重建yum缓存。
	# yum list #就会列出现有的rpm包。





	4.如果有分组信息，则在运行命令的时候使用-g参数指定分组文件
		createrepo -g /tmp/*comps.xml /rpm-directory
	CentOS/RHEL的分组信息保存在光盘repodata/目录下，文件名以comps.xml结尾的xml文件
	
	创建好之后本机可以通过file方式直接使用，如果需要作为对外的yum仓库服务器，可以通过http、ftp或nfs协议共享除去。
	
	
	图形界面安装程序：CentOS右上角 系统-管理-添加删除程序，也是使用的yum来管理软件的。
#



update 和 upgrade 的区别
	UPDATE: update is used to download package information from all configured sources.
	UPGRADE:  upgrade is used to install available upgrades of all packages currently installed on the system from the sources configured via sources.list

	yum -y update  #升级所有包，改变软件设置和系统设置,系统版本内核都升级。
	yum -y upgrade #升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变。
#

安装软件之前, 可以不upgrade, 但是要update.
前者是更新整个仓库的版本信息，后者是升级软件包。








	
========================================
|-- linux软件的安装/卸载/升级/添加环境变量(Ubuntu)
----------------------------------------
安装ssh服务
sudo apt install openssh-server
查看服务是否开启
ps -e|grep ssh
如果有sshd说明服务已经开启。


软件名字查找
sudo apt search 软件关键词


软件安装
sudo apt-get install 软件名字




查找软件安装位置：在路径PATH中查找所有同名软件。
wangjl@Ubuntu1404:~$ whereis mysql
mysql: /etc/mysql /usr/include/mysql
wangjl@Ubuntu1404:~$ whereis php
php:
wangjl@Ubuntu1404:~$ whereis R
R: /usr/bin/R /usr/lib/R /etc/R /usr/local/lib/R /usr/share/R /usr/share/man/man1/R.1.gz


查找软件运行目录：返回路径中第一个同名软件。
$ which ssh
/usr/bin/ssh






========================================
|-- linux软件添加环境变量或软链接(Ubuntu)
----------------------------------------
诸如bowtie、bismark等程序，只能在其目录下使用，不能再其他目录下使用，这样很不方便。
想在任何目录下使用该软件，有两种方式：添加环境变量或软链接。




######################
# 方法1：添加环境变量
######################
Ubuntu下设置环境变量有三种方法，一种用于当前终端，一种用于当前用户，一种用于所有用户。
最后一种需要root权限。


(1)用于当前终端：
在当前终端中输入：export PATH=$PATH:<你的要加入的路径>
不过上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效。
  export NDK_ROOT=/home/jiang/soft/Android-ndk-r8e 只能在当前终端使用。



(2)[推荐]用于当前用户：
在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下：
vi ~/.bashrc
加入：
export PATH=<你的要加入的路径>:$PATH

如果要加入多个路径，只要：
export PATH=<你要加入的路径1>:<你要加入的路径2>: ...... :$PATH
当中每个路径要以冒号分隔。
这样每次登录都会生效。


本例推荐使用该方法：在当前用户的主目录下找到隐藏文件“.profile”或类似文件，在这个文件的末尾增加2行，把bowtie所在的目录加到变量PATH中，比如我增加的两行是：

export PATH=PATH:/home/clever/tools/bowtie2-2.2.6/
export PATH=PATH:/home/clever/tools/bismark_v0.14.5/

注销一下，这样就可以在当前用户的主目录下的任何目录下使用bismark和bowtie2了。




(3)用于所有用户：
sudo vi /etc/profile 

加入：
export PATH=<你要加入的路径>:$PATH
就可以了。

终端输入：echo $PATH 可以查看环境变量

注意，修改环境变量后，除了第一种方法立即生效外，第二第三种方法要立即生效，可以
$ source ~/.bashrc
或者注销再次登录后就可以了！

建议如果可能，还是注销再登录，因为每source一次，PATH中有些变量就复制一次，不美观。一般不影响功能。






######################
# 方法2：在路径目录中添加软连接
######################

先查看当前环境变量查找的地点：
wangjl@ubt16:~$ echo $PATH
/home/wangjl/bin:/home/wangjl/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

当输入命令时，这些bin文件夹下的可执行文件会被依次查找。
当前用户可用的程序就可以放到/home/wangjl/bin下，全部用户都可见的一般都是安装在到/usr/share和/usr/local/bin中。
$ ln -s /path/to/fastQC/fastqc /home/wangjl/bin/fastqc




######################
# 方法3：修改PATH文件【不推荐，需要root权限】
######################
添加系统级环境变量 https://jingyan.baidu.com/article/db55b609a3f6274ba30a2fb8.html
$ sudo vim /etc/environment
后引号的前面加上
:/home/wangjl/Soft/sratoolkit.2.8.2-1-ubuntu64/bin
$source /etc/environment

这样以后PATH变量都会改变为修改后的。




环境变量：http://blog.csdn.net/z1002137615/article/details/50174567








========================================
|-- 设置软件别名 alias
----------------------------------------
别名可以简化命令，方便记忆。


1. 别名设置方式
alias vi="vim"  #输入vi其实运行的就是vim。

1)直接在命令中输入，则只在当前会话中起作用。

2)在 ~/.bashrc 末尾添加一行，注销再登录，则对该用户都有效。


2. 也可以连参数一起简化
alias la="ls -al --color=auto"



3.使用type 或 which 查找命令到底是本身，还是别名
$ type mkdir  #原始
mkdir is /usr/bin/mkdir

$ type grep  #别名
grep is aliased to `grep --color=auto'

$ which grep
alias grep='grep --color=auto'
	/usr/bin/grep
#



refer:
https://www.cnblogs.com/YMaster/p/9788938.html




========================================
linux程序前后台切换、查看、关闭
----------------------------------------

1.后台运行

(1)如果程序在前台运行中，可以通过ctrl + z来把程序暂停，然后用bg %[number]命令把这个程序放到后台运行 
$ sleep 10
^Z
[1]+  Stopped                 sleep 10
#ctrl+z 挂起当前任务

$ bg %1
[1]+ sleep 10 &


(2)&命令
&是指在后台运行，但当用户退出(挂起)的时候，命令自动也跟着退出。

功能：加在一个命令的最后，可以把这个命令放在后台执行，返回pid，可以通过 ps -ef|grep PID号 查看命令运行状态。 
$ sleep 10 &
[1] 15514



(3)nohup命令
功能：不挂断的运行命令，但是无法立刻获得shell的交互能力
$ nohup --help
Usage: nohup COMMAND [ARG]...
  or:  nohup OPTION
Run COMMAND, ignoring hangup signals.


那么，我们可以巧妙的吧他们结合起来用，这样就能立刻获得shell交互，同时使命令永久的在后台执行。
用户登出再连接，使用ps -ef发现它还在运行。
长命令必须写在shell文件中，否则nohup不起作用
nohup执行会产生日志文件 nohup.out，默认在当前目录，如果当前目录不可写，那么自动保存到家目录中。也可以自定义位置。

常用格式：
$ nohup COMMAND & #一般格式
$ nohup python3 test_nohup.py > logfile.log &  #自定义日志文件名字，错误输出到哪？ //todo
$ nohup command > myout.file 2>&1 & //log输出到myout.file，并将标准错误输出重定向到标准输出，再被重定向到myout.file
或者 
$ nohup bash xx.sh > myout.file 2>error.log &



实例
$ cat a.sh
sleep 5
date
$ bash a.sh
## Fri May 10 14:39:13 CST 2019
$ nohup bash a.sh >sleep.log &  #后台永续运行
[1] 31727
$ nohup: ignoring input and redirecting stderr to stdout
一段时间后运行结束
[1]+  Done                    nohup bash a.sh > sleep.log
日志文件 sleep.log 内容是 Fri May 10 14:39:37 CST 2019







2.查看后台运行的程序
两个命令可以用，jobs和ps,区别是jobs用于查看当前终端后台运行的任务，换了终端就看不到了。而ps命令用于查看瞬间进程的动态，可以看到别的终端运行的后台进程。

(1)jobs命令： 查看当前终端后台运行的任务
$ sleep 10 &
[1] 16015
$ jobs
[1]+  Running                 sleep 10 &


jobs -l选项可显示当前终端所有任务的PID，jobs的状态可以是running，stopped，Terminated。+ 号表示当前任务，- 号表示后一个任务。
-l参数 lists process IDs in addition to the normal information
#好像-l参数没啥用，加和没加没啥区别。


$ jobs #带+表示最新的jobs；带-表示次新的jobs；其他jobs不带符号
[2]   Done                    sleep 20
[3]   Running                 sleep 20 &
[4]   Running                 sleep 20 &
[5]-  Running                 sleep 20 &
[6]+  Running                 sleep 20 &



(2)ps命令：查看当前的所有进程
ps -aux | grep "test.sh"  
-a:显示所有程序;  -u:以用户为主的格式来显示;   -x:显示所有程序，不以终端机来区分
-e:Select all processes.  Identical to -A;
-f:Do full-format listing.

$ sleep 120 &
[1] 6164

$ ps -aux |grep "sleep 120"
wangjl    6164  0.0  0.0   6176   736 pts/3    S    14:56   0:00 sleep 120

$ ps -ef|grep "sleep" #可以按照命令关键词查进程
$ ps -ef|grep 6164 #也可以按照进程号查进程
wangjl    6164 10693  0 14:56 pts/3    00:00:00 sleep 120






3.fg将程序放到前台运行
$ sleep 10 &
[1] 16426
$ fg %1
sleep 10





4.kill 终止程序运行
(1)通过jobs命令查看后台运行的jobnum，然后执行 kill %jobnum
(2)通过ps命令查看进程号PID，然后执行 kill PID 或  kill -9 PID
(3)前台进程的终止: Ctrl+c

$ jobs
[1]-  Running                 sleep 20 &
[2]+  Running                 sleep 30 &

$ kill %1
$ jobs
[1]-  Terminated              sleep 20
[2]+  Running                 sleep 30 &

$ ps -aux |grep sleep
wangjl   11752  0.0  0.0   6176   760 pts/3    S    15:19   0:00 sleep 100
$ kill -9 11752
[1]+  Killed                  sleep 100 #kill -9 PID




另外有两个常用的ftp工具ncftpget和ncftpput，可以实现后台的ftp上传和下载，这样我就可以利用这些命令在后台上传和下载文件了。

refer:
https://blog.csdn.net/luckywang1103/article/details/80984985







========================================
|-- CentOS下的htop命令
----------------------------------------
htop比top命令更直观的显示cpu和内存的状态，并能显示完整命令。
Ubuntu下直接apt-get install htop 即可安装htop命令。而CentOS下并没有如此简洁的安装方法。


对于 CentOS7.9:
$ sudo yum -y install epel-release
$ sudo yum -y install htop
这两行就可以了。

$ htop
## end;








以下可以跳过:

## 本文CentOS版本号为6.7。
#一个可选的方法是：图形化监视界面	
$ gnome-system-monitor

一般开源项目托管在sourceforge上面，当然也有些托管在github上，但github最近才火起来，所以sourceforge上多一些成熟的项目。
第一步、找到sourceforge上的htop页面。
第二步、找到文件所在的目录，复制地址，使用wget命令下载。


2. 安装程序包
安装htop命令 http://www.sanduoyun.com/vpshj/htop.html

(1) 下载
# download:https://sourceforge.net/projects/htop/
wget http://heanet.dl.sourceforge.net/project/htop/htop/1.0.2/htop-1.0.2.tar.gz #下载失败

$ wget https://sourceforge.net/projects/htop/files/htop/1.0.2/htop-1.0.2.tar.gz --no-check-certificate

解压缩
$ tar -xzvf htop-1.0.2.tar.gz



(2) 配置[建议跳过，直接看下一步]
cd htop-1.0.2
./configure



如果是干净的系统：
# 失败！！ 提示需要安装依赖包libncursesw (ncurses:http://invisible-island.net/ncurses/announce.html)
wget ftp://invisible-island.net/ncurses/ncurses.tar.gz
tar -xzvf ncurses.tar.gz
cd ncurses-5.9
./configure
make 
make install

# 再次安装htop
cd htop-1.0.2
./configure --disable-unicode



(3) 建议升级 centos 系统:
$ sudo yum install epel-release 
$ sudo yum update #需要几个小时

cd htop-1.0.2
./configure


(4) 编译安装
$ make 
$ sudo make install

安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。键入如下命令：
$ make clean   
# make distclean   
至此，软件的安装结束



(5) 【可选】设置
如果您想每次使用top命令直接打开htop。
#vi  /root/.bashrc
if [ -f /usr/local/htop/bin/htop ]; then
  alias top='/usr/local/htop/bin/htop'
fi
#source /root/.bashrc









3. 使用说明
$ htop #即可查看

常用选项：
	-C –no-color 使用一个单色的配色方案。
	-d –delay=DELAY 设置延迟更新时间，单位秒。
	-h –help 显示htop命令帮助信息。
	-u –user=USERNAME 只显示一个给定的用户的过程。
	-v –version 显示版本信息

建议man一下，man很详细。

另外还在使用时
/:搜索字符
u:显示某个用户的进程，在左侧可以选项
t:显示树形结构
h ： 显示帮助
H ： 显示/隐藏用户线程
K ： 显示/隐藏内核线程

选择某一进程，按s:用strace追踪进程的系统调用

P、T、M和top下是一样的，按CPU,Time+、Memory使用排序。

下面有F1~F10的功能和对应的字母快捷键。
Shortcut Key	Function Key	Description
h	F1	Invoke htop Help
S	F2	Htop Setup Menu
/	F3	Search for a Process
I	F4	Invert Sort Order
t	F5	Tree View
>	F6	Sort by a column
[	F7	Nice - (change priority)
]	F8	Nice + (change priority)
k	F9	Kill a Process
q	F10	Quit htop




refer: 
http://www.centoscn.com/image-text/install/2014/0609/3112.html








========================================
|-- 杀掉进程 kill: terminate a process (使用信号控制)
----------------------------------------

kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看。


1. 常用命令

(1) 彻底杀死进程
$ kill -9 端口号

(2) 批量杀死命令中带某个关键词“Run.R”的进程
$ ps -aux | grep Run.R | awk '{print $2}' | xargs -i kill -9 {}


(3) 杀死指定用户所有进程

$ kill -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程 

$ kill -u hnlinux //方法二



2. 选项
kill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]

最常用的信号是：
1 (HUP)：重新加载进程。
9 (KILL)：杀死一个进程。
15 (TERM)：正常停止一个进程。


(1) 显示信号

$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

$ kill -l SIGUSR2
12



(2) 一个简单直接的重启 php-fpm 的方法：
先查看php-fpm的master进程号
$ ps aux | grep php-fpm | grep master | grep -v grep
root     13225  0.0  0.0 204820  7508 ?        Ss   09:37   0:01 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)
You have new mail in /var/spool/mail/root

重启php-fpm:
$ kill -USR2 13225  
我试了一下，确实重启了，新配置文件生效了，但是进程号不变。


INT, TERM 立刻终止
QUIT 平滑终止
USR1 重新打开日志文件
USR2 平滑重载所有worker进程并重新载入配置和二进制模块




ref:
https://blog.csdn.net/zhangkaiadl/article/details/92763973




========================================
|-- linux下杀死进程（kill）的N种方法、杀掉僵死进程
----------------------------------------
http://blog.csdn.net/andy572633/article/details/7211546

1.常规篇：
　首先，用ps查看进程，方法如下：

$ ps -ef

……
smx       1822     1  0 11:38 ?        00:00:49 gnome-terminal
smx       1823  1822  0 11:38 ?        00:00:00 gnome-pty-helper
smx       1824  1822  0 11:38 pts/0    00:00:02 bash
smx       1827     1  4 11:38 ?        00:26:28 /usr/lib/firefox-3.6.18/firefox-bin

或者：

$ ps -aux

……

smx       1822  0.1  0.8  58484 18152 ?        Sl   11:38   0:49 gnome-terminal
smx       1823  0.0  0.0   1988   712 ?        S    11:38   0:00 gnome-pty-helper
smx       1827  4.3  5.8 398196 119568 ?       Sl   11:38  26:13 /usr/lib/firefox-3.6.18/firefox-bin

此时如果我想杀了火狐的进程就在终端输入：

$ kill -s 9 1827

其中-s 9 制定了传递给进程的信号是９，即强制、尽快终止进程。各个终止信号及其作用见附录。
1827则是上面ps查到的火狐的PID。

简单吧，但有个问题，进程少了则无所谓，进程多了，就会觉得痛苦了，无论是ps -ef 还是ps -aux，每次都要在一大串进程信息里面查找到要杀的进程，看的眼都花了。




2.进阶篇：

把ps的查询结果通过管道给grep查找包含特定字符串的进程。管道符“|”用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。

$ ps -ef | grep firefox
smx       1827     1  4 11:38 ?        00:27:33 /usr/lib/firefox-3.6.18/firefox-bin
smx      12029  1824  0 21:54 pts/0    00:00:00 grep --color=auto firefox

这次就清爽了。然后就是

$kill -s 9 1827


(2) 杀掉所有 带有 tail -n 的命令的进程
使用前先目测一下，防止误杀。
$ ps -aux |grep "tail -n" | awk 'NR>1{print $2}' | less 
$ ps -aux |grep "tail -n" | awk 'NR>1{print $2}' | xargs -i  kill -9 {}




3.僵尸进程: 就是先于父进程结束的子进程，父进程又不管。
通过top命令可以监视僵尸进程的数量。
或者
$ ps -aux |grep Z 
#wangjl   411451  0.0  0.0      0     0 ?        Z    16:07   0:00 [ZMQbg/45] <defunct>


僵尸进程不能被直接杀掉，要不然也不叫僵尸进程了。
kill -9 411451


查找其父进程
$ ps -ef | grep 411451
#wangjl   411451   1988  0 16:07 ?        00:00:00 [ZMQbg/45] <defunct>
其父进程pid号为1988，
$ ps -ef|grep 1988|head
wangjl     1988   1376  3 May06 ?        02:49:33 /home/wangjl/software/anaconda3/bin/python -m ipykernel_launcher -f /run/user/1012/jupyter/kernel-fadf192b-d7bd-48b6-b926-df62432c2bb0.json

发现其父进程是一个python jupyter进程，由于没有运行，所以直接杀掉该进程？
kill -9 1988 #发现僵尸进程也消失了。


批量杀死僵尸进程的父进程：
ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]' | awk '{print $2}' | xargs kill -9



https://www.cnblogs.com/reality-soul/p/6343339.html


========================================
|-- linux下4种kill某个用户所有进程的方法
----------------------------------------
在linux系统管理中，我们有时候需要kill掉某个用户的所有进程，初学者一般先查询出用户的所有pid，然后一条条kill掉，或者写好一个脚本。

实际上有4种现成的通用方法，我们以kill用户sunjh的所有进程为例。

1. pkill方式
# pkill -u sunjh


2. killall方式
# killall -u sunjh


3. ps方式
ps列出sunjh的pid，然后依次kill掉，比较繁琐.
# ps -ef | grep sunjh | awk '{ print $2 }' | sudo xargs kill -9


4. pgrep方式
pgrep -u参数查出用户的所有pid，然后依次kill
# pgrep -u sunjh | sudo xargs kill -9

https://blog.csdn.net/lihuaichen/article/details/84066359





========================================
定时任务 at/batch, crontab, anacron
----------------------------------------
1.在未来的某个时间仅执行一次
at      executes commands at a specified time.

(1) 设置定时任务
使用 at timespec 可以启动该工具，然后在之后输入要执行的任务，最后按键盘 ctrl + d 保存并退出。
$ at now +1 minutes
at> ls
at> <EOT>
job 2 at Tue Apr  4 10:06:00 2023

(2) 时间表示法
HH:MM[AM|PM]
MM/DD/YY
now+#
	miniutes
	hours
Ctrl+d 提交完成
任务完成后通过邮件的方式发送过来

at的时间例子:
格式	用法
HH:MM	例：15:20，在下一次的15:30运行
YY-MM-DD	例：2021-08-21，在2021年8月21日的当前时间点运行
		例：14:00 2021-08-21，在2021年8月21日的14:00运行
now + count time-units	例：now + 5 minutes，在当前时间的5分钟后运行
		可用单位：minutes, hours, days, or weeks
time + count time-units	例：15:00 + 5 days，在5天后的15:00后运行






(3) 查看任务
使用 atq 可以查询已设置但还未执行的任务

-l查看任务，列出任务列表的任务计划
# at -l =atq # 命令 at-l 等价于 atq
$ atq
2	Tue Apr  4 10:06:00 2023 a wangjl
解释: atq输出每一行为一个任务，分别显示任务号、执行时间、队列名称、创建者。


等结果：
$ 
You have new mail in /var/spool/mail/wangjl
$ less /var/spool/mail/wangjl
对比结果，发现是在根目录使用的 ls 命令。
$ date
Tue Apr  4 10:06:39 +08 2023



(4) 删除任务
atrm 任务号 可以删除待进行的任务

# at -r job_num =atrm job_num 移除一个任务



(5) 从文件读取任务
# at -f file TIME(vim atfile)  是从一个文件中读取一个任务而不是交互式模式。



(6) 空闲时执行
# batch 不用指定时间，其余用法和at相同。
	batch   executes commands when system load levels permit; in other words, when the load average drops below 0.8, or the value specified in the invocation of atd.
	在系统空闲满足要求(<0.8或指定值)时执行。


(7) atd服务
使用at方式设置的定时任务依赖于atd服务，可以使用 /etc/init.d/atd status 来查看该服务是否运行，如果没有运行的话使用 /etc/init.d/atd start 来启动。你也可以使用 /etc/init.d/atd stop 来停止该服务。

如果atd服务没有开机启动的话可以使用 chkconfig atd on 命令来将其设置为开机启动。

我测试的:
$ service atd status
Active: active (running) since Fri 2022-12-23 15:02:19 +08; 3 months 10 days ago








ref:
https://blog.csdn.net/Naisu_kun/article/details/119817215
https://blog.51cto.com/zhou123/792163




========================================
|-- crontab定时任务
----------------------------------------
crontab - maintain crontab files for individual users (Vixie Cron)

cron是一个[守护程序]用于在指定的时间内执行行程类的任务，每一个用户都有一个 crontab 文件，来允许他们指定需要执行的内容和时间，此外，系统也有一个 crontab ，用来允许像交替日志和更新本地数据这样有规则的任务。


成功的task
0 0,12 * * * date >> /home/wangjl/web/log.txt #0点和12点写入一次时间戳

建议：如果命令行可以执行，而定时器中不执行，可以把命令写到文件中，在定时器中使用bash 调用该文件。




1.使用 crontab -e命令
这个命令比较简单直接输入就可以
$ crontab -e
然后选一个编辑器，比如2，回车。


(1)crontab的语法规则格式：
代表意义	分钟	小时	日期	月份	周	命令
数字范围	0~59	0~23	1~31	1~12	0~7	需要执行的命令
周的数字为 0 或 7 时，都代表“星期天”的意思。


(2)另外，还有一些辅助的字符，大概有下面这些：
特殊字符	代表意义
*(星号)	代表任何时刻都接受的意思。举例来说，0 12 * * * command 日、月、周都是*，就代表着不论何月、何日的礼拜几的12：00都执行后续命令的意思。
,(逗号)	代表分隔时段的意思。举例来说，如果要执行的工作是3：00与6：00时，就会是：0 3,6 * * * command时间还是有五列，不过第二列是 3,6 ，代表3与6都适用
-(减号)	代表一段时间范围内，举例来说，8点到12点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二列变成8-12.代表 8,9,10,11,12 都适用的意思
/n(斜线)	那个n代表数字，即是每隔n单位间隔的意思，例如每五分钟进行一次，则：*/5 * * * * command用*与/5来搭配，也可以写成0-59/5，意思相同





2.输入你想执行的内容了.
(1)比如:
*/2 * * * * date >> /home/wangjl/time.log #每过两分钟就向time.log文件中写入当然的系统时间.
* * * * * date>>/home/wangjl/web/test/date.txt #每分钟写入文件。

# For example, you can run a backup of all your user accounts at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/

格式：
# For more information see the manual pages of crontab(5) and cron(8)
# m h  dom mon dow   command
#minute hour day-of-month month-of-year day-of-week commands
合法值为：00-59 00-23 01-31 01-12 0-6 (0 is sunday)
除了数字还有几个特殊的符号："*"、"/"和"-"、","
	*代表所有的取值范围内的数字
	"/"代表每的意思,"/5"表示每5个单位，例如每3分钟运行一次命令： */3 * * * * /home/wangjl/XXXX.sh
	"-"代表从某个数字到某个数字
	","分开几个离散的数字

参数说明(看例子,就明白了)
	m 分钟 0-59
	h 小时 0-23
	dow 天1-31
	mon 月 1-12
	dow  星期 1-6  0表示星期天
	command 就是要执行的命令

(2)关键是要记住/var/spool/cron这个目录。
除了root用户之外的用户可以执行crontab配置计划任务。
所有用户定义的crontab存储在目录/var/spool/cron下，任务会以创建者的身份被执行。
要以特定用户创建一个crontab，先以该用户登录，执行命令crontab -e，系统会启动在VISUAL或者EDITOR中指定的的编辑软件编辑crontab。文件内容与/etc/crontab格式相同。

最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。

$ sudo cat /var/spool/cron/crontabs/wangjl
看到的内容和 $ crontab -e 看到的内容一样。



删除crontab文件
$crontab -r

千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。



(3)如果一个cron任务需要定期而不是按小时,天,周,月来执行,则需要添加/etc/cron.d目录。这个目录下的所有文件和文件/etc/crontab语法相同
//todo


(4)查看/etc/crontab文件：
###########################
$ cat /etc/crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user  command
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
###########################
解释：
SHELL变量的值指定系统使用的SHELL环境(该样例为bash shell)，
PATH变量定义了执行命令的路径。
文件/etc/crontab中每行任务的描述格式如下:

  minute hour day month dayofweek command
  minute - 从0到59的整数
  hour - 从0到23的整数
  day - 从1到31的整数 (必须是指定月份的有效日期)
  month - 从1到12的整数 (或如Jan或Feb简写的月份)
  dayofweek - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)
  command - 需要执行的命令(可用as ls /proc >> /tmp/proc或 执行自定义脚本的命令)
  root表示以root用户身份来运行
  run-parts表示后面跟着的是一个文件夹，要执行的是该文件夹下的所有脚本
  
  对于以上各语句，星号(*)表示所有可用的值。例如*在指代month时表示每月执行(需要符合其他限制条件)该命令。
  整数间的连字号(-)表示整数列，例如1-4意思是整数1,2,3,4
  指定数值由逗号分开。如：3,4,6,8表示这四个指定整数。
  符号“/”指定步进设置。“/”表示步进值。如0-59/2定义每两分钟执行一次。步进值也可用星号表示。如*/3用来运行每三个月份运行指定任务。
  以“#”开头的为注释行,不会被执行。

开始不知道/etc/crontab文件中的run-parts是什么意思，直接把命令按照/etc/crontab的格式加上总是无法运行，后来才知道run-parts是指后面跟着的是文件夹。


(5)其他注意事项
cron服务会每分钟检查一次/etc/crontab、/etc/cron.d/、/var/spool/cron文件下的变更。如果发现变化，就会下载到存储器中。因此，即使crontab文件改变了，程序也不需要重新启动。
新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

推荐自定义的任务使用crontab -e命令添加，退出后用/etc/init.d/crond restart命令重启crond进程，官方文件说不用重启进程，但我遇到不重启无法运行任务的情况。

更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:
$service cron restart

ubuntu下启动、停止与重启cron:
	$sudo /etc/init.d/cron start
	$sudo /etc/init.d/cron stop
	$sudo /etc/init.d/cron restart





3.更多例子
1)在 凌晨00:01运行
1 0 * * * /home/wangjl/XXXX.sh

2)每个工作日23:59都进行备份作业。
59 11 * * 1,2,3,4,5 /home/wangjl/XXXX.sh

或者如下写法：
59 11 * * 1-5 /home/wangjl/XXXX.sh

3)每分钟运行一次命令
*/1 * * * * /home/wangjl/XXXX.sh

4)每个月的1号 14:10 运行
10 14 1 * * /home/wangjl/XXXX.sh

每小时的第3和第15分钟执行
3,15 * * * * myCommand

在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand

每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand

实例5：每周一上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 myCommand

每月1、10、22日的4 : 45重启smb
45 4 1,10,22 * * /etc/init.d/smb restart

实例10：每星期六的晚上11 : 00 pm重启smb 
命令：
0 23 * * 6 /etc/init.d/smb restart


假设需要每天的 23:01 分创建目录，配置 crontab 如下即可：
1 23 * * * mkdir -p /path-to-your-dir/`date +%F`
宕机重启后需要单独另外执行脚本检查是否有缺失


实例： 比如搞一个日记本：每天四次时间戳，每周备份一次，中间随便cat>>添加内容。
* 0,6,12,18 * * * date >> /home/wangjl/web/log.txt #每6个小时写入一次时间戳
59 23 * * 0 cp /home/wangjl/web/log.txt /home/wangjl/web/log.`date +%F`.txt #每周日晚上11:59备份日记。备注日期。



实例15：每小时执行/etc/cron.hourly目录内的脚本
命令：
01 * * * * root run-parts /etc/cron.hourly
说明：
run-parts这个参数后跟文件夹；如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了

注意： 
1）脚本中涉及文件路径时写全局路径；
2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：

cat start_cbp.sh
#!/bin/sh
source /etc/profile
export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
/usr/local/jboss-4.0.5/bin/run.sh -c mev &






4. 问题排查

(1) ubuntu 打开 cron 日志（默认是关闭的）

打开 ubuntu 定时器日志
$ sudo vim /etc/rsyslog.d/50-default.conf #去掉前面的注释符号 #
cron.*                         /var/log/cron.log

重启服务
$ sudo service rsyslog restart
重启系统日志，就能查看 cron 的运行日志了：

$ sudo tail /var/log/cron.log
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2896]: (marigold) CMD (bash /home/marigold/soft/SeqReportSys/backup/daily.cron 2> /home/marigold/soft/SeqReportSys/backup/xx_logs.txt)
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2897]: (marigold) CMD (bash -c "echo `date` >> /home/marigold/soft/SeqReportSys/backup/xx_3_Backup-`date +)
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2898]: (marigold) CMD (echo `date` >> /home/marigold/soft/SeqReportSys/backup/xx_2_Backup-DB_SYSDB_PRO-`date +)
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2900]: (marigold) CMD (echo `date` >> /home/marigold/soft/SeqReportSys/backup/xx.txt)
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2894]: (CRON) info (No MTA installed, discarding output)
Sep  5 10:10:01 zxsys-PowerEdge-T630 CRON[2893]: (CRON) info (No MTA installed, discarding output)

可见，命令在 + 后被截断了。而这些命令在shell下是可以直接运行的。



(2) 把命令写入 shell 文件再执行
$ cd /home/marigold/soft/SeqReportSys/
$ cat script/system/cron/daily.sh
mysqldump -h192.168.1.3 -P7998 -uroot -p123456 SYSDB_PRO > /home/marigold/soft/SeqReportSys/backup/Backup-DB_SYSDB_PRO-$(date +%Y%m%d\_%H%M%S).sql

写到定时任务中
$ crontab -e #新增一行
0 19 * * 1-5 bash /home/marigold/soft/SeqReportSys/script/system/cron/daily.sh






refer:
https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#
https://blog.csdn.net/u013033143/article/details/82882842
https://blog.csdn.net/xinyflove/article/details/83178876




========================================
|-- anacron: 非24小时开机的主机使用，可以在开机时补齐任务 //todo
----------------------------------------

anacron是一种异步的定时任务调度器，大家都知道cron是Linux系统下的定时任务调度器，可以实现异步的任务调度。对于24小时开机运行的服务器可能用不到这种东西，但是非24小时开机，又想定时运行任务的机器还是十分有用的，可以实现异步的调用，下面为大家详细讲解一下anacron 命令。


anacron 的工作是确保你的自动化作业定期执行。为了做到这一点，anacron 会检查找出最后一次运行作业的时间，然后检查你告诉它运行作业的频率。

假设你将 anacron 设置为每五天运行一次脚本。每次你打开电脑或从睡眠中唤醒电脑时，anacron都会扫描其日志以确定是否需要运行作业。如果一个作业在五天或更久之前运行，那么 anacron 就会运行该作业。





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------









========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------




