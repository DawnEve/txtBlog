Linux网络
linux简介4|网络与iptables  



TP-link 路由器设置、网络工具等。
IP Gate DNS等。





ssh 教程：
	https://www.ronpad.com/ssh/



========================================
基于 xshell 的内网穿透： SSH 端口转发又叫 SSH 隧道（tunnel） 原理与实战
----------------------------------------
1. 简单模型
A服务器在局域网，我在外部用C电脑能连接和A同一个网的B跳板机。
整个模型是： C -> || B -> A ||

- 主机B和A在同一个局域网
- 平常通过B（win）访问服务器A（Linux）
- 在外网能通过 xshell 能连接B主机

(1) 之前是通过2次跳转，先连接B，再连接A。
缺点： 麻烦，且无法访问A的 Rstudio 等交互式页面。

(2) 通过隧道连接 Rstudio
a) 创建隧道
点击顶部文件夹图标右边的下三角，找到B的连接，右击-属性；
点击 连接-ssh-隧道，单击添加，
	设置登录方式，也就是站到B主机上： 类型：本地（拨出），	源主机： localhost，侦听端口：8787
	设置服务器A的信息： 目标主机： 10.10.x.143，目标端口：8787
	自定义注释： 说明：Rstudio server
	点确定。
	还可以再添加一下 jupyter 的设置，只是端口号不同，比如 8890
重新连接主机B，xshell标签图标变成圆圈，表示设置成功。
b) 访问Rstudio
浏览器访问 http://localhost:8787/
即可访问服务器A了。






2. 怎么自己构建主机B呢？
https://blog.csdn.net/qijiajun97/article/details/104194201

(1) 云主机D
就是A和C都能访问的主机。设置允许端口转发
$ vim /etc/ssh/sshd_config
找到文件中被注释掉的GatewayPorts no，去注释，并将no改成yes
如果没找到就在末尾添加上GatewayPorts yes

打开防火墙端口，比如 12345


(2) 设置B电脑为跳板机
打开XShell，添加连接，设置： 名称：跳板机，协议：ssh，主机：云主机的公网ip，端口号：22
	用户身份验证：云主机的用户名和密码。
	SSH-隧道，设置转移规则： 类型：远程(传入),源主机：0.0.0.0，侦听端口： 云主机开的端口，比如 12345。
		目标主机： 内网主机A的IP，目标端口：22
跳板机B必须在线，否则无法实现转发。


(3) 外部电脑C的配置
任意一个ssh软件，
	IP: 云主机IP
	端口： 云主机打开的端口，比如 12345
	用户名：服务器A的用户名
	密码：服务器A的密码

实现了在外网通过ssh隧道服务连接内网服务器。


(4) 设置隧道后，所有的ssh相关的服务都可以在外网使用，比如 sftp 文件传输
除了ssh登录外，ssh相关协议也是支持的。
比如，在外网电脑C上使用支持 sftp 的软件。

这套操作的原理是SSH的隧道协议，具体可以看
	SSH Tunnel 一般场景用法： https://blog.csdn.net/wxqee/article/details/49234595






3. 案例2: 通过ssh隧道转发本地ssh,实现内网穿透
https://blog.csdn.net/u010494323/article/details/134277926
实际场景，有A服务器，位于某内网环境，没有外网IP，外面无法SSH
但我自己有比如阿里云上的一台服务器D，我想直接SSH A服务器，怎么办？

D 服务器IP 101.198.*.*
A 服务器执行 # ssh -R 2201:0.0.0.0:22 -p 22 USERNAME@101.198.*.* -f -N






ref:
https://blog.csdn.net/qq_61562251/article/details/134910406





========================================
|-- SSH Tunnel 一般场景用法： ssh -p port 本地转发-L / 远程转发-R / 动态转发-D
----------------------------------------
反向端口转发是把本机的端口转发到远程的机子上；
与之对应，正向端口转发则是把远程的端口转发到本地。

0. 背景介绍
(1)ssh 参数：
	-C：压缩传输
	-f：将ssh转⼊后台，不占⽤当前shell
	-N：静默连接，减少被发现。 表示只是建立连接，而不登录。
	-g：允许远程主机连接本地⽤于端⼝转发
	-L：本地端⼝转发
	-R：远程端口转发
	-D：动态端⼝
	-p：指定ssh端口
	-T:不分配伪终端 tty
	
	-i ssh key 私钥文件


常用组合：
	-Ngf -R
	-fCNT -L


man 手册：
-C      Requests compression of all data (including stdin, stdout, stderr, and data for forwarded X11, TCP and UNIX-domain connections).  The compression algorithm is the same used by gzip(1).  Compression is desirable on modem lines and other slow connections, but will only slow down things on fast networks. The default value can be set on a host-by-host basis in the configuration files; see the Compression option.

允许远程主机连接本地⽤于转发端⼝。
-g      Allows remote hosts to connect to local forwarded ports.  If used on a multiplexed connection, then this option must be specified on the master process.

-N      Do not execute a remote command.  This is useful for just forwarding ports.

-T      Disable pseudo-terminal allocation.




(2) 端口转发时可见范围： 本地 vs 局域网
$ lsof -i:8881
Or
$ netstat -lntp | grep 8881
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 127.0.0.1:8881          0.0.0.0:*               LISTEN      -                   
tcp6       0      0 ::1:8881                :::*                    LISTEN      -
如果看到远端主机是 127.0.0.1 表示只能本地访问，要 0.0.0.0：port 才能使所有IP都能访问。

$ netstat -lntp | grep 8787 #参考 Rstudio 的地址
tcp        0      0 0.0.0.0:8787            0.0.0.0:*               LISTEN      -





(3) 端口转发 默认关闭，需要打开

确保SSH服务器的/etc/ssh/sshd_config配置文件的AllowTcpForwarding和GatewayPorts均配置为yes
然后 sudo systemctl restart sshd 重启 ssh- daemon 服务就开启成功了。

$ sudo vim /etc/ssh/sshd_config
AllowTcpForwarding yes
GatewayPorts yes

重启ssh 服务
$ sudo systemctl restart sshd #CentOS
Or
$ sudo service ssh restart #Ubuntu
$ sudo netstat -anp | grep 8888

查看端口是否开放：
$ telnet 192.168.2.120 8888




(10) 测试用机器：
	A: local Win
	B: Y station
	C: 105 VB
	D: Z server







1. ssh 基本用法 A->B
@A$ ssh userB@IP_B #登录B主机






2. SSH 的 -L, -R, -D 三种用法
(1) 本地转发 -L 用法 [-L address]
	 -L [bind_address:]port:host:hostport
     -L [bind_address:]port:remote_socket
     -L local_socket:host:hostport
     -L local_socket:remote_socket

指定本地连接到远程主机的端口。
Specifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side.  This works by allocating a socket to listen to either a TCP port on the local side, optionally bound to the specified bind_address, or to a Unix socket.  Whenever a connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.

Port forwardings can also be specified in the configuration file. Only the superuser can forward privileged ports.  IPv6 addresses can be specified by enclosing the address in square brackets.

By default, the local port is bound in accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to bind the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound for local use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces.


i) ssh -L 用法1（本地起端口映射到其他机器）
A->B-> | C
A-> | C
	@B$ sudo ssh -L 8888 userC@hostC
	@A$ ssh -p 8888 userC@hostB

意思是在 HostB 上，让 localhost 起 8888 端口，使之映射到 HostC 的 22 端口（默认）。
如此，在 HostA 上可以使用 HostB:8888 就像使用 HostC:22 一样。


测试报错：
	@B$ sudo ssh -L 8888 wangjl@192.168.2.105
	@B$ ssh -N -L 8888:192.168.2.105:22 wangjl@192.168.2.105
	[sudo] password for wangjl: 
	Bad local forwarding specification '8888'
	@B$ sudo ssh -L 8888:192.168.2.105:22 wangjl@192.168.2.105 #可以执行，登录

查端口占用：
	@B$ sudo netstat -anp | grep 8888
	tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      3999593/sshd: wangj 
	tcp6       0      0 ::1:8888                :::*                    LISTEN      3999593/sshd: wangj 
	unix  3      [ ]         STREAM     CONNECTED     58888    1/init               /run/systemd/journal/stdout
	wangjl@YStation:~$ 
	wangjl@YStation:~$ ps 3999593
		PID TTY      STAT   TIME COMMAND
	3999593 ?        S      0:00 sshd: wangjl@pts/7
	wangjl@YStation:~$ kill -9 3999593
测试端口是否可用
	@B$ python3 -m http.server 8888
	@A2$ $ curl -I http://192.168.2.120:8888
	HTTP/1.0 200 OK
	
再执行：
	不行的：
	@B$ ssh -L 8888:192.168.2.105:22 wangjl@192.168.2.105
	@B$ ssh -L 8888:localhost:22 wangjl@192.168.2.105
	@B$ ssh -Ng -L 8888 wangjl@192.168.2.105
	@B$ ssh -Ng -L 8888:locathost:22 wangjl@192.168.2.105
	可以的
	@B$ ssh -fNg -L 8888:192.168.2.105:22 wangjl@192.168.2.105 #必须参数 -g，没有则无法从A连接C
	@B$ ssh -Ng -L 8888:192.168.2.105:22 wangjl@192.168.2.105 #必须指定完整转发格式 本地端口:远程IP:远程端口
	检查：
	@B$ sudo netstat -anp | grep 8888 #注意区别：之前第三列是 127.0.0.1，只能本地可见，必须 0.0.0.0 才能局域网可见
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      4036534/ssh         
	tcp6       0      0 :::8888                 :::*                    LISTEN      4036534/ssh
	登录：
	@A2$ ssh -p 8888 wangjl@192.168.2.120 #输入C的密码，登录了C




ii) ssh -L 用法2（本地起端口映射到其他机器） OK 我的模式
本地主机（A）、跳板机（B）、目标主机（C）
A指定本地端口访问通过SSH连接转发给B，B将这些数据转发给C，同时将结果传回给A。（一般情况下B的端口是远程连接端口）
A：ssh -CfNg -L 本地端口:⽬标ip:⽬标端⼝ 跳板账号@ip

A-> | B-> C
A-> | C
	@A$ ssh -L 8888:HostC:22 UserB@HostB
	@A$ ssh -p 8888 userC@localhost
意思是在 HostA 上，让 localhost 起 8888 端口，使之映射到 HostC 的 22 端口。
如此，在 HostA 上可以使用 localhost:8888 就像使用 HostC:22 一样。

测试：
	@A$ ssh -N -L 8888:192.168.2.105:22 wangjl@y.biomooc.com
	@A$ ssh -p 8888 wangjl@localhost #输入C的密码登录C成功。 该条不退出(exit)，前一条也不会退出。

几个命令：
	A： ssh -CfNg -L 本地端口:⽬标ip:⽬标端⼝ 跳板账号@ip
	netstat -antulp | grep 6666 # 查看端⼝占⽤
	进行远程桌面连接：rdesktop 127.0.0.1:本地端口
	远程终端连接：ssh -p 端口 账户@ip地址











(2) 远程转发 -R 用法 [-R address]
需要设置，见上文1.3
	 -R [bind_address:]port:host:hostport
     -R [bind_address:]port:local_socket
     -R remote_socket:host:hostport
     -R remote_socket:local_socket
     -R [bind_address:]port

指定远程转发到本地。
Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the local side.

This works by allocating a socket to listen to either a TCP port or to a Unix socket on the remote side.  Whenever a connection is made to this port or Unix socket, the connection is forwarded over the secure channel, and a connection is made from the local machine to either an explicit destination specified by host port hostport, or local_socket, or, if no explicit destination was specified, ssh will act as a SOCKS 4/5 proxy and forward connections to the destinations requested by the remote SOCKS client.

Port forwardings can also be specified in the configuration file. Privileged ports can be forwarded only when logging in as root on the remote machine.  IPv6 addresses can be specified by enclosing the address in square brackets.

By default, TCP listening sockets on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address.  An empty bind_address, or the address ‘*’, indicates that the remote socket should listen on all interfaces. Specifying a remote bind_address will only succeed if the server's GatewayPorts option is enabled (see sshd_config(5)).

If the port argument is ‘0’, the listen port will be dynamically allocated on the server and reported to the client at run time. When used together with -O forward the allocated port will be printed to the standard output.



i) ssh -R 用法1（非本地起端口映射到其他机器）
A->B-> | C
A->| C
	HostC$ ssh -R 8888:localhost:22 UserB@HostB
	@A $ ssh -p 8888 UserC@hostB
意思是在 HostC 上，让 HostB 起 8888 端口，使之映射到 localhost 的 22 端口。
如此，在 HostA 上可以使用 HostB:8888 就像使用 HostC:22 一样。

测试： 
	@C $ ssh -Ng -R 8888:localhost:22 wangjl@y.biomooc.com #输入B的密码
	@A $ ssh -p 8888 wangjl@y.biomooc.com  #失败
	@A2 $ ssh -p 8888 wangjl@192.168.2.120 #输入C密码登录C
	@B $ ssh -p 8888 wangjl@localhost #输入C密码登录C
	
查端口：
	要加 sudo
	@B$ sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      4040417/sshd: wangj 
	tcp        0      0 192.168.2.120:8888      192.168.2.105:58410     ESTABLISHED 4040417/sshd: wangj
	
	$ ps 4040417
		PID TTY      STAT   TIME COMMAND
	4040417 ?        S      0:00 sshd: wangjl



ii) ssh -R 用法2（非本地起端口映射到其他机器）
A->|B->C
A->|C
	@A$ ssh -CfNg -R 自定义端⼝:hostC:⽬标端⼝ 跳板账号B@hostB
	@A$ ssh -p 自定义端口 userC@hostB

准备：
	A:y station
	B:j.server
	C:Z server
	@B$ sudo iptables -I INPUT -p tcp --dport 8881 -j ACCEPT #开端口
	配置文件，见上文1.3
	
测试：
	@A$ ssh -Ng -R 8881:z.biomooc.com:22 wangjl@j.biomooc.com #输入B的密码，挂起
	@A$ ssh -p 8881 wangjl@j.biomooc.com #输入C的密码，确实登录了C
	@B$ ssh -p 8881 wangjl@localhost #输入C的密码，确实登录了C

检查：
	@B$ sudo netstat -anp | grep 8881
	tcp        0      0 127.0.0.1:8881          0.0.0.0:*               LISTEN      8268/sshd: wangjl   
	tcp6       0      0 ::1:8881                :::*                    LISTEN      8268/sshd: wangjl 
	修改配置文件前，第三列是 127.0.0.1，只能本地可见。
	按上文1.3修改配置文件后，重启ssh服务，重新连接，可以看到 0.0.0.0 为局域网可见：
	$ sudo netstat -anp | grep 8881
	tcp        0      0 0.0.0.0:8881            0.0.0.0:*               LISTEN      8875/sshd: wangjl   
	tcp        0      0 10.20.57.27:8881        10.20.89.188:58696      ESTABLISHED 8875/sshd: wangjl





iii) ssh -R 用法3（非本地起端口映射到其他机器）

A->B-> | C -> D
A->| D
	HostC$ ssh -R 8888:HostD:22 UserB@HostB
	@A$ ssh -p 8888 userD@hostB

意思是在 HostC 上，让 HostB 起 8888 端口，使之映射到 HostD 的 22 端口。
	在C上执行，C就像一个转发器（B端口->D端口），本机无暴漏端口。
	检查端口时，在B上。
如此，在 HostA 上可以使用 HostB:8888 就像使用 HostD:22 一样。

准备：
	A： win
	B: J
	C: y
	D: 105

测试： 
	@C$ ssh -Ng -R 8881:192.168.2.105:22 wangjl@j.biomooc.com #输入B的密码
	@A$ ssh -p 8881 wangjl@j.biomooc.com #输入D的密码，登录D
	@C$ ssh -p 8881 wangjl@j.biomooc.com #输入D的密码，登录D
	
	检查端口 
	@B$ sudo netstat -anp | grep 8881
	tcp  0  0 0.0.0.0:8881  0.0.0.0:*   LISTEN      4177/sshd: wangjl   
	tcp6 0  0 :::8881       :::*        LISTEN      4177/sshd: wangjl













(3) 动态转发 -D 用法 [-D [bind_address:]port] 没看懂
 -D [bind_address:]port
Specifies a local “dynamic” application-level port forwarding. This works by allocating a socket to listen to port on the local side, optionally bound to the specified bind_address.  Whenever a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine.  Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.  Dynamic port forwardings can also be specified in the configuration file.

IPv6 addresses can be specified by enclosing the address in square brackets.  Only the superuser can forward privileged ports.  By default, the local port is bound in accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to bind the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound for local use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces.

相对于本地转发和远程转发的单一端口转发模式而言，动态转发有点更加强劲的端口转发功能，即是无需固定指定被访问目标主机的端口号。这个端口号需要在本地通过协议指定，该协议就是简单、安全、实用的 SOCKS 协议。


i) 本地的代理服务，通过 localhost:22 隧道入口建立 Failed
	HostA$ ssh -D 8080 user@hostB
此时 localhost:8080 就是本地的 Socket 代理服务器。
效果，即浏览器配置了 本机IP:8080 Socket5 的代理后，就可以像在本机上一样访问网站资源了。

测试：
	@win$ ssh -D 50000 wangjl@j.biomooc.com
	用firefox浏览器，在浏览器里设置使用socks5代理127.0.0.1:50000，然后浏览器就可以访问host1所在网络内的任何IP了。
How to use socks5?
	在Windows系统上，您可以通过以下步骤设置和使用Socks5代理：
	step1：打开控制面板并进入“Internet选项”。
	step2：选择“连接”选项卡，并点击“局域网设置”。
	step3：勾选“使用代理服务器”，在地址和端口号处分别填写Socks5代理服务器的IP地址和端口号，并在认证选项卡中填写用户名和密码（如果需要）。
	step4：点击“确定”并关闭窗口。
	step5：重新启动您的浏览器或其他网络应用程序，您应该能够成功连接到Socks5代理服务器并浏览网页或使用网络应用程序。


i) 本地的代理服务，通过 HostB:22 隧道入口建立
	HostA$ ssh -D 8080 UserB:HostB
或写全
	HostA$ ssh -D localhost:8080 -p 22 UserB:HostB

此时 localhost:8080 就是HostB上的 Socket 代理服务器。
效果，即浏览器配置了 本机IP:8080 Socket5 的代理后，就可以像在HostB上一样访问网站资源了。










ref： 
https://blog.csdn.net/wxqee/article/details/49234595
https://blog.csdn.net/qq_61562251/article/details/134910406
https://zhuanlan.zhihu.com/p/148825449





========================================
|-- ssh 配置文件: ~/.ssh/config 配置别名
----------------------------------------

1. 设置别名： 传输文件 scp 为例
基本用法：
Host lab
    HostName remote
    User user
    Port port

scp 和 ssh 类似，区别是端口号前者使用-P。

(1) 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file
$ scp -P port /path/to/local/file user@remote:/path/to/remote/file
也可以使用别名
$ scp /path/to/local/file lab:/path/to/remote/file

(2) 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file
$ scp lab:/path/to/remote/file /path/to/local/file
#远程的默认路径是家目录
#下面命令把当前目录下的 file 传到远程的 ~/dir/file
$ scp file lab:dir/file

# 加上 -r 命令可以传送文件夹
# 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下
$ scp -r dir lab:

# 别忘了 . 可以用来指代当前目录
# 下面命令可以把远程的 ~/dir 目录下载到当前目录里面
$ scp -r lab:dir/ .




2. 指定私钥（~/.ssh/id_rsa），实现无密码登录
Host ssh-host1
	user root
	Hostname 1.2.3.4
	Port 2222
	# 私钥文件
	identityfile ~/.ssh/id_rsa_mysql
	RemoteForward 0.0.0.0:3306 mysql-ip:3306

Host VB105
  HostName 192.168.2.105
  User wangjl
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/gitee_id_rsa





3. 综合示例：转发多个端口
Host vm
	User root
	Hostname 181.220.x.x
	# 将vm中的127.0.0.1:1081转发到localhost的30081
	LocalForward localhost:30081 127.0.0.1:1081
	# 本地开放一个30082端口
	DynamicForward 127.0.0.1:30082





ref:
https://blog.csdn.net/omaidb/article/details/128400531





========================================
|-- ssh/config： vscode利用跳板机二次ssh连接server
----------------------------------------
1.需要连接跳板机， 然后ssh 连接 bf2.

命令行需要首先 ssh sdfk@tiaobanji ，然后在跳板机上 ssh ubuntu@yourip

怎么用vscode 来连接呢?



2. 设置.ssh/config
Host bf2
  HostName yourip
  User ubuntu
  ProxyCommand ssh sdfk@tiaobanji -W %h:%p

Host tiaobanji
  ForwardAgent yes
  StrictHostKeyChecking no
  UserKnownHostsFile=/dev/null
  User sdfk

注意如果是window 主机 用vscode ssh 连接 unix 服务器话， 要把自己的id_rsa 设置为LF格式而不是CRLF， 这样才能连接上 unix 服务器， 否则会显示管道无法写入， invalid format.

private key 需要在结尾有new line， 否则也会invalid format.

远程vscode 想显示图片， 可以下载xquartz。





3. 实战：确实可以连接内网代码
(1) vim ~/.ssh/config
Host j3
  HostName j3.biomooc.com
  User wangjl
  ProxyCommand ssh wangjl@tiaobanji -W %h:%p

Host tiaobanji
  HostName gate3.biosino.org
  ForwardAgent yes
  StrictHostKeyChecking no
  UserKnownHostsFile=/dev/null
  User wangjl

(2) 登录
vscode 重启，点击连接j3，
依次输入跳板机密码，输入内部服务器密码。







ref:
https://zhuanlan.zhihu.com/p/660733922
https://code.visualstudio.com/docs/remote/ssh




========================================
|-- ssh 反向隧道实现内网穿透： 需要一台公网云主机
----------------------------------------
1. 场景1： 学校实验室有台服务器，我在家怎么登录它？
再买一台云主机即可。

A： win at home 家庭或者宿舍，不做设置。

B: 105 Server at school 学校实验室/公司服务器 lab
C: 公网云主机 （跳板机，jumpbox），A和B都可以访问该主机

A->C;
B->C;

怎么在家让笔记本A访问服务器B: A->B？ 


(1) 在B服务器设置
@B lab$ ssh -R 10022:localhost:22 user@jumpboxC
将 lab Server 上的 22 端口反向转发到了 jumpbox 的 10022 端口。
或者说：把远程端口(跳板机C) 1022 转发到 本地(@B)22端口。

只要保持这个 ssh 不断，任何一台机器都可以首先连接到 jumpboxC，然后通过 ssh user@localhost -p 10022 连回到 labB。可以看到，这里 jumpbox 起到了一个跳板的作用，所以我们把它称作跳板机。

(2) 测试连接
@C jumpbox$ ssh user@localhost -p 10022



(3) 示例
	A: win
	B: 105 server 
	C: J server

服务器连接云主机
	@B$ ssh -Ng -R 8888:localhost:22 wangjl@j.biomooc.com #输入C的密码，挂起
	
在云主机测试
	@C$ ssh wangjl@localhost -p 8888 #输入B的密码，登录B
	检查端口号
	@C$ sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      7381/sshd: wangjl   
	tcp6       0      0 :::8888                 :::*                    LISTEN      7381/sshd: wangjl

在笔记本A上通过云主机C登录实验室服务器B:
	@A$ ssh wangjl@j.biomooc.com -p 8888 #输入B的密码，登录B

切断连接：
	@C$ kill -9 7381
	或者
	@B$ ctrl+C 快捷键


(4) 缺点： 不稳定

不过上面这么做并不稳健，如果因为网络波动导致 ssh -R 那个连接断了，那么从 jumpbox 就完全失去了到 lab 的控制。万幸的是，有一个叫做 autossh 的软件，可以自动的检测断线，并在断线的时候重连。

autossh 见本页专题。










2. 场景2：我本地有个网站，怎么分享给远方朋友？
买台云服务器即可。

本地网站 $ python3 -m http.server 8000
本地可见： http://localhost:8000/

本地执行 local$ ssh -NR 0.0.0.0:18000:localhost:8000 jumpbox
	把远程端口(jumpbox:18000)映射到本地8000
远方朋友：  http://jumpbox:18000/ 


测试：
	local: y 
	yun: jumpbox J
	本地网站：http://y.biomooc.com:8000

执行端口转发：
	local$ ssh -NR 0.0.0.0:8888:localhost:8000 wangjl@j.biomooc.com #输入j密码

尝试访问： http://j.biomooc.com:8888
	结果同上。


注意: 这里明确指定了 0.0.0.0，这告诉 ssh，要把 8888 端口绑定在远端的所有IP上。
如果像之前那样省略的话，缺省值是只绑定在 localhost，也就是只有在 jumpbox 本机才可以访问，而其他人都不能访问。
或者修改配置文件，并指定-g参数。

查看端口：
	local$ sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888    0.0.0.0:*    LISTEN      9225/sshd: wangjl   
	tcp6       0      0 :::8888         :::*         LISTEN      9225/sshd: wangjl	






3. 场景3： 比方说在本地的127.0.0.1:1080运行了HTTP代理服务，现在我想让另一台机子 remote 也能够使用这个HTTP代理。

local$ ssh -NR 11080:localhost:1080 remote
local$ ssh remote
remote$ export http_proxy=http://127.0.0.1:11080/
remote$ export https_proxy=http://127.0.0.1:11080/
remote$ curl http://ifconfig.co

看看返回的IP，是不是 remote 也用上了代理？







4. 本地端口映射

(1) 注意区分这里的 localhost 的区别！

之前我们把 lab 的22端口反向转发到了 jumpbox 的10022端口。
	lab$ ssh -R 10022:localhost:22 jumpbox
	或者说 把(-R)远程的 1x 转发到 本地 22。此处的 localhost 就是当前登录主机 lab；

现在我想把它转发到本机的20022端口，只需要执行 ssh -L 就行了，例如：
	local$ ssh -NL 20022:localhost:10022 user@jumpbox
	把(-L)本地端口 2xx 映射到 远程本机J的 1xx 端口。此处的 localhost 是将要登录的云跳板机。

登录：
	local$ ssh localhost -p 20022
	lab$

(2)示例：
	A-local: Y station - Ubuntu 客户端
	B-lab: 105 server 目标主机
	C-jumpbox: J server 云主机 跳板

lab上设置反向代理，反向连接云主机： 远端J:8888-> 本地22
	lab-B$ ssh -Ng -R 8888:localhost:22 wangjl@j.biomooc.com # 输入C的密码
	检查端口 
	@B$ sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      11142/sshd: wangjl

	局域网外登录lab-B，通过云主机C：
	@A$ ssh -p 8888 wangjl@j.biomooc.com #输入B的密码，登录B

本地端口转发： 本地端口 9 转发到 云主机C端口8
	local-A$ ssh -NL 8889:localhost:8888 wangjl@j.biomooc.com #输入C的密码

	查看端口： 发现是 127.0.0.1 只能本地使用； 而使用 -g 参数或者写为 0.0.0.0:8889 后，就变成了 0.0.0.0 了，全局域网可见。
	local-A$ sudo netstat -anp | grep 8889
	tcp        0      0 127.0.0.1:8889          0.0.0.0:*    LISTEN      4176314/ssh         
	tcp6       0      0 ::1:8889                :::*         LISTEN      4176314/ssh

	登录： 使用本地端口9
	local-A$ ssh -p 8889 wangjl@localhost #输入B的密码，登录lab-B





ref:
https://zhuanlan.zhihu.com/p/266522925
https://zhuanlan.zhihu.com/p/21999778





========================================
|-- autossh 的使用：断线自动重连
----------------------------------------
autossh is a program to start a copy of ssh and monitor it, restarting it as necessary should it die or stop passing traffic.

1. 安装
Ubuntu
$ sudo apt-get install autossh

CentOS:
$ sudo yum install autossh

Mac: $ brew install autossh




2. 本地转发 -L [本地主机:]本地主机端口:目标主机:目标主机端口

(1) 命令与参数
local$ autossh -M 5678:5679 -f -CNT -L localhost:3306:mysql:3306 ssh-host

将本地端口映射到远程主机上
	-M 监控端口:[echo端口],请在服务器上将 监控端口 和 监控端口+1 开放。如果只指定一个，则其+1默认被使用。判断断线的机制
	-f 使autossh在运行ssh之前进入后台。

	ssh参数
	-C 使用数据压缩
	-N 只连接远程主机，不打开远程shell(不需执行指令，只作端口转发)
	-T: 不分配伪终端 tty

	转发命令
	-L 将`本地主机端口`通过`ssh-host主机端口`转发到`目标主机端口`上
	-g: 允许代理服务器连接到本地转发端口(谨慎使用)


(2)实战: A->|B->C
	A-local: j
	B-jumpbox: y
	C-lab: 105 server - centOS7.9 on B:VB
安装
	@A$ sudo yum install autossh
	@A$ autossh -V #autossh 1.4g

原型：
	@A$ ssh -L 8888:HostC:22 UserB@HostB #在A上开一个端口 8，指向C的22端口。貌似与B无关，B就是转发器。
	@A$ ssh -p 8888 userC@localhost
开启该隧道：
	@A$ autossh -M 8889 -Ng -L 8888:192.168.2.105:22 wangjl@y.biomooc.com #输入B的密码
登录测试：
	@A$ ssh -p 8888 wangjl@localhost #输入C的密码，登录C

查看M 监控的啥？ 
	@A$ sudo netstat -anp | grep 8889
	tcp        0      0 0.0.0.0:8889            0.0.0.0:*               LISTEN      22625/ssh           
	tcp6       0      0 :::8889                 :::*                    LISTEN      22625/ssh
	@A$ sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      22625/ssh           
	tcp6       0      0 :::8888                 :::*                    LISTEN      22625/ssh 

	浏览器查看，打不开： http://j.biomooc.com:8889

主动杀进程后：
	@A$ kill -9 22625
	@A$ 之前的 autossh 要求输入B的密码。wangjl@y.biomooc.com's password: 
	可见，要做成断线自动重新连接，还需要设置免密登录。否则，断线就等着让输入密码，无法连接。








3. 远程转发 -R ssh-host主机端口:目标主机:目标主机端口

(1) 反向隧道实现内网穿透： A家->C云主机 |->B服务器

在B服务器上设置 @B lab$ ssh -R 10022:localhost:22 user@jumpboxC
Or
@B$ autossh -M 5678:5679 -f -CNT -R 0.0.0.0:1080:host2:1081 ssh-host 

注意： ssh-host机器的sshd_config里要打开AllowTcpForwarding选项，否则-R远程端口转发会失败。
如要绑定0.0.0.0需要打开sshd_config里的GatewayPorts选项。

开启一个本地socks端口：
	-M 监控端口:[echo端口],请在服务器上将 监控端口 和 监控端口+1 开放
	-f 后台运行autossh
	
	ssh参数
	-C 使用数据压缩
	-N 只连接远程主机，不打开远程shell(不需执行指令，只作端口转发)
	-T: 不分配伪终端 tty
	
	转发命令
	-R 将`ssh-host主机端口`通过`本地主机端口`转发到`目标主机`上
	-g: 允许代理服务器连接到本地转发端口(谨慎使用)

(2) 实战
	A: win
	B-lab: 105 server 
	C-jumpbox: J server

启动隧道
	@B$ autossh -M 8889:8890 -f -CNT -Ng -R 0.0.0.0:8888:localhost:22 wangjl@j.biomooc.com
检查端口： 三个端口都在 C 上？
	@C$sudo netstat -anp | grep 8888
	tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      22625/ssh
登录，通过云主机C：
	@A$ ssh wangjl@j.biomooc.com -p 8888 #输入B的密码，登录B
杀进程： 没有自动重启连接
	$ kill -9 22625





ref:
https://blog.csdn.net/omaidb/article/details/128400531












========================================
|-- 动态代理的使用： socks 代理设置和使用
----------------------------------------
使用情景：假设A是win客户端，B是远程主机。我想连接B并通过B访问互联网及B所在的局域网。

1. 设置 socks 代理服务器: 从B访问公网
(1)@A 打开 xshell，设置隧道：
	菜单 文件-打开；
	选择自己设置的连接B主机的条目，右键-属性，找到 连接-SSH-隧道；
	点击 添加，类型 Dynamic(SOCKS4/5)，侦听端口 1080，勾选仅接受本地连接，确定；

查看隧道状态：
	菜单 查看 - 隧道窗格；
	底下新窗口，选择最后一个 转移规则，可以看到隧道状态列表。
	如果状态是 打开，表示正常。

(2) 命令行设置 //todo
@A$ 






2. 本地使用

(1) 设置
win10 右下角 右击网络，选择 打开网络和Internet设置，
	左边选择 代理；
	右边 手动设置代理：
		1)使用代理服务器：开
		2)地址： http://socks=127.0.0.1 端口 1080
		3)请勿对以下列条目开头的地址使用代理服务器：添加: ;blog.dawneve.com;
		4)请勿对代理服务器用于本地Intranet地址：勾选
		5)保存。

原来跳过代理的4)设置：
localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;192.168.*;
现在的设置:
	删除掉 10.*;
	结尾添加 blog.dawneve.com;x.dawneve.com;




(2) 测试
查看地址：
	https://www.showmyip.gr/
	Your IP is: 202.127.25.182
	
	$ ping gate1.picb.ac.cn
	PING gate1.picb.ac.cn (202.127.25.182) 56(84) bytes of data.
	64 bytes from 202.127.25.182 (202.127.25.182): icmp_seq=1 ttl=61 time=0.594 ms

现在A的任何网络请求，都是从B开始转发到公网的。
	而对A所在局域网的请求则可能失败，除非主动设置了：请勿对以下列条目开...

如果对B所在局域网访问失败，可能是跳过了那些IP，而在A本地找这些IP：只需要删掉，让它们走代理B访问即可。
	比如 http://10.10.118.143:8787 访问B所在环境的Rstudio server



(3) 在win上取消设置
参考2(1)，设置 使用代理服务器 关。即可直接连接公网。










========================================
网络原理
----------------------------------------

网络编制：主流是IP编址；
IPv4地址为32位长，IPv6地址为128位长，
IPv4包括：网络部分和主机部分：

$ ifconfig #查看当前IP等信息

子网掩码：IP和子网掩码成对出现才能知道那些部分为网络部分。
子网掩码为1的部分对应IP中的网络部分。余下的是

同一个网络主机之间通信：ARP协议。

不同网络之间通信：网关/路由器或具有路由器功能的主机。

路由：不同网络之间传输数据的功能叫做路由功能，一般有多个接口，连接到不同的网络中，并且通过路由表进行数据转发。

域名：IP地址难记，所有我们一般使用域名进行管理。

域名分为三个部分，用.分开：
	类型：www org
	域名：域名称
	主机名：该域中的某台主机。

DNS：每个域名代表一个IP，而DNS服务器就是用来在IP与域名之间进行转换的。





========================================
|-- OSI七层模型详解 (物理层、数据链路层、网络层、传输层.....应用层协议与硬件)
----------------------------------------
https://blog.csdn.net/yaopeng_2005/article/details/7064869


1.
互联网的本质就是一系列的网络协议，这个协议就叫OSI协议（一系列协议），按照功能不同，分工不同，人为的分层七层。实际上这个七层是不存在的。没有这七层的概念，只是人为的划分而已。区分出来的目的只是让你明白哪一层是干什么用的。

每一层都运行不同的协议。协议是干什么的，协议就是标准。
实际上还有人把它划成五层、四层。
七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
五层划分为：应用层、传输层、网络层、数据链路层、物理层。
四层划分为：应用层、传输层、网络层、网络接口层。





OSI 7层模型的小结
由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。
在7层模型中，每一层都提供一个特殊的网络功能。

从网络功能的角度观察：

- 下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；
- 第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；
- 而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。

简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。









========================================
|-- TCP/IP四层参考模型，传输层协议（TCP/UDP），https/http/socket认知
----------------------------------------
1.在网络通信中，网络组件的寻址对信息的路由选择和传输来说是相当关键的。相同网络中的两台机器间的消息传输有各自的技术协定。LAN 是通过提供6字节的唯一标识符（“MAC”地址）在机器间发送消息的。SNA 网络中的每台机器都有一个逻辑单元及与其相应的网络地址。DECNET、AppleTalk 和 Novell IPX 均有一个用来分配编号到各个本地网和工作站的配置。

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
在传输层中有TCP协议与UDP协议。
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。
HTTP是应用层协议，TCP是传输层协议！ 数据包在网络传输过程中，HTTP被封装在TCP包内！！

　　┌───────────────┐┌─┬─┬──┬─┬──┬─┬──┬─┬──┬─┬──┐
　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│
　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│
　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│
　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│
　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│
　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│
　　└───────────────┘└─┴─┴──┴─┴──┴─┴──┴─┴──┴─┴──┘
　　┌─────────────┐┌────────────────┬───────────────────┐
　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│
　　└─────────────┘└────────────────┴───────────────────┘
　　┌─────────────┐┌─────────┬───────┬─────────────────┐
　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│
　　│第二层，网间层　││　　　　　└───────┘　　　　　　　　　　│
　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │
　　└─────────────┘└───────────────────────────────────┘
　　┌─────────────┐┌────────────────┬───────────────────┐
　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│
　　└──────────────┘└───────────────┴───────────────────┘


2.
		TCP		UDP
是否连接		面向连接	面向非连接
传输可靠性	可靠	不可靠
应用场合		传输大量的数据，对可靠性要求较高的场合	传送少量数据、对可靠性要求不高的场景
速度		慢	快





3. socket协议
https://qinqianshan.com/web/web_basic/socks-https-http/







========================================
|-- 交换机、路由器、集线器
----------------------------------------
https://qinqianshan.com/web/web_basic/switches-and-routers/

集线器是物理层设备,采用广播的形式来传输信息。

交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。

路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。



首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。

而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。 这样在机器很多或数据量很大时，两者将会有比较明显的。

而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 






========================================
怎么设置信道来提高【无线路由】的速度？
----------------------------------------
1.现有无线基本上都是2.4G的，有1-13个信道。
2.每个路由发出的无线信号都有主信道和带宽。可以通过手机安装wifi analyzer这款app来查看。
3.信道不重叠时互不干扰，这时无线通信质量最好。只有1,6,11这三个信道能互相不干扰。
4.信道完全重叠的无线信号会自动协商，当一个wifi发送信号时，其他路由自动等待。
	这能完成基本通信，但肯定会降低速度。
5.信道有重叠的信号会互相争抢，干扰比同信道竞争更强，因为没有机制保证大家安静的等待一个wifi去通信。
6.蜂窝网络会自动减少每个路由器的功率，保证1,6,11三个通道基本覆盖整个体育场。


========================================
|-- 无线路由的ngb是什么意思？
----------------------------------------
//



========================================
|-- 路由功能？静态路由表有什么用？
----------------------------------------

路由器的作用是帮你把数据包发送到某个地址，比如有个数据包要发给115.239.210.27，路由器其实不认识这个地址，那么它就会发给wan口，wan口通向电信服务器那边，而服务器知道这是百度的地址，这样就联通了。这个例子中115.239.210.27这个ip是服务器认识的，但是如果服务器不认识这个地址的话，那么数据包就不能发到目的地址。比如两个路由器串联，A路由到B路由的lan口是互不认识的，当然电信服务器也不可能认识这种内网地址，因此这种情况下路由器就不能帮你转发到目的地址了。所以就有了静态路由这个东西，比如有这样的静态路由192.168.2.0 255.255.255.0 192.168.1.2，意思让路由器一发现有发到192.168.2.0 255.255.255.0这个地方去的数据，就啥也不管直接发到192.168.1.2即可。192.168.1.2这个地址不能路由器自己的地址，但是一定要是某个跟自己连接着的路由器那个口的ip。举个例子来说明一下：

A路由wan口192.168.0.1 255.255.255.0，lan口192.168.1.1 255.255.255.0
B路由wan口192.168.1.2 255.255.255.0，lan口192.168.2.1 255.255.255.0

A的lan口出来的线接B的wan口，这种情况下，接Awan口的电脑是ping不到B路由lan口下的电脑的。
路由器的基本作用是连接两个网络，可以让连接的2个网段互相连通，所以A路由wan下的电脑可以ping通A路由lan口下的电脑。然而A路由却不知道192.168.2.0这个网络，所以无法ping通B路由lan口下的电脑，所以要在
A路由下做192.168.2.0 255.255.255.0 192.168.1.2的静态路由
B路由下做192.168.0.0 255.255.255.0 192.168.1.1的静态路由。

以上只适用于高端路由器，普通家用路由器是不一样的，后者就算不做静态路由B下的电脑还是可以ping通A下的电脑，反过来就不行，因为普通家用路由器是做了动态路由的


注意事项：
配置静态路由，一定要两个路由都有配置到跳转，要不的话，只配置了一个路由，那么造成的情况就是数据包无法发送出来或数据包发送出去了，找不到返回的地址！切记


目的网络IP：访问的目标主机或IP网段。
　　子网掩码：填入子网掩码，一般为255.255.255.0。
　　网关：下一跳路由器入口的IP地址。
注意：
　　1、网关必须是与本路由器LAN口IP属于同一个网段。
　　2、如果目的IP地址是一台主机IP地址，则子网掩码必须为255.255.255.255。
　　3、如果目的IP地址为IP网段，则须与子网掩码匹配。例如，如果目的IP为10.0.0.0，子网掩码为255.0.0.0。
#




========================================
|-- 路由覆盖面积不够怎么办？
----------------------------------------

配置方法：
http://jingyan.baidu.com/article/c146541357a7fa0bfcfc4cb6.html
无线设置-基本设置-开启WDS。


注意事项
	2台路由器必须都支持WDS中继（桥接）功能。
	只需要主路由器1支持WPA加密中继连接就可以，路由器2可以不支持，但是必须支持WPA的无线加密协议。
	有些54M的老路由器不支持WPA方式的中继连接，但本身支持WPA加密，可以做附路由。

	DHCP不能2个都开启，必须是连接外网的那台路由器开启（手动配置IP除外）
	主路由器的Internet连接方式无需干涉，不需要额外配置，保持原有方式就可以。
	民用路由器无线信号稳定性差，如果断网、连接不上，必须先重启路由器2，再重启路由器1，然后用电脑重新连接即可。 先重启路由器1有时会导致中继失败。



原理：
其实很简单，无需购置额外的高功率路由器，只需加装一台无线中继器或无线拓展器，就能轻易增加无线网络的覆盖面积了，这样不仅可以收获较好的信号覆盖，而且也不用再担心大功率路由器会引发辐射的问题了。无线中继器通过无线连接到路由器或接入点（AP）上，加速信号，重新发送，来拓展信号的覆盖范围。

注意要点：
首先，无线中继器必须部署在信号源（无线路由器）和客户端设备（手机、平板）的接收范围内。
其次，如果信号源的WiFi是加密的话，无线中继器也需要相关的加密密钥。
还有，设备的兼容性问题可能降低无线信号源的信号质量。





========================================
|-- ip段/数字,如192.168.0.1/24是什么意思?
----------------------------------------
ip地址一共是32位，/24就表示他的网络号是24位，也就是说共有2^（32-24）-2个主机（因为主机为全0和全1的保留不用，所以需要减2），共254个ip，其他的按此类推~~

/24表示掩码的位数，A类IP地址的默认子网掩码为255.0.0.0（由于255相当于二进制的8位1，所以也缩写成“/8”，表示网络号占了8位）;B类的为255.255.0.0（/16）;C类的为255.255.255.0(/24)。/30就是255.255.255.252。32就是255.255.255.255.

子网掩码的前缀表示法！  
11111111 11111111 1111111 00000000  24个1组成    
转成成十进制等于 255.255.255.0    

11111111 11111111 1111111 11111100  30个1组成    
转成成十进制等于 255.255.255.252 



ip地址后面跟/24表示掩码位是24位，子网掩码是255.255.255.0的IP地址，其主机位最多有254个。
子网掩码通常有以下2种格式的表示方法：
1． 通过与IP地址格式相同的点分十进制表示
如：255.0.0.0 或255.255.255.128

2． 在IP地址后加上"/"符号以及1-32的数字，其中1-32的数字表示子网掩码中网络标识位的长度
如：192.168.1.1/24 的子网掩码也可以表示为255.255.255.0
子网掩码一般为255.255.255.0

http://blog.csdn.net/aerchi/article/details/39396423



========================================
|-- 默认DNS推荐
----------------------------------------
dns： 123.125.81.6

电信：首选地址：101.226.4.6，备用地址：218.30.118.6     联通：首选地址：123.125.81.6，备用地址：140.207.198.6
移动：首选地址：101.226.4.6，备用地址：218.30.118.6     铁通：首选地址：101.226.4.6，备用地址：218.30.118.6 
		
测试所在运营商网络 http://www.ip.cn/




========================================
|-- 二级路由器设置实例
----------------------------------------

更便宜的无线扩容方案，是从现有无线路由lan口接出一根网线，连到新路由的wan口，设置不同的域（如顶层用192.168.1.*，第二层使用192.168.2.*）即可容纳二倍的无线设备上网。同理，使用三个无线路由即可容纳三倍的无线设备上网。
同一个嵌套的子网内不要有重复的域名！


顶级Wan口：
	MAC地址：	D8-15-0D-7B-B2-DD	 
	IP地址：	202.196.120.202	静态IP
	子网掩码：	255.255.255.0	 
	网关：	202.196.120.193	 
	DNS服务器：	202.196.64.1 , 114.114.114.114

顶级Lan口：以太网适配器 本地连接:
   连接特定的 DNS 后缀 . . . . . . . : a.com
   本地链接 IPv6 地址. . . . . . . . : fe80::2046:449a:e5fb:8fce%11
   IPv4 地址 . . . . . . . . . . . . : 192.168.1.100
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . : 192.168.1.1	
#


二级Wan口：
	基本设置
	WAN口连接类型自动获得IP地址 
	IP地址192.168.1.200
	子网掩码255.255.255.0
	网关192.168.1.1
	DNS服务器202.196.64.1 , 114.114.114.114

二级LAN口设置
	MAC地址BC-46-99-23-96-EC
	LAN口IP设置自动（推荐） 
	IP地址192.168.0.1
	子网掩码255.255.255.0 






========================================
网络基础配置命令
----------------------------------------
lspci 列出所有网卡信息 eth0 eth1 ...；
lsusb	列出所有usb设备；

ifconfig -a查看所有接口
ifconfig eth0 查看特定接口

ifup、ifdown 来启用禁用某网卡
ifup eth0
ifdown eth0

setup命令配制网络：类图形界面，其实是文本的界面。
配制完成，用ifup启用网卡，并使用ifconfig命令查看信息。



网络相关配置文件
网卡配制文件
/etc/sysconfig/network-scripts/ifcfg-eth0

DNS配置文件
/etc/resolv.conf

主机名配置文件
/etc/sysconfig/network

静态主机名配置文件
/etc/hosts



网络相关配置文件Ubuntu1604
du@Bioinf1:/etc/network$ ls -lth
总用量 32K
-rw-r--r-- 1 root root  510 10月 17 11:49 interfaces

du@Bioinf1:/etc/network$ cat interfaces


========================================
|-- 网络测试命令
----------------------------------------
测试网络连通性
ping 192.168.1.1
ping baidu.com

测试DNS解析
host baidu.com
dig baidu.com

显示路由表
ip route

追踪到达目标地址的网络路径
traceroute baidu.com

使用mtr进行网络质量测试（结合traceroute和ping）
mtr baidu.com

修改主机名 hostname NGS
这是临时修改，重启就没了，永久修改需要:
主机名配置文件
/etc/sysconfig/network


========================================
|-- 网站性能测试工具 Apache Benchmark(ab)  
----------------------------------------
Apache Benchmark简称为ab，是apache自带的用于HTTP Server测试的工具。它可以接受单一的URL，然后重复地按照指定的多个独立线程的方式加载，并使用不同的命令行参数控制访问的次数、最大的并发访问数等。另外一项不错的功能是可以输出比较详细的报告。

#执行100次请求，并发是10.
>ab -n 100 -c 10 http://blog.dawneve.com/

>ab -k -n 1000 -c 100 http://localhost/

-k 
 启用KeepAlive功能，即在一个HTTP会话中执行多个请求。默认不启用KeepAlive功能。 
-n requests 
 在测试会话中所执行的请求个数。默认仅执行一个请求，此时其结果不具有意义。 
-c concurrency 
 一次产生的请求个数。默认是一次一个。 
#


========================================
|-- 故障排查指导思想
----------------------------------------
网络故障排查遵循 从底层到高层、从自身到外部 的流程进行；
1 先查看网络配置信息是否正确：
	-IP地址
	-子网掩码
	-网关
	-DNS
2.查看到达网关是否连通
ping 网关IP地址

3.查看DNS解析是否正常：(防止对方挂掉，多试几个)
host baidu.com
host 163.com
host douban.com


========================================
|-- VMware12中安装的虚拟机Ubuntu12桥接联网不能用怎么办？
----------------------------------------
一般恢复默认设置即可解决：VM菜单“编辑”下的“虚拟网络编辑器”，右下角有一个 “恢复默认设置”，经过几分钟，重启虚拟主机中的系统即可联网。


========================================
|-- 使用 curl 发起http请求: 模拟delete/put/post/get请求
----------------------------------------
安装 apt-get install curl 

1. 发起http请求
$ curl http://baidu.com
<html>
<meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
</html>

抓取页面内容到一个文件中
curl -o baidu.html  http://www.baidu.com/

用 -O（大写的），后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西
curl -O http://www.mydomain.com/linux/index.html



(2) 模拟delete/put/post/get请求
https://blog.csdn.net/b1303110335/article/details/78213281
curl -h来查看请求参数的含义
-v 显示请求的信息
-X 选项指定其它协议

get: $ 	curl -v 192.168.33.1:8080/girls/age/18

post:
	$ curl -v 192.168.33.1:8080/girls -d 'age=18&cupSize=C'
	$ curl -v -X POST 192.168.33.1:8080/girls -d 'age=18&cupSize=C'

put: $ curl -v -X PUT -d "age=19&cupSize=C" 192.168.33.1:8080/girls/3

delete: $curl -v -X DELETE 192.168.33.1:8080/girls/3

-H ‘xxx’ 带请求头
$ curl -v -H 'ApiKey:xxx' -H 'Sign:xxx' -H 'RequestTime:xxx' -H 'Content-Type:application/json' -H 'User-Agent:PostmanRuntime/7.26.10' -H 'Accept:*/*' -H 'Accept-Encoding:gzip, deflate, br' -H 'Connection:keep-alive' -X POST 192.xxx.xx.xx:xxxx/test/xxxx -d '{"orgCode":"xxx","districtId":"1"}'







2. 断点续传，-C(大写的)
curl -C -O http://www.sina.com.cn





3. 当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理
curl -x 192.168.2.203:8089 -o home.html https://www.sina.com.cn/

https://www.iteye.com/blog/pgwcumt-1706624
(1)有些网站要求我们使用固定的浏览器进行访问，使用curl同样可以模拟，只需要把浏览器信息加入http request中即可，使用option:-A，
curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 192.168.2.203:8089 -o page.html -D cookie0001.txt http://baidu.com
这样，服务器端接到访问的要求，会认为你是一个运行在Windows 2000上的IE6.0
而"Mozilla/4.73 [en] (X11; U; Linux 2.2; 15 i686"则可以服务端Linux上的Netscape 4.73。


(2)有些网站做了防盗链的处理，就是检查http访问的referer，如果和设定不匹配则不允许访问。curl提供了设定referer的option： -e
curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x 192.168.2.203:8089 -e "www.baidu.com" -o page.html -D cookie0001.txt http://baidu.com
这样就是告诉服务器，你是从百度点击某个链接过来的


https://www.cnblogs.com/panxuejun/p/10574038.html
# 指定http代理IP和端口
curl -x 113.185.19.192:80 http://aiezu.com/test.php
curl --proxy 113.185.19.192:80 http://aiezu.com/test.php
 
#指定为http代理
curl -x http_proxy://113.185.19.192:80 http://aiezu.com/test.php
 
#指定为https代理
curl -x HTTPS_PROXY://113.185.19.192:80 http://aiezu.com/test.php
 
#指定代理用户名和密码，basic认证方式
curl -x aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php
curl -x 113.185.19.192:80 -U aiezu:123456 http://aiezu.com/test.php
curl -x 113.185.19.192:80 --proxy-user aiezu:123456 http://aiezu.com/test.php
 
#指定代理用户名和密码，ntlm认证方式
curl -x 113.185.19.192:80 -U aiezu:123456 --proxy-ntlm http://aiezu.com/test.php
 
#指定代理协议、用户名和密码，basic认证方式
curl -x http_proxy://aiezu:123456@113.185.19.192:80 http://aiezu.com/test.php






4. 快速用法（配合sed/awk/grep）
$curl http://mydomain.net

下载保存
$curl http://mydomain.net > index.html
$curl -o index.html http://mydomain.net
$curl -O http://mydomain.net/target.tar.gz

GET
$curl http://www.yahoo.com/login.cgi?user=nickname&password=12345

POST
$curl -d "user=nickname&password=12345" http://www.yahoo.com/login.cgi

POST 文件
$curl -F upload= $localfile  -F $btn_name=$btn_value http://mydomain.net/~zzh/up_file.cgi

通过代理 -x
$curl -x 123.45.67.89:1080 -o page.html http://mydomain.net

保存cookie -D
$curl -x 123.45.67.89:1080 -o page1.html -D cookie0001.txt http://mydomain.net

使用cookie -b
$curl -x 123.45.67.89:1080 -o page1.html -D cookie0002.txt -b cookie0001.txt http://mydomain.net

模仿浏览器 -A
$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -o page.html -D cookie0001.txt http://mydomain.net

伪造referer -e
$curl -A "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)" -x123.45.67.89:1080 -e"mail.yahoo.com" -o page.html -D cookie0001.txt http://mydomain.net






5. 高级下载功能
循环下载
$curl -O http://mydomain.net/~zzh/screen[1-10].JPG

循环（匹配）下载
$curl -O http://mydomain.net/~{zzh,nick}/[001-201].JPG  # >like zzh/001.JPG

循环（引用）下载
$curl -o #2_#1.jpg http://mydomain.net/~{zzh,nick}/[001-201].JPG # like >001_zzh.jpg

断点续传
$curl -c -O http://mydomain.net/~zzh/screen1.JPG

分块下载
$curl -r  0 -10240  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 10241 -20480  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 20481 -40960  -o "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3 &\
$curl -r 40961 - -o  "zhao.part1"  http://mydomain.net/~zzh/zhao1.mp3
...
$cat zhao.part* > zhao.mp3







6. curl语法及选项
curl（7.29.0）所支持的选项（options）参数如下
在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP
    --anyauth       选择 "any" 认证方法 (H)
-a, --append        添加要上传的文件 (F/SFTP)
    --basic         使用HTTP基础认证（Basic Authentication）(H)
    --cacert FILE   CA 证书，用于每次请求认证 (SSL)
    --capath DIR    CA 证书目录 (SSL)
-E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL)
    --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL)
    --ciphers LIST  SSL 秘钥 (SSL)
    --compressed    请求压缩 (使用 deflate 或 gzip)
-K, --config FILE   指定配置文件
    --connect-timeout SECONDS  连接超时设置
-C, --continue-at OFFSET  断点续转
-b, --cookie STRING/FILE  Cookies字符串或读取Cookies的文件位置 (H)
-c, --cookie-jar FILE  操作结束后，要写入 Cookies 的文件位置 (H)
    --create-dirs   创建必要的本地目录层次结构
    --crlf          在上传时将 LF 转写为 CRLF
    --crlfile FILE  从指定的文件获得PEM格式CRL列表
-d, --data DATA     HTTP POST 数据 (H)
    --data-ascii DATA  ASCII 编码 HTTP POST 数据 (H)
    --data-binary DATA  binary 编码 HTTP POST 数据 (H)
    --data-urlencode DATA  url 编码 HTTP POST 数据 (H)
    --delegation STRING GSS-API 委托权限
    --digest        使用数字身份验证 (H)
    --disable-eprt  禁止使用 EPRT 或 LPRT (F)
    --disable-epsv  禁止使用 EPSV (F)
-D, --dump-header FILE  将头信息写入指定的文件
    --egd-file FILE  为随机数据设置EGD socket路径(SSL)
    --engine ENGINGE  加密引擎 (SSL). "--engine list" 指定列表
-f, --fail          连接失败时不显示HTTP错误信息 (H)
-F, --form CONTENT  模拟 HTTP 表单数据提交（multipart POST） (H)
    --form-string STRING  模拟 HTTP 表单数据提交 (H)
    --ftp-account DATA  帐户数据提交 (F)
    --ftp-alternative-to-user COMMAND  指定替换 "USER [name]" 的字符串 (F)
    --ftp-create-dirs  如果不存在则创建远程目录 (F)
    --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F)
    --ftp-pasv      使用 PASV/EPSV 替换 PORT (F)
-P, --ftp-port ADR  使用指定 PORT 及地址替换 PASV (F)
    --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F)
    --ftp-pret      在 PASV 之前发送 PRET (drftpd) (F)
    --ftp-ssl-ccc   在认证之后发送 CCC (F)
    --ftp-ssl-ccc-mode ACTIVE/PASSIVE  设置 CCC 模式 (F)
    --ftp-ssl-control ftp 登录时需要 SSL/TLS (F)
-G, --get           使用 HTTP GET 方法发送 -d 数据  (H)
-g, --globoff       禁用的 URL 队列 及范围使用 {} 和 []
-H, --header LINE   要发送到服务端的自定义请求头 (H)
-I, --head          仅显示响应文档头
-h, --help          显示帮助
-0, --http1.0       使用 HTTP 1.0 (H)
    --ignore-content-length  忽略 HTTP Content-Length 头
-i, --include       在输出中包含协议头 (H/F)
-k, --insecure      允许连接到 SSL 站点，而不使用证书 (H)
    --interface INTERFACE  指定网络接口／地址
-4, --ipv4          将域名解析为 IPv4 地址
-6, --ipv6          将域名解析为 IPv6 地址
-j, --junk-session-cookies 读取文件中但忽略会话cookie (H)
    --keepalive-time SECONDS  keepalive 包间隔
    --key KEY       私钥文件名 (SSL/SSH)
    --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL)
    --krb LEVEL     启用指定安全级别的 Kerberos (F)
    --libcurl FILE  命令的libcurl等价代码
    --limit-rate RATE  限制传输速度
-l, --list-only    只列出FTP目录的名称 (F)
    --local-port RANGE  强制使用的本地端口号
-L, --location      跟踪重定向 (H)
    --location-trusted 类似 --location 并发送验证信息到其它主机 (H)
-M, --manual        显示全手动
    --mail-from FROM  从这个地址发送邮件
    --mail-rcpt TO  发送邮件到这个接收人(s)
    --mail-auth AUTH  原始电子邮件的起始地址
    --max-filesize BYTES  下载的最大文件大小 (H/F)
    --max-redirs NUM  最大重定向数 (H)
-m, --max-time SECONDS  允许的最多传输时间
    --metalink      处理指定的URL上的XML文件
    --negotiate     使用 HTTP Negotiate 认证 (H)
-n, --netrc         必须从 .netrc 文件读取用户名和密码
    --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数
    --netrc-file FILE  设置要使用的 netrc 文件名
-N, --no-buffer     禁用输出流的缓存
    --no-keepalive  禁用 connection 的 keepalive
    --no-sessionid  禁止重复使用 SSL session-ID (SSL)
    --noproxy       不使用代理的主机列表
    --ntlm          使用 HTTP NTLM 认证 (H)
-o, --output FILE   将输出写入文件，而非 stdout
    --pass PASS     传递给私钥的短语 (SSL/SSH)
    --post301       在 301 重定向后不要切换为 GET 请求 (H)
    --post302       在 302 重定向后不要切换为 GET 请求 (H)
    --post303       在 303 重定向后不要切换为 GET 请求 (H)
-#, --progress-bar  以进度条显示传输进度
    --proto PROTOCOLS  启用/禁用 指定的协议
    --proto-redir PROTOCOLS  在重定向上 启用/禁用 指定的协议
-x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理
    --proxy-anyauth 在代理上使用 "any" 认证方法 (H)
    --proxy-basic   在代理上使用 Basic 认证  (H)
    --proxy-digest  在代理上使用 Digest 认证 (H)
    --proxy-negotiate 在代理上使用 Negotiate 认证 (H)
    --proxy-ntlm    在代理上使用 NTLM 认证 (H)
-U, --proxy-user USER[:PASSWORD]  代理用户名及密码
     --proxy1.0 HOST[:PORT]  在指定的端口上使用 HTTP/1.0 代理
-p, --proxytunnel   使用HTTP代理 (用于 CONNECT)
    --pubkey KEY    公钥文件名 (SSH)
-Q, --quote CMD     在传输开始前向服务器发送命令 (F/SFTP)
    --random-file FILE  读取随机数据的文件 (SSL)
-r, --range RANGE   仅检索范围内的字节
    --raw           使用原始HTTP传输，而不使用编码 (H)
-e, --referer       Referer URL (H)
-J, --remote-header-name 从远程文件读取头信息 (H)
-O, --remote-name   将输出写入远程文件
    --remote-name-all 使用所有URL的远程文件名
-R, --remote-time   将远程文件的时间设置在本地输出上
-X, --request COMMAND  使用指定的请求命令
    --resolve HOST:PORT:ADDRESS  将 HOST:PORT 强制解析到 ADDRESS
    --retry NUM   出现问题时的重试次数
    --retry-delay SECONDS 重试时的延时时长
    --retry-max-time SECONDS  仅在指定时间段内重试
-S, --show-error    显示错误. 在选项 -s 中，当 curl 出现错误时将显示
-s, --silent        Silent模式。不输出任务内容
    --socks4 HOST[:PORT]  在指定的 host + port 上使用 SOCKS4 代理
    --socks4a HOST[:PORT]  在指定的 host + port 上使用 SOCKSa 代理
    --socks5 HOST[:PORT]  在指定的 host + port 上使用 SOCKS5 代理
    --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码
    --socks5-gssapi-service NAME  为gssapi使用SOCKS5代理服务名称
    --socks5-gssapi-nec  与NEC Socks5服务器兼容
-Y, --speed-limit RATE  在指定限速时间之后停止传输
-y, --speed-time SECONDS  指定时间之后触发限速. 默认 30
    --ssl           尝试 SSL/TLS (FTP, IMAP, POP3, SMTP)
    --ssl-reqd      需要 SSL/TLS (FTP, IMAP, POP3, SMTP)
-2, --sslv2         使用 SSLv2 (SSL)
-3, --sslv3         使用 SSLv3 (SSL)
    --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL)
    --stderr FILE   重定向 stderr 的文件位置. - means stdout
    --tcp-nodelay   使用 TCP_NODELAY 选项
-t, --telnet-option OPT=VAL  设置 telnet 选项
     --tftp-blksize VALUE  设备 TFTP BLKSIZE 选项 (必须 >512)
-z, --time-cond TIME  基于时间条件的传输
-1, --tlsv1         使用 => TLSv1 (SSL)
    --tlsv1.0       使用 TLSv1.0 (SSL)
    --tlsv1.1       使用 TLSv1.1 (SSL)
    --tlsv1.2       使用 TLSv1.2 (SSL)
    --trace FILE    将 debug 信息写入指定的文件
    --trace-ascii FILE  类似 --trace 但使用16进度输出
    --trace-time    向 trace/verbose 输出添加时间戳
    --tr-encoding   请求压缩传输编码 (H)
-T, --upload-file FILE  将文件传输（上传）到指定位置
    --url URL       指定所使用的 URL
-B, --use-ascii     使用 ASCII/text 传输
-u, --user USER[:PASSWORD]  指定服务器认证用户名、密码
    --tlsuser USER  TLS 用户名
    --tlspassword STRING TLS 密码
    --tlsauthtype STRING  TLS 认证类型 (默认 SRP)
    --unix-socket FILE    通过这个 UNIX socket 域连接
-A, --user-agent STRING  要发送到服务器的 User-Agent (H)
-v, --verbose       显示详细操作信息
-V, --version       显示版本号并退出
-w, --write-out FORMAT  完成后输出什么
    --xattr        将元数据存储在扩展文件属性中
-q                 .curlrc 如果作为第一个参数无效






https://www.jianshu.com/p/07c4dddae43a



========================================
|-- 如何查看实时网速？
----------------------------------------
1. 推荐工具：nload
ubuntu的安装可以使用apt进行，apt-get install nload 

其他系统安装过程如下
wget http://www.roland-riegel.de/nload/nload-0.7.2.tar.gz
tar zxvf nload-0.7.2.tar.gz
cd nload-0.7.2
./configure;make;make install

安装完成后，直接用nload （也可后面跟上网卡号查看指定网卡号）
-u参数可以指定显示的网速的单位，如nload -u M是以MB为单位，nload -u K是以KB为单位

使用

如何使用 nload 显示当前网络使用量呢？

基本语法是：
nload
nload device
nload [options] device1 device2

键入下列命令：
$ nload
$ nload eth0
$ nload em0 em2

会得到输出：

操控 nload 应用程序

nload 命令一旦执行就会开始监控网络设备，你可以使用下列快捷键操控 nload 应用程序。

你可以按键盘上的 ← → 或者 Enter/Tab 键在设备间切换。
按 F2 显示选项窗口。
按 F5 将当前设置保存到用户配置文件。
按 F6 从配置文件重新加载设置。
按 q 或者 Ctrl+C 退出 nload。
设置显示刷新间隔

默认每 100 毫秒刷新一次显示数值，下面的例子将时间间隔设置成 500 毫秒：

$ nload -t {interval_number_in_millisec}
$ nload -t 500
输出：



2.
# sar -n DEV 1 100 

1代表一秒统计并显示一次 
100代表统计一百次 
使用ntop等工具，就更方便简单了，不过这个更灵活

P.S.  sar在sysstat包

http://www.cnblogs.com/eshizhan/archive/2012/04/11/2441644.html



3.
查看流量 watch -n 1 "/sbin/ifconfig eth0 | grep bytes"
http://blog.csdn.net/blade2001/article/details/7070591





========================================
|-- 如何监控主机的资源(CPU、内存、网络)使用情况 //todo
----------------------------------------
1.监视CPU，可以使用top的空闲idle百分比看，越小表示主机越忙。
$ top -d 10 |grep Cpu  #-d指定多久记录一次
%Cpu(s):  2.1 us,  0.6 sy,  0.0 ni, 96.8 id,  0.4 wa,  0.0 hi,  0.0 si,  0.0 st




2.可视化，定期调用R刷新image。




========================================
|-- 使用linux检查端口是否畅通 telnet 10.20.66.37 8090
----------------------------------------
在linux下，我们就直接可以用telnet命令来测试端口是否畅通。具体用法：telnet 指定的IP或者 域名 端口号.

比如：telnet 10.20.66.37 8090



1. 不能访问的端口。因为根本没设置过这些端口。
## 0.不能访问的端口
$ telnet y.biomooc.com 7071
Trying 10.20.46.143...
telnet: connect to address 10.20.46.143: Connection refused

$ telnet y.biomooc.com 443
Trying 10.20.46.143...
telnet: connect to address 10.20.46.143: Connection refused




2.可以正常访问的端口，都有具体的服务。
## 1. mysql端口
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
Connection closed by foreign host.


## 2. flask的web端口
$ telnet y.biomooc.com 8000
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

Connection closed by foreign host.


## 3. nginx端口
$ telnet y.biomooc.com 80
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
## ctrl+C
^CConnection closed by foreign host.


## 5. jupyter 端口
$ telnet y.biomooc.com 7000
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

HTTP/1.1 400 Bad Request

Connection closed by foreign host.



## 6. Rstudio端口
$ telnet y.biomooc.com 8787
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.

HTTP/1.1 400 Bad Request
Date: Thu, 05 Dec 2019 02:27:30 GMT
Connection: close
Server: RStudio

Connection closed by foreign host.


3.
综上，只要出现 Escape character is '^]'. 这一行，就表示这个端口可以正常访问。





========================================
|-- 因为断网，CentOS不能ssh连接怎么办？重启网络
----------------------------------------
1.显示器直接连接主机
ctrl+alt+F1 进入新终端，一共有F1-F6几个独立的root终端。

2. 重启网络服务
sudo systemctl restart network

3.再试试其他机器进行ssh连接
一般就可以了。

如果不可以，关机重启。
先关硬盘，再关主机。
开机也是先开硬盘，再开主机。





========================================
|-- 实时显示 tcp 访问请求和响应
----------------------------------------
$ sudo tcpdump -s0 -A -n -i any | grep -o -E '(GET|POST|HEAD) .*' 
[sudo] password for wangjl: 
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
POST /events/get_events HTTP/1.1
POST /rpc/set_workbench_metrics HTTP/1.1
POST /rpc/console_input HTTP/1.1
POST /rpc/console_input HTTP/1.1


请求pdf图片
GET /file_show?path=%2Fdata%2Fjinwf%2Fwangjl%2Fapa%2Fmouse%2FRNA_matrix%2Fcluster%2Fmef02_dotplot.pdf HTTP/1.1






2. 什么是RPC
https://zhuanlan.zhihu.com/p/139688497

提到RPC（Remote Procedure Call），就躲不开提到分布式，这个促使RPC诞生的领域。












========================================
用iptables搭建一套强大的安全防护盾
----------------------------------------
http://blog.chinaunix.net/uid-26495963-id-3279216.html

1.什么是iptables
常见于linux系统下的应用层防火墙工具。

常用人员：
	系统管理人员、网络工程人员、安全人员等。


2.场景：模拟用iptables控制并发的http访问

目标机器：IP2	json233
客户端机器：IP1	json232

场景描述：
IP1(通过ab命令) -> IP2(http服务)

需要虚拟机配合测试。
未完待续。


参考资料
http://www.imooc.com/learn/389

详情参考本博客： Linux/网络与iptables





3.学习iptables的意义
1）如何用iptables搭建一套实际使用的防火墙；
2）如何用iptables进行防攻击；
3）如何利用iptables进行数据包转发；
4）明白iptables的强大及实际使用的意义。




4. 参考资料 
2 小时玩转 iptables: https://zhuanlan.zhihu.com/p/279919870
CentOS7 下iptables安装与iptables使用 https://blog.csdn.net/a568418299/article/details/103472754
iptables相关操作以及简单理解端口和服务之间关系 https://blog.csdn.net/weixin_33922670/article/details/86464154






========================================
|-- iptables安全防护盾实例: 拒绝高并发访问源
----------------------------------------
2022.5.6 更新

1.
定义：iptables是常见的应用于linux下的应用层防火墙工具。
常用人员：
	系统管理人员: 安全策略
	网络工程人员: 网络控制，人员的上网行为等
	安全人员: 


视频：http://www.imooc.com/learn/389
	http://www.imooc.com/search/?words=iptables



(2) iptables v1.4.21 和 iptables-services 的区别?
centos7.2 (1511) 最小安装好以后，默认没有firewalld（经过rpm -qa查看的确没有），但有iptables，并且部分iptables命令却可以用，比如：
执行命令：iptables --version，可以看到iptables的版本号为1.4.21
执行命令：iptables -A INPUT -p tcp --dport 22 -j ACCEPT，这个命令敲完是立刻生效的，但重启后规则就没了，并且像service iptables save这样的命令也没有, /etc/sysconfig/iptables文件也不存在，即时手工建立这个文件也不管用。

网上查了些信息，基本都是要安装这个 yum install iptables-services
安装完以后，所有iptables的正常命令就可以用了。

现在问题来了：iptables v1.4.21和iptables-services的区别是什么？

有一个帖子说 后者 提供了一些脚本: https://forums.centos.org/viewtopic.php?t=69433
The iptables-services package supplies the scripts required to stop/start/restore iptables rules. 
Run rpm -ql iptables-services to see the files it supplies.
$ rpm -ql iptables-services
/etc/sysconfig/ip6tables
/etc/sysconfig/iptables
/usr/lib/systemd/system/ip6tables.service
/usr/lib/systemd/system/iptables.service
/usr/libexec/initscripts/legacy-actions/ip6tables
/usr/libexec/initscripts/legacy-actions/ip6tables/panic
/usr/libexec/initscripts/legacy-actions/ip6tables/save
/usr/libexec/initscripts/legacy-actions/iptables
/usr/libexec/initscripts/legacy-actions/iptables/panic
/usr/libexec/initscripts/legacy-actions/iptables/save
/usr/libexec/iptables
/usr/libexec/iptables/ip6tables.init
/usr/libexec/iptables/iptables.init

另一个回答
Playing around with a server some more, I think I answered my own question...
iptables is always "running". The only way to disable it would be to change the rules and allow all traffic. iptables-services makes this easy. If I write a rule to iptables, run iptables save, and run systemctl stop iptables it essentially clears the rules. Running systemctl start iptables restores the rules. Without iptables-services, I couldn't "disable" and "enable" the firewall - it would always be there and my only option is changing rules.

如果向 iptables 写入一条规则，
	运行 iptables save
	运行 systemctl stop iptables 就清除了这条规则
	运行 systemctl start iptables 就恢复了这条规则









2.场景：模拟用iptables控制并发的http访问。
ab命令通过 192.168.2.199(win10)/120(ubuntu20.04) 机器访问 134(CentOS7)http服务.

先关闭 SELinux
$ getenforce
Enforcing

$ sudo setenforce 0




(1)启动http服务
$ sudo yum install httpd
$ sudo service httpd start

## Linux中修改httpd默认端口
$ sudo vim /etc/httpd/conf/httpd.conf
修改为
Listen 8004


重启 httpd 服务
## systemctl restart httpd.service
$ sudo service httpd restart

$ sudo service httpd status
Redirecting to /bin/systemctl status httpd.service
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: active (running) since Sun 2021-10-10 10:39:32 EDT; 4s ago
     Docs: man:httpd(8)
           man:apachectl(8)
 Main PID: 9402 (httpd)


查端口号
$ sudo netstat -antlupe | grep  httpd
tcp6       0      0 :::8004                 :::*                    LISTEN      0          247540     9402/httpd 


##写入http文件
$ cd /var/www/html/
$ sudo vim test.txt
test

内部访问 
$ curl http://127.0.0.1:8004/test.txt
test




(2) 先关掉防火墙等软件
查看iptables版本
$ iptables --version
iptables v1.4.21
$ sudo yum install iptables-services


##关掉防火墙，要同时关掉 iptables 和 firewalld
$ sudo service iptables stop
$ sudo service firewalld stop


必须加入规则，关掉都不行？ 再关掉 firewalld 可以了。
$ sudo iptables -I INPUT -p tcp --dport 8005 -j ACCEPT

浏览器访问 http://192.168.2.134:8004/test.txt
可以看到文字：test




(3)win7客户端开始并发访问
使用apache的ab工具做压力测试。
G:\xampp\apache\bin>ab
ab: wrong number of arguments
Usage: ab [options] [http://]hostname[:port]/path

#-n总请求数，-c每次并发的数量。
G:\xampp\apache\bin> ab -n 100000 -c 40 http://192.168.2.134:8004/test.txt



(3)赶快查看服务端的压力和连接数
$ netstat -an|grep 8004|grep 192.168.2.134|grep EST -c
31
$ w
  11:55:36 up  4:11,  6 users,  load average: 0.84, 0.20, 0.10


而静息状态下，这两个参数分别是：
$ netstat -an|grep 8004|grep 192.168.2.134|grep EST -c
0
$ w
 11:58:28 up  4:14,  6 users,  load average: 0.47, 0.44, 0.22



(4)在服务端控制并发
如果想控制一下这些高并发，可以使用iptables工具在服务端设置，最多并发为10，否则拒绝
$ sudo iptables -I INPUT -p tcp --dport 8004 -s 192.168.2.199 -m connlimit --connlimit-above 10 -j REJECT

客户端再次并发访问：
> ab -n 100000 -c 40 http://192.168.2.134:8004/test.txt
直接报错，而-c修改为5的时候就正常了。



查看规则 
$ sudo iptables -L -n

删掉该规则
$ sudo iptables -D INPUT -p tcp --dport 8004 -s 192.168.2.199 -m connlimit --connlimit-above 10 -j REJECT








========================================
|-- iptables “四表五链”
----------------------------------------
4.Netfilter
Netfilter是linux操作系统核心层内部的一个数据包处理模块；
什么是Hook point？数据包在Netfilter中的挂载点共5个(防火墙“四表五链”中的五链)：
	PRE_ROUTING/ INPUT/ OUTPUT/ FORWARD/ POST_ROUTING

用户层的iptables命令是调用内核层的Netfilter，通过挂载点Hook point操作数据包的。

这5个钩子函数，用来抓取数据包，并把数据包的信息拿来匹配各个链位置在对应表中的规则，匹配之后，进行对应的accept、drop等。





5.iptables规则组成 
(1)组成部分：四张表 + 五条链 +规则
四张表table(保存规则)：filter表、nat表、 mangle表、raw表
五条链chain(钩子位置)：进路由之前PREROUTING/ 进系统INPUT/ 转发FORWARD/ 出系统OUTPUT/  出路由(发送到网卡之前)POSTROUTING


(用户层) 应用层 |  iptables命令
___________________________________
(内核层)
传输层：TCP UDP  | Filter表  NAT表  Mangle表
网络层   | NetFilter
网络接口层 | 


1)表就是存储的规则；数据包到了该链处，会去对应表中查询设置的规则，然后决定是否放行、丢弃、转发还是修改等等操作。

如果要访问某台主机上面的http服务，必须先经过那台主机的内核允许，才可以进行访问
防火墙其实也是在内核上面开启的一个服务。防火墙里面有表格，写一些规则，允许哪个主机访问什么服务，这个表格由iptables进行控制
有两种规则：iptables 与 firewalld 
第一张表：filter表：放的是经过内核的ip,可使用的链：  input output forward 
第二张表：nat表：放的不是经过内核的服务，可使用的链： input output postrouting prerouting 
第三张表：备用表格mangle：可使用的链： input output forward postrouting prerouting


表名称/	功能/	内核模块
filter/	负责过滤功能，防火墙/	iptables_filter
nat(Network Address Translation)/	网络地址转换/	iptables_net
mangle/	拆解报文，修改，重新封装/	iptables_mangle
	mangle表：修改数据包，改变包头中的内容（TTL, TOS, MARK）
raw表：关闭nat表上启用的链接追踪机制


最常用的表是： filter表（访问控制）和nat（转发）表。
Filter表：用来处理是否放行
NAT表：实现数据包转发，修改源地址 端口 目标地址 端口，实现地址转换



2) 数据包在规则表/链匹配流程:
IN => PREROUTING(nat/mangle/raw)==>
	destination == localhost: INPUT(filter/mangle) ==> localhost ==> OUTPUT(filter/nat/mangle/raw)==>
	destination != localhost: FORWARD(filter/mangle) ==>
POSTROUTING(nat/raw/mangle)==> OUT



PREROUTING是不经过内核路由之前的信息
INPUT和OUTPUT均包括经过内核和不经过内核的信息
FORWARD是经过内核的路由转发信息
POSTROUTING是不经过内核路由之后的信息







========================================
|-- iptable规则的组成
----------------------------------------
数据包访问控制： ACCEPT、DROP、REJECT
数据包改写：SNAT、DNAT
信息记录：LOG

DROP没有返回消息，而REJECT给客户端有返回消息。
SNAT是对发起端(source)地址改写，DNAT对目标地址(destination)改写。



1. iptable规则的组成

iptables命令常用方法: 
iptables [table] [command] [chain] [parameter & Xmatch] [target]

比如
$ iptables -t filter -A INPUT -p tcp --dport 20185 -j ACCEPT


链名必须大写(INPUT/OUTPUT/FORWARD/PREROUTING/PPOSTROUTING)，
表名必须小写(filter/nat/mangle)，
动作大写(ACCEPT/DROP/SNAT/DNAT/MASQUERADE)，
匹配小写(-s/-d/-m <module_name>/-p)






2. 参数解释:
(1) table 4个
-t 后跟着的table可以是4表之一: filter,nat,mangle,raw (默认为 filter)

(2) 命令
链管理命令(都是立即生效的)：
-F : 清空规则链
	iptables -t nat -F 清空nat表的所有链
-N：创建新的自定义规则链
-X : drop 删除用户自定义的规则链
-P : Policy 为指定链设置默认策略；iptables -t filter -P FORWARD DROP
	-P设置默认iptables规则。
	iptables -P INPUT (DROP|ACCEPT)默认是关的/默认是开的，比如： iptables -P INPUT DROP
-E：重命令自定义链


规则管理：
-A在末尾添加规则。
-I在开头插入规则。
-D删除规则
-R：替代指定链上的规则

查看：
-L：列表，列出指定链上的指定的规则。显示当前的规则
-n -v –line-numbers -x 等参数
-L和-n一般连用。


(3) chain 5个
INPUT/FORWARD/OUTPUT/PRETOUTING/POSTROUTING/


(4) 参数与匹配

匹配条件 - 基本匹配：
-s 原地址IP。-s 发起源有哪些
-d 目的IP。-d 目标地址
-p 协议{tcp|udp|icmp}。-p 连接类型
-i 数据报文的流入接口
-o 数据报文的流出接口

匹配条件 - 扩展匹配：-m match_name
-p udp|tcp|icmp 协议类型
--sport PORT:源端口
--dport PORT:目标端口，可以是单个端口
--dports 端口段
–icmp-type
0 : echo-reply
8 : echo-request
-m 在原有基础上做个补充，tcp, state, multiport


(5) targeet 目标
-j TARGET：jump至指定的TARGET
- ACCEPT 接受
- DROP 丢弃
- REJECT 拒绝访问

- RETURN 返回调用链

- DNAT
- SNAT





2)防火墙常用的行为动作
动作	说明
ACCEPT	允许数据包通过
DROP	直接丢弃数据包，不给任何回应，此时客户端会不停地去向服务器发送数据包，发送超时才会有反应
REJECT	拒绝数据包通过，必要时会给数据发送端一个响应信息，如果客户端的请求被拒绝，就会收到拒绝的信息

SNAT	源地址转换，解决内网用户用同一个公网地址上网的问题
MASQUERADE	是SNAT的一种特殊形式，适用于动态的，临时会变的ip上
DNAT	目的地址转换



refer:
https://blog.csdn.net/u011456940/article/details/52634184






========================================
|-- iptables配制-场景1 (查看端口、开闭端口): nmap 扫描
----------------------------------------
规则1：对所有的地址开放本机的tcp（80、22、10-21）端口的访问；
规则2：允许对所有的地址开放本机的基于ICMP协议的数据包的访问。
规则3：其他未被允许的端口则禁止访问。

服务端查看所有开放端口：
$ netstat -luntp
$ iptables --version
iptables v1.4.21


#-L列出之前设置过的iptables规则
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination




$ sudo iptables -nL #-n是数字化显示主机ip和端口号
## target     prot opt source               destination         
## ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain # 不加-n的时候都是显示的主机名

## target     prot opt source               destination         
## ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:53 # 加-n的时候数字化显示




$ iptables -F # -F更新为新的规则，如果没有新规则，相当于逐条删除已有规则。
 -F, --flush [chain]   Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the  rules  one  by one.




（1）设置新的规则 3 条
# iptables -I INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口
# iptables -I INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口: ssh。一定要允许，否则服务器失控。
# iptables -I INPUT -p tcp --dport 10:21 -j ACCEPT
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination






## 没有 -n 则没有数字化端口，比如 -n 时是22，不加-n时是ssh
$ sudo iptables -L 
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere            tcp dpts:10:ftp
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:http

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination









设置规则2：
# iptables -I INPUT -p icmp -j ACCEPT



设置规则3的拒绝：
# iptables -A INPUT -j REJECT
## -A表示是追加到末尾。优先级最低，如果错误的使用了-I，则加到最前面，生效后拒绝全部访问请求。

$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-port-unreachable

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination




看本机监听了哪些端口
$ netstat -lntp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:631               0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:42712               0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:25                0.0.0.0:*                   LISTEN      -
tcp        0      0 :::111                      :::*                        LISTEN      -
tcp        0      0 :::80                       :::*                        LISTEN      -
tcp        0      0 :::22                       :::*                        LISTEN      -
tcp        0      0 ::1:631                     :::*                        LISTEN      -
tcp        0      0 ::1:25                      :::*                        LISTEN      -
tcp        0      0 :::44731                    :::*                        LISTEN      -






使用另一个Ubuntu机器上的端口扫描工具：
$ sudo apt install nmap
$ sudo nmap -sS -p 0-1000 192.168.2.134
[sudo] password for wangjl: 
Starting Nmap 7.80 ( https://nmap.org ) at 2022-05-06 21:56 CST
Nmap scan report for 192.168.2.134
Host is up (0.00030s latency).
Not shown: 987 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed msp
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
80/tcp open   http
MAC Address: 08:00:27:FF:E5:D4 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 5.32 seconds

确实只有有限的2个端口开放，其他都是关闭状态。









（2）在服务器上删除一条80端口的访问规则：
$ sudo iptables -D INPUT -p tcp --dport 80 -j ACCEPT

检查，确实没有 80 端口了
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-port-unreachable



在Ubuntu上扫描该服务器端口，发现80端口已经不能外部访问了。
$ sudo nmap -sS -p 0-1000 192.168.2.134
Starting Nmap 7.80 ( https://nmap.org ) at 2022-05-06 21:59 CST
Nmap scan report for 192.168.2.134
Host is up (0.00030s latency).
Not shown: 988 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed msp
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
MAC Address: 08:00:27:FF:E5:D4 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 4.72 seconds









（3）如果服务器上明确禁止访问80端口呢？
$ sudo iptables -I INPUT -p tcp --dport 80 -j REJECT

查看现有规则：
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80 reject-with icmp-port-unreachable
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-port-unreachable

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination



在其他机器上扫描的结果：
$ sudo nmap -sS -p 0-1000 192.168.2.134
Starting Nmap 7.80 ( https://nmap.org ) at 2022-05-06 22:05 CST
Nmap scan report for 192.168.2.134
Host is up (0.00032s latency).
Not shown: 988 filtered ports
PORT   STATE  SERVICE
10/tcp closed unknown
11/tcp closed systat
12/tcp closed unknown
13/tcp closed daytime
14/tcp closed unknown
15/tcp closed netstat
16/tcp closed unknown
17/tcp closed qotd
18/tcp closed msp
19/tcp closed chargen
20/tcp closed ftp-data
21/tcp closed ftp
22/tcp open   ssh
MAC Address: 08:00:27:FF:E5:D4 (Oracle VirtualBox virtual NIC)

Nmap done: 1 IP address (1 host up) scanned in 4.92 seconds

和上一个一样，80端口看不到状态，也就是不能访问。








（4）以上设置iptables对本机访问有什么不良影响？

在服务器上看，80端口对本地是开放的
$ netstat -lntp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:631               0.0.0.0:*                   LISTEN      -
tcp        0      0 0.0.0.0:42712               0.0.0.0:*                   LISTEN      -
tcp        0      0 127.0.0.1:25                0.0.0.0:*                   LISTEN      -
tcp        0      0 :::111                      :::*                        LISTEN      -
tcp        0      0 :::80                       :::*                        LISTEN      -
tcp        0      0 :::22                       :::*                        LISTEN      -
tcp        0      0 ::1:631                     :::*                        LISTEN      -
tcp        0      0 ::1:25                      :::*                        LISTEN      -
tcp        0      0 :::44731                    :::*                        LISTEN      -




问题1：本机不能访问本机

$ ssh wangjl@127.0.0.1
一直连接中...
也就是外网可以访问，但是本机不能访问本机的22端口（回环地址）。

解决方法：如要对回环网卡lo做允许。

查看 127.0.0.1 的网卡名，一般是 lo。
$ ifconfig
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0


$ sudo iptables -I INPUT -i lo -j ACCEPT #允许所有数据包通过lo网卡。

[!] -i, --in-interface name
	Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains).  When the "!" argument is used before the interface name, the sense is inverted.  If the interface name ends in a "+", then any interface which begins with this name will match.  If this option is omitted, any interface name will match.


再用ssh登陆自己就可以了。
$ ssh wangjl@127.0.0.1
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
RSA key fingerprint is 8d:96:7a:f8:9f:0b:3e:e1:e5:49:dc:70:dd:89:8c:57.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '127.0.0.1' (RSA) to the list of known hosts.
wangjl@127.0.0.1's password:
Last login: Sun Oct 10 18:59:45 2021 from desktop-6tss3vl.lan (win10上的虚拟机)

##Last login: Fri Aug 19 12:23:24 2016 from 192.168.1.100


$ sudo yum install telnet
$ telnet 127.0.0.1 22




问题2：本机不能访问其他主机

$ wget http://www.imooc.com/
--2016-08-19 14:05:39--  http://www.imooc.com/
Resolving www.imooc.com...
一直连接不上。

对本地主动建立的监听(http 和 ftp)，设置允许
$ sudo iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

match = -m matchname [per-match-options]
state: This module, when combined with connection tracking, allows access to the connection tracking state for this packet.
      [!] --state state
       Where  state  is  a comma separated list of the connection states to match.  Possible states are INVALID meaning that the packet could not be identified for some reason which includes running out of memory and ICMP errors which don’t correspond to any known connection,  ESTABLISHED  meaning that the packet is associated with a connection which has seen packets in both directions, NEW meaning that the packet has started a new connection, or otherwise associated with a connection which has not  seen  packets  in both  directions,  and  RELATED meaning that the packet is starting a new connection, but is associated with an existing connection, such as an FTP data transfer, or an ICMP error.




再访问外网就正常了。
$ wget http://www.imooc.com/
--2016-08-19 14:14:42--  http://www.imooc.com/
Resolving www.imooc.com... 117.121.101.40, 117.121.101.41, 115.182.41.180
Connecting to www.imooc.com|117.121.101.40|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: “index.html”

    [  <=>                            ] 220,830      534K/s   in 0.4s

2016-08-19 14:14:43 (534 KB/s) - “index.html” saved [220830]

$ curl -I http://imooc.com
返回消息头。

$ curl -I http://www.baidu.com
HTTP/1.1 200 OK
Server: bfe/1.0.8.18
Date: Fri, 06 May 2022 14:28:07 GMT
Content-Type: text/html
Content-Length: 277
Connection: keep-alive
Accept-Ranges: bytes
Etag: "575e1f72-115"
Last-Modified: Mon, 13 Jun 2016 02:50:26 GMT
Pragma: no-cache









（5）只允许IP为具体值的主机访问httpd服务
删除这条拒绝所有人访问的规则
$ sudo iptables -D INPUT -p tcp --dport 80 -j REJECT

允许-s源机器IP访问
$ sudo iptables -I INPUT -p tcp -s 192.168.2.199 --dport 80 -j ACCEPT

$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  192.168.2.199        0.0.0.0/0            tcp dpt:80
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpts:10:21
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-port-unreachable



在 199 上访问目标主机
$ curl -I http://192.168.2.134/
TP/1.1 200 OK
Date: Sun, 10 Oct 2021 23:59:24 GMT
Server: Apache/2.4.6 (CentOS)
Last-Modified: Sun, 10 Oct 2021 15:03:20 GMT
ETag: "12-5ce00e9c3b52f"
Accept-Ranges: bytes
Content-Length: 18
Content-Type: text/html; charset=UTF-8


换个 199 的主机:
$ curl -I http://192.168.2.134/
curl: (7) Failed to connect to 192.168.2.134 port 80: Connection refused

说明只允许 199 访问设置成功了。




删除掉刚才的规则
$ sudo iptables -D INPUT -p tcp -s 192.168.2.199 --dport 80 -j ACCEPT






========================================
|-- nmap 扫描网络端口: 哪些端口开放
----------------------------------------

1. 常用功能和命令


nmap -PN 192.168.152.130


扫描指定端口
nmap -p 80 192.168.152.154


扫描地址段
nmap -p 80 125.80.192.72/24

就是 –> 125.80.192.0 - 125.80.192.255


实例
# nmap -p 22 10.20.59.72/24



Nmap万能开关
此选项设置包含了1~10000的端口的ping扫描，包括操作系统扫描，脚本扫描，路由器追踪，服务探测

命令语法：nmap -A <目标主机的IP>

# nmap -A 10.20.57.27









2. 怎么控制主机段?
nmap -p 80 125.80.192.72/24

就是 –> 125.80.192.0 - 125.80.192.255

有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR风格的地址。您可以附加一个/numbit在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 numbit相同比特的所有IP地址或主机。

例如，192.168.10.0/24将会扫描192.168.10.0 (二进制格式: 11000000 10101000 00001010 00000000)和192.168.10.255 (二进制格式: 11000000 10101000 00001010 11111111)之间的256台主机。

192.168.10.40/24 将会做同样的事情。

假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org/16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。

所允许的最小值是/1，这将会扫描半个互联网。
最大值是/32，这将会扫描该主机或IP地址，因为所有的比特都固定了。


# nmap -p 22 10.20.59.7/28
# nmap -p 22 10.20.59.7/28 >rs.txt
















========================================
|-- iptables配制-场景2: ftp主动模式和被动模式下的设置 //todo
----------------------------------------
iptables配制-场景2
ftp主动模式和被动模式下的设置。http://www.imooc.com/video/7609











========================================
|-- Ubuntu中iptables常用设置、防火墙 ufw
----------------------------------------
版本号
$ ufw --version
ufw 0.36
Copyright 2008-2015 Canonical Ltd.

如果死活连不上，则先关掉各种防火墙:
1)关闭防火墙
$ sudo ufw disable
Firewall stopped and disabled on system startup

2)清除iptables设置
多用几次，就完全清除了规则
$ iptables -F  # -F更新为新的规则，如果没有新规则，相当于逐条删除已有规则。
-F, --flush [chain]   Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the  rules  one  by one.

$ iptables -nL #查看规则




Linux 2.4内核以后提供了一个非常优秀的防火墙工具：netfilter/iptables，他免费且功能强大，可以对流入、流出的信息进行细化控制，它可以 实现防火墙、NAT（网络地址翻译）和数据包的分割等功能。netfilter工作在内核内部，而iptables则是让用户定义规则集的表结构。

但是iptables的规则稍微有些“复杂”，因此ubuntu提供了ufw这个设定工具，以简化iptables的某些设定，其后台仍然是 iptables。ufw 即uncomplicated firewall的简称，一些复杂的设定还是要去iptables。





1. 安装
sudo apt-get install ufw

启用
sudo ufw enable
sudo ufw default deny
运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。
以上2条命令已经足够安全了，如果你需要开放某些服务，再使用sudo ufw allow开启。


开启/关闭防火墙 （默认设置是’disable’）
sudo ufw enable|disable

查看防火墙状态
sudo ufw status

转换日志状态
sudo ufw logging on|off

设置默认策略 （比如 “mostly open” vs “mostly closed”）

sudo ufw default allow|deny

许可或者屏蔽端口 （可以在“status” 中查看到服务列表）。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。 ‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’ 则相反。基本语法如下：
sudo ufw allow|deny ［service］

开启/禁用
sudo ufw allow|deny ［service］

显示防火墙和端口的侦听状态，参见 /var/lib/ufw/maps。括号中的数字将不会被显示出来。
sudo ufw status



2. 打开或关闭某个端口，例如：
sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp （smtp）端口
sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp （ssh）端口
sudo ufw allow 53 允许外部访问53端口（tcp/udp）
sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口
sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53
sudo ufw deny smtp 禁止外部访问smtp服务
sudo ufw delete allow smtp 删除上面建立的某条规则

允许 53 端口 $ sudo ufw allow 53
禁用 53 端口 $ sudo ufw delete allow 53

允许 80 端口 $ sudo ufw allow 80/tcp
禁用 80 端口 $ sudo ufw delete allow 80/tcp

允许 smtp 端口
$ sudo ufw allow smtp
删除 smtp 端口的许可
$ sudo ufw delete allow smtp

允许某特定 IP  $ sudo ufw allow from 192.168.254.254
删除上面的规则 $ sudo ufw delete allow from 192.168.254.254

ufw allow/deny 20：允许/拒绝 访问20端口，20后可跟/tcp或/udp，表示tcp或udp封包。

ufw allow/deny servicename:ufw 从/etc/services中找到对应service的端口，进行过滤。

ufw delete allow/deny 20：删除以前定义的“允许/拒绝访问20端口”的规则

ufw allow proto tcp from 10.0.1.0/10 to 本机ip port 25：允许自10.0.1.0/10的tcp封包访问本机的25端口。







========================================
|-- CentOS6中iptables常用设置
----------------------------------------

1.在Linux中设置防火墙，以CentOS为例，打开iptables的配置文件：
$ sudo vim /etc/sysconfig/iptables
# Firewall configuration written by system-config-firewall
# Manual customization of this file is not recommended.
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT



修改vi /etc/sysconfig/iptables命令添加使防火墙开放80端口
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  

2.关闭/开启/重启防火墙
 $ sudo /etc/init.d/iptables start 
iptables: Applying firewall rules:                         [  OK  ]
 $ sudo /etc/init.d/iptables stop
 $ sudo /etc/init.d/iptables restart 


3.永久性关闭防火墙
    chkconfig --level 35 iptables off     
    /etc/init.d/iptables stop  
    iptables -P INPUT DROP  


4.打开主动模式21端口
    iptables -A INPUT -p tcp --dport 21 -j ACCEPT  
     
5.打开被动模式49152~65534之间的端口
    iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT  
    iptables -A INPUT -i lo -j ACCEPT  
    iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT  

$ iptables -h
查找参数意义。


注意：
一定要给自己留好后路,留VNC一个管理端口和ssh的管理端口。
需要注意的是，你必须根据自己服务器的情况来修改这个文件。
全部修改完之后重启iptables: service iptables restart
你可以验证一下是否规则都已经生效：iptables -L或者iptables -nL



========================================
|-- CentOS7中iptables常用设置
----------------------------------------
https://blog.csdn.net/qzc70919700/article/details/79784566

#查看规则
sudo iptables -L -n --line-numbers |less
$ sudo iptables -nL | head





#插入规则，插入第一条
# sudo iptables -I INPUT -p tcp --dport 10007 -j ACCEPT


删除规则
# sudo iptables -D INPUT -p tcp --dport 10007 -j ACCEPT
// 把第一条规则删除
# sudo iptables -D INPUT 1 


将第三条规则改为ACCEPT：
# iptables -R INPUT 3 -j ACCEPT


//开放8787端口访问
# iptables -I IN_public_allow -p tcp --dport 8787 -j ACCEPT


// 配置默认规则
iptables -P INPUT DROP #不允许进。不能执行，执行完22端口也无法登陆了。
iptables -P FORWARD DROP #不允许转发
iptables -P OUTPUT ACCEPT #允许出



//规则的保存
# iptables -F #清空规则缓存区(这个操作将会清空上面增加的操作，若想保留建议先执行下一句：保存)
# service iptables save # 保存规则到文件 /etc/sysconfig/iptables 
# service iptables restart #重启 iptables 服务

# chkconfig iptables on #开机自动启用


其他发行版：
保存 iptables-save > /root/iptables.conf
恢复 iptables-restore < /root/iptables.conf


打印规则到控制台，而不是文件
# iptables-save
# iptables-save > /etc/sysconfig/iptables #保存到文件
保存在/etc/sysconfig/iptables中效果和service iptables save命令一样。

如果保存在其他路径，重启后可以使用 iptables-restore命令恢复防火墙规则。
iptables-restore < path(path为保存的路径)






1. 查看是否开启启动

(1) 设置开机自启动
$ sudo systemctl enable iptables.service

$ systemctl is-enabled iptables.service 
enabled

$ sudo chkconfig –level 345 iptables on
$ chkconfig --list


(2) 
$ tail /etc/sysctl.conf
net.ipv4.ip_forward=1
$ sudo cat /proc/sys/net/ipv4/ip_forward 开启内核转发
1


$ sudo iptables -t filter -A FORWARD -j ACCEPT

(3) 需关闭firewalld防火墙
systemctl stop firewalld.service
systemctl disable firewalld.service





2. 空白 centOS7.9 虚拟机测试
(1) 尝试1: 不保存到文件
开服务
$ python3 -m http.server 8787

浏览器无法访问
http://192.168.2.105:8787/

开放8787端口访问
$ sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT
浏览器可以访问了。

查看当前状态，有8787端口的设置.
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8787

查看文件，没有找到 8787端口的设置。
$ sudo cat /etc/sysconfig/iptables | grep 8787

$ sudo reboot 
重启后，端口是关着的。




(2) 尝试2: 保存到文件
$ python3 -m http.server 8787 #开服务

$ sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT #开端口，可以访问了
$ sudo service iptables save #保存设置到文件, 如果没有该命令，就安装 yum install iptables-services
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]

$ sudo service iptables restart #重启服务，端口还可以访问

$ sudo cat /etc/sysconfig/iptables | grep 8787 #文件中可以查到该端口设置
-A INPUT -p tcp -m tcp --dport 8787 -j ACCEPT

$ sudo reboot 
重启后，端口可以访问。
文件中可查。









========================================
|-- centOS7 中的防火墙
----------------------------------------
Linux中存在iptables和firewalld两种防火墙
iptables：更接近数据的原始操作，精度更高
firewalld：更易操作




1.查看防火墙状态 systemctl status firewalld

开启防火墙 systemctl start firewalld  
关闭防火墙 systemctl stop firewalld
开启防火墙 service firewalld start 
若遇到无法开启
先用：systemctl unmask firewalld.service 
然后：systemctl start firewalld.service


关闭防火墙
如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估
systemctl stop firewalld.service


systemctl disable firewalld.service #禁止firewall开机启动

firewall-cmd --state ##查看默认防火墙状态（关闭后显示notrunning，开启后显示running）



2.查看对外开放的端口状态
查询已开放的端口 netstat -anp
查看监听的端口 netstat -lnpt

查询指定端口是否已开 firewall-cmd --query-port=10007/tcp
提示 yes，表示开启；no表示未开启。

firewall-cmd --list-ports ##查看已经开放的端口
firewall-cmd --zone=public --list-ports ##查看防火墙所有开放的端口





3.开启端口
firewall-cmd --zone=public --add-port=10007/tcp --permanent   # 开放端口
firewall-cmd --zone=public --remove-port=10007/tcp --permanent  #关闭端口
firewall-cmd --reload   # 配置立即生效
命令含义：
–zone #作用域
–add-port=80/tcp #添加端口，格式为：端口/通讯协议
–permanent #永久生效，没有此参数重启后失效


firewall-cmd --get-active-zones #运行完成之后，可以看到zone名称
## public
##  interfaces: em1



4.杀掉占用端口的进程

检查端口被哪个进程占用 sudo netstat -lnpt |grep 10007
tcp        0      0 10.20.57.27:10007       0.0.0.0:*               LISTEN      115213/python

查看进程的详细信息 ps 115213
115213 pts/22   S+     0:01 /home/hou/anaconda3/bin/python /home/hou/anaconda3/bin/jupyter-notebook --no-browser --port 10007 --ip=10.20.57.27

中止进程
kill -9 115213




5.查看端口是否开启
win下 > telnet  192.168.xx.xx 6379
linux下 $ sudo nmap -sS -p 0-1000 192.168.xx.xx


6.firewalld的域，类似于win的组概念
trusted 信任： 可接受所有网络连接
home 家庭：用于家庭网络，仅接受ssh/mdns/ipp-client/samba-client/dhcpv6-client服务连接
internal 内部：用于内部网络，仅接受ssh/mdns/ipp-client/samba-client/dhcpv6-client服务连接
work 工作：用于工作区，仅接受ssh/ipp-client或dhcpv6-client服务连接
public 公共：在公共区域呢使用，仅接受ssh/dhcpv6-client服务连接，为firewalld的默认区域
external 外部：出去的ipv4网络连接通过此区域伪装和转发，仅接受ssh服务连接
dmz 非军事区：仅接受ssh服务连接
block 限制：拒绝所有网络连接
drop 丢弃：任何接收的网络数据包都被丢弃，没有任何回复




refer:
https://blog.csdn.net/qq_28426351/article/details/52249710
https://blog.csdn.net/weixin_44224288/article/details/88136383





========================================
|-- service iptables save 保存规则到文件
----------------------------------------

打开 8787 端口，并立即执行，默认不写入文件，重启失效。
$ sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT
$ sudo iptables -I INPUT -p tcp --dport 22 -j ACCEPT
想一直有效，就需要保存到配置文件。


例:
$ sudo iptables -D INPUT -p tcp --dport 8001 -j ACCEPT #删除该端口
$ sudo service iptables save



1. 直接执行报错
$ sudo service iptables save
The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.



2. 安装 iptables-services
https://blog.csdn.net/ethnicitybeta/article/details/122633776

(1) 安装与启动
$ sudo systemctl stop firewalld  #关闭防火墙
$ sudo yum install iptables-services  #安装或更新服务再使用
$ sudo systemctl enable iptables #设置开机启动 iptables

$ sudo systemctl start iptables #打开iptables
$ sudo service iptables save #保存现有规则到文件
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]

$ sudo service iptables restart #重启


(2) 防火墙开机不启动
$ sudo systemctl disable firewalld.service
Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.

$ sudo service iptables restart
Redirecting to /bin/systemctl restart iptables.service




3. 查看
(1) 查看状态
$ sudo iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8787
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:53
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:53
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:67
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:67
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
INPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           
INPUT_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           
INPUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           
DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID
REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain FORWARD (policy ACCEPT)



(2) 查看配置文件
$ sudo wc /etc/sysconfig/iptables
 190  880 6497 /etc/sysconfig/iptables

$ sudo head /etc/sysconfig/iptables
# Generated by iptables-save v1.4.21 on Wed Jun 29 14:42:05 2022
*nat
:PREROUTING ACCEPT [2971:162413]
:INPUT ACCEPT [2730:141992]
:OUTPUT ACCEPT [257:16489]
:POSTROUTING ACCEPT [257:16489]
:OUTPUT_direct - [0:0]
:POSTROUTING_ZONES - [0:0]
:POSTROUTING_ZONES_SOURCE - [0:0]
:POSTROUTING_direct - [0:0]
...


$ sudo grep "8787" /etc/sysconfig/iptables
-A INPUT -p tcp -m tcp --dport 8787 -j ACCEPT



$ sudo grep "22" /etc/sysconfig/iptables
...
-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A FORWARD -d 192.168.122.0/24 -o virbr0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -s 192.168.122.0/24 -i virbr0 -j ACCEPT
-A IN_public_allow -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW,UNTRACKED -j ACCEPT
# Completed on Wed Jun 29 14:42:05 2022
















========================================
通信安全与gpg加密
----------------------------------------

1.对称加密和解密
这里，先简单介绍使用gpg进行对称加密和解密，后面重点介绍公钥加密和数字验证。 
*对称加密myfile： 
$ gpg -c myfile 
这样，会提示你输入两次密码，然后生成myfile的加密文件myfile.gpg,注意不能对目录加密,可以用-o选项指定输出文件名称。 


解密对称加密的文件： 
$ gpg -o mydecrypt -d myfile.gpg 
这样，会提示你输入解密密码，输入之后，将会解密相应的文件，通过-o指定生成的解密文件，-d指定被解密过的文件。 





2.非对称加密（也叫公钥加密）

(1)生成钥匙对： 
$ gpg --gen-key 
## gpg (GnuPG) 2.2.4; Copyright (C) 2017 Free Software Foundation, Inc.
输入姓名和邮箱，设置密码后产生key。 

gpg: /home/wangjl/.gnupg/trustdb.gpg: trustdb created
gpg: key 600247CD2973A676 marked as ultimately trusted
gpg: directory '/home/wangjl/.gnupg/openpgp-revocs.d' created
gpg: revocation certificate stored as '/home/wangjl/.gnupg/openpgp-revocs.d/F5369AFE4166801E40B2B9B8600247CD2973A676.rev'
public and secret key created and signed.

pub   rsa3072 2019-06-13 [SC] [expires: 2021-06-12]
      F5369AFE4166801E40B2B9B8600247CD2973A676
uid                      XXX <jXXXl@XX.com>
sub   rsa3072 2019-06-13 [E] [expires: 2021-06-12]


这里，首先要一个钥匙对才能公钥加密，这里根据系统情况不同，可能内容为英文。需要用户交互输入的地方，都通过"<====输入"这个标记指出来了。若对输入信息有所改动 ,可把 ~/.gnupg 目录下除 options 以外的文件删除 ,再运行 gpg --gen-key 命令 ,或者使用 gpg 的 edit 选项 .  钥匙对放在 ~/.gnupg 目录下 . 






(2)查看已有的钥匙： 
$ gpg --list-keys 

/home/wangjl/.gnupg/pubring.kbx
---- ---- ---
pub   rsa3072 2019-06-13 [SC] [expires: 2021-06-12]
      F5369AFE4166801E40B2B9B8600247CD2973A676
uid           [ultimate] XXX <jXXXl@XX.com>
sub   rsa3072 2019-06-13 [E] [expires: 2021-06-12]

这里， 
pub(公匙)
sub(私匙)







(3)使用gpg密钥进行加密和解密文件
1)查看要加密的文件
$ cat note.txt 
We'll meet on the 1st day next month at Water Gate.
Tom
2019.6.13


2)加密文件
$ gpg -ea -r XXX note.txt 

这里的XXX就是前面设置的你的名字。我们可以使用"gpg --list-keys"来查看我们可以选择用来加密的公钥。
选项"-e"实际就是"--encrypt"表示加密数据
"-a"表示创建ASCII的输出(可以不用这个选项,这样生成的文件就不是ASCII的内容了，并且文件后缀是*.gpg)
"-r"指定加密的用户id名称。 

3) 查看加密之后的文件： 
$ ls -l
total 4632
-rw-rw-r-- 1 wangjl wangjl      66 Jun 13 19:40 note.txt
-rw-rw-r-- 1 wangjl wangjl     785 Jun 13 19:43 note.txt.asc #文件增大了十倍。

$ cat note.txt.asc 
-----BEGIN PGP MESSAGE-----

hQGMA/s5kKzjTDH9AQwAnG6sIAxucafO8lNJkyUtZaEK4ROyMPMU3T71/6gZ1saf
T0a/zztIgPdmuTO01dtSXcuXcjygrdRN3Bt8Mdjg5zH2sfnZqBV/nT3AlvFDzgjV
NrnJ/uOJA6GlnA6F9zIzrvLg7R9B1EYurr/1TrDSKwQJH3ulcxBKCFRGV3Nscqna
LAmZpltC+3ToV7mIgq7RLb6W7vx3pU7iSLFCfNDQaTWyHkIT+XlNcw+xXOF3wphq
d4/awzFOwMX5b+HIakZmjihZUt5LnqXzXxinkA1eeOTmQFJZxlo4zIuQwJoLYkCa
4Q5Xx3t522aEmshQ/sNLyhhMYQscq7/AozL2nBjf8uferbTgY9oYquTDH7u8LOhl
eD30uSHpFFGIZK1Za5PgXsFDtaijklFTaKpCCsT4Ju9SUPFd3M5nNN2McRFG85vO
p/tFGExqzi3iCa/0R754ZHd7eCLQTE6XM+ZK/9PF4GcTIdpc7elRK4eaA4l9mXYL
evplhYMB4MwYCPgCFS0C0oQBBEpB73HfTzSRRL0KF2RUmYjJZ5GJ+IsP/yi3UltQ
7fF1KTqITckduLC2mjfXDXOCMA0+JXoeH9qTt+AjBXh3FkMxZ9/4loKrN+Q1c2yb
Cd2GIbF1ie5fwA1xhTrbI/T8VM8FXfEwYLm95eiyaHpF/oUglBwG6Yl2bLfEG8iH
necgtdQ=
=mPcF
-----END PGP MESSAGE-----


4)公钥解密过程 
$ gpg -o note_2.txt --decrypt note.txt.asc
 -o 指定解密文件名

	x Please enter the passphrase to unlock the OpenPGP secret key:  x
	x "XXX <jXXXl@XXX.com>"  x
	x 3072-bit RSA key, ID FB3990ACE34C31FD,  x #私钥号
	x created 2019-06-13 (main key ID 600247CD2973A676). #主钥号
输入刚才设置的密码，才能解开这个用户的私钥。
gpg: encrypted with 3072-bit RSA key, ID FB3990ACE34C31FD, created 2019-06-13
      "XXX <jXXXl@XXX.com>"

如果不在同一台机器上解密，则需要把本地私钥导出，放到待解密的机器上。
如果想要别人和你使用这个加密的方法通信，需要把你的公钥导出，发给别人，然后他们把这个公钥导入，在使用前面加密的方法用这个公钥加密数据并且发送给你，你再用你自己的私钥解密，得到解密后的原始数据,这也是公钥加密通信使用的常用方法。
后面会详细讲述如何导出本地的公钥和私钥，以及如何在其它机器上面导入之前导出的密钥。 


5)查看解密后的文件
内容是真的一模一样：
$ md5sum note*txt
63adefb2e879374c6ceff5d1d6359a03  note_2.txt
63adefb2e879374c6ceff5d1d6359a03  note.txt


6)导出（备份）公钥： gpg -o keyfilename --export KeyID
$ gpg -o mypubkey --export F5369AFE4166801E40B2B9B8600247CD2973A676 
-o指定生成的导出文件名称，
--export指定想要导出的密钥ID, 如果没有KeyID则是备份所有的公钥.
如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息


导出的公钥，可以发布，其它人只要导入你发布的公钥，就能用这个公钥加密数据并且发送给你，
你再用你自己的私钥解密，得到解密后的原始数据。
这也是公钥加密通信使用的常用方法。 


7)以文本方式导出公钥
$ gpg -o mypubkey2 -a --export F5369AFE4166801E40B2B9B8600247CD2973A676 



8)导出（备份）私钥
$ gpg -o mysubkey --export-secret-keys 600247CD2973A676 
如果没KeyID则是备份所有的私钥，
-o表示输出到文件mysubkey中，
如果加上-a的参数则输出文本格式的信息，否则输出的是二进制格式信息。 

输入密码就可以导出了。
$ ls -l
-rw------- 1 wangjl wangjl 3.7K Jun 13 20:08 mysubkey


9)导入私钥: 
$ gpg --import mysubkey 
gpg: key 600247CD2973A676: "XXX <jXXXl@XXX.com>" not changed
gpg: key 600247CD2973A676: secret key imported
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
gpg:  secret keys unchanged: 1


如果导入公钥命令是一样的，不过指定的文件应该是"mypubkey"了。
这个命令是另外一台机器上运行的，导入私钥之后那个机器就可以使用这个私钥解密数据了。
一般来说我们都是发布公钥让人导入，而不是导入私钥匙。 









(4)签名与验证
签名作用是验证明文、加密文件、密钥是来自正确的发送者的，没经过其它人的修改。签名使用的也是密钥对，与加密操作相同。只是在结果上，点不同。它只是在文件最后添上加密的验证信息（签名）。一旦文件有所改变，签名验证就会出错。

1)查看文件
$ cat note_2.txt
We'll meet on the 1st day next month at Water Gate.
Tom
2019.6.13


2)生成签名
$ gpg -o note_2.txt.sig -s note_2.txt
输入密码，解开私钥，加密获得文件，含有乱码头尾。.sig包含了原文件和签名。
-rw-rw-r-- 1 wangjl wangjl  544 Jun 13 20:17 note_2.txt.sig


产生文本格式的签名 
$ gpg -o note_2.txt.sig2 --clearsign note_2.txt 
该文件上边是原文本信息，下面是ascii码。


3)验证签名
$ gpg --verify note_2.txt.sig2
gpg: Signature made Thu 13 Jun 2019 08:21:20 PM CST
gpg:                using RSA key F5369AFE4166801E40B2B9B8600247CD2973A676
gpg: Good signature from "XXX <jXXXl@XXX.com>" [ultimate] #结论是 完好的签名。

这里，在验证之前，必须导入文件作者的公钥，对于分离式签名最后还要加上原文件参数(后面会讲到)。 


4)将签名文件恢复 
$ gpg -o note_3.txt --decrypt note_2.txt.sig
note_3.txt和原文件完全一样。









(5)签名并加密
$ gpg -o note_decrypt.sig -ser XXX note.txt 
## -rw-rw-r-- 1 wangjl wangjl  991 Jun 13 20:28 note_decrypt.sig

这里，无法直接通过"gpg --verify mydecrypt.sig"对文件mydecrypt.sig进行验证。而是在解密恢复文件的时候直接验证了


2)恢复加密的签名文件

$ gpg -o note_4.txt --decrypt note_decrypt.sig 
输出 Good signature。内容和原文件一样。








(6)分离式签名
$ gpg -o mydecrypt.sig -ab note.txt 
# -rw-rw-r-- 1 wangjl wangjl  659 Jun 13 20:33 mydecrypt.sig
mydecrypt.sig仅包含签名，分离式签名的意思是原文件和签名是分开的。
b选项表示分离式签名detach-sign. 

2)对分离的签名进行验证
$ gpg --verify mydecrypt.sig note.txt 
# Good signature
因为是分离的，所以要指定签名文件和原始文件。






(7)编辑公钥，不知道有啥用？

$ gpg --edit-key someone
someone是别人的用户id,输入之后，出现命令提示符号，进入交互模式。 
>fpr <===输入这个表示查看someone的指纹，核对信息真实性，这样之后签署。 
>sign <===输入这个签署公钥，这样以后再使用它加密的时候不会产生警告了。 
>check <===输入这个，检查someone已有的钥匙的签名。 
>quit <===输入这个，退出交互，可能会提示你保存之前的设置。







参考： 
refer: https://blog.csdn.net/xueye3000/article/details/51691720
http://blog.chinaitlab.com/html/57/340757-64526.html 
http://blog.sina.com.cn/s/blog_44abafb201008zjo.html 
http://wiki.ubuntu.org.cn/GPG/PGP 


白话GPG加密的应用场景、加密通信的理论过程 https://www.jianshu.com/p/671ebeddcf60













========================================
科学上网
----------------------------------------
1.傻瓜代理，一键搞定的；
2.基于hosts文件的；
3.基于VPN的。


推荐1:Lantern蓝灯（据说最近不太能用了） 
推荐2:hosts文件 hosts hosts@github https://github.com/racaljk/hosts



hosts文件的：http://laod.cn/hosts/2016-google-hosts.html
	如果是用linux系统的同学，请修改 /etc/hosts 这个文件。
	修改hosts后生效的方法：$ sudo rcnscd restart


（一般这些网站都是SSL加密链接）如谷歌学术：https://scholar.google.com/
https://www.google.com/ncr 方式访问，禁止国别跳转



科学上网工具大推荐[10151224更新Android]
https://www.bennythink.com/scientific-internet-tools-recommended.html



Lantern：官方译名蓝灯，基于P2P原理的工具。我更喜欢称之为拉登，本拉登的那个拉登。
安装即可使用。
监听端口为8787。
GitHub项目地址：https://github.com/getlantern/lantern
主页：https://getlantern.org/



VPNGate：日本筑波大学开发的分布式VPN，想要封只能靠DPI（深度包检测）了。选择服务器的技巧：运行时间比较短的日韩服务器。
监听端口为：VPN没有监听端口？又不是本地代理
主页：http://www.vpngate.net/cn/
PS，有个很好玩的现象，为啥韩国和中国的流量排名超靠前呢？这说明我们中国网民都在使用韩国人民开的VPN啊。
http://www.ll00.cn/network/vpngate.php








BreakWall:首页
https://wiki.yoitsu.moe/wiki/BreakWall:%E9%A6%96%E9%A1%B5

	chrome hosts:
	Shadow socks
	
	tor加网桥上socks4过墙再想其他的
#


========================================
|-- 纸飞机上谷歌查论文: 搭建ShadowSocks 服务
----------------------------------------

纸飞机看谷歌: 搭建ShadowSocks 服务。
官网 https://github.com/shadowsocks/shadowsocks/tree/master



1. VPS安装ShadowSocks
wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2>&amp;1 | tee shadowsocks-all.log

## 选择脚本（Python、R、Go、libev），任选一个：
## 输入密码和端口，笔者直接回车用默认
## 安装成功后，命令行出现：
Congratulations, Shadowsocks-Go server install completed!
Your Server IP        :  45.32.73.59
Your Server Port      :  8989
Your Password         :  teddysun.com
Your Encryption Method:  aes-256-cfb

Welcome to visit: https://teddysun.com/486.html
Enjoy it!
（如果安装失败，请尝试其他脚本）

不用启动，已经启动过了。
	sudo ssserver -p 7878 -k password -m rc4-md5 -d start
	sudo ssserver -p 20180 -k v123456 -m rc4-md5 -d start
#


低配版: https://www.daozhao.com/3202.html
git clone https://github.com/madeye/shadowsocks-libev.git


(2)如何暂停和重启？
$ ps -aux | grep sha
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root     34303  0.0  3.2  58060 13704 ?        Ss   07:53   0:00 /usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks-python/config.json -d start


Shadowsocks-Python 版：(推荐这个，可以查状态)
/etc/init.d/shadowsocks-python start | stop | restart | status


ssserver -d start/stop/restart  # daemon mode

ssserver -c /etc/shadowsocks.json -d start



(3)修改端口等
先暂停，修改后再启动
vim  /etc/shadowsocks.json



(4)设置开机启动
#vi /etc/rc.local    （加入以下一行命令）
ssserver -c /etc/shadowsocks.json -d start






2. Shadowsocks客户端
Shadowsocks官网 windows客户端下载：https://github.com/shadowsocks/shadowsocks-windows/releases

打开，输入服务器ip、端口、密码：

Shadowsocks windows客户端
把刚才安装Shadowsocks脚本成功后，输出的信息填上去：




3.一旦被墙了,该如何解决呢

怕vps被墙，现在都不敢登录ssh了，怎么破？

我改了端口号，证书登录。linode用了两年多，从未被墙
估计强是判断流量的，单纯ssh操作应该不会有问题，如果做端口转发，流量大了就不好说了


方法1 被动的处理: 被墙后,需要停止VPS , 几天或几周后 可能会自动解禁


墙有两百种阻断方式，一种是TCP阻断，一种是ICMP阻断。Ping命令走的是ICMP协议，而SHH连接的时候是TCP协议。你出现能ping通，ssh却连不上的这种情况时，就是ICMP包被放行了，而TCP包却被拦截了，这就是TCP阻断，也是目前封禁比较常用的方法，让你端口用不了问。另外也有专门针对某一个指定端口的封禁。这时候ping也是没问题的，但是无法连接指定端口。


遇到GFW谁也没办法: https://blog.csdn.net/chenggong2dm/article/details/6706370



(1)停掉ss
ssserver -d stop

/etc/init.d/shadowsocks-python stop
/etc/init.d/shadowsocks-python status

怎么关掉开机启动？
https://blog.csdn.net/qq_14989227/article/details/79227283


service ipstable stop





(3) 不用bash了，用mosh
远程和本地都安装mosh。
sudo apt-get install mosh







4.防止IP被墙的正确姿势是过CDN










ref: 
http://www.itucd.com/archives/1287
https://www.hinwen1.com/31972.html
https://zhuanlan.zhihu.com/p/113906130 如何使用客户端。




========================================
|-- 修改ssh端口号
----------------------------------------
1. Linux中SSH默认端口为22，为了安全考虑，我们有必要对22端口进行修改，现修改端口为60000；

修改方法如下：
在/etc/ssh/sshd_config中找到Port 22，将其修改为60000,或使用/usr/sbin/sshd -p 60000指定端口。

如果用户想让22和60000端口同时开放，只需在/etc/ssh/sshd_config增加一行内容如下：
$ sudo vim /etc/ssh/sshd_config
Port 22
Port 60000
保存并退出

重启ssh服务:
$ sudo service ssh restart
或者 /etc/init.d/ssh restart

ssh user@ip -P 60000 




2.
增加 UseDNS no配置，可以提速。
ref:
解决SSH登录国外VPS连接特别慢的问题
https://www.zhujimi.net/ssh-close-usedns.html






========================================
|-- 安装squid，让win通过代理上网 //todo
----------------------------------------
1.
sudo apt install squid //安装squid
squid -v //查看squid的版本
# Squid Cache: Version 3.5.27
# Service Name: squid


2.配置squid
需要编辑squid的配置文件/etc/squid/squid.conf

vim /etc/squid/squid.conf

找到
http_access deny all

在其之前添加下面数行内容：注意路径
auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd
auth_param basic children 5
auth_param basic realm hehe
auth_param basic credentialsttl 2 hours
acl myproxy proxy_auth REQUIRED
http_access allow myproxy

找到
#cache_dir ufs /var/spool/squid 100 16 256
去掉这一行的注释#，使缓存配置生效，否则无法初始化缓存。







查看端口
netstat -ntlp | grep squid
# Active Internet connections (only servers)
# Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name  
# tcp6       0      0 :::3128                 :::*                    LISTEN      21696/(squid-1) 

netstat -ntpl | grep 3128


Windows10设置代理
依次鼠标右键 Internet----打开“网络和Internet”设置----代理，在“手动设置代理”下，打开“使用代理服务器”并配置“地址”和“端口”，保存退出即可。
地址：物理服务器的IP地址；端口：3128


当第一次打开Firefox，Firefox会弹出认证窗口，填入用户名和密码，点击“确定”就可以上网了。



========================================
内网穿透软件natapp
----------------------------------------
需要购买服务（2019年是9元/月）：https://natapp.cn/article/nohup
下文的 authtoken=xxxx 用我的 authtoken=e53b1f66a57d57f9 代替。


1.下载
wget http://download.natapp.cn/assets/downloads/clients/2_3_9/natapp_linux_386_2_3_9.zip

2.解压出natapp文件
unzip natapp_linux_386_2_3_9.zip

3.为natapp文件加可执行权限
chmod +x natapp

4.运行该软件
./natapp -authtoken=xxxx

5.然后把Forwarding行、Linux用户名和密码发给我
Forwarding tcp://server.natappfree.cc:42589 -> 127.0.0.1:22 

6.远程登录方式
ssh username@server.natappfree.cc -p 42589
password




如上直接运行的缺点是,如果关掉窗口,就是关掉了natapp程序,所以会掉线.
建议改为后台运行。


4b. 最好是在tmux中运行。
$ tmux
$ ./natapp -authtoken=xxxx



4c. 后台运行（不推荐）
nohup ./natapp -authtoken=xxxx -log=stdout &
注意一定要加上 -log=stdout

另开一个窗口检查一下
ps -ef|grep natapp
如果要关掉进程，可以用上述命令查看进程号(第二列是pid)，然后kill掉
kill -9 2777

nohup 默认会在当前目录 创建 nohup.out 文件,会记录natapp运行日志,为避免日志过大,可以将日志等级降低 如
nohup ./natapp -authtoken=xxx -log=stdout -loglevel=ERROR &

注意，这样看不到端口号，必须购买natapp的端口号。




========================================
|-- 免费的内网穿透工具 ittun，支持自定义二级域名
----------------------------------------
http://www.ittun.com/ html服务器已经跪了，需要自己配置服务器。



1. 下载解压缩
wget http://www.ittun.com/upload/17.4/linux64.zip
unzip linux64.zip

mv linux64 ittun
$ cd ittun/
$ chmod +x ngrok # 增加执行权限


(1) 默认参数启动
linux: ./ngrok [port] (tcp: ./ngrok -proto=tcp 22)

$ ngrok 22

(2) 指定二级域名
./ngrok -subdomain [demo] [8080]


(3) 指定配置文件
./ngrok -config ittun.yml start [proname]





2. 怎么自己搭建服务器？ //todo
https://ngrok.com/

git clone https://github.com/inconshreveable/ngrok.git 








========================================
可用的局域网 wifi和密码
----------------------------------------
{
	jinlab:20172017,
	sc_F2: 姓名全拼,
}





========================================
(GitHub Pages) 校园网访问github.io被解析到127.0.0.1问题解决
----------------------------------------
1. 如果无法打开 github，则考虑如下步骤
(1) 查看登陆地所在地，最快的ttl对应的ip地址
http://ping.chinaz.com/github.com

广东深圳[多线]52.74.223.119

(2) 在 C:\Windows\System32\drivers\etc 下的 hosts中设置 github.com
52.74.223.119 github.com

(3)cmd中
> ipconfig /flushdns





1.问题发现
近期突然无法访问 github pages了，手机用4G可访问。
无奈 cmd下ping github.io 发现ip被解析127.0.0.1。

$ ping github.io
PING github.io(ip6-localhost (::1)) 56 data bytes
#
$ ping  github.io
PING github.io (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.038 ms



$ nslookup github.io
Server:		172.18.1.92
Address:	172.18.1.92#53

Non-authoritative answer:
Name:	github.io
Address: 127.0.0.1
Name:	github.io
Address: ::1



对照:
$ nslookup baidu.com
Server:		172.18.1.92
Address:	172.18.1.92#53

Non-authoritative answer:
Name:	baidu.com
Address: 39.156.69.79
Name:	baidu.com
Address: 220.181.38.148







2. 解决问题
-查找可用github.io解析ip
-修改hosts文件
-dns解析刷新（使hosts生效）

(1)
http://mping.chinaz.com/Ping/SpeedTest/?host=github.io




(2)C:\Windows\System32\drivers\etc\hosts中添加
185.199.109.153	github.io

185.199.111.153 www.biomooc.com
185.199.110.153 ielts.biomooc.com


(3)cmd中
ipconfig /flushdns



(4) 在ubuntu中，
直接在/etc/resolv.conf里面第一行写一句nameserver 8.8.8.8，不排查上游了。
/etc/resolv.conf应该每次重启都会被resolved这个服务覆写，重启完可能得重新修改


排查路由表:
nslookup github.io 
dig github.io 



3.
其实最简单的，就是使用阿里云解析到一个ip，但是可能有地狱限制，不过至少自己可以用。





ref:
https://blog.csdn.net/jipang6225/article/details/80097072



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

